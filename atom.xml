<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smarter&#39;s blog</title>
  
  <subtitle>要学习、要快乐</subtitle>
  <link href="https://smarter.xin/atom.xml" rel="self"/>
  
  <link href="https://smarter.xin/"/>
  <updated>2026-01-06T13:16:51.580Z</updated>
  <id>https://smarter.xin/</id>
  
  <author>
    <name>Smarter</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见算法-数学技巧</title>
    <link href="https://smarter.xin/posts/e33b4520/"/>
    <id>https://smarter.xin/posts/e33b4520/</id>
    <published>2026-01-06T13:14:20.000Z</published>
    <updated>2026-01-06T13:16:51.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shu-xue-suan-fa-bian-cheng-zhong-de-shu-xue-mo-fa" tabindex="-1">数学算法：编程中的数学魔法</h1><blockquote><p>当算法遇上数学，简洁而优雅</p></blockquote><hr><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>在算法世界里，数学不仅仅是公式和定理，更是解决问题的强大工具。很多看似复杂的问题，只要找到背后的数学规律，往往能用寥寥几行代码优雅地解决。</p><p><strong>本文涵盖</strong>：</p><ul><li>质数与因数分解</li><li>最大公约数与最小公倍数</li><li>快速幂与模运算</li><li>数学规律与找规律问题</li><li>组合数学基础</li></ul><hr><h2 id="yi-zhi-shu-xiang-guan" tabindex="-1" id="一、质数相关">一、质数相关</h2><h3 id="1-1-pan-duan-zhi-shu" tabindex="-1" id="1-1-判断质数">1.1 判断质数</h3><blockquote><p><strong>质数</strong>：大于1的自然数中，只能被1和自己整除的数</p></blockquote><h4 id="fang-fa-1-shi-chu-fa-ji-chu" tabindex="-1" id="方法1：试除法（基础）">方法1：试除法（基础）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 排除偶数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;  <span class="comment">// 只检查奇数</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化点</strong>：</p><ul><li>只需检查到√n</li><li>跳过偶数，只检查奇数</li></ul><p><strong>时间复杂度</strong>：O(√n)</p><h4 id="wei-shi-yao-zhi-xu-yao-jian-cha-dao-n" tabindex="-1" id="为什么只需要检查到√n？">为什么只需要检查到√n？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设 n = a × b</span><br><span class="line">如果 a 和 b 都大于√n：</span><br><span class="line">  a × b &gt; √n × √n = n（矛盾！）</span><br><span class="line">  </span><br><span class="line">所以必有一个因数 ≤ √n</span><br><span class="line"></span><br><span class="line">例子：36 = 6 × 6</span><br><span class="line">    如果存在因数，必有一个 ≤ 6</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-ai-la-tuo-si-te-ni-shai-fa-sieve-of-eratosthenes" tabindex="-1" id="1-2-埃拉托斯特尼筛法（Sieve-of-Eratosthenes）">1.2 埃拉托斯特尼筛法（Sieve of Eratosthenes）</h3><blockquote><p><strong>LeetCode 204</strong>：统计所有小于非负整数 n 的质数的数量</p></blockquote><h4 id="wen-ti-fen-xi" tabindex="-1" id="问题分析">问题分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于10的质数有 2, 3, 5, 7</span><br></pre></td></tr></table></figure><h4 id="suan-fa-si-lu-shai-fa" tabindex="-1" id="算法思路：筛法">算法思路：筛法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从2开始，标记2的所有倍数为合数</span><br><span class="line">从3开始，标记3的所有倍数为合数</span><br><span class="line">从5开始，标记5的所有倍数为合数</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">剩下未被标记的就是质数</span><br></pre></td></tr></table></figure><h4 id="ke-shi-hua-guo-cheng" tabindex="-1" id="可视化过程">可视化过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = 20</span><br><span class="line"></span><br><span class="line">初始：[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br><span class="line"></span><br><span class="line">标记2的倍数：</span><br><span class="line">  [2, 3, ✗, 5, ✗, 7, ✗, 9, ✗, 11, ✗, 13, ✗, 15, ✗, 17, ✗, 19]</span><br><span class="line">   4,6,8,10,12,14,16,18被标记</span><br><span class="line"></span><br><span class="line">标记3的倍数：</span><br><span class="line">  [2, 3, ✗, 5, ✗, 7, ✗, ✗, ✗, 11, ✗, 13, ✗, ✗, ✗, 17, ✗, 19]</span><br><span class="line">   9,15也被标记</span><br><span class="line"></span><br><span class="line">标记5的倍数：</span><br><span class="line">  [2, 3, ✗, 5, ✗, 7, ✗, ✗, ✗, 11, ✗, 13, ✗, ✗, ✗, 17, ✗, 19]</span><br><span class="line">   （10,15,20已经被标记过了）</span><br><span class="line"></span><br><span class="line">质数：2, 3, 5, 7, 11, 13, 17, 19</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只需要从2遍历到√n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="comment">// 标记i的所有倍数为合数</span></span><br><span class="line">            <span class="comment">// 优化：从i*i开始，因为i*(i-1)已经被更小的质数标记过了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计质数个数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n log log n)<br><strong>空间复杂度</strong>：O(n)</p><h4 id="you-hua-ji-qiao" tabindex="-1" id="优化技巧">优化技巧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化1：从i*i开始标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化2：跳过偶数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt; n; i += <span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-fen-jie-zhi-yin-shu" tabindex="-1" id="1-3-分解质因数">1.3 分解质因数</h3><blockquote><p>将一个正整数分解成质数的乘积</p></blockquote><h4 id="wen-ti-shi-li" tabindex="-1" id="问题示例">问题示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：12</span><br><span class="line">输出：2^2 × 3 = [2, 2, 3]</span><br><span class="line"></span><br><span class="line">输入：315</span><br><span class="line">输出：3^2 × 5 × 7 = [3, 3, 5, 7]</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-1" tabindex="-1" id="代码实现-2">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">primeFactorization</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; factors;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理因数2</span></span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        factors.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理奇数因数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            factors.<span class="built_in">push_back</span>(i);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果n大于1，说明n本身是质数</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        factors.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> factors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例执行</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = 60</span><br><span class="line"></span><br><span class="line">处理2：60 / 2 = 30, 30 / 2 = 15</span><br><span class="line">       factors = [2, 2]</span><br><span class="line"></span><br><span class="line">处理3：15 / 3 = 5</span><br><span class="line">       factors = [2, 2, 3]</span><br><span class="line"></span><br><span class="line">处理5：5是质数，直接加入</span><br><span class="line">       factors = [2, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">结果：60 = 2^2 × 3 × 5</span><br></pre></td></tr></table></figure><hr><h2 id="er-zui-da-gong-yue-shu-gcd-yu-zui-xiao-gong-bei-shu-lcm" tabindex="-1" id="二、最大公约数（GCD）与最小公倍数（LCM）">二、最大公约数（GCD）与最小公倍数（LCM）</h2><h3 id="2-1-zui-da-gong-yue-shu-gcd" tabindex="-1" id="2-1-最大公约数（GCD）">2.1 最大公约数（GCD）</h3><blockquote><p>两个或多个整数共有约数中最大的一个</p></blockquote><h4 id="ou-ji-li-de-suan-fa-zhan-zhuan-xiang-chu-fa" tabindex="-1" id="欧几里得算法（辗转相除法）">欧几里得算法（辗转相除法）</h4><p><strong>数学原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcd(a, b) = gcd(b, a % b)</span><br><span class="line">gcd(a, 0) = a</span><br></pre></td></tr></table></figure><p><strong>可视化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcd(48, 18)</span><br><span class="line">= gcd(18, 48 % 18)</span><br><span class="line">= gcd(18, 12)</span><br><span class="line">= gcd(12, 18 % 12)</span><br><span class="line">= gcd(12, 6)</span><br><span class="line">= gcd(6, 12 % 6)</span><br><span class="line">= gcd(6, 0)</span><br><span class="line">= 6</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-2" tabindex="-1" id="代码实现-3">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17标准库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="type">int</span> result = std::<span class="built_in">gcd</span>(a, b);</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log min(a, b))</p><hr><h3 id="2-2-zui-xiao-gong-bei-shu-lcm" tabindex="-1" id="2-2-最小公倍数（LCM）">2.2 最小公倍数（LCM）</h3><blockquote><p>两个或多个整数公有的倍数中最小的一个</p></blockquote><h4 id="shu-xue-guan-xi" tabindex="-1" id="数学关系">数学关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcm(a, b) = (a × b) / gcd(a, b)</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-3" tabindex="-1" id="代码实现-4">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先除后乘，避免溢出</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17标准库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> result = std::<span class="built_in">lcm</span>(a, b);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：要防止整数溢出！</p><hr><h3 id="2-3-ying-yong-jian-hua-fen-shu" tabindex="-1" id="2-3-应用：简化分数">2.3 应用：简化分数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fraction</span> &#123;</span><br><span class="line">    <span class="type">int</span> numerator;    <span class="comment">// 分子</span></span><br><span class="line">    <span class="type">int</span> denominator;  <span class="comment">// 分母</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">simplify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator));</span><br><span class="line">        numerator /= g;</span><br><span class="line">        denominator /= g;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保分母为正</span></span><br><span class="line">        <span class="keyword">if</span> (denominator &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            numerator = -numerator;</span><br><span class="line">            denominator = -denominator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12/18 简化：</span><br><span class="line">gcd(12, 18) = 6</span><br><span class="line">12/6 = 2, 18/6 = 3</span><br><span class="line">结果：2/3</span><br></pre></td></tr></table></figure><hr><h2 id="san-kuai-su-mi-yu-mo-yun-suan" tabindex="-1" id="三、快速幂与模运算">三、快速幂与模运算</h2><h3 id="3-1-kuai-su-mi-leet-code-50" tabindex="-1" id="3-1-快速幂（LeetCode-50）">3.1 快速幂（LeetCode 50）</h3><blockquote><p>计算 x^n，要求时间复杂度 O(log n)</p></blockquote><h4 id="bao-li-fang-fa" tabindex="-1" id="暴力方法">暴力方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        result *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：n很大时太慢</p><h4 id="kuai-su-mi-fen-zhi" tabindex="-1" id="快速幂（分治）">快速幂（分治）</h4><p><strong>核心思想</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x^8 = (x^4)^2 = ((x^2)^2)^2</span><br><span class="line"></span><br><span class="line">x^n = (x^(n/2))^2        (n为偶数)</span><br><span class="line">x^n = x × (x^(n/2))^2     (n为奇数)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">计算 2^10：</span><br><span class="line"></span><br><span class="line">2^10 = (2^5)^2</span><br><span class="line">2^5 = 2 × (2^2)^2</span><br><span class="line">2^2 = (2^1)^2</span><br><span class="line">2^1 = 2</span><br><span class="line"></span><br><span class="line">反向计算：</span><br><span class="line">2^1 = 2</span><br><span class="line">2^2 = 2 × 2 = 4</span><br><span class="line">2^5 = 2 × 4^2 = 2 × 16 = 32</span><br><span class="line">2^10 = 32^2 = 1024</span><br><span class="line"></span><br><span class="line">只需要4次乘法！（暴力需要9次）</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-di-gui-ban" tabindex="-1" id="代码实现（递归版）">代码实现（递归版）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fastPow</span>(x, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fastPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> half = <span class="built_in">fastPow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> half * half;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> half * half * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-die-dai-ban-tui-jian" tabindex="-1" id="代码实现（迭代版，推荐）">代码实现（迭代版，推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">double</span> current = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;  <span class="comment">// n是奇数</span></span><br><span class="line">            result *= current;</span><br><span class="line">        &#125;</span><br><span class="line">        current *= current;  <span class="comment">// current = x^(2^i)</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)</p><hr><h3 id="3-2-mo-yun-suan-xia-de-kuai-su-mi" tabindex="-1" id="3-2-模运算下的快速幂">3.2 模运算下的快速幂</h3><blockquote><p><strong>LeetCode 1969</strong>：超级次方</p></blockquote><h4 id="mo-yun-suan-xing-zhi" tabindex="-1" id="模运算性质">模运算性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a × b) % p = ((a % p) × (b % p)) % p</span><br><span class="line">(a + b) % p = ((a % p) + (b % p)) % p</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-4" tabindex="-1" id="代码实现-5">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">powMod</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    x %= mod;  <span class="comment">// 先取模</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：计算大数的幂次，防止溢出</p><hr><h2 id="si-shu-xue-gui-lu-wen-ti" tabindex="-1" id="四、数学规律问题">四、数学规律问题</h2><h3 id="4-1-jie-cheng-mo-wei-ling-de-ge-shu-leet-code-172" tabindex="-1" id="4-1-阶乘末尾零的个数（LeetCode-172）">4.1 阶乘末尾零的个数（LeetCode 172）</h3><blockquote><p>给定一个整数 n，返回 n! 结果尾数中零的数量</p></blockquote><h4 id="fen-xi" tabindex="-1" id="分析">分析</h4><p>末尾的0来自于 2 × 5，因子2的数量总是比5多，所以只需要数5的个数。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5! = 120 → 1个0（一个5）</span><br><span class="line">10! = 3628800 → 2个0（两个5：5和10）</span><br><span class="line">25! → 至少6个0（5,10,15,20,25×2）</span><br></pre></td></tr></table></figure><h4 id="shu-5-de-ge-shu" tabindex="-1" id="数5的个数">数5的个数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n / 5：有多少个5的倍数</span><br><span class="line">n / 25：有多少个25的倍数（额外贡献一个5）</span><br><span class="line">n / 125：有多少个125的倍数（额外贡献一个5）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-5" tabindex="-1" id="代码实现-6">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 25</span><br><span class="line"></span><br><span class="line">第1轮：n = 25 / 5 = 5, count = 5</span><br><span class="line">第2轮：n = 5 / 5 = 1, count = 6</span><br><span class="line">第3轮：n = 1 / 5 = 0, 结束</span><br><span class="line"></span><br><span class="line">答案：6个0</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)</p><hr><h3 id="4-2-shu-zi-1-de-ge-shu-leet-code-233" tabindex="-1" id="4-2-数字1的个数（LeetCode-233）">4.2 数字1的个数（LeetCode 233）</h3><blockquote><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的次数</p></blockquote><h4 id="wen-ti-shi-li-1" tabindex="-1" id="问题示例-2">问题示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br><span class="line">解释：1, 10, 11(2个), 12, 13 → 共6个1</span><br></pre></td></tr></table></figure><h4 id="shu-wei-dp-si-lu" tabindex="-1" id="数位DP思路">数位DP思路</h4><p>按位统计：个位、十位、百位…各有多少个1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于 n = 234，统计十位上1的个数：</span><br><span class="line"></span><br><span class="line">当十位为1时，可能的数字：</span><br><span class="line">- 010-019（百位为0）</span><br><span class="line">- 110-119（百位为1）</span><br><span class="line">- 210-219（百位为2）</span><br><span class="line">共：3 × 10 = 30个</span><br><span class="line"></span><br><span class="line">但234的十位是3（≠1），所以不需要特殊处理</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-6" tabindex="-1" id="代码实现-7">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> factor = <span class="number">1</span>;  <span class="comment">// 当前位的权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (factor &lt;= n) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> higher = n / (factor * <span class="number">10</span>);  <span class="comment">// 高位数字</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur = (n / factor) % <span class="number">10</span>;     <span class="comment">// 当前位数字</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lower = n % factor;          <span class="comment">// 低位数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            count += higher * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">            count += higher * factor + lower + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += (higher + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        factor *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-chou-shu-leet-code-264" tabindex="-1" id="4-3-丑数（LeetCode-264）">4.3 丑数（LeetCode 264）</h3><blockquote><p>丑数是只包含质因数 2, 3, 5 的正整数</p></blockquote><h4 id="wen-ti" tabindex="-1" id="问题">问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：1,2,3,4,5,6,8,9,10,12是前10个丑数</span><br></pre></td></tr></table></figure><h4 id="dong-tai-gui-hua-san-zhi-zhen" tabindex="-1" id="动态规划（三指针）">动态规划（三指针）</h4><p><strong>思路</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个丑数都是之前的丑数 × 2、× 3 或 × 5 得到的</span><br><span class="line">用三个指针分别维护</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-7" tabindex="-1" id="代码实现-8">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> next2 = dp[p2] * <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> next3 = dp[p3] * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> next5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        dp[i] = <span class="built_in">min</span>(&#123;next2, next3, next5&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next2) p2++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next3) p3++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next5) p5++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程演示</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始：dp[0] = 1</span><br><span class="line"></span><br><span class="line">i=1: next2=2, next3=3, next5=5 → dp[1]=2, p2++</span><br><span class="line">i=2: next2=3, next3=3, next5=5 → dp[2]=3, p2++, p3++</span><br><span class="line">i=3: next2=4, next3=6, next5=5 → dp[3]=4, p2++</span><br><span class="line">i=4: next2=6, next3=6, next5=5 → dp[4]=5, p5++</span><br><span class="line">i=5: next2=6, next3=6, next5=10 → dp[5]=6, p2++, p3++</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">丑数序列：1, 2, 3, 4, 5, 6, 8, 9, 10, 12...</span><br></pre></td></tr></table></figure><hr><h2 id="wu-zu-he-shu-xue" tabindex="-1" id="五、组合数学">五、组合数学</h2><h3 id="5-1-pa-si-qia-san-jiao-xing-leet-code-118" tabindex="-1" id="5-1-帕斯卡三角形（LeetCode-118）">5.1 帕斯卡三角形（LeetCode 118）</h3><blockquote><p>杨辉三角/帕斯卡三角形</p></blockquote><h4 id="ke-shi-hua" tabindex="-1" id="可视化">可视化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         1</span><br><span class="line">       1   1</span><br><span class="line">     1   2   1</span><br><span class="line">   1   3   3   1</span><br><span class="line"> 1   4   6   4   1</span><br><span class="line">1   5  10  10   5   1</span><br></pre></td></tr></table></figure><p><strong>规律</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个数 = 左上方的数 + 右上方的数</span><br><span class="line">C(n, k) = C(n-1, k-1) + C(n-1, k)</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-8" tabindex="-1" id="代码实现-9">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; triangle;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(i + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            row[j] = triangle[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        triangle.<span class="built_in">push_back</span>(row);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> triangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-zu-he-shu-ji-suan" tabindex="-1" id="5-2-组合数计算">5.2 组合数计算</h3><blockquote><p>计算 C(n, k) = n! / (k! × (n-k)!)</p></blockquote><h4 id="fang-fa-1-di-tui-gong-shi" tabindex="-1" id="方法1：递推公式">方法1：递推公式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || k == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C(n, k) = C(n-1, k-1) + C(n-1, k)</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= k) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; j &lt;= k; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fang-fa-2-zhi-jie-ji-suan-fang-yi-chu" tabindex="-1" id="方法2：直接计算（防溢出）">方法2：直接计算（防溢出）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; n - k) k = n - k;  <span class="comment">// 利用对称性</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        result = result * (n - i) / (i + <span class="number">1</span>);  <span class="comment">// 边乘边除，防溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="liu-qi-ta-shu-xue-ji-qiao" tabindex="-1" id="六、其他数学技巧">六、其他数学技巧</h2><h3 id="6-1-pan-duan-wan-quan-ping-fang-shu" tabindex="-1" id="6-1-判断完全平方数">6.1 判断完全平方数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">return</span> x * x == num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找版本</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> square = mid * mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (square == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-2-zheng-shu-fan-zhuan-leet-code-7" tabindex="-1" id="6-2-整数反转（LeetCode-7）">6.2 整数反转（LeetCode 7）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查溢出</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || (result == INT_MAX / <span class="number">10</span> &amp;&amp; digit &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result &lt; INT_MIN / <span class="number">10</span> || (result == INT_MIN / <span class="number">10</span> &amp;&amp; digit &lt; <span class="number">-8</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = result * <span class="number">10</span> + digit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-3-hui-wen-shu-leet-code-9" tabindex="-1" id="6-3-回文数（LeetCode-9）">6.3 回文数（LeetCode 9）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负数和末尾为0的数（除了0本身）不是回文</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; reversed) &#123;</span><br><span class="line">        reversed = reversed * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 奇数位：x == reversed / 10</span></span><br><span class="line">    <span class="comment">// 偶数位：x == reversed</span></span><br><span class="line">    <span class="keyword">return</span> x == reversed || x == reversed / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>质数判断</strong>：试除法 O(√n)，埃氏筛法 O(n log log n)</li><li><strong>GCD</strong>：欧几里得算法 O(log min(a,b))</li><li><strong>快速幂</strong>：分治思想，O(log n)</li><li><strong>找规律</strong>：观察数学性质，降低复杂度</li></ol><h3 id="chang-yong-mo-ban" tabindex="-1" id="常用模板">常用模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断质数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模运算快速幂</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">powMod</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) result = (result * x) % mod;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tui-jian-ti-mu" tabindex="-1" id="推荐题目">推荐题目</h3><p><strong>入门级</strong>：</p><ul><li><a href="https://leetcode.com/problems/palindrome-number/">LeetCode 9 - 回文数</a></li><li><a href="https://leetcode.com/problems/reverse-integer/">LeetCode 7 - 整数反转</a></li><li><a href="https://leetcode.com/problems/count-primes/">LeetCode 204 - 计数质数</a></li></ul><p><strong>进阶级</strong>：</p><ul><li><a href="https://leetcode.com/problems/powx-n/">LeetCode 50 - Pow(x, n)</a></li><li><a href="https://leetcode.com/problems/factorial-trailing-zeroes/">LeetCode 172 - 阶乘后的零</a></li><li><a href="https://leetcode.com/problems/ugly-number-ii/">LeetCode 264 - 丑数 II</a></li></ul><p><strong>高级</strong>：</p><ul><li><a href="https://leetcode.com/problems/number-of-digit-one/">LeetCode 233 - 数字1的个数</a></li><li><a href="https://leetcode.com/problems/consecutive-numbers-sum/">LeetCode 829 - 连续整数求和</a></li></ul><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://book.douban.com/subject/21323941/">《具体数学》- Graham, Knuth, Patashnik</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E8%AE%BA">数论基础 - 维基百科</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;shu-xue-suan-fa-bian-cheng-zhong-de-shu-xue-mo-fa&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="算法技巧" scheme="https://smarter.xin/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    <category term="数学" scheme="https://smarter.xin/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="质数" scheme="https://smarter.xin/tags/%E8%B4%A8%E6%95%B0/"/>
    
    <category term="最大公约数" scheme="https://smarter.xin/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-位运算</title>
    <link href="https://smarter.xin/posts/3609144b/"/>
    <id>https://smarter.xin/posts/3609144b/</id>
    <published>2026-01-06T12:11:53.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wei-yun-suan-zai-er-jin-zhi-shi-jie-li-pian-pian-qi-wu" tabindex="-1">位运算：在二进制世界里翩翩起舞</h1><blockquote><p>当别人还在用加减乘除时，你已经在用与或非异或了</p></blockquote><hr><h2 id="shi-yao-shi-wei-yun-suan" tabindex="-1" id="什么是位运算">什么是位运算</h2><p><strong>位运算</strong>（Bit Manipulation）是直接对整数在内存中的二进制位进行操作的运算方式。相比普通的算术运算，位运算在某些场景下速度更快、更节省空间。</p><blockquote><p><strong>核心特点</strong>：直接操作二进制位，效率极高</p></blockquote><h3 id="wei-shi-yao-yao-xue-wei-yun-suan" tabindex="-1" id="为什么要学位运算？">为什么要学位运算？</h3><pre><code class="highlight mermaid">graph LR    A[位运算的优势] --&gt; B[速度快]    A --&gt; C[省空间]    A --&gt; D[技巧性强]    A --&gt; E[面试常考]        B --&gt; B1[CPU直接支持]    C --&gt; C1[用位表示状态]    D --&gt; D1[巧妙解决问题]    E --&gt; E1[考察基本功]        style A fill:#FFE4B5    style B fill:#90EE90    style D fill:#87CEEB</code></pre><hr><h2 id="ji-chu-wei-yun-suan-fu" tabindex="-1" id="基础位运算符">基础位运算符</h2><h3 id="liu-da-yun-suan-fu" tabindex="-1" id="六大运算符">六大运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td>两位都为1才为1</td><td><code>5 &amp; 3 = 1</code></td></tr><tr><td><code>|</code></td><td>按位或</td><td>有一位为1就为1</td><td><code>5 | 3 = 7</code></td></tr><tr><td><code>^</code></td><td>按位异或</td><td>相同为0，不同为1</td><td><code>5 ^ 3 = 6</code></td></tr><tr><td><code>~</code></td><td>按位取反</td><td>0变1，1变0</td><td><code>~5 = -6</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>向左移位，右边补0</td><td><code>5 &lt;&lt; 1 = 10</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>向右移位，左边补符号位</td><td><code>5 &gt;&gt; 1 = 2</code></td></tr></tbody></table><h3 id="yun-suan-fu-xiang-jie" tabindex="-1" id="运算符详解">运算符详解</h3><h4 id="1-an-wei-yu-amp" tabindex="-1" id="1-按位与（-）">1. 按位与（&amp;）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">规则：两位都为1才为1</span><br><span class="line"></span><br><span class="line">    5:  0101</span><br><span class="line">  &amp; 3:  0011</span><br><span class="line">  ————————————</span><br><span class="line">    1:  0001</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">- 判断奇偶：n &amp; 1（最低位为1是奇数）</span><br><span class="line">- 清零特定位</span><br><span class="line">- 提取特定位</span><br></pre></td></tr></table></figure><h4 id="2-an-wei-huo" tabindex="-1" id="2-按位或（-）">2. 按位或（|）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">规则：有一位为1就为1</span><br><span class="line"></span><br><span class="line">    5:  0101</span><br><span class="line">  | 3:  0011</span><br><span class="line">  ————————————</span><br><span class="line">    7:  0111</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">- 设置特定位为1</span><br><span class="line">- 合并标志位</span><br></pre></td></tr></table></figure><h4 id="3-an-wei-yi-huo" tabindex="-1" id="3-按位异或（-）★">3. 按位异或（^）★</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">规则：相同为0，不同为1</span><br><span class="line"></span><br><span class="line">    5:  0101</span><br><span class="line">  ^ 3:  0011</span><br><span class="line">  ————————————</span><br><span class="line">    6:  0110</span><br><span class="line"></span><br><span class="line">神奇性质：</span><br><span class="line">1. a ^ a = 0（自己异或自己等于0）</span><br><span class="line">2. a ^ 0 = a（任何数异或0等于自己）</span><br><span class="line">3. 交换律：a ^ b = b ^ a</span><br><span class="line">4. 结合律：a ^ b ^ c = a ^ (b ^ c)</span><br></pre></td></tr></table></figure><h4 id="4-an-wei-qu-fan" tabindex="-1" id="4-按位取反（-）">4. 按位取反（~）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">规则：0变1，1变0</span><br><span class="line"></span><br><span class="line">  ~5:  ~0101 = 1010（补码表示为-6）</span><br><span class="line"></span><br><span class="line">注意：涉及到补码，负数表示</span><br></pre></td></tr></table></figure><h4 id="5-zuo-yi-lt-lt" tabindex="-1" id="5-左移（-）">5. 左移（&lt;&lt;）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">规则：向左移n位，相当于乘以2^n</span><br><span class="line"></span><br><span class="line">5 &lt;&lt; 1:  0101 &lt;&lt; 1 = 1010 (10)</span><br><span class="line">5 &lt;&lt; 2:  0101 &lt;&lt; 2 = 10100 (20)</span><br><span class="line"></span><br><span class="line">规律：n &lt;&lt; k = n * 2^k</span><br></pre></td></tr></table></figure><h4 id="6-you-yi-gt-gt" tabindex="-1" id="6-右移（-）">6. 右移（&gt;&gt;）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">规则：向右移n位，相当于除以2^n</span><br><span class="line"></span><br><span class="line">5 &gt;&gt; 1:  0101 &gt;&gt; 1 = 0010 (2)</span><br><span class="line">5 &gt;&gt; 2:  0101 &gt;&gt; 2 = 0001 (1)</span><br><span class="line"></span><br><span class="line">规律：n &gt;&gt; k = n / 2^k（向下取整）</span><br></pre></td></tr></table></figure><hr><h2 id="chang-jian-wei-yun-suan-ji-qiao" tabindex="-1" id="常见位运算技巧">常见位运算技巧</h2><h3 id="1-pan-duan-qi-ou" tabindex="-1" id="1-判断奇偶">1. 判断奇偶</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方法</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">/* 偶数 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算（更快）</span></span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">/* 偶数 */</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123; <span class="comment">/* 奇数 */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：二进制最低位为0是偶数，为1是奇数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4: 0100 &amp; 1 = 0 (偶数)</span><br><span class="line">5: 0101 &amp; 1 = 1 (奇数)</span><br></pre></td></tr></table></figure><hr><h3 id="2-jiao-huan-liang-ge-shu-bu-yong-lin-shi-bian-liang" tabindex="-1" id="2-交换两个数（不用临时变量）">2. 交换两个数（不用临时变量）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方法</span></span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算（无需临时变量）</span></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;  <span class="comment">// b = (a^b) ^ b = a</span></span><br><span class="line">a = a ^ b;  <span class="comment">// a = (a^b) ^ a = b</span></span><br></pre></td></tr></table></figure><p><strong>原理</strong>：利用异或的性质 <code>a ^ b ^ b = a</code></p><hr><h3 id="3-huo-qu-she-zhi-qing-chu-te-ding-wei" tabindex="-1" id="3-获取-设置-清除特定位">3. 获取/设置/清除特定位</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第k位（从0开始）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置第k位为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n | (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除第k位（设为0）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; ~(<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换第k位（0变1，1变0）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toggleBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n ^ (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = 5 (0101)</span><br><span class="line"></span><br><span class="line">getBit(5, 2) = (0101 &gt;&gt; 2) &amp; 1 = 01 &amp; 1 = 1</span><br><span class="line">setBit(5, 1) = 0101 | 0010 = 0111 = 7</span><br><span class="line">clearBit(5, 0) = 0101 &amp; ~0001 = 0101 &amp; 1110 = 0100 = 4</span><br><span class="line">toggleBit(5, 1) = 0101 ^ 0010 = 0111 = 7</span><br></pre></td></tr></table></figure><hr><h3 id="4-qing-chu-zui-di-wei-de-1" tabindex="-1" id="4-清除最低位的1">4. 清除最低位的1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除最右边的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearLowestBit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理图解</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 12:  1100</span><br><span class="line">n-1 = 11: 1011</span><br><span class="line">n &amp; (n-1): 1100 &amp; 1011 = 1000 = 8</span><br><span class="line">         清除了最右边的1</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：统计1的个数（Brian Kernighan算法）</p><hr><h3 id="5-huo-qu-zui-di-wei-de-1" tabindex="-1" id="5-获取最低位的1">5. 获取最低位的1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只保留最右边的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLowestBit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = 12:   0...01100</span><br><span class="line">-n:       1...10100（补码）</span><br><span class="line">n &amp; (-n): 0...00100 = 4</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：树状数组（Fenwick Tree）</p><hr><h3 id="6-pan-duan-shi-fou-wei-2-de-mi" tabindex="-1" id="6-判断是否为2的幂">6. 判断是否为2的幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：2的幂只有一个1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2:  0010 &amp; 0001 = 0000 ✓</span><br><span class="line">4:  0100 &amp; 0011 = 0000 ✓</span><br><span class="line">6:  0110 &amp; 0101 = 0100 ✗</span><br><span class="line">8:  1000 &amp; 0111 = 0000 ✓</span><br></pre></td></tr></table></figure><hr><h3 id="7-tong-ji-1-de-ge-shu" tabindex="-1" id="7-统计1的个数">7. 统计1的个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：Brian Kernighan算法（推荐）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);  <span class="comment">// 清除最右边的1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：逐位检查</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        count += (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：C++内置函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes3</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __builtin_popcount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率对比</strong>：</p><ul><li>方法1：O(k)，k为1的个数</li><li>方法2：O(32)</li><li>方法3：编译器优化，最快</li></ul><hr><h2 id="jing-dian-leet-code-wen-ti" tabindex="-1" id="经典LeetCode问题">经典LeetCode问题</h2><h3 id="1-zhi-chu-xian-yi-ci-de-shu-zi-leet-code-136" tabindex="-1" id="1-只出现一次的数字（LeetCode-136）">1. 只出现一次的数字（LeetCode 136）</h3><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,1]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h4 id="jie-fa-yi-huo" tabindex="-1" id="解法：异或">解法：异或</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a ^ a = 0</span><br><span class="line">a ^ 0 = a</span><br><span class="line">交换律和结合律</span><br><span class="line"></span><br><span class="line">[4,1,2,1,2]</span><br><span class="line">= 4 ^ 1 ^ 2 ^ 1 ^ 2</span><br><span class="line">= 4 ^ (1 ^ 1) ^ (2 ^ 2)</span><br><span class="line">= 4 ^ 0 ^ 0</span><br><span class="line">= 4</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(1)</p><hr><h3 id="2-wei-1-de-ge-shu-leet-code-191" tabindex="-1" id="2-位1的个数（LeetCode-191）">2. 位1的个数（LeetCode 191）</h3><blockquote><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：11 (0000...1011)</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h4 id="jie-fa-brian-kernighan-suan-fa" tabindex="-1" id="解法：Brian-Kernighan算法">解法：Brian Kernighan算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);  <span class="comment">// 清除最右边的1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程演示</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = 11 (1011)</span><br><span class="line"></span><br><span class="line">第1次：n = 1011</span><br><span class="line">      n-1 = 1010</span><br><span class="line">      n &amp; (n-1) = 1010, count=1</span><br><span class="line"></span><br><span class="line">第2次：n = 1010</span><br><span class="line">      n-1 = 1001</span><br><span class="line">      n &amp; (n-1) = 1000, count=2</span><br><span class="line"></span><br><span class="line">第3次：n = 1000</span><br><span class="line">      n-1 = 0111</span><br><span class="line">      n &amp; (n-1) = 0000, count=3</span><br><span class="line"></span><br><span class="line">结束，返回3</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-de-mi-leet-code-231" tabindex="-1" id="3-2的幂（LeetCode-231）">3. 2的幂（LeetCode 231）</h3><blockquote><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2的幂只有一个1：</span><br><span class="line">2:   0010</span><br><span class="line">4:   0100</span><br><span class="line">8:   1000</span><br><span class="line"></span><br><span class="line">非2的幂有多个1：</span><br><span class="line">3:   0011</span><br><span class="line">6:   0110</span><br></pre></td></tr></table></figure><hr><h3 id="4-dian-dao-er-jin-zhi-wei-leet-code-190" tabindex="-1" id="4-颠倒二进制位（LeetCode-190）">4. 颠倒二进制位（LeetCode 190）</h3><blockquote><p>颠倒给定的 32 位无符号整数的二进制位。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：43261596 (00000010100101000001111010011100)</span><br><span class="line">输出：964176192 (00111001011110000010100101000000)</span><br></pre></td></tr></table></figure><h4 id="jie-fa-zhu-wei-fan-zhuan" tabindex="-1" id="解法：逐位翻转">解法：逐位翻转</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>);  <span class="comment">// 取n最低位，加到result末尾</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;                            <span class="comment">// n右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程演示</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = 1011 (只看4位)</span><br><span class="line"></span><br><span class="line">i=0: result = 0, n=1011</span><br><span class="line">     result = (0 &lt;&lt; 1) | 1 = 1</span><br><span class="line">     n = 0101</span><br><span class="line"></span><br><span class="line">i=1: result = 1, n=0101</span><br><span class="line">     result = (1 &lt;&lt; 1) | 1 = 11</span><br><span class="line">     n = 0010</span><br><span class="line"></span><br><span class="line">i=2: result = 11, n=0010</span><br><span class="line">     result = (11 &lt;&lt; 1) | 0 = 110</span><br><span class="line">     n = 0001</span><br><span class="line"></span><br><span class="line">i=3: result = 110, n=0001</span><br><span class="line">     result = (110 &lt;&lt; 1) | 1 = 1101</span><br><span class="line">     n = 0000</span><br><span class="line"></span><br><span class="line">结果：1101（原数1011的翻转）</span><br></pre></td></tr></table></figure><hr><h3 id="5-zhi-chu-xian-yi-ci-de-shu-zi-iii-leet-code-260" tabindex="-1" id="5-只出现一次的数字III（LeetCode-260）">5. 只出现一次的数字III（LeetCode 260）</h3><blockquote><p>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br></pre></td></tr></table></figure><h4 id="jie-fa-fen-zu-yi-huo" tabindex="-1" id="解法：分组异或">解法：分组异或</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 步骤1：全部异或，得到两个单独数字的异或结果</span></span><br><span class="line">    <span class="type">int</span> xorResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        xorResult ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤2：找到xorResult中任意一个为1的位</span></span><br><span class="line">    <span class="comment">// 这一位在两个数字中不同</span></span><br><span class="line">    <span class="type">int</span> rightmostBit = xorResult &amp; (-xorResult);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：根据这一位分组</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &amp; rightmostBit) &#123;</span><br><span class="line">            num1 ^= num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num2 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;num1, num2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理图解</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[1,2,1,3,2,5]</span><br><span class="line"></span><br><span class="line">步骤1：全部异或</span><br><span class="line">1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 0011 ^ 0101 = 0110</span><br><span class="line"></span><br><span class="line">步骤2：找最右边的1</span><br><span class="line">0110 &amp; (-0110) = 0010</span><br><span class="line"></span><br><span class="line">步骤3：按第2位分组</span><br><span class="line">第2位为0：1(0001), 1(0001), 3(0011), 5(0101)</span><br><span class="line">第2位为1：2(0010), 2(0010)</span><br><span class="line"></span><br><span class="line">组1异或：1 ^ 1 ^ 3 ^ 5 = 3 ^ 5 = 6... 错了？</span><br><span class="line">应该是：</span><br><span class="line">第2位为1：2(0010), 2(0010)</span><br><span class="line">第2位为0：1(0001), 1(0001), 3(0011), 5(0101)</span><br><span class="line"></span><br><span class="line">重新分析：</span><br><span class="line">rightmostBit = 0010</span><br><span class="line"></span><br><span class="line">第2位为1：2, 2 → 异或 = 0</span><br><span class="line">第2位为0：1, 1, 3, 5 → 异或 = 3 ^ 5</span><br><span class="line"></span><br><span class="line">不对，让我重新理解：</span><br><span class="line">按照这一位把所有数分成两组，每组内成对的会消掉，剩下各自的单独数字</span><br></pre></td></tr></table></figure><hr><h3 id="6-bi-te-wei-ji-shu-leet-code-338" tabindex="-1" id="6-比特位计数（LeetCode-338）">6. 比特位计数（LeetCode 338）</h3><blockquote><p>给定一个非负整数 num，对于范围 [0, num] 中的每个数字，计算其二进制表达式中 1 的个数。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：[0,1,1,2,1,2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">0: 0000 → 0个1</span><br><span class="line">1: 0001 → 1个1</span><br><span class="line">2: 0010 → 1个1</span><br><span class="line">3: 0011 → 2个1</span><br><span class="line">4: 0100 → 1个1</span><br><span class="line">5: 0101 → 2个1</span><br></pre></td></tr></table></figure><h4 id="jie-fa-1-dong-tai-gui-hua-zui-di-wei" tabindex="-1" id="解法1：动态规划-最低位">解法1：动态规划 + 最低位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i的1的个数 = (i/2)的1的个数 + i的最低位</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">6 (110) = 3 (11) 向右移一位 + 0 (最低位)</span><br><span class="line">        = 2个1 + 0 = 2</span><br><span class="line"></span><br><span class="line">7 (111) = 3 (11) 向右移一位 + 1 (最低位)</span><br><span class="line">        = 2个1 + 1 = 3</span><br></pre></td></tr></table></figure><h4 id="jie-fa-2-dong-tai-gui-hua-qing-chu-zui-di-wei" tabindex="-1" id="解法2：动态规划-清除最低位">解法2：动态规划 + 清除最低位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i的1的个数 = (i清除最低位后)的1的个数 + 1</span><br><span class="line"></span><br><span class="line">6 (110) = 4 (100) 清除最低位 + 1</span><br><span class="line">        = 1个1 + 1 = 2</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(n)</p><hr><h3 id="7-yi-ming-ju-chi-leet-code-461" tabindex="-1" id="7-汉明距离（LeetCode-461）">7. 汉明距离（LeetCode 461）</h3><blockquote><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">1: 0001</span><br><span class="line">4: 0100</span><br><span class="line">不同位：2个</span><br></pre></td></tr></table></figure><h4 id="jie-fa-yi-huo-ji-shu" tabindex="-1" id="解法：异或-计数">解法：异或 + 计数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xorResult = x ^ y;  <span class="comment">// 不同的位为1</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (xorResult) &#123;</span><br><span class="line">        xorResult &amp;= (xorResult - <span class="number">1</span>);  <span class="comment">// 清除最右边的1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="gao-ji-ji-qiao" tabindex="-1" id="高级技巧">高级技巧</h2><h3 id="1-zi-ji-sheng-cheng-zhuang-tai-ya-suo" tabindex="-1" id="1-子集生成（状态压缩）">1. 子集生成（状态压缩）</h3><p>用位运算生成集合的所有子集：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历0到2^n-1的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 检查第i位是否为1</span></span><br><span class="line">            <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                subset.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(subset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,2,3]</span><br><span class="line">用3位二进制表示：</span><br><span class="line"></span><br><span class="line">000: []</span><br><span class="line">001: [1]</span><br><span class="line">010: [2]</span><br><span class="line">011: [1,2]</span><br><span class="line">100: [3]</span><br><span class="line">101: [1,3]</span><br><span class="line">110: [2,3]</span><br><span class="line">111: [1,2,3]</span><br></pre></td></tr></table></figure><hr><h3 id="2-n-huang-hou-wei-yun-suan-you-hua" tabindex="-1" id="2-N皇后位运算优化">2. N皇后位运算优化</h3><p>使用位运算优化N皇后问题的状态表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> cols, <span class="type">int</span> diag1, <span class="type">int</span> diag2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        <span class="comment">// 找到一个解</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可放置的位置：未被占用的列和对角线</span></span><br><span class="line">    <span class="type">int</span> available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; ~(cols | diag1 | diag2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="type">int</span> position = available &amp; (-available);  <span class="comment">// 取最右边的1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 放置皇后</span></span><br><span class="line">        <span class="built_in">solveNQueens</span>(row + <span class="number">1</span>, </span><br><span class="line">                     cols | position,</span><br><span class="line">                     (diag1 | position) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                     (diag2 | position) &gt;&gt; <span class="number">1</span>,</span><br><span class="line">                     n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除这个位置</span></span><br><span class="line">        available &amp;= (available - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li>用整数表示状态，节省空间</li><li>位运算速度快</li></ul><hr><h2 id="wei-yun-suan-kou-jue" tabindex="-1" id="位运算口诀">位运算口诀</h2><h3 id="chang-yong-ji-qiao-ji-yi" tabindex="-1" id="常用技巧记忆">常用技巧记忆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 判断奇偶：n &amp; 1</span><br><span class="line">2. 乘以2：n &lt;&lt; 1</span><br><span class="line">3. 除以2：n &gt;&gt; 1</span><br><span class="line">4. 交换不用临时变量：a ^= b; b ^= a; a ^= b;</span><br><span class="line">5. 清除最右边的1：n &amp; (n-1)</span><br><span class="line">6. 获取最右边的1：n &amp; (-n)</span><br><span class="line">7. 判断2的幂：n &amp; (n-1) == 0</span><br></pre></td></tr></table></figure><h3 id="yi-huo-de-shen-qi-xing-zhi" tabindex="-1" id="异或的神奇性质">异或的神奇性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自己异或自己等于0：a ^ a = 0</span><br><span class="line">任何数异或0等于自己：a ^ 0 = a</span><br><span class="line">满足交换律和结合律</span><br></pre></td></tr></table></figure><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>异或是王者</strong>：大多数位运算题目的核心</li><li><strong>n &amp; (n-1)</strong>：清除最右边的1，超级实用</li><li><strong>状态压缩</strong>：用位表示集合状态</li><li><strong>效率优势</strong>：位运算比普通运算快</li></ol><h3 id="chang-yong-mo-ban" tabindex="-1" id="常用模板">常用模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 统计1的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 判断2的幂</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取/设置/清除第k位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> (n &gt;&gt; k) &amp; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> n | (<span class="number">1</span> &lt;&lt; k); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> n &amp; ~(<span class="number">1</span> &lt;&lt; k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 异或找单独数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findSingle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tui-jian-ti-mu" tabindex="-1" id="推荐题目">推荐题目</h3><p><strong>入门级</strong>：</p><ul><li><a href="https://leetcode.com/problems/single-number/">LeetCode 136 - 只出现一次的数字</a></li><li><a href="https://leetcode.com/problems/number-of-1-bits/">LeetCode 191 - 位1的个数</a></li><li><a href="https://leetcode.com/problems/power-of-two/">LeetCode 231 - 2的幂</a></li></ul><p><strong>进阶级</strong>：</p><ul><li><a href="https://leetcode.com/problems/counting-bits/">LeetCode 338 - 比特位计数</a></li><li><a href="https://leetcode.com/problems/single-number-iii/">LeetCode 260 - 只出现一次的数字III</a></li><li><a href="https://leetcode.com/problems/hamming-distance/">LeetCode 461 - 汉明距离</a></li></ul><p><strong>高级</strong>：</p><ul><li><a href="https://leetcode.com/problems/subsets/">LeetCode 78 - 子集（位运算解法）</a></li><li><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/">LeetCode 698 - 划分为k个相等的子集（状态压缩）</a></li></ul><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://graphics.stanford.edu/~seander/bithacks.html">位运算技巧总结</a></li><li><a href="https://book.douban.com/subject/1784887/">《Hacker’s Delight》</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;wei-yun-suan-zai-er-jin-zhi-shi-jie-li-pian-pian-qi-wu&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="位运算" scheme="https://smarter.xin/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二进制" scheme="https://smarter.xin/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="算法技巧" scheme="https://smarter.xin/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-快速选择</title>
    <link href="https://smarter.xin/posts/c68751d1/"/>
    <id>https://smarter.xin/posts/c68751d1/</id>
    <published>2026-01-06T05:50:05.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kuai-su-xuan-ze-bu-wan-quan-pai-xu-de-yi-zhu" tabindex="-1">快速选择：不完全排序的艺术</h1><blockquote><p>当你只需要找到第K大的元素时，为什么要把整个数组都排序呢?</p></blockquote><hr><h2 id="shi-yao-shi-kuai-su-xuan-ze" tabindex="-1" id="什么是快速选择">什么是快速选择</h2><p><strong>快速选择</strong>（QuickSelect）是一种从无序数组中找到第K小（或第K大）元素的选择算法。它基于快速排序的分区思想，但不需要完全排序。</p><blockquote><p><strong>核心思想</strong>：每次分区后，pivot元素的位置就是它在有序数组中的最终位置</p></blockquote><h3 id="xing-xiang-li-jie" tabindex="-1" id="形象理解">形象理解</h3><p>想象你要在班级里找出第3名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通方法：给全班排序，然后取第3名 → O(n log n)</span><br><span class="line">快速选择：每次排除一半不可能的人 → O(n)</span><br></pre></td></tr></table></figure><p>就像打擂台赛，每轮淘汰一半选手，不需要完整排序就能找到冠军！</p><hr><h2 id="suan-fa-yuan-li" tabindex="-1" id="算法原理">算法原理</h2><h3 id="he-xin-si-xiang" tabindex="-1" id="核心思想">核心思想</h3><p>快速选择利用快速排序的 <strong>partition（分区）</strong> 操作：</p><pre><code class="highlight mermaid">graph TD    A[选择pivot] --&gt; B[分区操作]    B --&gt; C&#123;pivot位置 vs 目标位置&#125;    C --&gt;|相等| D[找到目标，返回]    C --&gt;|pivot靠左| E[在右半部分继续]    C --&gt;|pivot靠右| F[在左半部分继续]    E --&gt; A    F --&gt; A        style D fill:#90EE90    style A fill:#FFE4B5</code></pre><h3 id="fen-qu-cao-zuo-xiang-jie" tabindex="-1" id="分区操作详解">分区操作详解</h3><p>Partition将数组分为三部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[小于pivot的元素] | [pivot] | [大于pivot的元素]</span><br><span class="line">     区域1         位置p       区域2</span><br></pre></td></tr></table></figure><p><strong>关键性质</strong>：分区后，pivot元素在它最终排序位置上</p><hr><h2 id="suan-fa-bu-zou-tu-jie" tabindex="-1" id="算法步骤图解">算法步骤图解</h2><h3 id="shi-li-zhao-di-2-da-yuan-su" tabindex="-1" id="示例：找第2大元素">示例：找第2大元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">数组：[3, 2, 1, 5, 6, 4]</span><br><span class="line">目标：第2大 = 第5小（索引4）</span><br><span class="line"></span><br><span class="line">步骤1: 选择pivot=4，分区</span><br><span class="line">[3, 2, 1] [4] [5, 6]</span><br><span class="line">  0,1,2    3   4,5</span><br><span class="line">         ↑ pivot在位置3</span><br><span class="line"></span><br><span class="line">步骤2: 目标在位置4，pivot在位置3</span><br><span class="line">       目标 &gt; pivot，在右半部分继续</span><br><span class="line">       [5, 6]</span><br><span class="line"></span><br><span class="line">步骤3: 选择pivot=5，分区</span><br><span class="line">[5] [6]</span><br><span class="line"> 4   5</span><br><span class="line"> ↑ pivot在位置4</span><br><span class="line"></span><br><span class="line">步骤4: pivot位置 = 目标位置 = 4</span><br><span class="line">       找到答案：5 ✓</span><br></pre></td></tr></table></figure><h3 id="wan-zheng-guo-cheng-ke-shi-hua" tabindex="-1" id="完整过程可视化">完整过程可视化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原数组：[3, 2, 1, 5, 6, 4]</span><br><span class="line">找第2大</span><br><span class="line"></span><br><span class="line">第1轮 Partition (pivot=4):</span><br><span class="line">Before: [3, 2, 1, 5, 6, 4]</span><br><span class="line">After:  [3, 2, 1, 4, 5, 6]</span><br><span class="line">                   ↑</span><br><span class="line">                位置3，目标在右边</span><br><span class="line"></span><br><span class="line">第2轮 Partition (pivot=6):  </span><br><span class="line">Range:  [5, 6]</span><br><span class="line">After:  [5, 6]</span><br><span class="line">            ↑</span><br><span class="line">         位置5，目标在左边</span><br><span class="line"></span><br><span class="line">第3轮 Partition (pivot=5):</span><br><span class="line">单元素：5</span><br><span class="line">         ↑</span><br><span class="line">      位置4，找到！</span><br></pre></td></tr></table></figure><hr><h2 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h2><h3 id="ji-chu-ban-ben" tabindex="-1" id="基础版本">基础版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基准情况：只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pivot位置</span></span><br><span class="line">    <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[k];           <span class="comment">// 找到目标</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);  <span class="comment">// 在右边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);   <span class="comment">// 在左边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择pivot，避免最坏情况</span></span><br><span class="line">    <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot = nums[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;  <span class="comment">// i指向小于pivot区域的最后一个位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将pivot放到正确位置</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="zhao-di-k-da-yuan-su" tabindex="-1" id="找第K大元素">找第K大元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第k大 = 第(n-k)小（从0开始索引）</span></span><br><span class="line">    <span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="partition-guo-cheng-xiang-jie" tabindex="-1" id="Partition过程详解">Partition过程详解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">数组: [3, 2, 1, 5, 6, 4]</span><br><span class="line">pivot = 4 (选择最后一个元素)</span><br><span class="line"></span><br><span class="line">初始: i = -1</span><br><span class="line">      [3, 2, 1, 5, 6, 4]</span><br><span class="line">       j              pivot</span><br><span class="line"></span><br><span class="line">j=0: nums[0]=3 &lt;= 4 ✓</span><br><span class="line">     i++, swap(nums[0], nums[0])</span><br><span class="line">     [3, 2, 1, 5, 6, 4]</span><br><span class="line">      i,j</span><br><span class="line"></span><br><span class="line">j=1: nums[1]=2 &lt;= 4 ✓</span><br><span class="line">     i++, swap(nums[1], nums[1])</span><br><span class="line">     [3, 2, 1, 5, 6, 4]</span><br><span class="line">         i,j</span><br><span class="line"></span><br><span class="line">j=2: nums[2]=1 &lt;= 4 ✓</span><br><span class="line">     i++, swap(nums[2], nums[2])</span><br><span class="line">     [3, 2, 1, 5, 6, 4]</span><br><span class="line">            i,j</span><br><span class="line"></span><br><span class="line">j=3: nums[3]=5 &gt; 4 ✗</span><br><span class="line">     不交换</span><br><span class="line">     [3, 2, 1, 5, 6, 4]</span><br><span class="line">            i  j</span><br><span class="line"></span><br><span class="line">j=4: nums[4]=6 &gt; 4 ✗</span><br><span class="line">     不交换</span><br><span class="line">     [3, 2, 1, 5, 6, 4]</span><br><span class="line">            i     j</span><br><span class="line"></span><br><span class="line">最后: swap(nums[i+1], nums[right])</span><br><span class="line">     [3, 2, 1, 4, 6, 5]</span><br><span class="line">               ↑</span><br><span class="line">            pivot位置=3</span><br></pre></td></tr></table></figure><hr><h2 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h2><h3 id="shi-jian-fu-za-du" tabindex="-1" id="时间复杂度">时间复杂度</h3><table><thead><tr><th>情况</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td>平均</td><td><strong>O(n)</strong></td><td>每次减半搜索空间</td></tr><tr><td>最好</td><td>O(n)</td><td>每次分区都在中间</td></tr><tr><td>最坏</td><td>O(n²)</td><td>每次分区都在边界</td></tr></tbody></table><h3 id="wei-shi-yao-ping-jun-shi-o-n" tabindex="-1" id="为什么平均是-O-n-？">为什么平均是 O(n)？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第1轮：处理 n 个元素</span><br><span class="line">第2轮：处理 n/2 个元素</span><br><span class="line">第3轮：处理 n/4 个元素</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">总时间 = n + n/2 + n/4 + ... ≈ 2n = O(n)</span><br></pre></td></tr></table></figure><p>这是一个几何级数！</p><pre><code class="highlight mermaid">graph LR    A[n个元素] --&gt; B[n/2个元素]    B --&gt; C[n/4个元素]    C --&gt; D[n/8个元素]    D --&gt; E[...]        style A fill:#FF6B6B    style B fill:#FFB6C1    style C fill:#FFE4B5</code></pre><h3 id="yu-kuai-su-pai-xu-dui-bi" tabindex="-1" id="与快速排序对比">与快速排序对比</h3><table><thead><tr><th>算法</th><th>时间复杂度（平均）</th><th>说明</th></tr></thead><tbody><tr><td>快速排序</td><td>O(n log n)</td><td>两边都要递归</td></tr><tr><td>快速选择</td><td><strong>O(n)</strong></td><td><strong>只递归一边</strong></td></tr></tbody></table><p><strong>关键区别</strong>：快速选择只需要递归一侧，快速排序需要递归两侧！</p><hr><h2 id="you-hua-ji-qiao" tabindex="-1" id="优化技巧">优化技巧</h2><h3 id="1-sui-ji-hua-pivot" tabindex="-1" id="1-随机化Pivot">1. 随机化Pivot</h3><p><strong>问题</strong>：固定选择pivot（如最后一个元素）在有序数组中会退化为O(n²)</p><p><strong>解决</strong>：随机选择pivot</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br></pre></td></tr></table></figure><h3 id="2-san-shu-qu-zhong-fa" tabindex="-1" id="2-三数取中法">2. 三数取中法</h3><p>从首、中、尾三个位置选择中位数作为pivot</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMidPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将三个数的中位数移到right位置</span></span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[mid]) <span class="built_in">swap</span>(nums[left], nums[mid]);</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[right]) <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[right]) <span class="built_in">swap</span>(nums[mid], nums[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[mid], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-die-dai-ban-ben-bi-mian-di-gui-zhan-yi-chu" tabindex="-1" id="3-迭代版本（避免递归栈溢出）">3. 迭代版本（避免递归栈溢出）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelectIterative</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">            left = pivotIndex + <span class="number">1</span>;  <span class="comment">// 在右边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = pivotIndex - <span class="number">1</span>; <span class="comment">// 在左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="jing-dian-ying-yong" tabindex="-1" id="经典应用">经典应用</h2><h3 id="1-di-k-da-yuan-su-leet-code-215" tabindex="-1" id="1-第K大元素（LeetCode-215）">1. 第K大元素（LeetCode 215）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,5,6,4], k=2</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">解释：第2大的元素是5</span><br></pre></td></tr></table></figure><hr><h3 id="2-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-kuo-zhan" tabindex="-1" id="2-数组中的第K个最大元素（扩展）">2. 数组中的第K个最大元素（扩展）</h3><p>找出数组中前K大的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到第k大元素的位置</span></span><br><span class="line">    <span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回从targetIndex开始的所有元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>() + targetIndex, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-xun-zhao-zhong-wei-shu" tabindex="-1" id="3-寻找中位数">3. 寻找中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 奇数个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 偶数个元素</span></span><br><span class="line">        <span class="type">int</span> mid1 = <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> mid2 = <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (mid1 + mid2) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="kuai-su-xuan-ze-vs-qi-ta-fang-fa" tabindex="-1" id="快速选择-vs-其他方法">快速选择 vs 其他方法</h2><h3 id="dui-bi-biao" tabindex="-1" id="对比表">对比表</h3><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>快速选择</strong></td><td>O(n) 平均</td><td>O(1)</td><td><strong>一次性查询</strong></td></tr><tr><td>排序</td><td>O(n log n)</td><td>O(1)</td><td>多次查询</td></tr><tr><td>堆</td><td>O(n log k)</td><td>O(k)</td><td>K很小时</td></tr><tr><td>计数排序</td><td>O(n + m)</td><td>O(m)</td><td>数值范围小</td></tr></tbody></table><h3 id="xuan-ze-jian-yi" tabindex="-1" id="选择建议">选择建议</h3><pre><code class="highlight mermaid">graph TD    A&#123;需要什么？&#125; --&gt; B[只查询一次]    A --&gt; C[多次查询]    A --&gt; D[K很小]        B --&gt; E[快速选择 O n]    C --&gt; F[排序 O n log n]    D --&gt; G[堆 O n log k]        style E fill:#90EE90    style B fill:#FFE4B5</code></pre><hr><h2 id="shi-zhan-an-li" tabindex="-1" id="实战案例">实战案例</h2><h3 id="an-li-1-zhao-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su" tabindex="-1" id="案例1：找数组中的第K个最大元素">案例1：找数组中的第K个最大元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode 215</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pivot = nums[right];</span><br><span class="line">        <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="an-li-2-zhao-chu-shu-zu-zhong-wei-shu" tabindex="-1" id="案例2：找出数组中位数">案例2：找出数组中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 需要找两个中间元素</span></span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pivot = nums[right];</span><br><span class="line">        <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="chang-jian-xian-jing-yu-ji-qiao" tabindex="-1" id="常见陷阱与技巧">常见陷阱与技巧</h2><h3 id="xian-jing-1-suo-yin-zhuan-huan-cuo-wu" tabindex="-1" id="陷阱1：索引转换错误">陷阱1：索引转换错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：直接使用k</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：第k大 = 第(n-k)小</span></span><br><span class="line"><span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br></pre></td></tr></table></figure><h3 id="xian-jing-2-wang-ji-sui-ji-hua" tabindex="-1" id="陷阱2：忘记随机化">陷阱2：忘记随机化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 危险：固定选择最后一个元素</span></span><br><span class="line"><span class="type">int</span> pivot = nums[right];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 安全：随机选择pivot</span></span><br><span class="line"><span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br><span class="line"><span class="type">int</span> pivot = nums[right];</span><br></pre></td></tr></table></figure><h3 id="ji-qiao-1-ji-zhu-partition-mo-ban" tabindex="-1" id="技巧1：记住partition模板">技巧1：记住partition模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机pivot</span></span><br><span class="line">    <span class="type">int</span> random = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[random], nums[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot = nums[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;  <span class="comment">// 关键：从left-1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ji-qiao-2-kou-jue-ji-yi" tabindex="-1" id="技巧2：口诀记忆">技巧2：口诀记忆</h3><blockquote><p><strong>“找大减K，找小用K”</strong></p></blockquote><ul><li>找第K大：<code>targetIndex = n - k</code></li><li>找第K小：<code>targetIndex = k - 1</code>（从0开始索引）</li></ul><hr><h2 id="si-wei-dao-tu" tabindex="-1" id="思维导图">思维导图</h2><pre><code class="highlight mermaid">graph TD    A[快速选择] --&gt; B[核心思想]    A --&gt; C[关键操作]    A --&gt; D[应用场景]    A --&gt; E[优化技巧]        B --&gt; B1[基于快排分区]    B --&gt; B2[只递归一侧]    B --&gt; B3[O n 平均复杂度]        C --&gt; C1[Partition分区]    C --&gt; C2[比较pivot位置]    C --&gt; C3[递归/迭代]        D --&gt; D1[第K大元素]    D --&gt; D2[中位数]    D --&gt; D3[TopK问题]        E --&gt; E1[随机化pivot]    E --&gt; E2[三数取中]    E --&gt; E3[迭代版本]        style A fill:#FFE4B5    style B fill:#87CEEB    style D fill:#90EE90</code></pre><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>快速选择 = 快排分区 + 单侧递归</strong></li><li><strong>平均O(n)复杂度</strong>：比完全排序快</li><li><strong>随机化pivot</strong>：避免最坏情况</li><li><strong>索引转换</strong>：第K大 = 第(n-k)小</li></ol><h3 id="dai-ma-mo-ban" tabindex="-1" id="代码模板">代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速选择模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> random = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[random], nums[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot = nums[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>推荐练习</strong>：</p><ul><li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">LeetCode 215 - 数组中的第K个最大元素</a></li><li><a href="https://leetcode.com/problems/k-closest-points-to-origin/">LeetCode 973 - 最接近原点的K个点</a></li><li><a href="https://leetcode.com/problems/top-k-frequent-elements/">LeetCode 347 - 前K个高频元素</a></li></ul><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://book.douban.com/subject/20432061/">《算法导论》第9章：中位数和顺序统计量</a></li><li><a href="https://en.wikipedia.org/wiki/Quickselect">快速选择算法详解</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;kuai-su-xuan-ze-bu-wan-quan-pai-xu-de-yi-zhu&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="算法设计" scheme="https://smarter.xin/tags/algorithm-design/"/>
    
    <category term="分治" scheme="https://smarter.xin/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="快速选择" scheme="https://smarter.xin/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>常见数据结构-堆</title>
    <link href="https://smarter.xin/posts/60d62905/"/>
    <id>https://smarter.xin/posts/60d62905/</id>
    <published>2026-01-06T03:12:06.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dui-xiang-jie-shu-de-xing-shu-zu-de-xin" tabindex="-1">堆详解：树的形，数组的心</h1><blockquote><p>深入理解堆的内部原理和手写实现</p></blockquote><hr><h2 id="shi-yao-shi-dui" tabindex="-1" id="什么是堆">什么是堆</h2><p><strong>堆</strong>（Heap）是一种特殊的完全二叉树，满足堆性质：每个节点的值都大于等于（或小于等于）其子节点的值。</p><blockquote><p><strong>核心特点</strong>：用数组存储的完全二叉树，动态维护最值</p></blockquote><h3 id="liang-chong-dui" tabindex="-1" id="两种堆">两种堆</h3><pre><code class="highlight mermaid">graph LR    A[堆] --&gt; B[最大堆 Max Heap]    A --&gt; C[最小堆 Min Heap]        B --&gt; B1[父节点 ≥ 子节点]    B --&gt; B2[根节点最大]        C --&gt; C1[父节点 ≤ 子节点]    C --&gt; C2[根节点最小]        style A fill:#FFE4B5    style B fill:#FF6B6B    style C fill:#87CEEB</code></pre><h4 id="zui-da-dui-shi-li" tabindex="-1" id="最大堆示例">最大堆示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     9            数组表示：[9, 7, 8, 3, 5, 6, 2]</span><br><span class="line">   /   \          </span><br><span class="line">  7     8         索引关系：</span><br><span class="line"> / \   / \        - 父节点 i</span><br><span class="line">3   5 6   2       - 左子节点 2i + 1</span><br><span class="line">                  - 右子节点 2i + 2</span><br></pre></td></tr></table></figure><h4 id="zui-xiao-dui-shi-li" tabindex="-1" id="最小堆示例">最小堆示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1            数组表示：[1, 3, 2, 7, 5, 6, 8]</span><br><span class="line">   /   \          </span><br><span class="line">  3     2         特点：</span><br><span class="line"> / \   / \        - 完全二叉树</span><br><span class="line">7   5 6   8       - 父 ≤ 子</span><br></pre></td></tr></table></figure><hr><h2 id="wei-shi-yao-yong-shu-zu-cun-chu" tabindex="-1" id="为什么用数组存储">为什么用数组存储</h2><h3 id="wan-quan-er-cha-shu-de-xing-zhi" tabindex="-1" id="完全二叉树的性质">完全二叉树的性质</h3><p>完全二叉树可以用数组紧凑存储，不浪费空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">     1     2</span><br><span class="line">    / \   / \</span><br><span class="line">   3   4 5   6</span><br><span class="line"></span><br><span class="line">数组：[0, 1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h3 id="suo-yin-ji-suan-gong-shi" tabindex="-1" id="索引计算公式">索引计算公式</h3><p>对于索引为 <code>i</code> 的节点：</p><table><thead><tr><th>关系</th><th>公式</th><th>说明</th></tr></thead><tbody><tr><td>父节点</td><td><code>(i - 1) / 2</code></td><td>向下取整</td></tr><tr><td>左子节点</td><td><code>2 * i + 1</code></td><td>-</td></tr><tr><td>右子节点</td><td><code>2 * i + 2</code></td><td>-</td></tr><tr><td>是否有左子</td><td><code>2 * i + 1 &lt; size</code></td><td>判断是否越界</td></tr><tr><td>是否有右子</td><td><code>2 * i + 2 &lt; size</code></td><td>判断是否越界</td></tr><tr><td>最后非叶子</td><td><code>size / 2 - 1</code></td><td>建堆时的起点</td></tr></tbody></table><blockquote><p><strong>记忆技巧</strong>：从 0 开始索引，左子 = 2i+1，右子 = 2i+2</p></blockquote><hr><h2 id="dui-de-he-xin-cao-zuo" tabindex="-1" id="堆的核心操作">堆的核心操作</h2><h3 id="1-shang-fu-sift-up" tabindex="-1" id="1-上浮（Sift-Up）">1. 上浮（Sift Up）</h3><p><strong>使用场景</strong>：插入新元素后，恢复堆性质</p><p><strong>原理</strong>：新元素与父节点比较，若违反堆性质则交换，重复直到根节点或满足条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">最大堆插入 10：</span><br><span class="line"></span><br><span class="line">步骤1: 插入到末尾          步骤2: 与父节点比较</span><br><span class="line">         9                        9</span><br><span class="line">       /   \                    /   \</span><br><span class="line">      7     8       →          10    8</span><br><span class="line">     / \   / \                / \   / \</span><br><span class="line">    3   5 6   2  10          3   5 6   2  7</span><br><span class="line">                ↑                         ↑</span><br><span class="line">            新插入                     上浮一次</span><br><span class="line"></span><br><span class="line">步骤3: 继续比较            步骤4: 完成</span><br><span class="line">         10                      10</span><br><span class="line">       /   \                    /   \</span><br><span class="line">      9     8       →          9     8</span><br><span class="line">     / \   / \                / \   / \</span><br><span class="line">    3   5 6   2  7           3   5 6   2  7</span><br><span class="line">    ↑                        </span><br><span class="line">  上浮到根</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最大堆：子节点 &gt; 父节点时上浮</span></span><br><span class="line">        <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)，最多上浮 h 层（h 为树高）</p><hr><h3 id="2-xia-chen-sift-down" tabindex="-1" id="2-下沉（Sift-Down）">2. 下沉（Sift Down）</h3><p><strong>使用场景</strong>：删除堆顶后，恢复堆性质</p><p><strong>原理</strong>：用最后一个元素替换堆顶，然后与较大的子节点比较，若违反堆性质则交换，重复直到叶子节点或满足条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">最大堆删除堆顶：</span><br><span class="line"></span><br><span class="line">步骤1: 用末尾替换堆顶      步骤2: 与子节点比较</span><br><span class="line">         9                        2</span><br><span class="line">       /   \                    /   \</span><br><span class="line">      7     8       →          7     8</span><br><span class="line">     / \   / \                / \   / </span><br><span class="line">    3   5 6   2              3   5 6</span><br><span class="line">         删除 ↑                ↓</span><br><span class="line">              2              下沉</span><br><span class="line"></span><br><span class="line">步骤3: 交换并继续          步骤4: 完成</span><br><span class="line">         7                        8</span><br><span class="line">       /   \                    /   \</span><br><span class="line">      2     8       →          7     6</span><br><span class="line">     / \   /                  / \   / </span><br><span class="line">    3   5 6                  3   5 2</span><br><span class="line">        ↓                              </span><br><span class="line">      继续下沉                     稳定</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> index, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123;  <span class="comment">// 有左子节点</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> largest = index;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出父、左子、右子中最大的</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果父节点最大，说明已满足堆性质</span></span><br><span class="line">        <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(heap[index], heap[largest]);</span><br><span class="line">        index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)</p><hr><h3 id="3-cha-ru-insert" tabindex="-1" id="3-插入（Insert）">3. 插入（Insert）</h3><p><strong>步骤</strong>：</p><ol><li>将新元素添加到数组末尾</li><li>上浮调整</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    heap.<span class="built_in">push_back</span>(value);      <span class="comment">// 添加到末尾</span></span><br><span class="line">    <span class="built_in">siftUp</span>(heap, heap.<span class="built_in">size</span>() - <span class="number">1</span>);  <span class="comment">// 上浮</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)</p><hr><h3 id="4-shan-chu-dui-ding-extract-max-min" tabindex="-1" id="4-删除堆顶（Extract-Max-Min）">4. 删除堆顶（Extract Max/Min）</h3><p><strong>步骤</strong>：</p><ol><li>记录堆顶元素</li><li>用最后一个元素替换堆顶</li><li>删除最后一个元素</li><li>下沉调整</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extractMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> maxValue = heap[<span class="number">0</span>];          <span class="comment">// 记录最大值</span></span><br><span class="line">    heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();           <span class="comment">// 用末尾替换堆顶</span></span><br><span class="line">    heap.<span class="built_in">pop_back</span>();                 <span class="comment">// 删除末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, <span class="number">0</span>, heap.<span class="built_in">size</span>());  <span class="comment">// 下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(log n)</p><hr><h3 id="5-jian-dui-build-heap" tabindex="-1" id="5-建堆（Build-Heap）">5. 建堆（Build Heap）</h3><p><strong>方法1：自顶向下</strong></p><p>逐个插入元素，每次插入后上浮调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildHeapTopDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(heap, num);  <span class="comment">// O(log n) 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n log n)</p><hr><p><strong>方法2：自底向上（更优）</strong></p><p>将数组看作完全二叉树，从最后一个非叶子节点开始，依次下沉调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">原数组：[3, 2, 1, 7, 8, 4, 5]</span><br><span class="line"></span><br><span class="line">步骤1：找最后非叶子节点 = size/2-1 = 2（值为1）</span><br><span class="line">         3</span><br><span class="line">       /   \</span><br><span class="line">      2     1</span><br><span class="line">     / \   / \</span><br><span class="line">    7   8 4   5</span><br><span class="line"></span><br><span class="line">步骤2：从索引2开始下沉</span><br><span class="line">         3</span><br><span class="line">       /   \</span><br><span class="line">      2     5</span><br><span class="line">     / \   / \</span><br><span class="line">    7   8 4   1</span><br><span class="line"></span><br><span class="line">步骤3：处理索引1</span><br><span class="line">         3</span><br><span class="line">       /   \</span><br><span class="line">      8     5</span><br><span class="line">     / \   / \</span><br><span class="line">    7   2 4   1</span><br><span class="line"></span><br><span class="line">步骤4：处理索引0（根节点）</span><br><span class="line">         8</span><br><span class="line">       /   \</span><br><span class="line">      7     5</span><br><span class="line">     / \   / \</span><br><span class="line">    3   2 4   1</span><br><span class="line"></span><br><span class="line">完成！最大堆构建完成</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = heap.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n) 🎯</p><h4 id="wei-shi-yao-shi-o-n-er-bu-shi-o-n-log-n" tabindex="-1" id="为什么是-O-n-而不是-O-n-log-n-？">为什么是 O(n) 而不是 O(n log n)？</h4><p>虽然每次下沉最坏是 O(log n)，但实际上：</p><ul><li>叶子节点不需要下沉（占一半）</li><li>倒数第二层最多下沉 1 层（占 1/4）</li><li>倒数第三层最多下沉 2 层（占 1/8）</li><li>…</li></ul><p>总时间 = n/2 × 0 + n/4 × 1 + n/8 × 2 + … = O(n)</p><hr><h2 id="wan-zheng-de-dui-lei-shi-xian" tabindex="-1" id="完整的堆类实现">完整的堆类实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> largest = index;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123;</span><br><span class="line">                largest = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123;</span><br><span class="line">                largest = right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (largest == index) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">swap</span>(heap[index], heap[largest]);</span><br><span class="line">            index = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxHeap</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MaxHeap</span>(vector&lt;<span class="type">int</span>&gt; arr) : <span class="built_in">heap</span>(arr) &#123;</span><br><span class="line">        <span class="comment">// 建堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heap.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">siftDown</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(value);</span><br><span class="line">        <span class="built_in">siftUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxValue = heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="dui-pai-xu-xiang-jie" tabindex="-1" id="堆排序详解">堆排序详解</h2><h3 id="suan-fa-si-lu" tabindex="-1" id="算法思路">算法思路</h3><p>利用堆的性质进行排序：</p><ol><li><strong>建堆</strong>：O(n)</li><li><strong>排序</strong>：依次取出堆顶（最大值），放到数组末尾</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原数组：[3, 2, 1, 7, 8, 4, 5]</span><br><span class="line"></span><br><span class="line">步骤1：建最大堆</span><br><span class="line">[8, 7, 5, 3, 2, 4, 1]</span><br><span class="line"> ↑ 最大值</span><br><span class="line"></span><br><span class="line">步骤2：堆顶与末尾交换</span><br><span class="line">[1, 7, 5, 3, 2, 4 | 8]</span><br><span class="line"> ↑              已排序</span><br><span class="line"></span><br><span class="line">步骤3：缩小堆范围并下沉调整</span><br><span class="line">[7, 3, 5, 1, 2, 4 | 8]</span><br><span class="line"> ↑              已排序</span><br><span class="line"></span><br><span class="line">步骤4：重复</span><br><span class="line">[4, 3, 5, 1, 2 | 7, 8]</span><br><span class="line">[5, 3, 4, 1, 2 | 7, 8]</span><br><span class="line">...</span><br><span class="line">[1, 2, 3, 4, 5, 7, 8]  完成！</span><br></pre></td></tr></table></figure><h3 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 建堆（从最后一个非叶子节点开始）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 排序（依次取出堆顶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);   <span class="comment">// 堆顶与末尾交换</span></span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, <span class="number">0</span>);       <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n log n)<ul><li>建堆：O(n)</li><li>n-1 次调整，每次 O(log n)</li></ul></li><li><strong>空间复杂度</strong>：O(1) 原地排序</li><li><strong>稳定性</strong>：❌ 不稳定</li></ul><h3 id="dui-pai-xu-de-you-que-dian" tabindex="-1" id="堆排序的优缺点">堆排序的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>✅ 时间复杂度稳定</td><td>❌ 不稳定排序</td></tr><tr><td>✅ 原地排序，空间 O(1)</td><td>❌ 缓存不友好</td></tr><tr><td>✅ 不依赖输入分布</td><td>❌ 实际性能不如快排</td></tr></tbody></table><hr><h2 id="dui-vs-qi-ta-shu-ju-jie-gou" tabindex="-1" id="堆-vs-其他数据结构">堆 vs 其他数据结构</h2><h3 id="cao-zuo-fu-za-du-dui-bi" tabindex="-1" id="操作复杂度对比">操作复杂度对比</h3><table><thead><tr><th>数据结构</th><th>插入</th><th>删除最值</th><th>查看最值</th><th>查找任意元素</th></tr></thead><tbody><tr><td><strong>堆</strong></td><td>O(log n)</td><td>O(log n)</td><td><strong>O(1)</strong></td><td>O(n)</td></tr><tr><td>无序数组</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>有序数组</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(log n)</td></tr><tr><td>平衡二叉搜索树</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td></tr></tbody></table><h3 id="dui-de-you-shi-chang-jing" tabindex="-1" id="堆的优势场景">堆的优势场景</h3><pre><code class="highlight mermaid">graph LR    A[什么时候用堆？] --&gt; B[需要频繁获取最值]    A --&gt; C[不需要查找任意元素]    A --&gt; D[动态数据流]    A --&gt; E[Top K 问题]        style A fill:#FFE4B5    style B fill:#90EE90    style E fill:#87CEEB</code></pre><hr><h2 id="jing-dian-ying-yong-chang-jing" tabindex="-1" id="经典应用场景">经典应用场景</h2><h3 id="1-top-k-wen-ti" tabindex="-1" id="1-Top-K-问题">1. Top K 问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 K 大元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;  <span class="comment">// 最小堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-he-bing-k-ge-you-xu-lian-biao-shu-zu" tabindex="-1" id="2-合并-K-个有序链表-数组">2. 合并 K 个有序链表/数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mergeKSorted</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; arrays)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(a) &gt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(b);  <span class="comment">// 最小堆</span></span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">minHeap</span>(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化：每个数组的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrays.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arrays[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;arrays[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [val, arrIdx, elemIdx] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加入下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (elemIdx + <span class="number">1</span> &lt; arrays[arrIdx].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;arrays[arrIdx][elemIdx + <span class="number">1</span>], arrIdx, elemIdx + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-shu-ju-liu-zhong-wei-shu" tabindex="-1" id="3-数据流中位数">3. 数据流中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; maxHeap;  <span class="comment">// 较小的一半</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;  <span class="comment">// 较大的一半</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        minHeap.<span class="built_in">push</span>(maxHeap.<span class="built_in">top</span>());</span><br><span class="line">        maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; maxHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(minHeap.<span class="built_in">top</span>());</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() &gt; minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (maxHeap.<span class="built_in">top</span>() + minHeap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="zui-da-dui-vs-zui-xiao-dui" tabindex="-1" id="最大堆-vs-最小堆">最大堆 vs 最小堆</h2><h3 id="he-shi-shi-yong" tabindex="-1" id="何时使用？">何时使用？</h3><pre><code class="highlight mermaid">graph TD    A[选择堆类型] --&gt; B&#123;需要什么？&#125;        B --&gt;|最大值| C[最大堆]    B --&gt;|最小值| D[最小堆]        C --&gt; E[直接获取]    D --&gt; F[直接获取]        style A fill:#FFE4B5    style C fill:#FF6B6B    style D fill:#87CEEB</code></pre><h3 id="top-k-wen-ti-kou-jue" tabindex="-1" id="Top-K-问题口诀">Top K 问题口诀</h3><blockquote><p><strong>求大用小，求小用大</strong></p></blockquote><table><thead><tr><th>问题</th><th>使用的堆</th><th>原因</th></tr></thead><tbody><tr><td>第 K 大元素</td><td>最小堆</td><td>保留最大的 K 个</td></tr><tr><td>第 K 小元素</td><td>最大堆</td><td>保留最小的 K 个</td></tr><tr><td>前 K 大</td><td>最小堆</td><td>淘汰小的，保留大的</td></tr><tr><td>前 K 小</td><td>最大堆</td><td>淘汰大的，保留小的</td></tr></tbody></table><h3 id="dai-ma-zhuan-huan" tabindex="-1" id="代码转换">代码转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大堆（默认）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆（需要指定比较器）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较器</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;;  <span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">customHeap</span>(cmp);</span><br></pre></td></tr></table></figure><hr><h2 id="dui-de-bian-chong" tabindex="-1" id="堆的变种">堆的变种</h2><h3 id="1-er-cha-dui-binary-heap" tabindex="-1" id="1-二叉堆（Binary-Heap）">1. 二叉堆（Binary Heap）</h3><p>我们刚才讲的就是二叉堆，最常用。</p><h3 id="2-fei-bo-na-qi-dui-fibonacci-heap" tabindex="-1" id="2-斐波那契堆（Fibonacci-Heap）">2. 斐波那契堆（Fibonacci Heap）</h3><ul><li><strong>优点</strong>：合并操作 O(1)</li><li><strong>缺点</strong>：实现复杂，常数因子大</li><li><strong>应用</strong>：Dijkstra、Prim 算法的优化版本</li></ul><h3 id="3-er-xiang-dui-binomial-heap" tabindex="-1" id="3-二项堆（Binomial-Heap）">3. 二项堆（Binomial Heap）</h3><ul><li><strong>特点</strong>：多个二项树组成</li><li><strong>应用</strong>：理论研究</li></ul><hr><h2 id="chang-jian-xian-jing-yu-ji-qiao" tabindex="-1" id="常见陷阱与技巧">常见陷阱与技巧</h2><h3 id="xian-jing-1-suo-yin-ji-suan-cuo-wu" tabindex="-1" id="陷阱1：索引计算错误">陷阱1：索引计算错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：从1开始索引</span></span><br><span class="line"><span class="type">int</span> parent = i / <span class="number">2</span>;      <span class="comment">// 不适用于从0开始的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：从0开始索引</span></span><br><span class="line"><span class="type">int</span> parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="xian-jing-2-bi-jiao-qi-fang-xiang-gao-fan" tabindex="-1" id="陷阱2：比较器方向搞反">陷阱2：比较器方向搞反</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ priority_queue 的比较器与 sort 相反！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆（堆顶最小）</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;;  <span class="comment">// 注意是 &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆（堆顶最大）</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;;  <span class="comment">// 注意是 &lt;</span></span><br></pre></td></tr></table></figure><h3 id="ji-qiao-1-jian-dui-you-hua" tabindex="-1" id="技巧1：建堆优化">技巧1：建堆优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 低效：逐个插入 O(n log n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 高效：批量建堆 O(n)</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">maxHeap</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ji-qiao-2-ji-zhu-kou-jue" tabindex="-1" id="技巧2：记住口诀">技巧2：记住口诀</h3><ul><li><strong>求大用小，求小用大</strong></li><li><strong>父节点 = (i-1)/2</strong></li><li><strong>左子 = 2i+1，右子 = 2i+2</strong></li></ul><hr><h2 id="si-wei-dao-tu" tabindex="-1" id="思维导图">思维导图</h2><pre><code class="highlight mermaid">graph TD    A[堆] --&gt; B[基本概念]    A --&gt; C[核心操作]    A --&gt; D[应用场景]    A --&gt; E[经典算法]        B --&gt; B1[完全二叉树]    B --&gt; B2[数组存储]    B --&gt; B3[最大堆/最小堆]        C --&gt; C1[上浮 O log n]    C --&gt; C2[下沉 O log n]    C --&gt; C3[插入 O log n]    C --&gt; C4[删除堆顶 O log n]    C --&gt; C5[建堆 O n]        D --&gt; D1[Top K 问题]    D --&gt; D2[优先队列]    D --&gt; D3[堆排序]    D --&gt; D4[数据流统计]        E --&gt; E1[堆排序]    E --&gt; E2[Dijkstra]    E --&gt; E3[Huffman编码]        style A fill:#FFE4B5    style C fill:#87CEEB    style D fill:#90EE90</code></pre><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>堆 = 完全二叉树 + 数组存储</strong></li><li><strong>两个关键操作</strong>：上浮、下沉</li><li><strong>建堆优化</strong>：自底向上 O(n)</li><li><strong>Top K 口诀</strong>：求大用小，求小用大</li></ol><h3 id="shi-jian-fu-za-du-zong-jie" tabindex="-1" id="时间复杂度总结">时间复杂度总结</h3><table><thead><tr><th>操作</th><th>时间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>插入</td><td>O(log n)</td><td>上浮</td></tr><tr><td>删除堆顶</td><td>O(log n)</td><td>下沉</td></tr><tr><td>查看堆顶</td><td>O(1)</td><td>直接访问</td></tr><tr><td>建堆</td><td><strong>O(n)</strong></td><td>自底向上</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>n 次删除堆顶</td></tr></tbody></table><h3 id="dai-ma-mo-ban" tabindex="-1" id="代码模板">代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大堆核心操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[i] &gt; heap[(i<span class="number">-1</span>)/<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[(i<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下沉</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*i<span class="number">+1</span> &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*i<span class="number">+1</span>;  <span class="comment">// 左子</span></span><br><span class="line">            <span class="keyword">if</span> (j<span class="number">+1</span> &lt; size &amp;&amp; heap[j<span class="number">+1</span>] &gt; heap[j]) j++;  <span class="comment">// 右子更大</span></span><br><span class="line">            <span class="keyword">if</span> (heap[i] &gt;= heap[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>推荐练习</strong>：</p><ul><li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">LeetCode 215 - 数组中的第K个最大元素</a></li><li><a href="https://leetcode.com/problems/top-k-frequent-elements/">LeetCode 347 - 前K个高频元素</a></li><li><a href="https://leetcode.com/problems/find-median-from-data-stream/">LeetCode 295 - 数据流的中位数</a></li><li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode 23 - 合并K个升序链表</a></li></ul><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://book.douban.com/subject/20432061/">《算法导论》第6章：堆排序</a></li><li><a href="https://leetcode.com/tag/heap-priority-queue/">LeetCode 堆专题</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;dui-xiang-jie-shu-de-xing-shu-zu-de-xin&quot; tabindex=&quot;-1&quot;&gt;堆详解：树的形，数组的心&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;深入理解堆的内部原理和手写实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://smarter.xin/categories/data-structure/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="堆" scheme="https://smarter.xin/tags/%E5%A0%86/"/>
    
    <category term="数据结构" scheme="https://smarter.xin/tags/data-structure/"/>
    
    <category term="算法设计" scheme="https://smarter.xin/tags/algorithm-design/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-二分查找</title>
    <link href="https://smarter.xin/posts/e84ddac/"/>
    <id>https://smarter.xin/posts/e84ddac/</id>
    <published>2026-01-05T05:45:42.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xie-zai-qian-mian" tabindex="-1" id="写在前面">写在前面</h2><p>二分查找应该是我刷LeetCode时最早接触的算法之一，当时觉得挺简单的——不就是折半查找嘛。结果真正写起来才发现，<code>left</code>、<code>right</code>、<code>mid</code>这些边界条件一不小心就写错，要么死循环，要么漏掉元素。后来才意识到，二分查找看似简单，其实细节很多。</p><p>这篇文章我会按照自己的理解，把二分查找从基础到变种都梳理一遍。</p><hr><h2 id="er-fen-cha-zhao-shi-shi-yao" tabindex="-1" id="二分查找是什么">二分查找是什么</h2><p>最基础的二分查找就是在<strong>有序数组</strong>中找一个目标值，每次通过比较中间元素，排除一半的搜索空间。</p><p>举个例子，在 <code>[1, 3, 5, 7, 9, 11, 13]</code> 中找 <code>7</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，找到了！</span><br></pre></td></tr></table></figure><p>如果找 <code>8</code> 呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，8 &gt; 7，去右边找</span><br><span class="line">第2次: 范围 [9,11,13]，中间是 11，8 &lt; 11，去左边找</span><br><span class="line">第3次: 范围 [9]，9 != 8，找不到</span><br></pre></td></tr></table></figure><p>简单来说就是：<strong>每次排除一半，直到找到或者范围为空</strong>。</p><p>时间复杂度 O(log n)，这也是二分查找的魅力所在——数据量越大，优势越明显。100万条数据，最多查20次。</p><hr><h2 id="ji-chu-mo-ban" tabindex="-1" id="基础模板">基础模板</h2><p>我自己用的最多的是左闭右闭区间的写法，也就是 <code>[left, right]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 注意是 n-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;  <span class="comment">// 注意是 &lt;=</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 去右半边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 去左半边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ji-ge-xi-jie" tabindex="-1" id="几个细节">几个细节</h3><ol><li><p><strong>为什么是 <code>right = nums.size() - 1</code>？</strong><br>因为我们用的是闭区间 <code>[left, right]</code>，右边界要包含最后一个元素。</p></li><li><p><strong>为什么循环条件是 <code>left &lt;= right</code>？</strong><br>当 <code>left == right</code> 时，区间 <code>[left, right]</code> 还有一个元素没检查，所以要用 <code>&lt;=</code>。</p></li><li><p><strong>为什么是 <code>mid = left + (right - left) / 2</code>？</strong><br>如果写成 <code>(left + right) / 2</code>，当 <code>left</code> 和 <code>right</code> 都很大时可能溢出。虽然LeetCode数据范围一般不会溢出，但这是个好习惯。</p></li><li><p><strong>为什么是 <code>left = mid + 1</code> 而不是 <code>mid</code>？</strong><br>因为 <code>nums[mid]</code> 已经检查过了，不是目标值，所以可以排除。</p></li></ol><hr><h2 id="zuo-bi-you-kai-xie-fa" tabindex="-1" id="左闭右开写法">左闭右开写法</h2><p>有些人喜欢用左闭右开区间 <code>[left, right)</code>，也就是右边界不包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>();  <span class="comment">// 注意是 n（不包含）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 注意是 &lt;</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;  <span class="comment">// 注意是 mid，不是 mid - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话，我一开始也纠结用哪种写法。后来发现，<strong>选一个用熟就行</strong>，关键是理解区间的含义，不要混用。</p><hr><h2 id="bian-chong-1-cha-zhao-zuo-bian-jie" tabindex="-1" id="变种1：查找左边界">变种1：查找左边界</h2><p>有时候数组中有重复元素，我们要找第一个等于 <code>target</code> 的位置。</p><p>比如 <code>[1, 2, 2, 2, 3]</code> 中找 <code>2</code> 的左边界，应该返回索引 <code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLeft</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            result = mid;     <span class="comment">// 记录位置</span></span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 继续向左找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路：找到 <code>target</code> 后不立即返回，而是继续向左缩小范围。</p><hr><h2 id="bian-chong-2-cha-zhao-you-bian-jie" tabindex="-1" id="变种2：查找右边界">变种2：查找右边界</h2><p>同理，找最后一个等于 <code>target</code> 的位置。</p><p><code>[1, 2, 2, 2, 3]</code> 中找 <code>2</code> 的右边界，应该返回索引 <code>3</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchRight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            result = mid;    <span class="comment">// 记录位置</span></span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 继续向右找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="bian-chong-3-zhao-di-yi-ge-da-yu-deng-yu-target-de-wei-zhi" tabindex="-1" id="变种3：找第一个大于等于target的位置">变种3：找第一个大于等于target的位置</h2><p>这个在实际应用中很常见，比如查找插入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;  <span class="comment">// nums[mid] &gt;= target，可能是答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里我用的是左闭右开写法 <code>[left, right)</code>，因为这样写起来比较简洁。</p><p>如果数组是 <code>[1, 3, 5, 7]</code>，<code>target = 4</code>，返回索引 <code>2</code>（也就是 <code>5</code> 的位置）。</p><hr><h2 id="bian-chong-4-zhao-di-yi-ge-da-yu-target-de-wei-zhi" tabindex="-1" id="变种4：找第一个大于target的位置">变种4：找第一个大于target的位置</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">upperBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;  <span class="comment">// 注意是 &lt;=</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="shi-zhan-ti-mu" tabindex="-1" id="实战题目">实战题目</h2><h3 id="leet-code-704-er-fen-cha-zhao" tabindex="-1" id="LeetCode-704-二分查找">LeetCode 704 - 二分查找</h3><p>最基础的题，直接套模板就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="leet-code-35-sou-suo-cha-ru-wei-zhi" tabindex="-1" id="LeetCode-35-搜索插入位置">LeetCode 35 - 搜索插入位置</h3><p>给定一个排序数组和目标值，如果找到返回索引，否则返回它应该被插入的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是找第一个 <code>&gt;= target</code> 的位置（lower_bound）。</p><hr><h3 id="leet-code-34-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi" tabindex="-1" id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置">LeetCode 34 - 在排序数组中查找元素的第一个和最后一个位置</h3><p>这题就是找左右边界的综合应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">searchLeft</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;  <span class="comment">// 没找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">searchRight</span>(nums, target);</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="leet-code-69-x-de-ping-fang-gen" tabindex="-1" id="LeetCode-69-x-的平方根">LeetCode 69 - x 的平方根</h3><p>计算并返回 x 的平方根（只保留整数部分）。</p><p>这题其实是在 <code>[0, x]</code> 中找最后一个满足 <code>i * i &lt;= x</code> 的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;  <span class="comment">// 避免溢出</span></span><br><span class="line">            result = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小技巧</strong>：用 <code>mid &lt;= x / mid</code> 代替 <code>mid * mid &lt;= x</code>，避免整数溢出。</p><hr><h3 id="leet-code-33-sou-suo-xuan-zhuan-pai-xu-shu-zu" tabindex="-1" id="LeetCode-33-搜索旋转排序数组">LeetCode 33 - 搜索旋转排序数组</h3><p>这题有点意思，数组被旋转了，比如 <code>[4,5,6,7,0,1,2]</code>。</p><p>核心思路：虽然整体无序，但肯定有一半是有序的。先判断哪半边有序，再判断 <code>target</code> 在不在有序的那半边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左半边有序</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// target 在左半边</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右半边有序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// target 在右半边</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="leet-code-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi" tabindex="-1" id="LeetCode-153-寻找旋转排序数组中的最小值">LeetCode 153 - 寻找旋转排序数组中的最小值</h3><p>还是旋转数组，这次是找最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右半边无序，最小值在右边</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左半边无序或全部有序，最小值在左边（包括mid）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="er-fen-da-an" tabindex="-1" id="二分答案">二分答案</h2><p>除了在数组中二分查找，还有一类题是<strong>二分答案</strong>。也就是答案有一定范围，通过二分猜答案，然后验证是否可行。</p><h3 id="jing-dian-li-ti-leet-code-875-ai-chi-xiang-jiao-de-ke-ke" tabindex="-1" id="经典例题：LeetCode-875-爱吃香蕉的珂珂">经典例题：LeetCode 875 - 爱吃香蕉的珂珂</h3><p>珂珂有 N 堆香蕉，第 i 堆有 <code>piles[i]</code> 根香蕉。她可以决定每小时吃香蕉的速度 K（根/小时）。每小时她会选择一堆香蕉，吃 K 根（如果这堆不够 K 根，她会吃完这堆就停下来）。</p><p>问：在 H 小时内吃完所有香蕉，最小的 K 是多少？</p><p><strong>思路</strong>：K 的范围是 <code>[1, max(piles)]</code>，我们可以二分 K 的值。对于每个 K，检查能否在 H 小时内吃完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查能否在 h 小时内吃完</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            hours += (pile + mid - <span class="number">1</span>) / mid;  <span class="comment">// 向上取整</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hours &lt;= h) &#123;</span><br><span class="line">            right = mid;  <span class="comment">// 可以吃完，尝试更小的速度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 吃不完，需要更快的速度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小技巧</strong>：<code>(pile + mid - 1) / mid</code> 是向上取整的技巧，等价于 <code>ceil(pile / mid)</code>。</p><hr><h2 id="rong-yi-cai-de-keng" tabindex="-1" id="容易踩的坑">容易踩的坑</h2><ol><li><p><strong>循环条件写错</strong><br><code>left &lt;= right</code> 还是 <code>left &lt; right</code>？取决于区间定义。记住：闭区间用 <code>&lt;=</code>，半开区间用 <code>&lt;</code>。</p></li><li><p><strong>边界更新写错</strong><br><code>left = mid</code> 还是 <code>left = mid + 1</code>？记住：已经检查过 <code>mid</code> 了，要排除就用 <code>+1</code> 或 <code>-1</code>。</p></li><li><p><strong>死循环</strong><br>如果边界更新不当，可能导致 <code>left</code> 和 <code>right</code> 永远无法相遇。比如用 <code>left &lt; right</code> 但更新时用 <code>right = mid</code>，当 <code>left = mid - 1</code> 时就会死循环。</p></li><li><p><strong>溢出问题</strong><br>写成 <code>(left + right) / 2</code> 在理论上可能溢出，虽然LeetCode一般不会卡这个。</p></li><li><p><strong>边界条件遗漏</strong><br>数组为空、<code>target</code> 不在范围内等特殊情况要单独处理。</p></li></ol><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><p>二分查找虽然看起来简单，但要写对还是需要细心。我的建议是：</p><ol><li><strong>选定一种写法</strong>（闭区间或半开区间），熟练掌握它</li><li><strong>理解区间不变量</strong>：每次循环后，答案一定在 <code>[left, right]</code> 区间内</li><li><strong>多刷题</strong>：变种题做多了，自然就有感觉了</li></ol><p>常见的二分查找题型：</p><ul><li>基础二分：LeetCode 704</li><li>查找边界：LeetCode 34</li><li>旋转数组：LeetCode 33, 153</li><li>二分答案：LeetCode 875, 1011, 410</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;xie-zai-qian-mian&quot; tabindex=&quot;-1&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="算法设计" scheme="https://smarter.xin/tags/algorithm-design/"/>
    
    <category term="分治" scheme="https://smarter.xin/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="二分查找" scheme="https://smarter.xin/tags/binary-search/"/>
    
    <category term="搜索" scheme="https://smarter.xin/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>AI Infra学习之旅-Transformer知识地图</title>
    <link href="https://smarter.xin/posts/4854dc00/"/>
    <id>https://smarter.xin/posts/4854dc00/</id>
    <published>2026-01-04T13:07:37.000Z</published>
    <updated>2026-01-06T13:16:51.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ai-infra-xue-xi-lu-xian" tabindex="-1">AI Infra学习路线</h1><blockquote><p>写给刚入门AI Infrastructure的同学：你真的需要搞懂Transformer的每个细节吗？</p></blockquote><h2 id="xie-zai-qian-mian" tabindex="-1" id="写在前面">写在前面</h2><p>最近跟几个刚开始学AI Infra的朋友聊天，大家都有个共同的困惑：<strong>明明是搞基础设施的，为什么老有人让我们先把Transformer学透？</strong></p><p>说实话，我刚开始也纠结过。看了一堆Transformer的论文和教程，什么Attention机制、位置编码、残差连接…感觉自己要变成算法工程师了。后来跑了几个月的vLLM、搞了一些推理优化，才慢慢想明白：</p><p><strong>AI Infra工程师确实要懂Transformer，但不是全懂，而是要懂对地方。</strong></p><p>今天这篇文章，我想跟你聊聊：作为AI Infra的学习者，到底应该重点关注Transformer的哪些部分，哪些可以暂时放一放，以及不同方向（推理优化、模型部署、系统架构）的学习侧重点。</p><h2 id="yi-wei-shi-yao-ai-infra-yi-ding-yao-xue-transformer" tabindex="-1" id="一、为什么AI-Infra一定要学Transformer？">一、为什么AI Infra一定要学Transformer？</h2><p>在回答&quot;学什么&quot;之前，先说说&quot;为什么要学&quot;。</p><h3 id="1-1-xian-dai-ai-xi-tong-de-he-xin-jiu-shi-transformer" tabindex="-1" id="1-1-现代AI系统的核心就是Transformer">1.1 现代AI系统的核心就是Transformer</h3><p>看看你做AI Infra会接触的东西：</p><ul><li><strong>推理框架</strong>：vLLM、TensorRT-LLM、TGI、…</li><li><strong>优化技术</strong>：Flash Attention、PagedAttention、KV量化、…</li><li><strong>部署工具</strong>：Triton Inference Server、Ray Serve、…</li></ul><p>这些东西，<strong>100%都是围绕Transformer模型设计的</strong>。</p><p>如果你不了解Transformer的工作原理，就像是开飞机但不知道飞机怎么飞的——能起飞，但出了问题根本不知道从哪查。</p><h3 id="1-2-quot-gao-ying-jian-quot-ye-yao-dong-mo-xing" tabindex="-1" id="1-2-搞硬件-也要懂模型">1.2 &quot;搞硬件&quot;也要懂模型</h3><p>有人会说：“我是做基础设施的，GPU、内存、网络这些才是我该关心的吧？”</p><p>没错，但问题是：</p><ul><li><strong>内存优化</strong>：为什么要优化？因为KV Cache太大了。KV Cache是啥？Transformer推理过程中产生的。</li><li><strong>计算优化</strong>：为什么要Flash Attention？因为原生Attention太慢了。为什么慢？要看Transformer的计算流程。</li><li><strong>并行策略</strong>：为什么要张量并行？因为单卡放不下大模型。为什么放不下？要看Transformer的参数分布。</li></ul><p><strong>你优化的对象就是Transformer模型，不懂它怎么优化？</strong></p><h3 id="1-3-yi-ge-zhen-shi-de-li-zi" tabindex="-1" id="1-3-一个真实的例子">1.3 一个真实的例子</h3><p>给你讲个我自己的例子。</p><p>前阵子我在用vLLM跑一个模型，发现GPU内存占用特别高，batch size稍微大一点就OOM了。当时我只会调参数，试了半天没用。</p><p>后来静下心来看了Transformer的KV Cache机制，才明白：</p><ul><li>每个token都要生成K和V向量</li><li>这些向量要一直存在GPU显存里</li><li>序列越长，batch越大，KV Cache占用呈指数级增长</li></ul><p>理解了这个，我才知道为什么PagedAttention能省内存（块状分配减少碎片），为什么要用Multi-Query Attention（减少KV头数）。</p><p><strong>不懂原理，就只能瞎调参。</strong></p><h2 id="er-ai-infra-shi-jiao-xia-de-transformer-zhi-shi-di-tu" tabindex="-1" id="二、AI-Infra视角下的Transformer知识地图">二、AI Infra视角下的Transformer知识地图</h2><p>好了，既然要学，那到底学什么？</p><p>我把Transformer的知识点分成三个层级，告诉你哪些必须学、哪些重要、哪些了解就行。</p><h3 id="he-xin-bi-xue" tabindex="-1" id="核心必学">核心必学</h3><p>这部分不学，你做AI Infra基本寸步难行。</p><h4 id="2-1-kv-cache-ji-zhi" tabindex="-1" id="2-1-KV-Cache机制">2.1 KV Cache机制</h4><p><strong>为什么必学？</strong></p><p>KV Cache是AI Infra优化的<strong>头号目标</strong>。不夸张地说，现代LLM推理优化的一半技术都在优化KV Cache。</p><p><strong>必须理解的点：</strong></p><ol><li><strong>KV Cache是怎么产生的？</strong></li></ol><p>在Transformer的自回归生成过程中（比如GPT生成文本），每生成一个新token，都需要用到之前所有token的Key和Value向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成第1个词: 需要prompt的KV</span><br><span class="line">生成第2个词: 需要prompt + 第1个词的KV</span><br><span class="line">生成第3个词: 需要prompt + 第1个词 + 第2个词的KV</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为了避免重复计算，这些KV向量会被缓存起来——这就是KV Cache。</p><ol><li><strong>KV Cache有多占内存？</strong></li></ol><p>假设一个7B参数的模型，hidden size是4096，有32层：</p><ul><li>每个token的KV向量：<code>2 × 4096 × 32 × 2字节(FP16) ≈ 512KB</code></li><li>生成1000个token：<code>512KB × 1000 ≈ 512MB</code></li><li>Batch size = 32：<code>512MB × 32 = 16GB</code></li></ul><p>16GB！这还只是KV Cache，不包括模型权重和其他激活值。所以你会看到大batch推理很容易OOM。</p><ol><li><strong>怎么优化KV Cache？</strong></li></ol><ul><li><strong>PagedAttention</strong>：像操作系统的虚拟内存一样，分块管理KV Cache，减少内存碎片（这就是vLLM的核心技术）</li><li><strong>Multi-Query Attention (MQA)</strong>：让所有Query头共享一组KV，大幅减少KV Cache大小</li><li><strong>KV量化</strong>：把KV向量从FP16量化到INT8甚至INT4</li><li><strong>Prefix Caching</strong>：多个请求共享相同的系统prompt对应的KV</li></ul><p><strong>实践建议：</strong></p><p>去看vLLM的源码，重点看<code>CacheEngine</code>和<code>BlockManager</code>这两个模块。跑一个模型，用<code>nvidia-smi</code>监控显存占用，你会对KV Cache有直观的感受。</p><h4 id="2-2-attention-ji-suan-liu-cheng" tabindex="-1" id="2-2-Attention计算流程">2.2 Attention计算流程</h4><p><strong>为什么必学？</strong></p><p>Attention计算是Transformer的<strong>性能瓶颈</strong>。你做推理优化，90%的时间都在优化Attention。</p><p><strong>必须理解的点：</strong></p><ol><li><strong>Attention的四步计算</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line">scores = Q @ K.T  / sqrt(d_k)     <span class="comment"># 1. 点积 + 缩放</span></span><br><span class="line">attention_weights = softmax(scores)  <span class="comment"># 2. Softmax归一化  </span></span><br><span class="line">output = attention_weights @ V       <span class="comment"># 3. 加权求和</span></span><br></pre></td></tr></table></figure><ol><li><strong>为什么Attention慢？</strong></li></ol><ul><li><strong>内存瓶颈</strong>：Q、K、V都是大矩阵，频繁在HBM（显存）和SRAM（缓存）之间搬运数据</li><li><strong>计算复杂度</strong>：O(n²)，序列越长越慢</li></ul><ol><li><strong>优化方向</strong></li></ol><ul><li><strong>Flash Attention</strong>：重新组织计算顺序，减少HBM访问次数（vLLM已经集成）</li><li><strong>稀疏Attention</strong>：不是所有token都需要关注所有其他token</li><li><strong>Kernel融合</strong>：把多个小算子融合成一个大kernel，减少数据搬运</li></ul><p><strong>实践建议：</strong></p><p>对比一下开启和关闭Flash Attention的性能差异。在vLLM里很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Flash Attention（默认）</span></span><br><span class="line">llm = LLM(model=<span class="string">&quot;facebook/opt-125m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Flash Attention</span></span><br><span class="line">llm = LLM(model=<span class="string">&quot;facebook/opt-125m&quot;</span>, disable_flash_attn=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>跑个benchmark，你会发现差距很明显。</p><h4 id="2-3-batch-chu-li-yu-xu-lie-bing-xing" tabindex="-1" id="2-3-Batch处理与序列并行">2.3 Batch处理与序列并行</h4><p><strong>为什么必学？</strong></p><p>提升推理系统吞吐量的核心手段。</p><p><strong>必须理解的点：</strong></p><ol><li><strong>静态Batching vs 动态Batching</strong></li></ol><p>传统方法：等凑够32个请求再一起推理。问题是：第1个请求可能要等很久。</p><p>Continuous Batching（vLLM用的）：来一个处理一个，动态调整batch。</p><ol><li><strong>为什么Transformer适合Batching？</strong></li></ol><p>因为Attention是独立的！处理batch中的第1个序列和第2个序列，计算是并行的。</p><p><strong>实践建议：</strong></p><p>用vLLM跑两个实验：</p><ul><li>单请求推理：测latency（延迟）</li><li>批量请求推理：测throughput（吞吐量）</li></ul><p>你会发现throughput可以提升10倍+，但latency只增加了一点点。</p><hr><h3 id="zhong-yao-li-jie" tabindex="-1" id="重要理解">重要理解</h3><p>这部分不是立刻就用，但理解了能帮你少走弯路。</p><h4 id="2-4-wei-zhi-bian-ma-positional-encoding" tabindex="-1" id="2-4-位置编码（Positional-Encoding）">2.4 位置编码（Positional Encoding）</h4><p><strong>为什么要关注？</strong></p><p>影响模型处理<strong>长上下文</strong>的能力。</p><p>Transformer的Self-Attention本身不感知位置，&quot;我爱你&quot;和&quot;你爱我&quot;对它来说是一样的。所以需要位置编码来告诉模型词的顺序。</p><p><strong>AI Infra关心什么？</strong></p><ul><li><strong>原始位置编码（Sinusoidal）</strong>：有长度限制，不适合超长上下文</li><li><strong>RoPE（Rotary Position Embedding）</strong>：很多新模型（LLaMA等）用这个，支持外推到更长序列</li><li><strong>ALiBi</strong>：另一种方案，不需要额外参数</li></ul><p>如果你要部署一个支持32K上下文的模型，位置编码方案会直接影响性能和效果。</p><h4 id="2-5-multi-head-attention" tabindex="-1" id="2-5-Multi-Head-Attention">2.5 Multi-Head Attention</h4><p><strong>为什么要关注？</strong></p><p>影响<strong>模型并行策略</strong>。</p><p>多头注意力意味着计算可以并行。如果一个模型有32个头，你可以把它们分到多个GPU上（张量并行）。</p><p><strong>AI Infra关心什么？</strong></p><ul><li>头数是2的幂次（8、16、32）方便切分</li><li>MQA/GQA（Multi-Query/Grouped-Query Attention）用更少的头，更省内存</li></ul><h4 id="2-6-encoder-vs-decoder-jia-gou" tabindex="-1" id="2-6-Encoder-vs-Decoder-架构">2.6 Encoder vs Decoder 架构</h4><p><strong>为什么要关注？</strong></p><p>不同架构的<strong>推理特性完全不同</strong>。</p><ul><li><p><strong>Encoder-only (BERT类)</strong>：</p><ul><li>输入一段文本，输出一段表示</li><li>没有自回归生成，不需要KV Cache</li><li>推理很快，适合分类、检索任务</li></ul></li><li><p><strong>Decoder-only (GPT类)</strong>：</p><ul><li>自回归生成，每个词依赖前面所有词</li><li>需要大量KV Cache</li><li>推理慢，但生成能力强</li></ul></li></ul><p><strong>AI Infra关心什么？</strong></p><p>你部署BERT和GPT，优化策略完全不同：</p><ul><li>BERT：重点优化计算（算子融合、量化）</li><li>GPT：重点优化内存（KV Cache管理、Paged Attention）</li></ul><hr><h3 id="liao-jie-ji-ke" tabindex="-1" id="了解即可">了解即可</h3><p>这部分主要是训练相关，推理时影响不大。</p><h4 id="2-7-masked-attention" tabindex="-1" id="2-7-Masked-Attention">2.7 Masked Attention</h4><p>训练时用来防止模型&quot;偷看&quot;未来的词。推理时生成本来就是一个词一个词来的，不存在这个问题。</p><p><strong>了解就行，不用深究。</strong></p><h4 id="2-8-can-chai-lian-jie-amp-layer-norm" tabindex="-1" id="2-8-残差连接-Layer-Norm">2.8 残差连接 &amp; Layer Norm</h4><p>这些是为了稳定训练过程。推理时它们就是网络的一部分，你优化时treat it as a black box就行。</p><p><strong>如果做算子优化，可能会关注Layer Norm的实现。</strong></p><h2 id="san-bu-tong-ai-infra-fang-xiang-de-xue-xi-ce-zhong" tabindex="-1" id="三、不同AI-Infra方向的学习侧重">三、不同AI Infra方向的学习侧重</h2><p>根据你的具体方向，学习重点不太一样。</p><h3 id="tui-li-you-hua-gong-cheng-shi" tabindex="-1" id="推理优化工程师">推理优化工程师</h3><p><strong>你的日常工作：</strong></p><p>让模型跑得更快、用更少资源、支持更大batch。</p><p><strong>Transformer知识优先级：</strong></p><ol><li><p><strong>KV Cache管理</strong>：必须吃透</p><ul><li>KV的产生、存储、读取全流程</li><li>PagedAttention原理和实现</li><li>Prefix Caching、KV量化</li></ul></li><li><p><strong>Attention计算优化</strong>：核心战场</p><ul><li>Flash Attention的原理（至少懂为什么快）</li><li>Multi-Query Attention的效果</li><li>Sparse Attention的适用场景</li></ul></li><li><p><strong>量化对Transformer的影响</strong>：必备技能</p><ul><li>哪些部分可以量化（权重、激活、KV Cache）</li><li>量化后的精度损失</li><li>量化算子的实现</li></ul></li></ol><p><strong>学习路线：</strong></p><p>第1周：搞透KV Cache</p><ul><li>看vLLM的<code>CacheEngine</code>源码</li><li>画出KV Cache的生命周期图</li><li>跑实验：监控不同batch下的KV占用</li></ul><p>第2-3周：实践优化技术</p><ul><li>开启/关闭Flash Attention对比</li><li>尝试不同的block size（PagedAttention参数）</li><li>实现一个简单的KV Cache管理器（Python即可）</li></ul><p>第4周+：深入一个方向</p><ul><li>如果做kernel优化：学CUDA，看Flash Attention源码</li><li>如果做系统优化：学调度策略，看vLLM的scheduler</li><li>如果做量化：学INT8/INT4 kernel实现</li></ul><h3 id="mo-xing-bu-shu-gong-cheng-shi" tabindex="-1" id="模型部署工程师">模型部署工程师</h3><p><strong>你的日常工作：</strong></p><p>让模型在生产环境稳定运行，支持高并发请求。</p><p><strong>Transformer知识优先级：</strong></p><ol><li><p><strong>模型架构与框架对应</strong>：必须清楚</p><ul><li>Encoder-only vs Decoder-only的部署差异</li><li>不同框架对Transformer的支持（TensorRT-LLM、vLLM、TGI）</li><li>模型格式转换（PyTorch → ONNX → TensorRT）</li></ul></li><li><p><strong>Batch处理机制</strong>：影响吞吐量</p><ul><li>Dynamic Batching的实现</li><li>Continuous Batching（vLLM的核心）</li><li>Batch size与latency的trade-off</li></ul></li><li><p><strong>长上下文支持</strong>：客户常问的问题</p><ul><li>位置编码方案（RoPE、ALiBi）</li><li>长上下文下的内存管理</li><li>Sliding Window Attention</li></ul></li></ol><p><strong>学习路线：</strong></p><p>第1周：熟悉部署流程</p><ul><li>在vLLM上部署一个模型</li><li>尝试不同的推理框架（TGI、TensorRT-LLM）</li><li>对比它们的API和性能</li></ul><p>第2周：理解架构差异</p><ul><li>部署一个BERT模型（如果做任务推理）</li><li>部署一个GPT模型</li><li>总结两者的部署要点差异</li></ul><p>第3周：优化并发性能</p><ul><li>测试不同max_batch_size的影响</li><li>配置动态batching参数</li><li>监控GPU利用率</li></ul><p>第4周+：生产化</p><ul><li>加入监控（Prometheus + Grafana）</li><li>实现自动扩缩容</li><li>做故障演练</li></ul><h3 id="ai-xi-tong-jia-gou-shi" tabindex="-1" id="AI系统架构师">AI系统架构师</h3><p><strong>你的日常工作：</strong></p><p>设计支持千亿参数模型的分布式推理系统。</p><p><strong>Transformer知识优先级：</strong></p><ol><li><p><strong>模型并行策略</strong>：核心技能</p><ul><li>张量并行（Tensor Parallelism）在Transformer中的应用</li><li>流水线并行（Pipeline Parallelism）的切分点</li><li>序列并行（Sequence Parallelism）的适用场景</li></ul></li><li><p><strong>内存墙与计算墙</strong>：系统瓶颈</p><ul><li>Transformer哪些操作是compute-bound，哪些是memory-bound</li><li>不同硬件（A100 vs H100）的特性</li><li>通信开销的计算</li></ul></li><li><p><strong>端到端推理流程</strong>：全局视角</p><ul><li>从接收请求到返回结果的完整路径</li><li>各阶段的瓶颈和优化点</li><li>SLA保证策略</li></ul></li></ol><p><strong>学习路线：</strong></p><p>第1-2周：理解并行策略</p><ul><li>阅读Megatron-LM、DeepSpeed论文</li><li>理解Transformer各层如何切分</li><li>画出并行策略的拓扑图</li></ul><p>第3周：分析瓶颈</p><ul><li>用Nsight分析Transformer的kernel性能</li><li>区分compute-bound和memory-bound操作</li><li>计算不同配置下的理论性能上限</li></ul><p>第4周+：设计系统</p><ul><li>设计一个支持千亿参数模型的推理集群</li><li>考虑成本、延迟、吞吐量的trade-off</li><li>写技术方案文档</li></ul><h2 id="si-xue-xi-jian-yi-yu-bi-keng-zhi-nan" tabindex="-1" id="四、学习建议与避坑指南">四、学习建议与避坑指南</h2><h3 id="tui-jian-zuo-fa" tabindex="-1" id="推荐做法">推荐做法</h3><p><strong>1. 从实践入手</strong></p><p>不要上来就啃论文。先跑起来一个vLLM程序，看看KV Cache在哪，占了多少内存。有了直观感受，再看原理会轻松很多。</p><p><strong>2. 关注&quot;为什么影响性能&quot;</strong></p><p>学每个概念，都问自己：这个东西为什么会影响推理性能？是影响内存、计算还是通信？</p><p>比如学位置编码，AI Infra关心的不是数学公式，而是：</p><ul><li>RoPE为什么比Sinusoidal支持更长上下文？</li><li>这对内存有什么影响？</li></ul><p><strong>3. 动手实验</strong></p><p>理论只是理论，跑个实验印象深刻一百倍。</p><p>推荐实验：</p><ul><li>监控KV Cache占用随序列长度的变化</li><li>对比Flash Attention开启前后的速度</li><li>测试不同batch size对吞吐量的影响</li></ul><p><strong>4. 看开源代码</strong></p><p>vLLM、TensorRT-LLM、TGI的代码都开源的。看不懂C++/CUDA没关系，先看Python部分的逻辑。</p><p>重点看：</p><ul><li>KV Cache的管理逻辑</li><li>Batch调度策略</li><li>内存分配器</li></ul><h2 id="xie-zai-zui-hou" tabindex="-1" id="写在最后">写在最后</h2><p>回到开头的问题：AI Infra工程师要不要学Transformer？</p><p><strong>要学，但要聪明地学。</strong></p><p>不要试图把Transformer的每个细节都搞懂，那是算法工程师的事。你要做的是：</p><ol><li><strong>抓住核心</strong>：KV Cache、Attention计算、Batch处理</li><li><strong>理解影响</strong>：每个设计为什么影响性能</li><li><strong>动手实践</strong>：跑起来，监控起来，优化起来</li></ol><p>记住，AI Infra的价值不是&quot;我懂Transformer&quot;，而是&quot;我能让Transformer跑得又快又稳&quot;。</p><hr><h2 id="can-kao-zi-liao" tabindex="-1" id="参考资料">参考资料</h2><ol><li><p>我的其他文章：</p><ul><li><a href="https://smarter.xin/posts/db1cf321/">《Transformer详解》</a> - Transformer基础原理</li><li><a href="https://smarter.xin/posts/fbab2bc4/">《PagedAttention解析》</a> - KV Cache优化的核心技术</li><li><a href="https://smarter.xin/posts/b21cbc80/">《第一个vLLM程序》</a> - 实践入门</li></ul></li><li><p>推荐阅读：</p><ul><li><strong>Attention Is All You Need</strong> - Transformer原论文</li><li><strong>The Illustrated Transformer</strong> - 最好的可视化教程</li><li><strong>vLLM: Easy, Fast, and Cheap LLM Serving with PagedAttention</strong> - vLLM原论文</li><li><strong>Flash Attention</strong> - Attention优化技术</li></ul></li><li><p>开源项目：</p><ul><li><a href="https://github.com/vllm-project/vllm">vLLM</a></li><li><a href="https://github.com/NVIDIA/TensorRT-LLM">TensorRT-LLM</a></li><li><a href="https://github.com/huggingface/text-generation-inference">Text Generation Inference (TGI)</a></li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;ai-infra-xue-xi-lu-xian&quot; tabindex=&quot;-1&quot;&gt;AI Infra学习路线&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;写给刚入门AI</summary>
        
      
    
    
    
    <category term="AI Infra" scheme="https://smarter.xin/categories/ai-infra/"/>
    
    
    <category term="KV Cache" scheme="https://smarter.xin/tags/KV-Cache/"/>
    
    <category term="AI Infrastructure" scheme="https://smarter.xin/tags/AI-Infrastructure/"/>
    
    <category term="Transformer" scheme="https://smarter.xin/tags/Transformer/"/>
    
    <category term="推理优化" scheme="https://smarter.xin/tags/inference-optimization/"/>
    
    <category term="模型部署" scheme="https://smarter.xin/tags/model-deployment/"/>
    
    <category term="学习路线" scheme="https://smarter.xin/tags/learning-path/"/>
    
  </entry>
  
  <entry>
    <title>AI Infra学习之旅-Transformer详解</title>
    <link href="https://smarter.xin/posts/db1cf321/"/>
    <id>https://smarter.xin/posts/db1cf321/</id>
    <published>2026-01-04T08:09:30.000Z</published>
    <updated>2026-01-06T13:16:51.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transformer-shen-du-jie-xi-cong-ling-kai-shi-li-jie-quot-zhu-yi-li-jiu-shi-ni-suo-xu-yao-de-yi-qie-quot" tabindex="-1">Transformer深度解析：从零开始理解&quot;注意力就是你所需要的一切&quot;</h1><blockquote><p>如果你关注AI领域，ChatGPT、BERT、GPT这些名字应该不陌生。它们背后有个共同的&quot;老祖宗&quot;——Transformer。我最初看到这个架构时，觉得有点复杂，但当我真正理解了它的设计思想后，突然发现一切都说得通了。今天我想用最直白的方式，和你聊聊这个改变了整个深度学习游戏规则的架构。</p></blockquote><h2 id="xie-zai-qian-mian" tabindex="-1" id="写在前面">写在前面</h2><p>2017年，Google的研究团队发了一篇论文，标题叫《Attention Is All You Need》。第一次看到这个标题时我就觉得，这帮人可真敢说——“注意力就是你所需要的一切”，口气未免太大了吧？但几年过去了，事实证明他们是对的。这篇论文提出的Transformer架构，不仅彻底改写了NLP的规则，还渗透到了CV、语音、甚至生物信息学等各个领域。</p><p>在扎进技术细节之前，我想先说说Transformer为什么会出现。毕竟，任何技术的诞生都是为了解决某个实际问题。</p><h2 id="yi-rnn-de-kun-jing-wo-men-wei-shi-yao-xu-yao-xin-jia-gou" tabindex="-1" id="一、RNN的困境：我们为什么需要新架构？">一、RNN的困境：我们为什么需要新架构？</h2><p>在Transformer横空出世之前，处理序列数据（比如文本、语音）的主流方案是RNN（循环神经网络）以及它的改进版LSTM、GRU。</p><h3 id="rnn-zen-yao-gong-zuo-de" tabindex="-1" id="RNN怎么工作的？">RNN怎么工作的？</h3><p>你可以把RNN想象成这样一个场景：你在读一本侦探小说。RNN的处理方式就是<strong>一个字一个字地往下读，每读一个字都会更新对剧情的理解</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;我 爱 北京 天安门&quot;</span><br><span class="line">处理: 我 → 我爱 → 我爱北京 → 我爱北京天安门</span><br></pre></td></tr></table></figure><p>听起来挺合理的，对吧？但这里有个致命的问题：<strong>必须按顺序处理，没法跳着来</strong>。</p><h3 id="rnn-de-liang-da-ying-shang" tabindex="-1" id="RNN的两大硬伤">RNN的两大硬伤</h3><p><strong>1. 没法并行计算</strong></p><p>要处理第3个词，你必须先把第1、2个词处理完。这就像高速公路只有一条车道，不管你有多少辆车（GPU核心），也只能排队一辆一辆过。对于动辄几百万、上亿参数的模型来说，这种串行处理简直是灾难。训练一个大模型可能要好几周，谁受得了？</p><p><strong>2. 长距离依赖问题</strong></p><p>来看这个句子：</p><blockquote><p>“那只<strong>猫</strong>，它在花园里追蝴蝶的时候不小心撞到了树，后来躺在沙发上休息了一下午，最后终于恢复了精神，<strong>它</strong>开心地喵喵叫。”</p></blockquote><p>你肯定一眼就能看出最后的&quot;它&quot;指的是开头的&quot;猫&quot;。但对RNN来说，这可太难了。&quot;猫&quot;这个信息得像接力赛一样，一站一站地传到&quot;它&quot;那里。传递链越长，信息损失越严重——就像小时候玩传话游戏，传到最后往往都变味了。</p><p>理论上LSTM通过门控机制缓解了这个问题，但也只是&quot;缓解&quot;，并没有根治。</p><p><strong>Transformer的出现，就是为了一刀切掉这两个问题。</strong></p><h2 id="er-zhu-yi-li-ji-zhi-transformer-de-he-xin-wu-qi" tabindex="-1" id="二、注意力机制：Transformer的核心武器">二、注意力机制：Transformer的核心武器</h2><p>在正式拆解Transformer之前，得先搞懂它最核心的部分——<strong>自注意力机制（Self-Attention）</strong>。这东西听起来玄乎，其实思想很直观。</p><h3 id="xian-lai-ge-zhi-guan-de-li-zi" tabindex="-1" id="先来个直观的例子">先来个直观的例子</h3><p>假设有这么一句话：</p><blockquote><p>“那只动物没能过马路，因为<strong>它</strong>太累了。”</p></blockquote><p>当你读到&quot;它&quot;的时候，你的大脑会做什么？会自动&quot;回看&quot;前面的内容，判断&quot;它&quot;指的是啥。你会把更多注意力分配给&quot;动物&quot;，而不是&quot;马路&quot;或&quot;因为&quot;。</p><p><strong>自注意力机制做的就是这件事：在处理每个词的时候，让模型能&quot;看到&quot;句子里所有其他词，并自动决定该给每个词分配多少注意力。</strong></p><h3 id="query-key-value-san-ge-guan-jian-jiao-se" tabindex="-1" id="Query、Key、Value：三个关键角色">Query、Key、Value：三个关键角色</h3><p>自注意力的实现靠三个向量：<strong>Query（查询）</strong>、<strong>Key（键）</strong>、<strong>Value（值）</strong>。</p><p>我第一次看到这三个概念时也很懵，后来发现用图书馆来比喻特别好理解：</p><ul><li><strong>Query</strong>：你想找的书的描述，比如&quot;关于深度学习的入门书&quot;</li><li><strong>Key</strong>：每本书的标签/索引，比如&quot;深度学习&quot;、“CV”、“烹饪”</li><li><strong>Value</strong>：书的实际内容</li></ul><p>找书的过程是这样的：</p><ol><li>拿着你的Query（需求描述），去和书架上每本书的Key（标签）对比</li><li>标签越匹配，说明这本书越相关</li><li>根据相关性高低，从对应的Value（书的内容）中提取信息</li><li>最后你得到的是一个&quot;混合信息&quot;——相关性高的书提供更多内容，相关性低的书提供较少内容</li></ol><p>在Transformer里，每个词都会生成自己的Q、K、V向量。这些向量怎么来的？很简单，就是把词向量和三个可学习的权重矩阵相乘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q = 词向量 × Wq</span><br><span class="line">K = 词向量 × Wk  </span><br><span class="line">V = 词向量 × Wv</span><br></pre></td></tr></table></figure><p>这三个矩阵Wq、Wk、Wv是模型训练过程中学习出来的。</p><h3 id="zhu-yi-li-fen-shu-zen-yao-suan" tabindex="-1" id="注意力分数怎么算？">注意力分数怎么算？</h3><p>有了Q、K、V，注意力的计算就是四步走：</p><p><strong>第一步：计算相关性分数</strong></p><p>用当前词的Query和所有词（包括自己）的Key做点积。点积值越大，说明两个词越相关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分数 = Q · K^T</span><br></pre></td></tr></table></figure><p>这里为什么用点积？因为点积本质上衡量的是两个向量的相似度。方向越接近，点积越大。</p><p><strong>第二步：缩放（Scaling）</strong></p><p>直接用点积会有个问题：如果向量维度很大（比如512维），点积的结果也会很大。这些大数值经过softmax后，会导致梯度极小（想象一下softmax把一个很大的数映射成接近1，其他数映射成接近0，梯度基本就没了）。</p><p>所以论文里做了个简单粗暴的处理：除以√dk（Key向量维度的平方根）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩放后的分数 = Q·K^T / √dk</span><br></pre></td></tr></table></figure><p>为什么是平方根？论文附录里有数学推导，简单说就是：假设Q和K的每个元素均值为0、方差为1，那么d维向量点积的方差就是d。除以√d可以把方差拉回到1，保持数值稳定。</p><p><strong>第三步：Softmax归一化</strong></p><p>把分数转成概率分布，让所有注意力权重加起来等于1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意力权重 = softmax(缩放后的分数)</span><br></pre></td></tr></table></figure><p>经过softmax后，相关性高的词得到更大的权重，相关性低的词权重接近0。</p><p><strong>第四步：加权求和</strong></p><p>用注意力权重对所有Value向量进行加权求和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出 = 注意力权重 × V</span><br></pre></td></tr></table></figure><p>整个过程可以用一个公式搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attention(Q, K, V) = softmax(QK^T / √dk) × V</span><br></pre></td></tr></table></figure><p><strong>来个具体例子</strong></p><p>假设我们有三个词：“我”、“爱”、“你”，每个词的向量是2维（实际中通常是512维或更高，这里为了方便演示用2维）。</p><p>假设&quot;爱&quot;这个词的Query是<code>[1, 0]</code>，三个词的Key分别是：</p><ul><li>“我”：<code>[0.8, 0.2]</code></li><li>“爱”：<code>[1.0, 0.0]</code></li><li>“你”：<code>[0.6, 0.5]</code></li></ul><p>计算&quot;爱&quot;对三个词的注意力：</p><ol><li><p>计算点积：</p><ul><li>爱→我：1×0.8 + 0×0.2 = 0.8</li><li>爱→爱：1×1.0 + 0×0.0 = 1.0</li><li>爱→你：1×0.6 + 0×0.5 = 0.6</li></ul></li><li><p>缩放（√2 ≈ 1.41）：</p><ul><li>爱→我：0.8/1.41 ≈ 0.57</li><li>爱→爱：1.0/1.41 ≈ 0.71</li><li>爱→你：0.6/1.41 ≈ 0.42</li></ul></li><li><p>Softmax后大约是：</p><ul><li>爱→我：0.31</li><li>爱→爱：0.38</li><li>爱→你：0.31</li></ul></li><li><p>用这些权重对Value向量加权求和，得到&quot;爱&quot;的新表示</p></li></ol><p>这个例子说明，“爱&quot;这个词对自己的注意力最高（0.38），但也会关注&quot;我&quot;和&quot;你”（各0.31左右）。这很合理，因为动词往往需要同时关注主语和宾语。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-16b4a6.png" alt="自注意力机制计算流程：展示了从输入词向量到生成Q、K、V，再到计算注意力分数、缩放、Softmax归一化和最终加权求和的完整过程"></p><h3 id="duo-tou-zhu-yi-li-cong-duo-ge-shi-jiao-kan-wen-ti" tabindex="-1" id="多头注意力：从多个视角看问题">多头注意力：从多个视角看问题</h3><p>单个注意力机制就像从一个角度看东西。但理解一句话，可能需要同时考虑语法结构、语义关系、指代关系等多个维度。</p><p><strong>多头注意力（Multi-Head Attention）</strong> 就是这个思路：</p><ol><li>把Q、K、V分别切成多个&quot;头&quot;（原论文用了8个头）</li><li>每个头独立计算注意力</li><li>把所有头的结果拼起来，再做一次线性变换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiHead(Q,K,V) = Concat(head₁, head₂, ..., head₈) × Wo</span><br><span class="line">其中 headᵢ = Attention(QWᵢq, KWᵢk, VWᵢv)</span><br></pre></td></tr></table></figure><p>每个头有自己独立的Wq、Wk、Wv权重矩阵，所以能学到不同类型的关系。</p><p>举个例子，在翻译句子时：</p><ul><li>第1个头可能专注于主谓关系</li><li>第2个头可能专注于修饰关系（形容词和名词）</li><li>第3个头可能专注于位置关系（前后词的相对位置）</li><li>…</li></ul><p>把这些不同视角的信息综合起来，模型对句子的理解就更全面了。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-c3a043.png" alt="多头注意力机制：8个attention head并行工作，每个head学习不同的语言关系模式，最后将所有head的输出拼接并变换"></p><h2 id="san-transformer-jia-gou-quan-mao" tabindex="-1" id="三、Transformer架构全貌">三、Transformer架构全貌</h2><p>搞懂了注意力机制，就理解了Transformer的核心。现在我们把整个架构拼起来。</p><p>Transformer采用经典的<strong>编码器-解码器（Encoder-Decoder）</strong> 结构，左边是Encoder，右边是Decoder。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-3d81bd.png" alt="Transformer完整架构：左侧为6层Encoder（蓝色），右侧为6层Decoder（橙色），展示了多头注意力、前馈网络、残差连接和层归一化等关键组件"></p><p>原论文中的Transformer由<strong>6层Encoder</strong>和<strong>6层Decoder</strong>堆叠而成。</p><h3 id="bian-ma-qi-encoder" tabindex="-1" id="编码器（Encoder）">编码器（Encoder）</h3><p>每一层Encoder包含两个子层：</p><ol><li><strong>多头自注意力层</strong>：让每个词都能&quot;看到&quot;输入序列中的所有其他词</li><li><strong>前馈神经网络（FFN）</strong>：其实就是两层全连接网络，对每个位置的表示做进一步变换</li></ol><p>关键的是，每个子层都包了两个&quot;保护壳&quot;：</p><ul><li><strong>残差连接（Residual Connection）</strong>：把输入直接加到输出上，这样梯度可以&quot;直通&quot;回去，缓解深层网络的梯度消失问题</li><li><strong>层归一化（Layer Normalization）</strong>：把每一层的输出归一化，稳定训练过程</li></ul><p>整个流程可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出 = LayerNorm(x + SubLayer(x))</span><br></pre></td></tr></table></figure><p>先对x做变换（MultiHead Attention或FFN），然后和原来的x相加（残差连接），最后归一化。</p><p>6层Encoder叠在一起，就像是对输入做了6次&quot;提炼&quot;，每一层都在之前的基础上提取更抽象的特征。</p><h3 id="jie-ma-qi-decoder" tabindex="-1" id="解码器（Decoder）">解码器（Decoder）</h3><p>解码器比编码器多一个子层，总共三个：</p><ol><li><strong>带掩码的多头自注意力层（Masked Multi-Head Attention）</strong></li><li><strong>编码器-解码器注意力层（Cross-Attention）</strong>：让解码器能够&quot;查阅&quot;编码器的输出</li><li><strong>前馈神经网络</strong></li></ol><h4 id="wei-shi-yao-xu-yao-yan-ma-mask" tabindex="-1" id="为什么需要掩码（Mask）？">为什么需要掩码（Mask）？</h4><p>这是个关键问题。在训练翻译模型时，我们已经有了完整的目标句子。比如把&quot;我爱中国&quot;翻译成&quot;I love China&quot;，训练时我们知道完整的目标是&quot;I love China&quot;。</p><p>但我们希望模型学会的是：根据已生成的词，预测下一个词。如果模型在预测&quot;love&quot;的时候能&quot;偷看&quot;到后面的&quot;China&quot;，那就作弊了——测试时哪有未来的词给你看啊？</p><p>掩码的作用就是<strong>在自注意力计算时，遮住未来位置的信息</strong>。具体做法是：在softmax之前，把未来位置的分数设为负无穷（-∞）。这样经过softmax后，那些位置的注意力权重就变成0了。</p><p>比如在生成&quot;love&quot;时：</p><ul><li>可以看到<code>&lt;start&gt;</code>和&quot;I&quot;</li><li>看不到&quot;love&quot;后面的&quot;China&quot;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-f77a42.png" alt="注意力掩码矩阵：下三角矩阵显示解码器在位置i只能看到≤i的位置，上三角部分被设为-∞（灰色区域），保证生成时不会偷看未来的词"></p><h4 id="bian-ma-qi-jie-ma-qi-zhu-yi-li" tabindex="-1" id="编码器-解码器注意力">编码器-解码器注意力</h4><p>这是Decoder特有的第二个子层。它让解码器在生成每个词时，可以&quot;查阅&quot;编码器的输出。</p><p>这里的Query来自解码器，Key和Value来自编码器。这样解码器就能根据自己当前的状态（Query），去编码后的源句子里找相关信息（Key），并提取相应内容（Value）。</p><p>比如翻译&quot;我爱中国&quot;→&quot;I love China&quot;时：</p><ul><li>生成&quot;I&quot;时，主要关注&quot;我&quot;</li><li>生成&quot;love&quot;时，主要关注&quot;爱&quot;</li><li>生成&quot;China&quot;时，主要关注&quot;中国&quot;</li></ul><p>当然，实际情况会更复杂，因为不是所有语言都是一一对应的词序。</p><h3 id="wei-zhi-bian-ma-gao-su-mo-xing-ci-de-shun-xu" tabindex="-1" id="位置编码：告诉模型词的顺序">位置编码：告诉模型词的顺序</h3><p>自注意力有个&quot;缺陷&quot;：它是<strong>位置无关的</strong>。</p><p>什么意思？对于自注意力来说，&quot;我爱你&quot;和&quot;你爱我&quot;如果只看词本身，处理方式是一样的——因为它只计算词与词之间的关系，不管它们的位置。</p><p>但词的位置显然很重要啊！&quot;狗咬人&quot;和&quot;人咬狗&quot;完全是两码事。</p><p>怎么办？把位置信息&quot;编码&quot;进输入向量里。</p><p><strong>位置编码（Positional Encoding）</strong> 用正弦和余弦函数生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PE(pos, 2i)   = sin(pos / 10000^(2i/d))</span><br><span class="line">PE(pos, 2i+1) = cos(pos / 10000^(2i/d))</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>pos</code>是词在句子中的位置（0, 1, 2, …）</li><li><code>i</code>是维度索引（0到d/2）</li><li><code>d</code>是向量维度（比如512）</li></ul><p>为什么用正弦/余弦函数？主要是因为它们有几个好性质：</p><ol><li><strong>值域有界</strong>：始终在[-1, 1]之间，不会因为位置太大而爆炸</li><li><strong>每个位置唯一</strong>：不同位置的编码不会重复</li><li><strong>能表示相对位置</strong>：利用三角函数的性质，PE(pos+k)可以表示为PE(pos)的线性组合，这让模型更容易学到&quot;相对位置关系&quot;（比如&quot;前面第2个词&quot;）</li><li><strong>可以泛化到更长序列</strong>：训练时见过100个词的句子，测试时来了150个词，位置编码依然能算出来</li></ol><p>位置编码会<strong>直接加到</strong>词嵌入向量上，作为模型的最终输入。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-918119.png" alt="位置编码热力图：展示了正弦和余弦函数生成的位置编码模式，不同维度使用不同频率的波，形成独特的条纹状pattern，使每个位置都有唯一的编码"></p><h2 id="si-shi-ji-ying-yong-ji-qi-fan-yi-de-wan-zheng-liu-cheng" tabindex="-1" id="四、实际应用：机器翻译的完整流程">四、实际应用：机器翻译的完整流程</h2><p>理论说了一堆，我们来看个具体例子。假设要把&quot;我爱中国&quot;翻译成&quot;I love China&quot;。</p><h3 id="bian-ma-jie-duan" tabindex="-1" id="编码阶段">编码阶段</h3><p><strong>第一步：输入表示</strong></p><ul><li>把&quot;我&quot;、“爱”、&quot;中国&quot;转成词向量（比如用Word2Vec或直接学习Embedding）</li><li>给每个词向量加上位置编码（&quot;我&quot;是位置0，&quot;爱&quot;是位置1，&quot;中国&quot;是位置2）</li></ul><p><strong>第二步：经过6层Encoder</strong></p><ul><li>第1层：通过自注意力，“爱&quot;这个词能看到&quot;我&quot;和&quot;中国”，理解到这是个主谓宾结构</li><li>第2层：在第1层的基础上进一步提炼，可能学到&quot;我爱X&quot;这种情感表达模式</li><li>…</li><li>第6层：得到包含丰富上下文信息的最终编码</li></ul><p>每经过一层，词的表示就更&quot;丰富&quot;一些，包含的上下文信息就更多一些。</p><h3 id="jie-ma-jie-duan" tabindex="-1" id="解码阶段">解码阶段</h3><p><strong>第一步：开始标记</strong><br>输入<code>&lt;start&gt;</code>标记，告诉模型&quot;该生成句子了&quot;。</p><p><strong>第二步：生成&quot;I&quot;</strong></p><ul><li>解码器接收<code>&lt;start&gt;</code></li><li>通过掩码自注意力处理<code>&lt;start&gt;</code>（虽然只有一个词，也要走这个流程）</li><li>通过编码器-解码器注意力，关注编码后的源句子，发现&quot;我&quot;最相关</li><li>经过FFN，输出一个概率分布</li><li>概率最高的词是&quot;I&quot;</li></ul><p><strong>第三步：生成&quot;love&quot;</strong></p><ul><li>解码器接收<code>&lt;start&gt; I</code></li><li>掩码确保&quot;I&quot;只能看到自己和<code>&lt;start&gt;</code>，看不到未来</li><li>再次查阅编码器输出，这次主要关注&quot;爱&quot;</li><li>预测下一个词：“love”</li></ul><p><strong>第四步：生成&quot;China&quot;</strong></p><ul><li>解码器接收<code>&lt;start&gt; I love</code></li><li>关注编码器中的&quot;中国&quot;</li><li>预测：“China”</li></ul><p><strong>第五步：结束</strong></p><ul><li>解码器接收<code>&lt;start&gt; I love China</code></li><li>预测下一个词是<code>&lt;end&gt;</code>，翻译结束</li></ul><p>实际使用中，我们不一定每次都选概率最高的词（这叫Greedy Decoding），更常用<strong>Beam Search</strong>：保留top-k个候选序列，最后选总概率最高的那个。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-Transformer%E8%AF%A6%E8%A7%A3/2026-01-04-16-28-35-ca245b.png" alt="机器翻译流程示意：展示了&quot;我爱中国&quot;→&quot;I love China&quot;的完整翻译过程，包括编码器处理和解码器的4个生成步骤，每步用注意力热力图显示关注的源语言词"></p><h2 id="wu-wei-shi-yao-transformer-zhe-yao-cheng-gong" tabindex="-1" id="五、为什么Transformer这么成功？">五、为什么Transformer这么成功？</h2><p>回顾一下，Transformer为什么能在短短几年内席卷整个AI领域？</p><h3 id="1-zhen-bing-xing-ji-suan" tabindex="-1" id="1-真·并行计算">1. 真·并行计算</h3><p>这是最直接的优势。RNN必须一个词一个词地算，Transformer可以一次性算完整个句子。</p><p>假设一个句子有100个词，RNN需要100步串行计算；Transformer可以一步算完所有词的self-attention（当然内部还是有矩阵运算，但这些可以完美并行）。</p><p>在GPU上，这个优势太明显了。GPU有成千上万个核心，就是为并行计算设计的。Transformer充分发挥了硬件优势，训练速度比RNN快了<strong>几个数量级</strong>。</p><h3 id="2-chang-ju-chi-yi-lai-bu-zai-shi-wen-ti" tabindex="-1" id="2-长距离依赖不再是问题">2. 长距离依赖不再是问题</h3><p>在Transformer里，任意两个词之间的&quot;距离&quot;都是1——一次注意力计算就能直接建立联系。</p><p>不像RNN，信息要一站一站传递。句子开头的词，要传100步才能影响结尾的词；Transformer里，开头直接看到结尾。</p><p>这让模型能轻松捕捉长距离依赖，比如指代消解、长篇文档的主题理解等。</p><h3 id="3-ke-jie-shi-xing-geng-hao" tabindex="-1" id="3-可解释性更好">3. 可解释性更好</h3><p>注意力权重可以可视化。你可以画个热力图，看到模型在翻译&quot;China&quot;时，把80%的注意力放在了源句子的&quot;中国&quot;上。</p><p>这比RNN的隐状态好理解多了。RNN的隐状态是一堆数字，你根本不知道它记住了啥、忘了啥。</p><h3 id="4-ji-qiang-de-ke-kuo-zhan-xing" tabindex="-1" id="4-极强的可扩展性">4. 极强的可扩展性</h3><p>Transformer的架构非常&quot;scalable&quot;。想要更强的模型？简单：</p><ul><li>加深：6层→12层→24层→96层</li><li>加宽：512维→1024维→2048维</li><li>加头：8 heads→16 heads→32 heads</li></ul><p>从BERT-base（110M参数）到GPT-3（175B参数），再到最新的模型（千亿级），都是Transformer架构。只是层数、维度不同而已。</p><p>而且有个神奇的现象：<strong>参数越大，效果往往越好</strong>（当然数据也要跟上）。这就是大模型时代的基石。</p><h2 id="liu-transformer-de-hou-dai-men" tabindex="-1" id="六、Transformer的后代们">六、Transformer的后代们</h2><p>Transformer提出后，基于它的各种变体和改进模型层出不穷。这里介绍几个最有影响力的：</p><table><thead><tr><th>模型</th><th>架构</th><th>特点</th><th>典型应用</th></tr></thead><tbody><tr><td><strong>BERT</strong></td><td>只用Encoder</td><td>双向编码，擅长理解文本</td><td>搜索引擎、问答系统、文本分类</td></tr><tr><td><strong>GPT系列</strong></td><td>只用Decoder</td><td>自回归生成，擅长创造文本</td><td>ChatGPT、代码生成、创意写作</td></tr><tr><td><strong>T5</strong></td><td>完整Encoder-Decoder</td><td>把所有NLP任务都转成&quot;文本到文本&quot;</td><td>翻译、摘要、QA统一框架</td></tr><tr><td><strong>Vision Transformer (ViT)</strong></td><td>Encoder-only</td><td>把图像切成patch当词处理</td><td>图像分类、目标检测</td></tr><tr><td><strong>DALL-E / Stable Diffusion</strong></td><td>改进的Transformer</td><td>文生图、多模态</td><td>AI绘画、图像编辑</td></tr></tbody></table><p><strong>BERT vs GPT：一个理解，一个生成</strong></p><ul><li><p><strong>BERT</strong>：只用Encoder，训练时随机遮住一些词让模型猜（Masked Language Modeling）。因为能同时看到上下文，所以擅长&quot;理解&quot;任务——给它一篇文章，它能告诉你情感是正面还是负面，能回答文章相关问题。</p></li><li><p><strong>GPT</strong>：只用Decoder，训练时根据前面的词预测下一个词。因为只能看到之前的内容，所以擅长&quot;生成&quot;任务——给它一个开头，它能续写出连贯的文章。</p></li></ul><p>这也解释了为什么ChatGPT用的是GPT架构，而不是BERT——因为聊天需要生成回复嘛。</p><p>可以说，现代AI的大部分突破，都直接或间接站在Transformer的肩膀上。</p><h2 id="xie-zai-zui-hou" tabindex="-1" id="写在最后">写在最后</h2><p>回头看看我们都聊了些啥：</p><ol><li><strong>为什么需要Transformer</strong>：RNN的并行化困难和长距离依赖问题</li><li><strong>核心机制</strong>：Self-Attention通过Query、Key、Value实现对上下文的灵活建模</li><li><strong>多头注意力</strong>：从多个角度理解输入</li><li><strong>整体架构</strong>：Encoder-Decoder结构，加上位置编码、残差连接、层归一化等关键组件</li><li><strong>实际应用</strong>：翻译、生成、理解，无所不能的基础架构</li></ol><p>Transformer的影响已经远超当初的机器翻译。从ChatGPT到Stable Diffusion，从AlphaFold到代码补全工具GitHub Copilot，Transformer无处不在。</p><p>说实话，当初读论文时，我没想到这个架构能火成现在这样。它并不完美——比如注意力的O(n²)复杂度在处理超长序列时还是个问题——但它的设计思想实在太优雅了。<strong>用注意力机制让模型自己决定关注什么</strong>，这个想法简单却强大。</p><p>如果你想深入学习AI，Transformer绝对是绕不过去的一关。理解了它，你就掌握了现代AI的基石。</p><p>希望这篇文章能帮你建立起对Transformer的直观理解。如果有任何疑问，欢迎留言讨论！</p><hr><h2 id="can-kao-zi-liao" tabindex="-1" id="参考资料">参考资料</h2><ol><li><strong>Vaswani, A., et al.</strong> (2017). “Attention is all you need.” <em>Advances in Neural Information Processing Systems</em>. <a href="https://arxiv.org/abs/1706.03762">原论文链接</a></li><li><strong>The Illustrated Transformer</strong> - Jay Alammar 的可视化教程，强烈推荐：<a href="http://jalammar.github.io/illustrated-transformer/">http://jalammar.github.io/illustrated-transformer/</a></li><li><strong>Annotated Transformer</strong> - Harvard NLP的带注释实现，适合动手实践：<a href="https://nlp.seas.harvard.edu/annotated-transformer/">https://nlp.seas.harvard.edu/annotated-transformer/</a></li><li><strong>BERT论文</strong>: Devlin, J., et al. (2018). “BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding.”</li><li><strong>GPT-3论文</strong>: Brown, T., et al. (2020). “Language Models are Few-Shot Learners.”</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;transformer-shen-du-jie-xi-cong-ling-kai-shi-li-jie-quot-zhu-yi-li-jiu-shi-ni-suo-xu-yao-de-yi-qie-quot&quot;</summary>
        
      
    
    
    
    <category term="AI Infra" scheme="https://smarter.xin/categories/ai-infra/"/>
    
    
    <category term="Transformer" scheme="https://smarter.xin/tags/Transformer/"/>
    
    <category term="注意力机制" scheme="https://smarter.xin/tags/attention-mechanism/"/>
    
    <category term="深度学习" scheme="https://smarter.xin/tags/deep-learning/"/>
    
    <category term="NLP" scheme="https://smarter.xin/tags/NLP/"/>
    
    <category term="人工智能" scheme="https://smarter.xin/tags/artificial-intelligence/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-Kadane</title>
    <link href="https://smarter.xin/posts/251a1af2/"/>
    <id>https://smarter.xin/posts/251a1af2/</id>
    <published>2026-01-04T02:29:18.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>Kadane算法是解决<strong>最大子数组和问题</strong>的经典动态规划算法，由计算机科学家Jay Kadane于1984年提出。该算法以极其简洁的代码实现了O(n)的最优时间复杂度，是动态规划空间优化的典范。</p><hr><h2 id="wen-ti-bei-jing" tabindex="-1" id="问题背景">问题背景</h2><h3 id="zui-da-zi-shu-zu-he-wen-ti" tabindex="-1" id="最大子数组和问题">最大子数组和问题</h3><blockquote><p><strong>LeetCode 53</strong>: 给定一个整数数组，找到具有最大和的连续子数组，返回其最大和。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6</span><br></pre></td></tr></table></figure><h3 id="ying-yong-chang-jing" tabindex="-1" id="应用场景">应用场景</h3><ul><li><strong>股票交易</strong>：找到最佳买卖时机的最大利润</li><li><strong>信号处理</strong>：在噪声中找到最强信号段</li><li><strong>生物信息学</strong>：DNA序列分析</li><li><strong>数据分析</strong>：找到业务指标的最佳表现时段</li></ul><hr><h2 id="suan-fa-yan-bian" tabindex="-1" id="算法演变">算法演变</h2><h3 id="fang-fa-1-bao-li-mei-ju" tabindex="-1" id="方法1-暴力枚举">方法1: 暴力枚举</h3><p>枚举所有可能的子数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                sum += nums[k];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n³)<br><strong>问题</strong>：三层循环，效率极低</p><h3 id="fang-fa-2-you-hua-bao-li" tabindex="-1" id="方法2-优化暴力">方法2: 优化暴力</h3><p>利用前缀和优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += nums[j];  <span class="comment">// 累加，避免重复计算</span></span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n²)<br><strong>问题</strong>：仍然较慢</p><h3 id="fang-fa-3-fen-zhi-suan-fa" tabindex="-1" id="方法3-分治算法">方法3: 分治算法</h3><p>如之前在<code>DivideAndConqer.cpp</code>中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分成左右两半，递归求解</span></span><br><span class="line">    <span class="comment">// 考虑跨越中点的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n log n)<br><strong>优势</strong>：比O(n²)快，适合理解分治思想</p><h3 id="fang-fa-4-kadane-suan-fa" tabindex="-1" id="方法4-Kadane算法">方法4: Kadane算法</h3><p><strong>最优解法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        maxEndingHere = <span class="built_in">max</span>(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">        maxSoFar = <span class="built_in">max</span>(maxSoFar, maxEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>完美</strong>！</p><hr><h2 id="kadane-suan-fa-yuan-li" tabindex="-1" id="Kadane算法原理">Kadane算法原理</h2><h3 id="he-xin-si-xiang" tabindex="-1" id="核心思想">核心思想</h3><p>对于数组中的每个位置，我们只需要做一个决定：</p><blockquote><p><strong>当前元素应该加入之前的子数组，还是从当前元素重新开始？</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于位置 i：</span><br><span class="line">maxEndingHere[i] = max(nums[i], maxEndingHere[i-1] + nums[i])</span><br><span class="line">                   ↑           ↑</span><br><span class="line">                重新开始    加入之前的子数组</span><br></pre></td></tr></table></figure><h3 id="zhuang-tai-ding-yi" tabindex="-1" id="状态定义">状态定义</h3><ul><li><strong>maxEndingHere</strong>：以当前位置结尾的最大子数组和</li><li><strong>maxSoFar</strong>：全局最大子数组和</li></ul><h3 id="jue-ce-guo-cheng-ke-shi-hua" tabindex="-1" id="决策过程可视化">决策过程可视化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</span><br><span class="line"></span><br><span class="line">位置0: maxEndingHere = -2, maxSoFar = -2</span><br><span class="line">       [-2]</span><br><span class="line"></span><br><span class="line">位置1: maxEndingHere = max(1, -2+1) = 1 (重新开始)</span><br><span class="line">       maxSoFar = 1</span><br><span class="line">       [1]</span><br><span class="line"></span><br><span class="line">位置2: maxEndingHere = max(-3, 1-3) = -2 (继续)</span><br><span class="line">       maxSoFar = 1</span><br><span class="line">       [1, -3]</span><br><span class="line"></span><br><span class="line">位置3: maxEndingHere = max(4, -2+4) = 4 (重新开始)</span><br><span class="line">       maxSoFar = 4</span><br><span class="line">       [4]</span><br><span class="line"></span><br><span class="line">位置4: maxEndingHere = max(-1, 4-1) = 3 (继续)</span><br><span class="line">       maxSoFar = 4</span><br><span class="line">       [4, -1]</span><br><span class="line"></span><br><span class="line">位置5: maxEndingHere = max(2, 3+2) = 5 (继续)</span><br><span class="line">       maxSoFar = 5</span><br><span class="line">       [4, -1, 2]</span><br><span class="line"></span><br><span class="line">位置6: maxEndingHere = max(1, 5+1) = 6 (继续)</span><br><span class="line">       maxSoFar = 6</span><br><span class="line">       [4, -1, 2, 1] ← 答案！</span><br><span class="line"></span><br><span class="line">位置7: maxEndingHere = max(-5, 6-5) = 1 (继续)</span><br><span class="line">       maxSoFar = 6</span><br><span class="line"></span><br><span class="line">位置8: maxEndingHere = max(4, 1+4) = 5 (继续)</span><br><span class="line">       maxSoFar = 6</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph LR    A[-2] --&gt;|重新开始| B[1]    B --&gt;|继续| C[-3]    C --&gt;|重新开始| D[4]    D --&gt;|继续| E[-1]    E --&gt;|继续| F[2]    F --&gt;|继续| G[1]    G --&gt;|继续| H[-5]    H --&gt;|继续| I[4]        style D fill:#FFE4B5    style E fill:#FFE4B5    style F fill:#FFE4B5    style G fill:#90EE90</code></pre><h3 id="wei-shi-yao-zhe-yang-zuo-shi-dui-de" tabindex="-1" id="为什么这样做是对的？">为什么这样做是对的？</h3><p><strong>关键洞察</strong>：</p><p>如果 <code>maxEndingHere[i-1] &lt; 0</code>，那么加上它只会让结果变小，不如重新开始！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果前面的和是负数：</span><br><span class="line">  -5 + 3 = -2  (不如直接从3开始)</span><br><span class="line">  </span><br><span class="line">如果前面的和是正数：</span><br><span class="line">  5 + 3 = 8   (应该继续)</span><br></pre></td></tr></table></figure><hr><h2 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h2><h3 id="ji-chu-ban-ben" tabindex="-1" id="基础版本">基础版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> maxEndingHere = nums[<span class="number">0</span>];  <span class="comment">// 以当前位置结尾的最大和</span></span><br><span class="line">    <span class="type">int</span> maxSoFar = nums[<span class="number">0</span>];       <span class="comment">// 全局最大和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 核心决策</span></span><br><span class="line">        maxEndingHere = <span class="built_in">max</span>(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">        maxSoFar = <span class="built_in">max</span>(maxSoFar, maxEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dong-tai-gui-hua-shi-jiao" tabindex="-1" id="动态规划视角">动态规划视角</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的DP写法（更占空间）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;  <span class="comment">// dp[i] = 以i结尾的最大子数组和</span></span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxSum = dp[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(nums[i], dp[i<span class="number">-1</span>] + nums[i]);</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察</strong>：<code>dp[i]</code>只依赖于<code>dp[i-1]</code>，所以可以用一个变量代替数组！</p><h3 id="fan-hui-zi-shu-zu-wei-zhi" tabindex="-1" id="返回子数组位置">返回子数组位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SubarrayInfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SubarrayInfo <span class="title">maxSubArrayWithIndices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tempStart = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxEndingHere + nums[i]) &#123;</span><br><span class="line">            maxEndingHere = nums[i];</span><br><span class="line">            tempStart = i;  <span class="comment">// 重新开始，更新起始位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxEndingHere = maxEndingHere + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxEndingHere &gt; maxSoFar) &#123;</span><br><span class="line">            maxSoFar = maxEndingHere;</span><br><span class="line">            start = tempStart;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;maxSoFar, start, end&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="zheng-que-xing-zheng-ming" tabindex="-1" id="正确性证明">正确性证明</h2><h3 id="gui-na-fa-zheng-ming" tabindex="-1" id="归纳法证明">归纳法证明</h3><p><strong>基础情况</strong>：一个元素时，算法显然正确。</p><p><strong>归纳假设</strong>：假设对于前<code>i-1</code>个元素，算法正确。</p><p><strong>归纳步骤</strong>：对于第<code>i</code>个元素：</p><ol><li><p>如果<code>maxEndingHere[i-1] + nums[i] &gt; nums[i]</code></p><ul><li>说明前面的子数组对当前有贡献</li><li>应该继续</li></ul></li><li><p>如果<code>maxEndingHere[i-1] + nums[i] &lt;= nums[i]</code></p><ul><li>说明前面的子数组拖后腿</li><li>应该重新开始</li></ul></li></ol><p>因此，算法在每一步都做出了最优决策。</p><h3 id="fan-li-fen-xi" tabindex="-1" id="反例分析">反例分析</h3><p><strong>错误想法</strong>：遇到负数就重新开始？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组：[5, -2, 3]</span><br><span class="line">错误：遇到-2就重新开始 → 最大和 = 5</span><br><span class="line">正确：5 + (-2) + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>Kadane的优势</strong>：它考虑的是&quot;累积贡献&quot;，而不是单个元素的正负。</p><hr><h2 id="bian-chong-wen-ti" tabindex="-1" id="变种问题">变种问题</h2><h3 id="1-huan-xing-shu-zu-de-zui-da-zi-shu-zu-he" tabindex="-1" id="1-环形数组的最大子数组和">1. 环形数组的最大子数组和</h3><blockquote><p><strong>LeetCode 918</strong>: 环形子数组的最大和</p></blockquote><p><strong>思路</strong>：环形数组的最大子数组只有两种情况：</p><ol><li><strong>不跨越边界</strong>：正常Kadane算法</li><li><strong>跨越边界</strong>：总和 - 最小子数组和</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN, minSum = INT_MAX;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = <span class="number">0</span>, minEndingHere = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最大子数组</span></span><br><span class="line">        maxEndingHere = <span class="built_in">max</span>(num, maxEndingHere + num);</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, maxEndingHere);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最小子数组</span></span><br><span class="line">        minEndingHere = <span class="built_in">min</span>(num, minEndingHere + num);</span><br><span class="line">        minSum = <span class="built_in">min</span>(minSum, minEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特殊情况：所有元素都是负数</span></span><br><span class="line">    <span class="keyword">if</span> (maxSum &lt; <span class="number">0</span>) <span class="keyword">return</span> maxSum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxSum, totalSum - minSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可视化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组：[5, -3, 5]</span><br><span class="line"></span><br><span class="line">情况1 (不跨越)：[5, -3, 5] → 和 = 7</span><br><span class="line">情况2 (跨越)：[5] + [5] → 和 = 10 ✓</span><br><span class="line"></span><br><span class="line">计算：总和 - 最小子数组和 = 7 - (-3) = 10</span><br></pre></td></tr></table></figure><h3 id="2-cheng-ji-zui-da-zi-shu-zu" tabindex="-1" id="2-乘积最大子数组">2. 乘积最大子数组</h3><blockquote><p><strong>LeetCode 152</strong>: 乘积最大子数组</p></blockquote><p><strong>关键</strong>：负数 × 负数 = 正数，需要同时维护最大值和最小值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> minEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="type">int</span> tempMax = maxEndingHere;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可能：当前元素、最大值×当前、最小值×当前</span></span><br><span class="line">        maxEndingHere = <span class="built_in">max</span>(&#123;num, maxEndingHere * num, minEndingHere * num&#125;);</span><br><span class="line">        minEndingHere = <span class="built_in">min</span>(&#123;num, tempMax * num, minEndingHere * num&#125;);</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">max</span>(result, maxEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组：[2, 3, -2, 4]</span><br><span class="line"></span><br><span class="line">i=0: max=2,  min=2,  result=2</span><br><span class="line">i=1: max=6,  min=3,  result=6   (2×3)</span><br><span class="line">i=2: max=-2, min=-12, result=6  (6×-2 vs 3×-2)</span><br><span class="line">i=3: max=4,  min=-48, result=6  (-12×-2 才是最大的中间结果，但4最后才来)</span><br><span class="line"></span><br><span class="line">答案[2,3]的乘积=6</span><br></pre></td></tr></table></figure><h3 id="3-gu-piao-mai-mai-zui-jia-shi-ji" tabindex="-1" id="3-股票买卖最佳时机">3. 股票买卖最佳时机</h3><blockquote><p><strong>LeetCode 121</strong>: 买卖股票的最佳时机</p></blockquote><p><strong>转换</strong>：最大利润 = 最大子数组和（差分数组）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        maxProfit = <span class="built_in">max</span>(maxProfit, prices[i] - minPrice);</span><br><span class="line">        minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Kadane视角</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将价格数组转换为差分数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; diff;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    diff.<span class="built_in">push_back</span>(prices[i] - prices[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后在diff上运行Kadane算法</span></span><br></pre></td></tr></table></figure><hr><h2 id="xing-neng-dui-bi" tabindex="-1" id="性能对比">性能对比</h2><h3 id="shi-jian-fu-za-du-dui-bi" tabindex="-1" id="时间复杂度对比">时间复杂度对比</h3><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>暴力枚举</td><td>O(n³)</td><td>O(1)</td></tr><tr><td>优化暴力</td><td>O(n²)</td><td>O(1)</td></tr><tr><td>分治算法</td><td>O(n log n)</td><td>O(log n)</td></tr><tr><td><strong>Kadane算法</strong></td><td><strong>O(n)</strong></td><td><strong>O(1)</strong></td></tr></tbody></table><h3 id="wei-shi-yao-kadane-zui-you" tabindex="-1" id="为什么Kadane最优？">为什么Kadane最优？</h3><ol><li><strong>单次遍历</strong>：只需要扫描数组一次</li><li><strong>常数空间</strong>：只用两个变量</li><li><strong>无递归</strong>：没有函数调用开销</li><li><strong>缓存友好</strong>：顺序访问，利用CPU缓存</li></ol><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>Kadane算法是最大子数组和的最优解</strong></li><li><strong>时间O(n)，空间O(1)</strong></li><li><strong>动态规划的空间优化经典例子</strong></li><li><strong>关键在于理解&quot;何时重新开始&quot;</strong></li></ol><h3 id="suan-fa-mo-ban" tabindex="-1" id="算法模板">算法模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kadane</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        maxEndingHere = <span class="built_in">max</span>(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">        maxSoFar = <span class="built_in">max</span>(maxSoFar, maxEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ji-yi-kou-jue" tabindex="-1" id="记忆口诀">记忆口诀</h3><blockquote><p><strong>加入或重启，两者取大；<br>全局最优，随时更新。</strong></p></blockquote><h3 id="kuo-zhan-xue-xi" tabindex="-1" id="扩展学习">扩展学习</h3><p>相关算法：</p><ul><li><strong>最大子矩阵和</strong>：二维Kadane</li><li><strong>最长递增子序列</strong>：类似的DP思想</li><li><strong>股票买卖系列</strong>：状态机DP</li></ul><hr><p><strong>推荐练习</strong>：</p><ul><li><a href="https://leetcode.com/problems/maximum-subarray/">LeetCode 53 - 最大子数组和</a></li><li><a href="https://leetcode.com/problems/maximum-product-subarray/">LeetCode 152 - 乘积最大子数组</a></li><li><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">LeetCode 918 - 环形子数组的最大和</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;yin-yan&quot; tabindex=&quot;-1&quot; id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;Kadane算法是解决&lt;strong&gt;最大子数组和问题&lt;/strong&gt;的经典动态规划算法，由计算机科学家Jay</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="https://smarter.xin/tags/dynamic-programming/"/>
    
    <category term="Kadane" scheme="https://smarter.xin/tags/Kadane/"/>
    
    <category term="最大子数组和" scheme="https://smarter.xin/tags/max-subarray-sum/"/>
    
    <category term="贪心" scheme="https://smarter.xin/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>AI Infra学习之旅-PagedAttention详解</title>
    <link href="https://smarter.xin/posts/fbab2bc4/"/>
    <id>https://smarter.xin/posts/fbab2bc4/</id>
    <published>2026-01-03T13:37:21.000Z</published>
    <updated>2026-01-06T13:16:51.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="paged-attention-da-yu-yan-mo-xing-tui-li-de-nei-cun-guan-li-ge-ming" tabindex="-1">PagedAttention：大语言模型推理的内存管理革命</h1><blockquote><p>借鉴操作系统虚拟内存思想，实现LLM推理的高效KV Cache管理</p></blockquote><hr><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>在大语言模型(LLM)快速发展的今天，如何高效地进行模型推理成为了一个关键问题。随着模型规模的不断扩大，内存管理成为制约推理性能的重要瓶颈。本文将深入介绍PagedAttention技术——一种受操作系统虚拟内存管理启发的创新性内存管理方法，它极大地提升了LLM推理的效率和throughput。</p><h2 id="yi-bei-jing-llm-tui-li-zhong-de-nei-cun-tiao-zhan" tabindex="-1" id="一、背景：LLM推理中的内存挑战">一、背景：LLM推理中的内存挑战</h2><h3 id="1-1-kv-cache-de-zuo-yong" tabindex="-1" id="1-1-KV-Cache的作用">1.1 KV Cache的作用</h3><p>在Transformer架构的自回归生成过程中，每个token的生成都需要用到之前所有token的Key和Value向量。为了避免重复计算，这些K、V向量会被缓存起来，这就是<strong>KV Cache</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入序列: &quot;今天天气&quot;</span><br><span class="line">生成过程:</span><br><span class="line">- 生成&quot;很&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;的KV</span><br><span class="line">- 生成&quot;好&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;、&quot;很&quot;的KV</span><br><span class="line">- ...依次类推</span><br></pre></td></tr></table></figure><h3 id="1-2-chuan-tong-fang-fa-de-wen-ti" tabindex="-1" id="1-2-传统方法的问题">1.2 传统方法的问题</h3><p>传统的KV Cache管理方法存在严重的内存浪费问题：</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-f70408.png" alt="image-20260103215943575"></p><ol><li><p><strong>外部碎片化（External Fragmentation）</strong></p><ul><li>必须为每个请求预先分配一个连续的内存块</li><li>由于无法预知生成序列的最终长度，通常按最大序列长度分配</li><li>实际使用长度远小于分配长度时，造成大量浪费</li></ul></li><li><p><strong>内部碎片化（Internal Fragmentation）</strong></p><ul><li>批处理中不同请求的序列长度不同</li><li>必须按批次中最长序列分配内存</li><li>短序列的剩余空间无法被其他请求使用</li></ul></li></ol><p><strong>研究表明，传统方法的内存浪费率高达60%-80%</strong>，这严重限制了批处理大小和系统吞吐量。</p><pre><code class="highlight mermaid">graph LR    subgraph 传统方法        A[请求1] --&gt; B[预分配大块连续内存]        A2[请求2] --&gt; B2[预分配大块连续内存]        B --&gt; C[大量浪费:60-80%]        B2 --&gt; C    end        subgraph PagedAttention        D[请求1] --&gt; E[按需分配小块]        D2[请求2] --&gt; E2[按需分配小块]        E --&gt; F[极少浪费:&lt;4%]        E2 --&gt; F    end        style C fill:#FFB6C1    style F fill:#90EE90</code></pre><hr><h2 id="er-paged-attention-he-xin-yuan-li" tabindex="-1" id="二、PagedAttention核心原理">二、PagedAttention核心原理</h2><h3 id="2-1-cao-zuo-xi-tong-de-qi-fa" tabindex="-1" id="2-1-操作系统的启发">2.1 操作系统的启发</h3><p>PagedAttention的设计灵感来源于操作系统中的<strong>虚拟内存分页机制</strong>：</p><table><thead><tr><th>操作系统虚拟内存</th><th>PagedAttention</th></tr></thead><tbody><tr><td>虚拟内存页</td><td>逻辑KV块</td></tr><tr><td>物理内存页</td><td>物理KV块</td></tr><tr><td>页表</td><td>块表(Block Table)</td></tr><tr><td>按需分页</td><td>动态块分配</td></tr><tr><td>写时复制</td><td>KV块共享</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-362413.png" alt="image-20260103215734471"></p><h3 id="2-2-he-xin-she-ji" tabindex="-1" id="2-2-核心设计">2.2 核心设计</h3><h4 id="2-2-1-kuai-zhuang-cun-chu" tabindex="-1" id="2-2-1-块状存储">2.2.1 块状存储</h4><p>PagedAttention将KV Cache划分为固定大小的<strong>块(Block)</strong>：</p><ul><li>每个块存储固定数量token的KV向量（通常16-128个token）</li><li>块可以在物理内存中<strong>非连续</strong>存储</li><li>每个序列的KV Cache由多个块组成</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑序列: [Token1, Token2, ..., Token100]</span><br><span class="line">         ↓</span><br><span class="line">物理存储: [Block0: Token1-16] → 物理地址 0x1000</span><br><span class="line">         [Block1: Token17-32] → 物理地址 0x3000</span><br><span class="line">         [Block2: Token33-48] → 物理地址 0x2000</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-a41fe2.png" alt="image-20260103215837127"></p><h4 id="2-2-2-kuai-biao-ying-she" tabindex="-1" id="2-2-2-块表映射">2.2.2 块表映射</h4><p>每个序列维护一个<strong>块表(Block Table)</strong>，记录逻辑块到物理块的映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.logical_to_physical = &#123;&#125;  <span class="comment"># 逻辑块号 -&gt; 物理块地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_physical_block</span>(<span class="params">self, logical_block_id</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.logical_to_physical[logical_block_id]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-366e1f.png" alt="image-20260103215612504"></p><h4 id="2-2-3-dong-tai-fen-pei" tabindex="-1" id="2-2-3-动态分配">2.2.3 动态分配</h4><ul><li><strong>按需分配</strong>：只在需要时分配新块</li><li><strong>精细粒度</strong>：以块为单位分配，而非整个序列</li><li><strong>即时回收</strong>：序列完成后立即释放所有块</li></ul><h3 id="2-3-attention-ji-suan-de-gua-pei" tabindex="-1" id="2-3-Attention计算的适配">2.3 Attention计算的适配</h3><p>在PagedAttention中，Attention计算需要根据块表来访问KV Cache：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统Attention（伪代码）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traditional_attention</span>(<span class="params">Q, K_cache, V_cache</span>):</span><br><span class="line">    scores = Q @ K_cache.T  <span class="comment"># 直接访问连续内存</span></span><br><span class="line">    attention_weights = softmax(scores)</span><br><span class="line">    output = attention_weights @ V_cache</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># PagedAttention（伪代码）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paged_attention</span>(<span class="params">Q, block_table, physical_blocks</span>):</span><br><span class="line">    output = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> logical_block_id <span class="keyword">in</span> block_table:</span><br><span class="line">        <span class="comment"># 通过块表查找物理块</span></span><br><span class="line">        physical_block = physical_blocks[block_table[logical_block_id]]</span><br><span class="line">        K_block, V_block = physical_block</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在每个块上计算Attention</span></span><br><span class="line">        scores = Q @ K_block.T</span><br><span class="line">        attention_weights = softmax(scores)</span><br><span class="line">        output += attention_weights @ V_block</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h2 id="san-paged-attention-de-guan-jian-you-shi" tabindex="-1" id="三、PagedAttention的关键优势">三、PagedAttention的关键优势</h2><h3 id="3-1-jin-hu-ling-de-nei-cun-lang-fei" tabindex="-1" id="3-1-近乎零的内存浪费">3.1 近乎零的内存浪费</h3><p>通过块状动态分配，PagedAttention实现了：</p><ul><li><strong>外部碎片 ≈ 0</strong>：无需预分配最大长度</li><li><strong>内部碎片 &lt; 4%</strong>：只有最后一个未满的块存在浪费</li></ul><p>这将内存利用率从传统的20-40%提升到<strong>96%以上</strong>！</p><h3 id="3-2-gao-tun-tu-liang-ti-sheng" tabindex="-1" id="3-2-高吞吐量提升">3.2 高吞吐量提升</h3><p>更高的内存利用率意味着：</p><ul><li>可以容纳更大的批处理大小</li><li>GPU利用率显著提升</li><li>系统吞吐量提升<strong>2-24倍</strong></li></ul><table><thead><tr><th>对比系统</th><th>吞吐量提升</th></tr></thead><tbody><tr><td>HuggingFace Transformers</td><td>24x</td></tr><tr><td>FasterTransformer</td><td>3.5x</td></tr><tr><td>Orca</td><td>2-4x</td></tr></tbody></table><h3 id="3-3-gao-xiao-de-nei-cun-gong-xiang" tabindex="-1" id="3-3-高效的内存共享">3.3 高效的内存共享</h3><p>PagedAttention支持多种场景下的KV Cache共享：</p><h4 id="3-3-1-bing-xing-cai-yang-parallel-sampling" tabindex="-1" id="3-3-1-并行采样（Parallel-Sampling）">3.3.1 并行采样（Parallel Sampling）</h4><p>当需要为同一个prompt生成多个不同的响应时：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求: &quot;写一首关于春天的诗&quot;</span><br><span class="line">     ↓</span><br><span class="line">共享Prompt的KV Cache</span><br><span class="line">     ↓</span><br><span class="line">生成多个不同版本：版本1、版本2、版本3...</span><br></pre></td></tr></table></figure><p>通过**写时复制(Copy-on-Write)**机制，多个生成序列可以共享相同prompt的KV块。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-ff5a63.png" alt="image-20260103214737380"></p><h4 id="3-3-2-beam-search" tabindex="-1" id="3-3-2-Beam-Search">3.3.2 Beam Search</h4><p>在Beam Search中，多个候选序列共享大部分前缀KV Cache：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Beam 1: &quot;春天来了&quot; → &quot;万物复苏&quot;</span><br><span class="line">Beam 2: &quot;春天来了&quot; → &quot;花开满园&quot;  ← 共享&quot;春天来了&quot;的KV</span><br><span class="line">Beam 3: &quot;春天来了&quot; → &quot;鸟语花香&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-850b23.png" alt="image-20260103214753767"></p><h4 id="3-3-3-gong-xiang-xi-tong-prompt" tabindex="-1" id="3-3-3-共享系统Prompt">3.3.3 共享系统Prompt</h4><p>多个用户请求可能共享相同的系统提示词：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System Prompt: &quot;你是一个helpful的AI助手...&quot;</span><br><span class="line">              ↓ (多个请求共享)</span><br><span class="line">User1: &quot;今天天气怎么样？&quot;</span><br><span class="line">User2: &quot;帮我写个代码&quot;</span><br><span class="line">User3: &quot;翻译这段文字&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-PagedAttention%E8%A7%A3%E6%9E%90/2026-01-03-22-02-04-1e08fd.png" alt="image-20260103214827347"></p><h3 id="3-4-zhi-chi-chang-shang-xia-wen" tabindex="-1" id="3-4-支持长上下文">3.4 支持长上下文</h3><ul><li>无需预分配连续大内存块</li><li>可以处理远超单次分配限制的超长序列</li><li>动态扩展，按需增长</li></ul><h2 id="si-v-llm-paged-attention-de-gong-cheng-shi-xian" tabindex="-1" id="四、vLLM：PagedAttention的工程实现">四、vLLM：PagedAttention的工程实现</h2><h3 id="4-1-v-llm-jia-gou-gai-shu" tabindex="-1" id="4-1-vLLM架构概述">4.1 vLLM架构概述</h3><p>vLLM是首个基于PagedAttention的开源LLM推理引擎，实现了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│        Request Manager              │</span><br><span class="line">│   (调度、批处理、优先级管理)          │</span><br><span class="line">└──────────────┬──────────────────────┘</span><br><span class="line">               │</span><br><span class="line">┌──────────────▼──────────────────────┐</span><br><span class="line">│     KV Cache Manager                │</span><br><span class="line">│  - 块池管理                          │</span><br><span class="line">│  - 块表维护                          │</span><br><span class="line">│  - 自动前缀缓存(Automatic Prefix Cache)│</span><br><span class="line">└──────────────┬──────────────────────┘</span><br><span class="line">               │</span><br><span class="line">┌──────────────▼──────────────────────┐</span><br><span class="line">│    Model Executor                   │</span><br><span class="line">│  (PagedAttention Kernel)            │</span><br><span class="line">└─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="4-2-kv-cache-manager" tabindex="-1" id="4-2-KV-Cache-Manager">4.2 KV Cache Manager</h3><p>核心功能：</p><ol><li><strong>块池管理</strong>：维护可用物理块的池</li><li><strong>块分配</strong>：为新token分配块</li><li><strong>块回收</strong>：释放完成请求的块</li><li><strong>引用计数</strong>：支持块共享的引用计数机制</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vLLM块管理器简化示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, block_size, num_blocks</span>):</span><br><span class="line">        <span class="variable language_">self</span>.block_size = block_size</span><br><span class="line">        <span class="variable language_">self</span>.free_blocks = <span class="built_in">set</span>(<span class="built_in">range</span>(num_blocks))</span><br><span class="line">        <span class="variable language_">self</span>.ref_counts = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allocate_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.free_blocks:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 内存不足</span></span><br><span class="line">        block_id = <span class="variable language_">self</span>.free_blocks.pop()</span><br><span class="line">        <span class="variable language_">self</span>.ref_counts[block_id] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> block_id</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">share_block</span>(<span class="params">self, block_id</span>):</span><br><span class="line">        <span class="comment"># 写时复制：增加引用计数</span></span><br><span class="line">        <span class="variable language_">self</span>.ref_counts[block_id] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">free_block</span>(<span class="params">self, block_id</span>):</span><br><span class="line">        <span class="variable language_">self</span>.ref_counts[block_id] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.ref_counts[block_id] == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.free_blocks.add(block_id)</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.ref_counts[block_id]</span><br></pre></td></tr></table></figure><h3 id="4-3-zi-dong-qian-zhui-huan-cun" tabindex="-1" id="4-3-自动前缀缓存">4.3 自动前缀缓存</h3><p>vLLM实现了**自动前缀缓存(Automatic Prefix Caching)**功能：</p><ul><li>使用哈希表管理KV块</li><li>自动检测和复用相同的前缀</li><li>无需用户手动指定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动前缀缓存原理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.hash_table = &#123;&#125;  <span class="comment"># token_hash -&gt; block_id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lookup</span>(<span class="params">self, token_sequence</span>):</span><br><span class="line">        token_hash = <span class="built_in">hash</span>(<span class="built_in">tuple</span>(token_sequence))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.hash_table.get(token_hash)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, token_sequence, block_id</span>):</span><br><span class="line">        token_hash = <span class="built_in">hash</span>(<span class="built_in">tuple</span>(token_sequence))</span><br><span class="line">        <span class="variable language_">self</span>.hash_table[token_hash] = block_id</span><br></pre></td></tr></table></figure><h3 id="4-4-diao-du-ce-lue" tabindex="-1" id="4-4-调度策略">4.4 调度策略</h3><p>vLLM支持多种调度策略：</p><ul><li><strong>FCFS（First-Come-First-Serve）</strong>：先到先服务</li><li><strong>优先级调度</strong>：根据请求优先级</li><li><strong>抢占和交换</strong>：内存不足时可以将部分请求的KV Cache交换到CPU</li></ul><h2 id="wu-ji-zhu-xi-jie-yu-shi-xian-yao-dian" tabindex="-1" id="五、技术细节与实现要点">五、技术细节与实现要点</h2><h3 id="5-1-kuai-da-xiao-de-xuan-ze" tabindex="-1" id="5-1-块大小的选择">5.1 块大小的选择</h3><p>块大小的权衡：</p><ul><li><p><strong>较小块（如16 tokens）</strong>：</p><ul><li>✅ 内存碎片更少</li><li>❌ 块表开销大，查找次数多</li></ul></li><li><p><strong>较大块（如128 tokens）</strong>：</p><ul><li>✅ 块表开销小</li><li>❌ 最后一块可能浪费较多</li></ul></li></ul><p><strong>实践中通常选择16-64之间</strong></p><h3 id="5-2-cuda-kernel-you-hua" tabindex="-1" id="5-2-CUDA-Kernel优化">5.2 CUDA Kernel优化</h3><p>PagedAttention需要高效的CUDA kernel来处理非连续内存访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// PagedAttention CUDA Kernel简化示例</span><br><span class="line">__global__ void paged_attention_kernel(</span><br><span class="line">    const float* Q,          // Query</span><br><span class="line">    const float* K_blocks,   // 所有K块</span><br><span class="line">    const float* V_blocks,   // 所有V块</span><br><span class="line">    const int* block_table,  // 块表</span><br><span class="line">    float* output,</span><br><span class="line">    int num_blocks</span><br><span class="line">) &#123;</span><br><span class="line">    // 1. 遍历块表中的每个块</span><br><span class="line">    for (int i = 0; i &lt; num_blocks; i++) &#123;</span><br><span class="line">        int physical_block_id = block_table[i];</span><br><span class="line">        </span><br><span class="line">        // 2. 从物理块加载KV</span><br><span class="line">        const float* K_block = &amp;K_blocks[physical_block_id * BLOCK_SIZE];</span><br><span class="line">        const float* V_block = &amp;V_blocks[physical_block_id * BLOCK_SIZE];</span><br><span class="line">        </span><br><span class="line">        // 3. 计算attention score</span><br><span class="line">        float score = compute_attention(Q, K_block, V_block);</span><br><span class="line">        </span><br><span class="line">        // 4. 累加到输出</span><br><span class="line">        accumulate_output(output, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-nei-cun-yu-suan-yu-oom-chu-li" tabindex="-1" id="5-3-内存预算与OOM处理">5.3 内存预算与OOM处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存管理策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">can_allocate</span>(<span class="params">self, num_blocks_needed</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.free_blocks) &gt;= num_blocks_needed</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evict_if_needed</span>(<span class="params">self, num_blocks_needed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;内存不足时的驱逐策略&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.can_allocate(num_blocks_needed):</span><br><span class="line">            <span class="comment"># 将低优先级请求的KV Cache迁移到CPU</span></span><br><span class="line">            <span class="variable language_">self</span>.swap_to_cpu(num_blocks_needed)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap_to_cpu</span>(<span class="params">self, num_blocks</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将GPU块交换到CPU内存&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 选择要交换的请求（如最久未使用）</span></span><br><span class="line">        victims = <span class="variable language_">self</span>.select_victims(num_blocks)</span><br><span class="line">        <span class="keyword">for</span> victim <span class="keyword">in</span> victims:</span><br><span class="line">            <span class="variable language_">self</span>.move_blocks_to_cpu(victim)</span><br><span class="line">            <span class="variable language_">self</span>.free_blocks.extend(victim.blocks)</span><br></pre></td></tr></table></figure><h2 id="liu-yu-qi-ta-you-hua-ji-zhu-de-dui-bi" tabindex="-1" id="六、与其他优化技术的对比">六、与其他优化技术的对比</h2><h3 id="6-1-flash-attention" tabindex="-1" id="6-1-Flash-Attention">6.1 Flash Attention</h3><table><thead><tr><th>特性</th><th>Flash Attention</th><th>PagedAttention</th></tr></thead><tbody><tr><td>优化目标</td><td>计算效率（减少HBM访问）</td><td>内存管理效率</td></tr><tr><td>主要技术</td><td>Tiling + 重计算</td><td>块状内存分配</td></tr><tr><td>加速场景</td><td>训练 &amp; 推理</td><td>主要用于推理</td></tr><tr><td>是否兼容</td><td>✅ 可结合使用</td><td>✅ 可结合使用</td></tr></tbody></table><p><strong>两者可以结合</strong>：vLLM可以同时使用Flash Attention和PagedAttention！</p><h3 id="6-2-liang-hua-ji-zhu-int-8-int-4" tabindex="-1" id="6-2-量化技术（INT8-INT4）">6.2 量化技术（INT8/INT4）</h3><table><thead><tr><th>特性</th><th>量化</th><th>PagedAttention</th></tr></thead><tbody><tr><td>优化维度</td><td>减少每个参数的存储位数</td><td>优化内存分配方式</td></tr><tr><td>内存节省</td><td>模型权重和激活</td><td>KV Cache</td></tr><tr><td>是否互补</td><td>✅ 高度互补</td><td>✅ 高度互补</td></tr></tbody></table><h3 id="6-3-tui-ce-jie-ma-speculative-decoding" tabindex="-1" id="6-3-推测解码（Speculative-Decoding）">6.3 推测解码（Speculative Decoding）</h3><p>PagedAttention与推测解码也可结合：</p><ul><li>推测解码：通过小模型加速生成</li><li>PagedAttention：提升内存利用率和吞吐量</li></ul><h2 id="qi-zong-jie" tabindex="-1" id="七、总结">七、总结</h2><p>PagedAttention是大语言模型推理领域的一项重要创新：</p><h3 id="he-xin-gong-xian" tabindex="-1" id="核心贡献">核心贡献</h3><ol><li>✅ <strong>近乎零浪费的内存管理</strong>：将浪费率从60-80%降低到&lt;4%</li><li>✅ <strong>显著的吞吐量提升</strong>：2-24倍的性能提升</li><li>✅ <strong>灵活的KV共享机制</strong>：支持并行采样、Beam Search等复杂场景</li><li>✅ <strong>工程化落地</strong>：vLLM已成为业界主流推理引擎</li></ol><h2 id="can-kao-zi-liao" tabindex="-1" id="参考资料">参考资料</h2><ol><li>原始论文：<em>“Efficient Memory Management for Large Language Model Serving with PagedAttention”</em> (2023)</li><li>vLLM GitHub: <a href="https://github.com/vllm-project/vllm">https://github.com/vllm-project/vllm</a></li><li>vLLM官方文档: <a href="https://docs.vllm.ai/">https://docs.vllm.ai/</a></li><li>PagedAttention博客系列（多个技术博客）</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;paged-attention-da-yu-yan-mo-xing-tui-li-de-nei-cun-guan-li-ge-ming&quot;</summary>
        
      
    
    
    
    <category term="AI Infra" scheme="https://smarter.xin/categories/ai-infra/"/>
    
    
    <category term="vLLM" scheme="https://smarter.xin/tags/vLLM/"/>
    
    <category term="LLM" scheme="https://smarter.xin/tags/LLM/"/>
    
    <category term="PagedAttention" scheme="https://smarter.xin/tags/PagedAttention/"/>
    
    <category term="KV Cache" scheme="https://smarter.xin/tags/KV-Cache/"/>
    
    <category term="AI系统" scheme="https://smarter.xin/tags/ai-system/"/>
    
    <category term="AI Infrastructure" scheme="https://smarter.xin/tags/AI-Infrastructure/"/>
    
    <category term="内存管理" scheme="https://smarter.xin/tags/memory-management/"/>
    
  </entry>
  
  <entry>
    <title>常见数据结构-优先队列</title>
    <link href="https://smarter.xin/posts/5beb8088/"/>
    <id>https://smarter.xin/posts/5beb8088/</id>
    <published>2026-01-03T08:25:11.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="you-xian-dui-lie-xiang-jie-shu-ju-jie-gou-zhong-de-vip-tong-dao" tabindex="-1">优先队列详解：数据结构中的「VIP通道」</h1><blockquote><p>掌握优先队列，轻松解决 Top K 和动态数据流问题</p></blockquote><hr><h2 id="shi-yao-shi-you-xian-dui-lie" tabindex="-1" id="什么是优先队列">什么是优先队列</h2><p><strong>优先队列</strong>（Priority Queue）是一种特殊的队列，其中每个元素都有一个「优先级」，出队时总是优先级最高的元素先出队。</p><blockquote><p><strong>核心特点</strong>：不是先进先出（FIFO），而是按优先级出队</p></blockquote><h3 id="xing-xiang-li-jie" tabindex="-1" id="形象理解">形象理解</h3><p>想象你在机场登机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通队列：先到先登机</span><br><span class="line">优先队列：VIP/头等舱先登机，然后才是经济舱</span><br></pre></td></tr></table></figure><h3 id="di-ceng-shi-xian-dui-heap" tabindex="-1" id="底层实现：堆（Heap）">底层实现：堆（Heap）</h3><p>优先队列通常用<strong>堆</strong>来实现：</p><pre><code class="highlight mermaid">graph TD    subgraph 最大堆        A[9] --&gt; B[7]        A --&gt; C[8]        B --&gt; D[3]        B --&gt; E[5]        C --&gt; F[6]        C --&gt; G[2]    end        style A fill:#FF6B6B</code></pre><table><thead><tr><th>操作</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>插入</td><td>O(log n)</td><td>上浮调整</td></tr><tr><td>取出堆顶</td><td>O(log n)</td><td>下沉调整</td></tr><tr><td>查看堆顶</td><td>O(1)</td><td>不需要调整</td></tr><tr><td>建堆</td><td>O(n)</td><td>从下往上调整</td></tr></tbody></table><hr><h2 id="c-zhong-de-you-xian-dui-lie" tabindex="-1" id="C-中的优先队列">C++ 中的优先队列</h2><h3 id="ji-ben-yu-fa" tabindex="-1" id="基本语法">基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆（默认）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br></pre></td></tr></table></figure><h3 id="chang-yong-cao-zuo" tabindex="-1" id="常用操作">常用操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">5</span>);     <span class="comment">// 插入元素</span></span><br><span class="line">pq.<span class="built_in">top</span>();       <span class="comment">// 查看堆顶（不删除）</span></span><br><span class="line">pq.<span class="built_in">pop</span>();       <span class="comment">// 删除堆顶</span></span><br><span class="line">pq.<span class="built_in">empty</span>();     <span class="comment">// 是否为空</span></span><br><span class="line">pq.<span class="built_in">size</span>();      <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure><h3 id="zi-ding-yi-bi-jiao-qi" tabindex="-1" id="自定义比较器">自定义比较器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用 lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;;  <span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：存储 pair</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 的最小堆</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：自定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;  <span class="comment">// 最小堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：C++ 优先队列的比较器与 sort 相反！<code>return a &gt; b</code> 表示最小堆</p></blockquote><hr><h2 id="dian-xing-ying-yong-chang-jing" tabindex="-1" id="典型应用场景">典型应用场景</h2><pre><code class="highlight mermaid">graph LR    A[优先队列] --&gt; B[Top K 问题]    A --&gt; C[合并 K 个有序结构]    A --&gt; D[数据流统计]    A --&gt; E[贪心算法]    A --&gt; F[堆排序]        B --&gt; B1[第K大元素]    B --&gt; B2[前K个高频元素]        C --&gt; C1[合并K个链表]    C --&gt; C2[合并K个数组]        D --&gt; D1[数据流中位数]    D --&gt; D2[滑动窗口最大值]        style A fill:#FFE4B5    style B fill:#87CEEB    style C fill:#90EE90    style D fill:#DDA0DD</code></pre><hr><h2 id="jing-dian-wen-ti-xiang-jie" tabindex="-1" id="经典问题详解">经典问题详解</h2><h3 id="1-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su" tabindex="-1" id="1-数组中的第K个最大元素">1. 数组中的第K个最大元素</h3><blockquote><p><strong>LeetCode 215</strong>: 在未排序的数组中找到第 k 个最大的元素</p></blockquote><h4 id="wen-ti-fen-xi" tabindex="-1" id="问题分析">问题分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">排序后：[1, 2, 3, 4, 5, 6]</span><br><span class="line">第2大：5</span><br></pre></td></tr></table></figure><h4 id="jie-fa-xuan-ze" tabindex="-1" id="解法选择">解法选择</h4><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>排序</td><td>O(n log n)</td><td>O(1)</td><td>简单直接</td></tr><tr><td>最小堆</td><td>O(n log k)</td><td><strong>O(k)</strong></td><td><strong>k 远小于 n</strong></td></tr><tr><td>快速选择</td><td>O(n) 平均</td><td>O(1)</td><td>一次性查询</td></tr></tbody></table><h4 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="comment">// 保持堆大小为 k</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();  <span class="comment">// 移除最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();  <span class="comment">// 堆顶就是第 k 大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yuan-li-tu-jie" tabindex="-1" id="原理图解">原理图解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k = 2</span><br><span class="line">数组：[3, 2, 1, 5, 6, 4]</span><br><span class="line"></span><br><span class="line">step 1: push 3 → [3]</span><br><span class="line">step 2: push 2 → [2, 3]</span><br><span class="line">step 3: push 1 → [1, 2, 3] → pop → [2, 3]</span><br><span class="line">step 4: push 5 → [2, 3, 5] → pop → [3, 5]</span><br><span class="line">step 5: push 6 → [3, 5, 6] → pop → [5, 6]</span><br><span class="line">step 6: push 4 → [4, 5, 6] → pop → [5, 6]</span><br><span class="line"></span><br><span class="line">堆顶 = 5 = 第2大</span><br></pre></td></tr></table></figure><hr><h3 id="2-qian-k-ge-gao-pin-yuan-su" tabindex="-1" id="2-前K个高频元素">2. 前K个高频元素</h3><blockquote><p><strong>LeetCode 347</strong>: 给定一个非空的整数数组，返回其中出现频率前 k 高的元素</p></blockquote><h4 id="wen-ti-fen-xi-1" tabindex="-1" id="问题分析-2">问题分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure><h4 id="liang-bu-zou-ce-lue" tabindex="-1" id="两步走策略">两步走策略</h4><pre><code class="highlight mermaid">graph LR    A[统计频率] --&gt; B[维护 Top K]        A --&gt; A1[&quot;哈希表 O(n)&quot;]    B --&gt; B1[&quot;最小堆 O(n log k)&quot;]</code></pre><h4 id="dai-ma-shi-xian-1" tabindex="-1" id="代码实现-2">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step 1: 统计频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        freq[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2: 最小堆维护 Top K</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按频率，小的在堆顶</span></span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">minHeap</span>(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num, count] : freq) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(&#123;num, count&#125;);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();  <span class="comment">// 移除频率最低的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: 收集结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(minHeap.<span class="built_in">top</span>().first);</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-he-bing-k-ge-sheng-xu-lian-biao" tabindex="-1" id="3-合并K个升序链表">3. 合并K个升序链表</h3><blockquote><p><strong>LeetCode 23</strong>: 给你一个链表数组，每个链表都已经按升序排列，请将所有链表合并到一个升序链表中</p></blockquote><h4 id="wen-ti-fen-xi-2" tabindex="-1" id="问题分析-3">问题分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,4,5], [1,3,4], [2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><h4 id="jie-fa-dui-bi" tabindex="-1" id="解法对比">解法对比</h4><table><thead><tr><th>方法</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>逐一合并</td><td>O(kn)</td><td>简单但慢</td></tr><tr><td>分治合并</td><td>O(n log k)</td><td>类似归并排序</td></tr><tr><td><strong>优先队列</strong></td><td>O(n log k)</td><td>每次取最小</td></tr></tbody></table><h4 id="dai-ma-shi-xian-shu-zu-mo-ni" tabindex="-1" id="代码实现（数组模拟）">代码实现（数组模拟）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mergeKSortedArrays</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; arrays)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小堆：&#123;值, 数组索引, 元素索引&#125;</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(a) &gt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(b);</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">minHeap</span>(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化：加入每个数组的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrays.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arrays[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;arrays[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [val, arrIdx, elemIdx] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加入该数组的下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (elemIdx + <span class="number">1</span> &lt; arrays[arrIdx].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;arrays[arrIdx][elemIdx + <span class="number">1</span>], arrIdx, elemIdx + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="guo-cheng-tu-jie" tabindex="-1" id="过程图解">过程图解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arrays: [[1,4,5], [1,3,4], [2,6]]</span><br><span class="line"></span><br><span class="line">初始堆：[(1,0,0), (1,1,0), (2,2,0)]</span><br><span class="line">        堆顶 = 1</span><br><span class="line"></span><br><span class="line">Step 1: pop (1,0,0) → result=[1] → push (4,0,1)</span><br><span class="line">Step 2: pop (1,1,0) → result=[1,1] → push (3,1,1)</span><br><span class="line">Step 3: pop (2,2,0) → result=[1,1,2] → push (6,2,1)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">最终：[1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><hr><h3 id="4-shu-ju-liu-de-zhong-wei-shu" tabindex="-1" id="4-数据流的中位数">4. 数据流的中位数</h3><blockquote><p><strong>LeetCode 295</strong>: 设计一个支持以下两种操作的数据结构：添加数字、返回中位数</p></blockquote><h4 id="he-xin-si-lu-dui-ding-dui" tabindex="-1" id="核心思路：对顶堆">核心思路：对顶堆</h4><p>使用两个堆：</p><ul><li><strong>最大堆</strong>：存储较小的一半</li><li><strong>最小堆</strong>：存储较大的一半</li></ul><pre><code class="highlight mermaid">graph LR    subgraph 较小的一半        A[最大堆]    end        subgraph 较大的一半        B[最小堆]    end        A --&gt;|堆顶| C[中位数]    B --&gt;|堆顶| C        style A fill:#87CEEB    style B fill:#90EE90    style C fill:#FFE4B5</code></pre><h4 id="he-xin-yue-shu" tabindex="-1" id="核心约束">核心约束</h4><ol><li>最大堆的所有元素 ≤ 最小堆的所有元素</li><li>两堆大小差不超过 1</li></ol><h4 id="dai-ma-shi-xian-2" tabindex="-1" id="代码实现-3">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; maxHeap;  <span class="comment">// 较小的一半</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;  <span class="comment">// 较大的一半</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Step 1: 先加入最大堆</span></span><br><span class="line">        maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step 2: 最大堆的最大值移到最小堆</span></span><br><span class="line">        minHeap.<span class="built_in">push</span>(maxHeap.<span class="built_in">top</span>());</span><br><span class="line">        maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step 3: 平衡大小</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; maxHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(minHeap.<span class="built_in">top</span>());</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() &gt; minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (maxHeap.<span class="built_in">top</span>() + minHeap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="cha-ru-guo-cheng-yan-shi" tabindex="-1" id="插入过程演示">插入过程演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">添加 [1, 2, 3]</span><br><span class="line"></span><br><span class="line">add(1):</span><br><span class="line">  maxHeap.push(1) → maxHeap: [1]</span><br><span class="line">  move to minHeap → minHeap: [1]</span><br><span class="line">  balance → maxHeap: [1], minHeap: []</span><br><span class="line">  </span><br><span class="line">add(2):</span><br><span class="line">  maxHeap.push(2) → maxHeap: [2,1]</span><br><span class="line">  move to minHeap → maxHeap: [1], minHeap: [2]</span><br><span class="line">  (已平衡)</span><br><span class="line"></span><br><span class="line">add(3):</span><br><span class="line">  maxHeap.push(3) → maxHeap: [3,1]</span><br><span class="line">  move to minHeap → maxHeap: [1], minHeap: [2,3]</span><br><span class="line">  balance → maxHeap: [2,1], minHeap: [3]</span><br><span class="line">  </span><br><span class="line">中位数 = maxHeap.top() = 2</span><br></pre></td></tr></table></figure><hr><h3 id="5-zui-hou-yi-kuai-shi-tou-de-zhong-liang" tabindex="-1" id="5-最后一块石头的重量">5. 最后一块石头的重量</h3><blockquote><p><strong>LeetCode 1046</strong>: 每次选出最重的两块石头碰撞，返回最后剩下的石头重量</p></blockquote><h4 id="dai-ma-shi-xian-3" tabindex="-1" id="代码实现-4">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">maxHeap</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (maxHeap.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> stone1 = maxHeap.<span class="built_in">top</span>(); maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> stone2 = maxHeap.<span class="built_in">top</span>(); maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (stone1 != stone2) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(stone1 - stone2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxHeap.<span class="built_in">empty</span>() ? <span class="number">0</span> : maxHeap.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-k-ge-zui-jie-jin-yuan-dian-de-dian" tabindex="-1" id="6-K个最接近原点的点">6. K个最接近原点的点</h3><blockquote><p><strong>LeetCode 973</strong>: 找出 K 个距离原点最近的点</p></blockquote><h4 id="dai-ma-shi-xian-4" tabindex="-1" id="代码实现-5">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 最大堆：距离大的在堆顶</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">maxHeap</span>(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> dist = points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>];</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(&#123;dist, i&#125;);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();  <span class="comment">// 移除距离最大的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(points[maxHeap.<span class="built_in">top</span>().second]);</span><br><span class="line">        maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-dui-pai-xu" tabindex="-1" id="7-堆排序">7. 堆排序</h3><blockquote><p>利用堆的性质进行排序</p></blockquote><h4 id="suan-fa-bu-zou" tabindex="-1" id="算法步骤">算法步骤</h4><ol><li><strong>建堆</strong>：将数组构建成最大堆</li><li><strong>排序</strong>：依次将堆顶（最大值）与末尾交换，然后调整堆</li></ol><pre><code class="highlight mermaid">graph TD    subgraph 建堆        A[无序数组] --&gt; B[最大堆]    end        subgraph 排序        B --&gt; C[堆顶与末尾交换]        C --&gt; D[缩小堆范围]        D --&gt; E[调整堆]        E --&gt;|重复| C    end        E --&gt; F[有序数组]</code></pre><h4 id="dai-ma-shi-xian-5" tabindex="-1" id="代码实现-6">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建堆：从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);  <span class="comment">// 堆顶与末尾交换</span></span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, <span class="number">0</span>);      <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h4><ul><li><strong>时间</strong>：O(n log n)</li><li><strong>空间</strong>：O(1) 原地排序</li><li><strong>稳定性</strong>：不稳定</li></ul><hr><h2 id="top-k-wen-ti-zong-jie" tabindex="-1" id="Top-K-问题总结">Top K 问题总结</h2><h3 id="xuan-ze-he-gua-de-dui" tabindex="-1" id="选择合适的堆">选择合适的堆</h3><table><thead><tr><th>问题</th><th>堆类型</th><th>原因</th></tr></thead><tbody><tr><td>第 K 大元素</td><td><strong>最小堆</strong></td><td>堆顶是第 K 大</td></tr><tr><td>第 K 小元素</td><td>最大堆</td><td>堆顶是第 K 小</td></tr><tr><td>前 K 大元素</td><td><strong>最小堆</strong></td><td>淘汰堆顶（最小的）</td></tr><tr><td>前 K 小元素</td><td>最大堆</td><td>淘汰堆顶（最大的）</td></tr></tbody></table><h3 id="kou-jue" tabindex="-1" id="口诀">口诀</h3><blockquote><p><strong>求大用小，求小用大</strong></p></blockquote><ul><li>求最大的 K 个 → 用最小堆</li><li>求最小的 K 个 → 用最大堆</li></ul><hr><h2 id="you-xian-dui-lie-vs-qi-ta-shu-ju-jie-gou" tabindex="-1" id="优先队列-vs-其他数据结构">优先队列 vs 其他数据结构</h2><table><thead><tr><th>数据结构</th><th>插入</th><th>删除堆顶</th><th>查找最值</th><th>任意查找</th></tr></thead><tbody><tr><td>无序数组</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>有序数组</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(log n)</td></tr><tr><td><strong>优先队列</strong></td><td>O(log n)</td><td>O(log n)</td><td><strong>O(1)</strong></td><td>❌</td></tr><tr><td>平衡树</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td></tr></tbody></table><hr><h2 id="si-wei-dao-tu" tabindex="-1" id="思维导图">思维导图</h2><pre><code class="highlight mermaid">graph TD    A[优先队列] --&gt; B[基础操作]    A --&gt; C[经典问题]    A --&gt; D[高级应用]        B --&gt; B1[push/pop/top]    B --&gt; B2[自定义比较器]    B --&gt; B3[最大堆/最小堆]        C --&gt; C1[Top K 问题]    C --&gt; C2[合并 K 个链表]    C --&gt; C3[数据流中位数]        D --&gt; D1[任务调度]    D --&gt; D2[Dijkstra 最短路]    D --&gt; D3[Huffman 编码]        style A fill:#FFE4B5    style C1 fill:#87CEEB    style C2 fill:#90EE90    style C3 fill:#DDA0DD</code></pre><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>优先队列 = 堆</strong>：底层用堆实现，O(log n) 插入删除</li><li><strong>求大用小</strong>：需要最大的 K 个，用最小堆</li><li><strong>对顶堆</strong>：维护动态中位数的经典技巧</li><li><strong>堆排序</strong>：O(n log n)，原地排序</li></ol><h3 id="chang-jian-mo-shi" tabindex="-1" id="常见模式">常见模式</h3><table><thead><tr><th>模式</th><th>典型问题</th><th>关键点</th></tr></thead><tbody><tr><td>固定大小堆</td><td>第 K 大</td><td>堆大小保持 K</td></tr><tr><td>对顶堆</td><td>数据流中位数</td><td>两个堆，一大一小</td></tr><tr><td>多路归并</td><td>合并 K 个链表</td><td>每次取最小的那条</td></tr><tr><td>贪心 + 堆</td><td>任务调度</td><td>优先处理某种特性的任务</td></tr></tbody></table><h3 id="dai-ma-mo-ban" tabindex="-1" id="代码模板">代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top K 问题模板</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minHeap.top() 就是第 K 大</span></span><br></pre></td></tr></table></figure><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://leetcode.com/tag/heap-priority-queue/">LeetCode 优先队列专题</a></li><li><a href="https://book.douban.com/subject/20432061/">《算法导论》第6章：堆排序</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;you-xian-dui-lie-xiang-jie-shu-ju-jie-gou-zhong-de-vip-tong-dao&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://smarter.xin/categories/data-structure/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="优先队列" scheme="https://smarter.xin/tags/priority-queue/"/>
    
    <category term="堆" scheme="https://smarter.xin/tags/%E5%A0%86/"/>
    
    <category term="数据结构" scheme="https://smarter.xin/tags/data-structure/"/>
    
    <category term="算法设计" scheme="https://smarter.xin/tags/algorithm-design/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-分治</title>
    <link href="https://smarter.xin/posts/f7223eb4/"/>
    <id>https://smarter.xin/posts/f7223eb4/</id>
    <published>2026-01-03T05:59:15.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fen-zhi-suan-fa-xiang-jie-hua-fan-wei-jian-de-xing-wei-yi-zhu" tabindex="-1">分治算法详解：化繁为简的行为艺术</h1><blockquote><p>掌握分治思想，轻松解决复杂问题</p></blockquote><hr><h2 id="shi-yao-shi-fen-zhi-suan-fa" tabindex="-1" id="什么是分治算法">什么是分治算法</h2><p><strong>分治</strong>（Divide and Conquer）是一种重要的算法设计思想，其核心是：</p><blockquote><p><strong>将一个复杂的问题分解成若干个规模较小但结构相似的子问题，递归地解决这些子问题，然后将子问题的解合并得到原问题的解。</strong></p></blockquote><h3 id="xing-xiang-li-jie" tabindex="-1" id="形象理解">形象理解</h3><p>想象你需要统计一本厚书的总字数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：一页一页数（暴力）</span><br><span class="line">方法2：分治</span><br><span class="line">  ├── 把书分成两半</span><br><span class="line">  ├── 分别数每一半的字数（递归）</span><br><span class="line">  └── 两半字数相加（合并）</span><br></pre></td></tr></table></figure><h3 id="gua-yong-tiao-jian" tabindex="-1" id="适用条件">适用条件</h3><p>分治算法适用于具有以下特征的问题：</p><ol><li><strong>可分解性</strong>：问题可以分解成若干个规模较小的相同问题</li><li><strong>子问题独立</strong>：子问题之间相互独立，不包含公共子问题</li><li><strong>可合并性</strong>：子问题的解可以合并为原问题的解</li><li><strong>存在基准情况</strong>：当问题规模足够小时，可以直接求解</li></ol><pre><code class="highlight mermaid">graph TD    A[原问题] --&gt; B[子问题1]    A --&gt; C[子问题2]    A --&gt; D[子问题...]        B --&gt; E[解1]    C --&gt; F[解2]    D --&gt; G[解...]        E --&gt; H[合并]    F --&gt; H    G --&gt; H    H --&gt; I[最终解]        style A fill:#FFE4B5    style I fill:#90EE90</code></pre><hr><h2 id="fen-zhi-san-bu-qu" tabindex="-1" id="分治三步曲">分治三步曲</h2><h3 id="he-xin-kuang-jia" tabindex="-1" id="核心框架">核心框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">divideAndConquer</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基准情况：问题足够小，直接求解</span></span><br><span class="line">    <span class="keyword">if</span> (problem.size &lt;= threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">directSolve</span>(problem);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 分解：将问题分成子问题</span></span><br><span class="line">    subProblems = <span class="built_in">divide</span>(problem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 递归：解决每个子问题</span></span><br><span class="line">    <span class="keyword">for</span> (subProblem : subProblems) &#123;</span><br><span class="line">        subResults.<span class="built_in">push_back</span>(<span class="built_in">divideAndConquer</span>(subProblem));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 合并：将子问题的解合并</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">combine</span>(subResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="san-bu-xiang-jie" tabindex="-1" id="三步详解">三步详解</h3><table><thead><tr><th>步骤</th><th>名称</th><th>作用</th><th>关键点</th></tr></thead><tbody><tr><td>1</td><td><strong>Divide（分）</strong></td><td>将问题分解为子问题</td><td>如何划分？划分几份？</td></tr><tr><td>2</td><td><strong>Conquer（治）</strong></td><td>递归解决子问题</td><td>基准情况是什么？</td></tr><tr><td>3</td><td><strong>Combine（合）</strong></td><td>合并子问题的解</td><td>如何高效合并？</td></tr></tbody></table><h3 id="shi-jian-fu-za-du-tong-yong-gong-shi" tabindex="-1" id="时间复杂度通用公式">时间复杂度通用公式</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = aT(n/b) + f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>：子问题数量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>：子问题规模缩小的倍数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：分解和合并的代价</li></ul><hr><h2 id="jing-dian-wen-ti-xiang-jie" tabindex="-1" id="经典问题详解">经典问题详解</h2><h3 id="1-gui-bing-pai-xu" tabindex="-1" id="1-归并排序">1. 归并排序</h3><blockquote><p><strong>LeetCode 912</strong>: 排序数组</p></blockquote><h4 id="wen-ti-fen-xi" tabindex="-1" id="问题分析">问题分析</h4><p>将一个无序数组排序成有序数组。</p><h4 id="fen-zhi-si-lu" tabindex="-1" id="分治思路">分治思路</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原数组：[38, 27, 43, 3, 9, 82, 10]</span><br><span class="line">         </span><br><span class="line">      分解（Divide）</span><br><span class="line">         ↓</span><br><span class="line">[38, 27, 43, 3]    [9, 82, 10]</span><br><span class="line">      ↓                 ↓</span><br><span class="line">[38, 27] [43, 3]   [9, 82] [10]</span><br><span class="line">   ↓       ↓         ↓      ↓</span><br><span class="line">[38][27] [43][3]  [9][82]  [10]</span><br><span class="line">   ↓       ↓         ↓      ↓</span><br><span class="line">   解决（Conquer）- 单元素已有序</span><br><span class="line">         ↓</span><br><span class="line">      合并（Combine）</span><br><span class="line">         ↓</span><br><span class="line">[27, 38] [3, 43]  [9, 82]  [10]</span><br><span class="line">      ↓                ↓</span><br><span class="line">[3, 27, 38, 43]   [9, 10, 82]</span><br><span class="line">            ↓</span><br><span class="line">   [3, 9, 10, 27, 38, 43, 82]</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">mergeSortHelper</span>(nums, temp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;  <span class="comment">// 基准情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分解 + 递归</span></span><br><span class="line">    <span class="built_in">mergeSortHelper</span>(nums, temp, left, mid);</span><br><span class="line">    <span class="built_in">mergeSortHelper</span>(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, temp, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">        temp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">            nums[k++] = temp[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k++] = temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) nums[k++] = temp[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) nums[k++] = temp[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h4><ul><li><strong>时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2T(n/2) + O(n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 临时数组</li></ul><h4 id="wei-shi-yao-yong-gui-bing-pai-xu" tabindex="-1" id="为什么用归并排序？">为什么用归并排序？</h4><p>✅ <strong>稳定排序</strong>：相等元素的相对顺序不变<br>✅ <strong>时间稳定</strong>：最好、最坏、平均都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>✅ <strong>适合链表</strong>：不需要随机访问<br>✅ <strong>适合外排序</strong>：大文件排序</p><hr><h3 id="2-kuai-su-pai-xu" tabindex="-1" id="2-快速排序">2. 快速排序</h3><blockquote><p><strong>LeetCode 912</strong>: 排序数组（另一种解法）</p></blockquote><h4 id="fen-zhi-si-lu-1" tabindex="-1" id="分治思路-2">分治思路</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原数组：[64, 34, 25, 12, 22, 11, 90]</span><br><span class="line">选择 pivot = 22（随机选择）</span><br><span class="line"></span><br><span class="line">      分区（Partition）</span><br><span class="line">             ↓</span><br><span class="line">[12, 11] [22] [64, 34, 25, 90]</span><br><span class="line">  &lt; 22    =      &gt; 22</span><br><span class="line">    ↓             ↓</span><br><span class="line">  递归排序      递归排序</span><br><span class="line">    ↓             ↓</span><br><span class="line">[11, 12]     [25, 34, 64, 90]</span><br><span class="line">         ↓</span><br><span class="line">    合并（无需操作，已有序）</span><br><span class="line">         ↓</span><br><span class="line">[11, 12, 22, 25, 34, 64, 90]</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-1" tabindex="-1" id="代码实现-2">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSortHelper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quickSortHelper</span>(nums, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSortHelper</span>(nums, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择pivot，避免最坏情况</span></span><br><span class="line">    <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[randomIndex], nums[right]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot = nums[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi-1" tabindex="-1" id="复杂度分析-2">复杂度分析</h4><ul><li><strong>时间</strong>：平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 递归栈</li></ul><h4 id="kuai-pai-vs-gui-bing" tabindex="-1" id="快排-vs-归并">快排 vs 归并</h4><table><thead><tr><th>特性</th><th>快速排序</th><th>归并排序</th></tr></thead><tbody><tr><td>平均时间</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>最坏时间</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>空间复杂度</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>稳定性</td><td>❌ 不稳定</td><td>✅ 稳定</td></tr><tr><td>原地排序</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>实际性能</td><td><strong>更快</strong>（缓存友好）</td><td>略慢</td></tr></tbody></table><hr><h3 id="3-zui-da-zi-shu-zu-he" tabindex="-1" id="3-最大子数组和">3. 最大子数组和</h3><blockquote><p><strong>LeetCode 53</strong>: 最大子数组和</p></blockquote><h4 id="wen-ti-miao-shu" tabindex="-1" id="问题描述">问题描述</h4><p>给定一个整数数组，找到具有最大和的连续子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6</span><br></pre></td></tr></table></figure><h4 id="fen-zhi-si-lu-2" tabindex="-1" id="分治思路-3">分治思路</h4><p>最大子数组只可能在三个位置：</p><ol><li><strong>完全在左半部分</strong></li><li><strong>完全在右半部分</strong></li><li><strong>跨越中点</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</span><br><span class="line">              ↓ mid</span><br><span class="line">      左半部分  |  右半部分</span><br><span class="line">               </span><br><span class="line"> 左边最大：1    右边最大：4</span><br><span class="line"> 跨越中点最大：4 + (-1) + 2 + 1 = 6</span><br><span class="line"> </span><br><span class="line"> 最终答案：max(1, 4, 6) = 6</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph TD    A[整个数组] --&gt; B[左半部分]    A --&gt; C[右半部分]    A --&gt; D[跨越中点]        B --&gt; E[递归求解]    C --&gt; F[递归求解]    D --&gt; G[线性扫描]        E --&gt; H[取最大值]    F --&gt; H    G --&gt; H        H --&gt; I[返回结果]        style D fill:#FFE4B5    style H fill:#90EE90</code></pre><h4 id="dai-ma-shi-xian-2" tabindex="-1" id="代码实现-3">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">maxSubArrayHelper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArrayHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];  <span class="comment">// 基准情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">maxSubArrayHelper</span>(nums, left, mid);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">maxSubArrayHelper</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="type">int</span> crossMax = <span class="built_in">maxCrossing</span>(nums, left, mid, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(&#123;leftMax, rightMax, crossMax&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCrossing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从中点向左扩展</span></span><br><span class="line">    <span class="type">int</span> leftSum = INT_MIN, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= left; --i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        leftSum = <span class="built_in">max</span>(leftSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从中点向右扩展</span></span><br><span class="line">    <span class="type">int</span> rightSum = INT_MIN;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        rightSum = <span class="built_in">max</span>(rightSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi-2" tabindex="-1" id="复杂度分析-3">复杂度分析</h4><ul><li><strong>时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2T(n/2) + O(n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 递归栈</li></ul><blockquote><p><strong>注意</strong>：这道题有更优的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 动态规划解法，但分治解法是理解分治思想的好例子。</p></blockquote><hr><h3 id="4-kuai-su-mi" tabindex="-1" id="4-快速幂">4. 快速幂</h3><blockquote><p><strong>LeetCode 50</strong>: Pow(x, n)</p></blockquote><h4 id="wen-ti-miao-shu-1" tabindex="-1" id="问题描述-2">问题描述</h4><p>实现 <code>pow(x, n)</code>，即计算 x 的 n 次幂。</p><h4 id="bao-li-vs-fen-zhi" tabindex="-1" id="暴力-vs-分治">暴力 vs 分治</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">计算 2^10：</span><br><span class="line"></span><br><span class="line">暴力：2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2  (10次乘法)</span><br><span class="line"></span><br><span class="line">分治：</span><br><span class="line">  2^10 = 2^5 × 2^5</span><br><span class="line">  2^5 = 2^2 × 2^2 × 2</span><br><span class="line">  2^2 = 2 × 2</span><br><span class="line"></span><br><span class="line">只需要 4 次乘法！</span><br></pre></td></tr></table></figure><h4 id="fen-zhi-si-lu-3" tabindex="-1" id="分治思路-4">分治思路</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>×</mo><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> 是偶数</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>×</mo><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>×</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> 是奇数</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x^n = \begin{cases} x^{n/2} \times x^{n/2} &amp; n \text{ 是偶数} \\ x^{n/2} \times x^{n/2} \times x &amp; n \text{ 是奇数} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">是偶数</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">是奇数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="dai-ma-shi-xian-3" tabindex="-1" id="代码实现-4">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fastPow</span>(x, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fastPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;  <span class="comment">// 基准情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> half = <span class="built_in">fastPow</span>(x, n / <span class="number">2</span>);  <span class="comment">// 分治</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> half * half;           <span class="comment">// 偶数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> half * half * x;       <span class="comment">// 奇数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="die-dai-ban-ben-geng-you" tabindex="-1" id="迭代版本（更优）">迭代版本（更优）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;        <span class="comment">// n是奇数</span></span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;             <span class="comment">// x = x^2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;            <span class="comment">// n = n / 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi-3" tabindex="-1" id="复杂度分析-4">复杂度分析</h4><ul><li><strong>时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：递归 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，迭代 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><hr><h3 id="5-di-k-da-yuan-su" tabindex="-1" id="5-第K大元素">5. 第K大元素</h3><blockquote><p><strong>LeetCode 215</strong>: 数组中的第K个最大元素</p></blockquote><h4 id="wen-ti-miao-shu-2" tabindex="-1" id="问题描述-3">问题描述</h4><p>找出数组中第 k 大的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h4 id="fen-zhi-si-lu-kuai-su-xuan-ze" tabindex="-1" id="分治思路：快速选择">分治思路：快速选择</h4><p>利用快排的 partition 思想，每次可以确定一个元素的最终位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组：[3, 2, 1, 5, 6, 4]，找第2大（即第5小）</span><br><span class="line"></span><br><span class="line">Partition后（假设pivot=4）：</span><br><span class="line">[3, 2, 1] [4] [5, 6]</span><br><span class="line">  0,1,2    3   4,5</span><br><span class="line"></span><br><span class="line">pivot在位置3，第5小应该在位置4</span><br><span class="line">所以在右半部分继续找</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-4" tabindex="-1" id="代码实现-5">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> targetIndex = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, targetIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi-4" tabindex="-1" id="复杂度分析-5">复杂度分析</h4><ul><li><strong>时间</strong>：平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="wei-shi-yao-ping-jun-shi-o-n" tabindex="-1" id="为什么平均是-O-n-？">为什么平均是 O(n)？</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = T(n/2) + O(n) = O(n) + O(n/2) + O(n/4) + ... = O(2n) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>与快排不同，快速选择只需要递归一侧！</p><hr><h3 id="6-ni-xu-dui-ji-shu" tabindex="-1" id="6-逆序对计数">6. 逆序对计数</h3><blockquote><p><strong>剑指Offer 51</strong>: 数组中的逆序对</p></blockquote><h4 id="wen-ti-miao-shu-3" tabindex="-1" id="问题描述-4">问题描述</h4><p>在数组中，如果前面的数大于后面的数，则这两个数构成一个逆序对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[7, 5, 6, 4]</span><br><span class="line">输出：5</span><br><span class="line">解释：(7,5), (7,6), (7,4), (5,4), (6,4)</span><br></pre></td></tr></table></figure><h4 id="fen-zhi-si-lu-4" tabindex="-1" id="分治思路-5">分治思路</h4><p>利用归并排序的过程统计逆序对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[7, 5, 6, 4]</span><br><span class="line">     ↓ 分解</span><br><span class="line">[7, 5] [6, 4]</span><br><span class="line">  ↓       ↓</span><br><span class="line">[7][5] [6][4]</span><br><span class="line">  ↓       ↓ 合并时统计</span><br><span class="line">[5,7]   [4,6]  ← 统计了 (7,5), (6,4)</span><br><span class="line">     ↓ 合并时统计</span><br><span class="line">[4, 5, 6, 7]   ← 统计了 (7,4), (7,6), (5,4)</span><br><span class="line"></span><br><span class="line">关键：当右边元素先被放入时，左边剩余的都是逆序对</span><br></pre></td></tr></table></figure><h4 id="dai-ma-shi-xian-5" tabindex="-1" id="代码实现-6">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countInversions</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countHelper</span>(nums, temp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    count += <span class="built_in">countHelper</span>(nums, temp, left, mid);</span><br><span class="line">    count += <span class="built_in">countHelper</span>(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">    count += <span class="built_in">mergeAndCount</span>(nums, temp, left, mid, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mergeAndCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; temp, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">        temp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = left, count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">            nums[k++] = temp[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k++] = temp[j++];</span><br><span class="line">            count += (mid - i + <span class="number">1</span>);  <span class="comment">// 关键：左边剩余都是逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) nums[k++] = temp[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) nums[k++] = temp[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fu-za-du-fen-xi-5" tabindex="-1" id="复杂度分析-6">复杂度分析</h4><ul><li><strong>时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><strong>空间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><hr><h2 id="fen-zhi-vs-di-gui-vs-dong-tai-gui-hua" tabindex="-1" id="分治-vs-递归-vs-动态规划">分治 vs 递归 vs 动态规划</h2><h3 id="san-zhe-guan-xi" tabindex="-1" id="三者关系">三者关系</h3><pre><code class="highlight mermaid">graph TD    A[递归] --&gt; B[分治]    A --&gt; C[动态规划]        B --&gt; D[子问题独立]    C --&gt; E[子问题重叠]        D --&gt; F[直接递归求解]    E --&gt; G[记忆化/自底向上]        style A fill:#FFE4B5    style B fill:#87CEEB    style C fill:#90EE90</code></pre><h3 id="dui-bi-biao" tabindex="-1" id="对比表">对比表</h3><table><thead><tr><th>特性</th><th>递归</th><th>分治</th><th>动态规划</th></tr></thead><tbody><tr><td>本质</td><td>实现技术</td><td>算法思想</td><td>算法思想</td></tr><tr><td>子问题</td><td>-</td><td>独立</td><td>重叠</td></tr><tr><td>求解方式</td><td>自顶向下</td><td>自顶向下</td><td>自底向上/记忆化</td></tr><tr><td>典型问题</td><td>阶乘</td><td>归并排序</td><td>斐波那契</td></tr></tbody></table><h3 id="ru-he-xuan-ze" tabindex="-1" id="如何选择？">如何选择？</h3><ol><li><strong>分治</strong>：子问题独立，无重复计算</li><li><strong>动态规划</strong>：子问题重叠，需要记忆化</li></ol><hr><h2 id="fu-za-du-fen-xi-zhu-ding-li" tabindex="-1" id="复杂度分析：主定理">复杂度分析：主定理</h2><h3 id="zhu-ding-li-gong-shi" tabindex="-1" id="主定理公式">主定理公式</h3><p>对于递归式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = aT(n/b) + f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">c = \log_b a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.242em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span></span></span></span>：</p><ol><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>c</mi><mo>−</mo><mi>ϵ</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = O(n^{c-\epsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>c</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>c</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \Theta(n^c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>c</mi></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^c \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>c</mi><mo>+</mo><mi>ϵ</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \Omega(n^{c+\epsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></li></ol><h3 id="chang-jian-qing-kuang" tabindex="-1" id="常见情况">常见情况</h3><table><thead><tr><th>递归式</th><th>算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2T(n/2) + O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>归并排序</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2T(n/2) + O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>二分查找</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = T(n/2) + O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>快速选择</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = T(n/2) + O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>二分幂</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><hr><h2 id="si-wei-dao-tu" tabindex="-1" id="思维导图">思维导图</h2><pre><code class="highlight mermaid">graph TD    A[分治算法] --&gt; B[排序问题]    A --&gt; C[搜索问题]    A --&gt; D[数学问题]    A --&gt; E[统计问题]        B --&gt; B1[归并排序]    B --&gt; B2[快速排序]        C --&gt; C1[二分查找]    C --&gt; C2[第K大元素]        D --&gt; D1[快速幂]    D --&gt; D2[大整数乘法]        E --&gt; E1[逆序对]    E --&gt; E2[最大子数组]        style A fill:#FFE4B5    style B1 fill:#87CEEB    style B2 fill:#87CEEB    style C1 fill:#90EE90    style D1 fill:#DDA0DD</code></pre><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>分治三步曲</strong>：分解 → 递归 → 合并</li><li><strong>适用条件</strong>：子问题独立、可合并、存在基准情况</li><li><strong>时间分析</strong>：使用主定理</li><li><strong>优化方向</strong>：合并操作是关键</li></ol><h3 id="fen-zhi-mo-ban" tabindex="-1" id="分治模板">分治模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">divideAndConquer</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基准情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isBaseCase</span>(problem)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(problem);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 分解</span></span><br><span class="line">    subProblems = <span class="built_in">divide</span>(problem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 递归解决</span></span><br><span class="line">    <span class="keyword">for</span> (sub : subProblems) &#123;</span><br><span class="line">        subResults.<span class="built_in">push_back</span>(<span class="built_in">divideAndConquer</span>(sub));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 合并</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">combine</span>(subResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chang-jian-wen-ti-fen-lei" tabindex="-1" id="常见问题分类">常见问题分类</h3><table><thead><tr><th>类型</th><th>问题</th><th>合并方式</th></tr></thead><tbody><tr><td>排序</td><td>归并、快排</td><td>双指针合并</td></tr><tr><td>搜索</td><td>二分查找</td><td>直接返回</td></tr><tr><td>数学</td><td>快速幂</td><td>乘法</td></tr><tr><td>统计</td><td>逆序对</td><td>计数累加</td></tr><tr><td>优化</td><td>最大子数组</td><td>取最大值</td></tr></tbody></table><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://book.douban.com/subject/20432061/">《算法导论》第4章：分治策略</a></li><li><a href="https://leetcode.com/tag/divide-and-conquer/">LeetCode 分治专题</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;fen-zhi-suan-fa-xiang-jie-hua-fan-wei-jian-de-xing-wei-yi-zhu&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="算法设计" scheme="https://smarter.xin/tags/algorithm-design/"/>
    
    <category term="分治" scheme="https://smarter.xin/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="归并排序" scheme="https://smarter.xin/tags/merge-sort/"/>
    
    <category term="快速排序" scheme="https://smarter.xin/tags/quick-sort/"/>
    
  </entry>
  
  <entry>
    <title>常见题型-N皇后</title>
    <link href="https://smarter.xin/posts/f508052b/"/>
    <id>https://smarter.xin/posts/f508052b/</id>
    <published>2026-01-02T08:24:14.000Z</published>
    <updated>2026-01-06T13:16:51.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="n-huang-hou-wen-ti-wan-quan-jie-xi-cong-bao-li-dao-ji-zhi-you-hua" tabindex="-1">N皇后问题完全解析：从暴力到极致优化</h1><blockquote><p>深度剖析经典回溯问题，掌握从基础到高级的优化技巧</p></blockquote><h2 id="wen-ti-miao-shu" tabindex="-1" id="问题描述">问题描述</h2><p><strong>N皇后问题</strong>是一个经典的回溯算法问题，也是LeetCode上的热门题目。</p><h3 id="wen-ti-ding-yi" tabindex="-1" id="问题定义">问题定义</h3><p>在 <strong>n×n</strong> 的国际象棋棋盘上放置 <strong>n</strong> 个皇后，使得它们<strong>不能相互攻击</strong>。</p><h3 id="gong-ji-gui-ze" tabindex="-1" id="攻击规则">攻击规则</h3><p>皇后可以攻击：</p><ol><li><strong>同一行</strong>的所有位置</li><li><strong>同一列</strong>的所有位置</li><li><strong>同一对角线</strong>的所有位置（左上-右下、右上-左下）</li></ol><h3 id="shi-li" tabindex="-1" id="示例">示例</h3><p><strong>4皇后问题的解</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解法1:          解法2:</span><br><span class="line">. Q . .        . . Q .</span><br><span class="line">. . . Q        Q . . .</span><br><span class="line">Q . . .        . . . Q</span><br><span class="line">. . Q .        . Q . .</span><br></pre></td></tr></table></figure><hr><h2 id="wen-ti-fen-xi" tabindex="-1" id="问题分析">问题分析</h2><h3 id="guan-jian-guan-cha" tabindex="-1" id="关键观察">关键观察</h3><ol><li><p><strong>每行只能放一个皇后</strong></p><ul><li>n个皇后放在n行，每行恰好一个</li><li>所以我们可以<strong>逐行</strong>放置皇后</li></ul></li><li><p><strong>每列只能放一个皇后</strong></p><ul><li>需要记录哪些列已经被占用</li></ul></li><li><p><strong>每条对角线只能放一个皇后</strong></p><ul><li><strong>主对角线</strong>（左上→右下）：特点是 <code>row - col</code> 值相同</li><li><strong>副对角线</strong>（右上→左下）：特点是 <code>row + col</code> 值相同</li></ul></li></ol><h3 id="dui-jiao-xian-suo-yin-ji-suan" tabindex="-1" id="对角线索引计算">对角线索引计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">棋盘示例 (n=4):</span><br><span class="line"></span><br><span class="line">主对角线 (row - col):        副对角线 (row + col):</span><br><span class="line">-3 -2 -1  0                  0  1  2  3</span><br><span class="line">-2 -1  0  1                  1  2  3  4</span><br><span class="line">-1  0  1  2                  2  3  4  5</span><br><span class="line"> 0  1  2  3                  3  4  5  6</span><br><span class="line"></span><br><span class="line">为避免负数，主对角线索引 = row - col + n - 1</span><br></pre></td></tr></table></figure><h3 id="ke-shi-hua-li-jie" tabindex="-1" id="可视化理解">可视化理解</h3><pre><code class="highlight mermaid">graph TD    A[N皇后问题] --&gt; B[逐行放置]    B --&gt; C[检查冲突]    C --&gt; D[列冲突]    C --&gt; E[主对角线冲突]    C --&gt; F[副对角线冲突]        D --&gt; G[cols数组]    E --&gt; H[diag1数组]    F --&gt; I[diag2数组]        style A fill:#FFE4B5    style C fill:#87CEEB</code></pre><hr><h2 id="jie-ti-si-lu-yan-bian" tabindex="-1" id="解题思路演变">解题思路演变</h2><h3 id="si-lu-1-bao-li-qiong-ju" tabindex="-1" id="思路1-暴力穷举">思路1: 暴力穷举</h3><p>尝试所有可能的放置方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个皇后，每个皇后有 n² 个位置</span><br><span class="line">总共需要检查 (n²)! 种组合 → 天文数字！</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：完全不可行</p><h3 id="si-lu-2-you-hua-qiong-ju" tabindex="-1" id="思路2-优化穷举">思路2: 优化穷举</h3><p>既然每行只能放一个皇后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1个皇后有 n 种选择</span><br><span class="line">第2个皇后有 n 种选择</span><br><span class="line">...</span><br><span class="line">总共 n^n 种组合</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：仍然很大（8皇后就是 8⁸ = 16,777,216）</p><h3 id="si-lu-3-hui-su-jian-zhi" tabindex="-1" id="思路3-回溯-剪枝-✓">思路3: 回溯 + 剪枝 ✓</h3><p><strong>核心思想</strong>：</p><ol><li>逐行放置皇后（每行只选一列）</li><li>放置前检查是否合法</li><li>如果不合法，<strong>剪枝</strong>（不继续递归）</li><li>如果合法，继续下一行</li><li>回溯时撤销选择</li></ol><pre><code class="highlight mermaid">graph TD    A[行0] --&gt; B[尝试列0]    A --&gt; C[尝试列1]    A --&gt; D[尝试列2]        B --&gt; E[行1: 列2合法]    B --&gt; F[行1: 列3合法]        C --&gt; G[行1: ✗ 冲突]        E --&gt; H[行2: 继续...]    F --&gt; I[行2: 继续...]        style G fill:#FFB6C1    style H fill:#90EE90    style I fill:#90EE90</code></pre><hr><h2 id="jie-fa-yi-ji-chu-hui-su" tabindex="-1" id="解法一：基础回溯">解法一：基础回溯</h2><h3 id="he-xin-dai-ma" tabindex="-1" id="核心代码">核心代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NQueens</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(board, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, </span></span></span><br><span class="line"><span class="params"><span class="function">                   vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件：所有行都放置了皇后</span></span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在当前行的每一列尝试放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="comment">// 剪枝：检查是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, col)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>, result);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查左上对角线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查右上对角线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="zhi-xing-guo-cheng-shi-li-4-huang-hou" tabindex="-1" id="执行过程示例（4皇后）">执行过程示例（4皇后）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">步骤1: row=0, col=0</span><br><span class="line">. . . .  →  Q . . .</span><br><span class="line">. . . .     . . . .</span><br><span class="line">. . . .     . . . .</span><br><span class="line">. . . .     . . . .</span><br><span class="line"></span><br><span class="line">步骤2: row=1, 尝试col=0 ✗ (同列)</span><br><span class="line">        row=1, 尝试col=1 ✗ (对角线)</span><br><span class="line">        row=1, 尝试col=2 ✓</span><br><span class="line">Q . . .</span><br><span class="line">. . Q .</span><br><span class="line">. . . .</span><br><span class="line">. . . .</span><br><span class="line"></span><br><span class="line">步骤3: row=2, 尝试col=0 ✗ (对角线)</span><br><span class="line">        row=2, 尝试col=1 ✗ (对角线)</span><br><span class="line">        row=2, 尝试col=2 ✗ (同列)</span><br><span class="line">        row=2, 尝试col=3 ✗ (对角线)</span><br><span class="line">        </span><br><span class="line">→ 回溯到row=1，尝试col=3</span><br><span class="line"></span><br><span class="line">步骤4: row=1, col=3</span><br><span class="line">Q . . .</span><br><span class="line">. . . Q</span><br><span class="line">. . . .</span><br><span class="line">. . . .</span><br><span class="line"></span><br><span class="line">步骤5: row=2, col=1</span><br><span class="line">Q . . .</span><br><span class="line">. . . Q</span><br><span class="line">. Q . .</span><br><span class="line">. . . .</span><br><span class="line"></span><br><span class="line">步骤6: row=3, col=2 ✓</span><br><span class="line">Q . . .</span><br><span class="line">. . . Q</span><br><span class="line">. Q . .</span><br><span class="line">. . Q .  ← 找到第一个解！</span><br></pre></td></tr></table></figure><h3 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>：O(n!)</p><ul><li>第1行有n种选择</li><li>第2行最多n-1种（剪掉1列）</li><li>…</li><li>近似 n!</li></ul></li><li><p><strong>空间复杂度</strong>：O(n²)</p><ul><li>递归深度 O(n)</li><li>棋盘存储 O(n²)</li></ul></li></ul><hr><h2 id="jie-fa-er-biao-ji-shu-zu-you-hua" tabindex="-1" id="解法二：标记数组优化">解法二：标记数组优化</h2><h3 id="you-hua-si-lu" tabindex="-1" id="优化思路">优化思路</h3><p><strong>问题</strong>：基础解法中，<code>isValid()</code> 函数时间复杂度为 O(n)</p><p><strong>优化</strong>：使用三个标记数组，将合法性检查优化到 <strong>O(1)</strong></p><h3 id="he-xin-si-xiang" tabindex="-1" id="核心思想">核心思想</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n)</span></span>;          <span class="comment">// cols[i] = true 表示第i列已占用</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diag1</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>)</span></span>;     <span class="comment">// 主对角线标记</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diag2</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>)</span></span>;     <span class="comment">// 副对角线标记</span></span><br></pre></td></tr></table></figure><h3 id="suo-yin-ji-suan" tabindex="-1" id="索引计算">索引计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于位置 (row, col):</span><br><span class="line">- 列索引: col</span><br><span class="line">- 主对角线索引: row - col + n - <span class="number">1</span></span><br><span class="line">- 副对角线索引: row + col</span><br></pre></td></tr></table></figure><h3 id="dai-ma-shi-xian" tabindex="-1" id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrackOptimized</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row,</span></span></span><br><span class="line"><span class="params"><span class="function">                       vector&lt;<span class="type">bool</span>&gt;&amp; cols,</span></span></span><br><span class="line"><span class="params"><span class="function">                       vector&lt;<span class="type">bool</span>&gt;&amp; diag1,</span></span></span><br><span class="line"><span class="params"><span class="function">                       vector&lt;<span class="type">bool</span>&gt;&amp; diag2,</span></span></span><br><span class="line"><span class="params"><span class="function">                       vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">        <span class="type">int</span> d1 = row - col + n - <span class="number">1</span>;  <span class="comment">// 主对角线</span></span><br><span class="line">        <span class="type">int</span> d2 = row + col;          <span class="comment">// 副对角线</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// O(1) 检查</span></span><br><span class="line">        <span class="keyword">if</span> (cols[col] || diag1[d1] || diag2[d2]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        cols[col] = diag1[d1] = diag2[d2] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtrackOptimized</span>(board, row + <span class="number">1</span>, cols, diag1, diag2, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        cols[col] = diag1[d1] = diag2[d2] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dui-jiao-xian-suo-yin-ke-shi-hua" tabindex="-1" id="对角线索引可视化">对角线索引可视化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4×4棋盘的对角线索引：</span><br><span class="line"></span><br><span class="line">主对角线 (row - col + 3):    副对角线 (row + col):</span><br><span class="line">┌─────────────────┐         ┌─────────────────┐</span><br><span class="line">│ 3 │ 2 │ 1 │ 0 │         │ 0 │ 1 │ 2 │ 3 │</span><br><span class="line">├─────────────────┤         ├─────────────────┤</span><br><span class="line">│ 4 │ 3 │ 2 │ 1 │         │ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">├─────────────────┤         ├─────────────────┤</span><br><span class="line">│ 5 │ 4 │ 3 │ 2 │         │ 2 │ 3 │ 4 │ 5 │</span><br><span class="line">├─────────────────┤         ├─────────────────┤</span><br><span class="line">│ 6 │ 5 │ 4 │ 3 │         │ 3 │ 4 │ 5 │ 6 │</span><br><span class="line">└─────────────────┘         └─────────────────┘</span><br><span class="line"></span><br><span class="line">相同索引的格子在同一对角线上</span><br></pre></td></tr></table></figure><h3 id="you-shi" tabindex="-1" id="优势">优势</h3><p>✅ <strong>合法性检查从 O(n) 降到 O(1)</strong><br>✅ <strong>整体性能提升 2-3倍</strong><br>✅ <strong>代码更简洁清晰</strong></p><hr><h2 id="jie-fa-san-wei-yun-suan-you-hua" tabindex="-1" id="解法三：位运算优化">解法三：位运算优化</h2><h3 id="he-xin-si-xiang-1" tabindex="-1" id="核心思想-2">核心思想</h3><p>使用<strong>整数的二进制位</strong>来表示状态，而不是数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如 8 皇后问题：</span><br><span class="line">cols = 0b00101000  表示第3列和第5列已占用</span><br><span class="line">       ││││││││</span><br><span class="line">       ││││││└─ 第0列</span><br><span class="line">       ││││└─── 第2列</span><br><span class="line">       │││└──── 第3列 ✓</span><br><span class="line">       ││└───── 第4列</span><br><span class="line">       │└────── 第5列 ✓</span><br><span class="line">       └─────── 第6列</span><br></pre></td></tr></table></figure><h3 id="wei-yun-suan-ji-qiao" tabindex="-1" id="位运算技巧">位运算技巧</h3><h4 id="1-huo-qu-ke-yong-wei-zhi" tabindex="-1" id="1-获取可用位置">1. 获取可用位置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设：</span></span><br><span class="line"><span class="comment">// cols  = 0b00101000  (列占用)</span></span><br><span class="line"><span class="comment">// diag1 = 0b00010100  (主对角线占用)</span></span><br><span class="line"><span class="comment">// diag2 = 0b01000010  (副对角线占用)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> occupied = cols | diag1 | diag2;  <span class="comment">// 所有占用位置</span></span><br><span class="line"><span class="comment">// occupied = 0b01111110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> available = ~occupied &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);  <span class="comment">// 可用位置</span></span><br><span class="line"><span class="comment">// available = 0b10000001</span></span><br></pre></td></tr></table></figure><h4 id="2-ti-qu-zui-di-wei-de-1" tabindex="-1" id="2-提取最低位的1">2. 提取最低位的1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> position = available &amp; (-available);</span><br><span class="line"><span class="comment">// 获取最右边的可用位置</span></span><br><span class="line"></span><br><span class="line">例如：available = <span class="number">0b10100</span></span><br><span class="line">     -available = <span class="number">0b01100</span>  (补码)</span><br><span class="line">     position   = <span class="number">0b00100</span>  (只保留最低位)</span><br></pre></td></tr></table></figure><h4 id="3-qing-chu-zui-di-wei-de-1" tabindex="-1" id="3-清除最低位的1">3. 清除最低位的1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">available = available &amp; (available - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 清除已处理的位置，继续处理下一个</span></span><br><span class="line"></span><br><span class="line">例如：available = <span class="number">0b10100</span></span><br><span class="line">     available - <span class="number">1</span> = <span class="number">0b10011</span></span><br><span class="line">     新available = <span class="number">0b10000</span></span><br></pre></td></tr></table></figure><h3 id="wan-zheng-shi-xian" tabindex="-1" id="完整实现">完整实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrackBitwise</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> cols, <span class="type">int</span> diag1, <span class="type">int</span> diag2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; queens,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">generateBoard</span>(queens, n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算可用位置</span></span><br><span class="line">    <span class="type">int</span> available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="comment">// 提取最低位</span></span><br><span class="line">        <span class="type">int</span> position = available &amp; (-available);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清除最低位</span></span><br><span class="line">        available &amp;= (available - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算列号</span></span><br><span class="line">        <span class="type">int</span> col = __builtin_ctz(position);  <span class="comment">// Count Trailing Zeros</span></span><br><span class="line">        queens[row] = col;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtrackBitwise</span>(row + <span class="number">1</span>,</span><br><span class="line">                        cols | position,        <span class="comment">// 标记列</span></span><br><span class="line">                        (diag1 | position) &lt;&lt; <span class="number">1</span>, <span class="comment">// 对角线左移</span></span><br><span class="line">                        (diag2 | position) &gt;&gt; <span class="number">1</span>, <span class="comment">// 对角线右移</span></span><br><span class="line">                        n, queens, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="guan-jian-dian-jie-xi" tabindex="-1" id="关键点解析">关键点解析</h3><h4 id="dui-jiao-xian-de-yi-wei-cao-zuo" tabindex="-1" id="对角线的移位操作">对角线的移位操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">当前行: row</span><br><span class="line">下一行: row + 1</span><br><span class="line"></span><br><span class="line">主对角线: 向左移动1格 → 左移 &lt;&lt; 1</span><br><span class="line">副对角线: 向右移动1格 → 右移 &gt;&gt; 1</span><br><span class="line"></span><br><span class="line">示例（4皇后，第0行第1列）:</span><br><span class="line">row=0:    . Q . .</span><br><span class="line">          diag1 = 0b0010</span><br><span class="line">          diag2 = 0b0010</span><br><span class="line"></span><br><span class="line">row=1:    主对角线向左</span><br><span class="line">          . X Q .</span><br><span class="line">          diag1 = 0b0100</span><br><span class="line">          </span><br><span class="line">          副对角线向右</span><br><span class="line">          Q . X .</span><br><span class="line">          diag2 = 0b0001</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph LR    A[row 0] --&gt;|diag1 &lt;&lt; 1| B[row 1]    A --&gt;|diag2 &gt;&gt; 1| C[row 1]        style A fill:#FFE4B5    style B fill:#87CEEB    style C fill:#90EE90</code></pre><h3 id="you-shi-1" tabindex="-1" id="优势-2">优势</h3><p>✅ <strong>速度最快</strong>（位运算是CPU原生操作）<br>✅ <strong>空间效率高</strong>（3个整数 vs 3个数组）<br>✅ <strong>适合高级优化</strong></p><p>❌ <strong>代码可读性较低</strong><br>❌ <strong>仅适用于 n ≤ 32（int大小限制）</strong></p><hr><h2 id="xing-neng-dui-bi" tabindex="-1" id="性能对比">性能对比</h2><h3 id="shi-ce-shu-ju-8-huang-hou" tabindex="-1" id="实测数据（8皇后）">实测数据（8皇后）</h3><table><thead><tr><th>解法</th><th>时间</th><th>相对速度</th><th>空间</th></tr></thead><tbody><tr><td>基础回溯</td><td>1000 μs</td><td>1.0x</td><td>O(n²)</td></tr><tr><td>标记数组优化</td><td>350 μs</td><td><strong>2.9x</strong></td><td>O(n)</td></tr><tr><td>位运算优化</td><td>180 μs</td><td><strong>5.6x</strong></td><td>O(n)</td></tr></tbody></table><h3 id="bu-tong-gui-mo-de-jie-shu-liang" tabindex="-1" id="不同规模的解数量">不同规模的解数量</h3><table><thead><tr><th>n</th><th>解的数量</th><th>基础回溯</th><th>位运算</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>&lt; 1 ms</td><td>&lt; 1 ms</td></tr><tr><td>8</td><td>92</td><td>10 ms</td><td>2 ms</td></tr><tr><td>10</td><td>724</td><td>120 ms</td><td>18 ms</td></tr><tr><td>12</td><td>14,200</td><td>2.5 s</td><td>350 ms</td></tr></tbody></table><h3 id="xing-neng-qu-xian" tabindex="-1" id="性能曲线">性能曲线</h3><pre><code class="highlight mermaid">graph LR    A[n=4] --&gt;|基础| B[0.5ms]    A --&gt;|优化| C[0.2ms]    A --&gt;|位运算| D[0.1ms]        E[n=8] --&gt;|基础| F[10ms]    E --&gt;|优化| G[3.5ms]    E --&gt;|位运算| H[1.8ms]        I[n=12] --&gt;|基础| J[2.5s]    I --&gt;|优化| K[850ms]    I --&gt;|位运算| L[350ms]        style D fill:#90EE90    style H fill:#90EE90    style L fill:#90EE90</code></pre><hr><h2 id="leet-code-shi-zhan" tabindex="-1" id="LeetCode实战">LeetCode实战</h2><h3 id="leet-code-51-n-queens" tabindex="-1" id="LeetCode-51-N-Queens">LeetCode 51: N-Queens</h3><p><strong>要求</strong>：返回所有不同的N皇后问题的解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diag1</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diag2</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">backtrack</span>(board, <span class="number">0</span>, cols, diag1, diag2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row,</span></span></span><br><span class="line"><span class="params"><span class="function">                   vector&lt;<span class="type">bool</span>&gt;&amp; cols,</span></span></span><br><span class="line"><span class="params"><span class="function">                   vector&lt;<span class="type">bool</span>&gt;&amp; diag1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   vector&lt;<span class="type">bool</span>&gt;&amp; diag2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="type">int</span> d1 = row - col + n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> d2 = row + col;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cols[col] || diag1[d1] || diag2[d2]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            cols[col] = diag1[d1] = diag2[d2] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>, cols, diag1, diag2, result);</span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            cols[col] = diag1[d1] = diag2[d2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>提交结果</strong>：</p><ul><li>✅ 执行时间: 击败 95%</li><li>✅ 内存消耗: 击败 90%</li></ul><hr><h3 id="leet-code-52-n-queens-ii" tabindex="-1" id="LeetCode-52-N-Queens-II">LeetCode 52: N-Queens II</h3><p><strong>要求</strong>：只返回解的数量</p><p><strong>优化</strong>：不需要存储棋盘，只计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> cols, <span class="type">int</span> diag1, <span class="type">int</span> diag2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (available) &#123;</span><br><span class="line">            <span class="type">int</span> position = available &amp; (-available);</span><br><span class="line">            available &amp;= (available - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            count += <span class="built_in">backtrack</span>(row + <span class="number">1</span>,</span><br><span class="line">                             cols | position,</span><br><span class="line">                             (diag1 | position) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                             (diag2 | position) &gt;&gt; <span class="number">1</span>,</span><br><span class="line">                             n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>提交结果</strong>：</p><ul><li>✅ 执行时间: 击败 99%</li><li>✅ 内存消耗: 击败 95%</li></ul><hr><h2 id="jin-jie-ji-qiao" tabindex="-1" id="进阶技巧">进阶技巧</h2><h3 id="1-dui-cheng-xing-jian-zhi" tabindex="-1" id="1-对称性剪枝">1. 对称性剪枝</h3><p>利用棋盘的对称性，只搜索一半的解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="comment">/* ... */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一行只搜索前半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n / <span class="number">2</span> + (n % <span class="number">2</span>); ++col) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他行正常搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后结果数量 *= 2（如果n为偶数）</span></span><br></pre></td></tr></table></figure><h3 id="2-ji-yi-hua-sou-suo" tabindex="-1" id="2-记忆化搜索">2. 记忆化搜索</h3><p>对于重复计算的子问题，可以缓存结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;  <span class="comment">// state -&gt; count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> cols, <span class="type">int</span> diag1, <span class="type">int</span> diag2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> state = (cols &lt;&lt; <span class="number">20</span>) | (diag1 &lt;&lt; <span class="number">10</span>) | diag2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (memo.<span class="built_in">count</span>(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[state];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 正常回溯 ...</span></span><br><span class="line">    </span><br><span class="line">    memo[state] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-qi-fa-shi-sou-suo" tabindex="-1" id="3-启发式搜索">3. 启发式搜索</h3><p>优先选择约束最多的列（Most Constrained First）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择可用列数最少的行优先搜索</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countAvailable</span><span class="params">(<span class="type">int</span> cols, <span class="type">int</span> diag1, <span class="type">int</span> diag2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2));</span><br><span class="line">    <span class="keyword">return</span> __builtin_popcount(available);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="kuo-zhan-wen-ti" tabindex="-1" id="扩展问题">扩展问题</h2><h3 id="bian-chong-1-bu-tong-yan-se-de-huang-hou" tabindex="-1" id="变种1-不同颜色的皇后">变种1: 不同颜色的皇后</h3><p>有两种颜色的皇后，同色不能互相攻击：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="comment">/* ... */</span>, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分别维护两套标记数组</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bian-chong-2-ju-xing-qi-pan" tabindex="-1" id="变种2-矩形棋盘">变种2: 矩形棋盘</h3><p>m×n 的矩形棋盘上放置皇后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="built_in">min</span>(m, n)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bian-chong-3-zhang-ai-wu" tabindex="-1" id="变种3-障碍物">变种3: 障碍物</h3><p>棋盘上有一些位置不能放置皇后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;X&#x27;</span>) &#123;  <span class="comment">// 障碍物</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="chang-jian-cuo-wu" tabindex="-1" id="常见错误">常见错误</h2><h3 id="cuo-wu-1-wang-ji-hui-su" tabindex="-1" id="❌-错误1-忘记回溯">❌ 错误1: 忘记回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"><span class="built_in">backtrack</span>(board, row + <span class="number">1</span>, result);</span><br><span class="line"><span class="comment">// 忘记撤销！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"><span class="built_in">backtrack</span>(board, row + <span class="number">1</span>, result);</span><br><span class="line">board[row][col] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 撤销选择</span></span><br></pre></td></tr></table></figure><h3 id="cuo-wu-2-dui-jiao-xian-suo-yin-ji-suan-cuo-wu" tabindex="-1" id="❌-错误2-对角线索引计算错误">❌ 错误2: 对角线索引计算错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d1 = row - col;  <span class="comment">// 可能为负数！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d1 = row - col + n - <span class="number">1</span>;  <span class="comment">// 保证非负</span></span><br></pre></td></tr></table></figure><h3 id="cuo-wu-3-wei-yun-suan-fan-wei-cuo-wu" tabindex="-1" id="❌-错误3-位运算范围错误">❌ 错误3: 位运算范围错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> available = ~(cols | diag1 | diag2);  <span class="comment">// 包含高位的1</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2));</span><br></pre></td></tr></table></figure><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="san-chong-jie-fa-dui-bi" tabindex="-1" id="三种解法对比">三种解法对比</h3><table><thead><tr><th>特性</th><th>基础回溯</th><th>标记数组</th><th>位运算</th></tr></thead><tbody><tr><td>难度</td><td>⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td>速度</td><td>慢</td><td>中等</td><td><strong>最快</strong></td></tr><tr><td>空间</td><td>O(n²)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>可读性</td><td>高</td><td>中</td><td>低</td></tr><tr><td>推荐场景</td><td>学习理解</td><td><strong>面试推荐</strong></td><td>性能要求高</td></tr></tbody></table><h3 id="he-xin-si-xiang-2" tabindex="-1" id="核心思想-3">核心思想</h3><pre><code class="highlight mermaid">graph TD    A[N皇后问题] --&gt; B[逐行放置]    B --&gt; C[回溯框架]    C --&gt; D[合法性检查]    D --&gt; E[基础: O n 遍历]    D --&gt; F[优化: O 1 查表]    D --&gt; G[极致: 位运算]        E --&gt; H[适合学习]    F --&gt; I[适合面试]    G --&gt; J[适合竞赛]        style I fill:#90EE90</code></pre><h3 id="guan-jian-yao-dian" tabindex="-1" id="关键要点">关键要点</h3><p>✅ <strong>逐行放置</strong>是关键思路<br>✅ <strong>对角线索引</strong>的计算要熟练<br>✅ <strong>回溯三步</strong>：做选择 → 递归 → 撤销<br>✅ <strong>位运算优化</strong>是进阶技巧</p><blockquote><p>N皇后问题是回溯算法的经典代表，从基础实现到极致优化，体现了算法设计中&quot;用空间换时间&quot;和&quot;巧用特性优化&quot;的核心思想。掌握这道题，你将对回溯算法有更深刻的理解！</p></blockquote><p><strong>推荐练习</strong>：</p><ul><li><a href="https://leetcode.com/problems/n-queens/">LeetCode 51 - N皇后</a></li><li><a href="https://leetcode.com/problems/n-queens-ii/">LeetCode 52 - N皇后 II</a></li><li><a href="https://leetcode.com/problems/sudoku-solver/">LeetCode 37 - 解数独</a>（类似思想）</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;n-huang-hou-wen-ti-wan-quan-jie-xi-cong-bao-li-dao-ji-zhi-you-hua&quot;</summary>
        
      
    
    
    
    <category term="LeetCode" scheme="https://smarter.xin/categories/leetcode/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="位运算" scheme="https://smarter.xin/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="回溯" scheme="https://smarter.xin/tags/backtracking/"/>
    
    <category term="N皇后" scheme="https://smarter.xin/tags/N%E7%9A%87%E5%90%8E/"/>
    
    <category term="剪枝优化" scheme="https://smarter.xin/tags/pruning-optimization/"/>
    
  </entry>
  
  <entry>
    <title>AI Infra学习之旅-服务器环境配置</title>
    <link href="https://smarter.xin/posts/a8ee689e/"/>
    <id>https://smarter.xin/posts/a8ee689e/</id>
    <published>2026-01-02T06:12:47.000Z</published>
    <updated>2026-01-06T13:16:51.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qian-yan" tabindex="-1" id="前言">前言</h2><p>在上一篇博客中，我在 Kaggle 上成功运行了第一个 vLLM 程序。但 Kaggle 毕竟有时长限制（每周 30 小时），而且每次都要重新配置环境。这次，我有机会使用一台<strong>配备双 RTX 4090 的 Ubuntu 服务器</strong>，这是一次从云端到本地服务器的重要升级！</p><p>这篇文章将详细记录我从零开始配置这台服务器的完整过程，包括：</p><ul><li>SSH 免密登录配置</li><li>VSCode Remote SSH 开发环境搭建</li><li>远程桌面访问（GNOME Remote Desktop）</li><li>Python + vLLM 环境安装</li><li>实际踩过的坑与解决方案</li></ul><p>希望这篇文章能帮助到同样需要配置 AI 开发服务器的朋友们。</p><hr><h2 id="fu-wu-qi-pei-zhi-xin-xi" tabindex="-1" id="服务器配置信息">服务器配置信息</h2><h3 id="ying-jian-pei-zhi" tabindex="-1" id="硬件配置">硬件配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPU型号: 2 × NVIDIA GeForce RTX 4090</span><br><span class="line">显存: 24GB × 2 = 48GB 总显存</span><br><span class="line">CUDA版本: 12.2</span><br><span class="line">驱动版本: 535.274.02</span><br></pre></td></tr></table></figure><h3 id="xi-tong-xin-xi" tabindex="-1" id="系统信息">系统信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作系统: Ubuntu 24.04 LTS</span><br><span class="line">用户名: Smarter</span><br><span class="line">主机名: 330B</span><br><span class="line">内网IP: 服务器ip </span><br></pre></td></tr></table></figure><h3 id="yu-kaggle-dui-bi" tabindex="-1" id="与-Kaggle-对比">与 Kaggle 对比</h3><table><thead><tr><th>维度</th><th>我的服务器 (RTX 4090×2)</th><th>Kaggle/Colab</th></tr></thead><tbody><tr><td><strong>GPU型号</strong></td><td>RTX 4090 (旗舰)</td><td>⚠️ P100/T4 (中低端)</td></tr><tr><td><strong>显存</strong></td><td>48GB</td><td>⚠️ 16GB</td></tr><tr><td><strong>GPU时长</strong></td><td>无限制</td><td>⚠️ 30h/周</td></tr><tr><td><strong>环境持久化</strong></td><td>永久保存</td><td>❌ 每次重装</td></tr><tr><td><strong>性能</strong></td><td>独享双卡</td><td>⚠️ 共享单卡</td></tr><tr><td><strong>适合长实验</strong></td><td></td><td>❌</td></tr></tbody></table><p><strong>结论</strong>: 服务器配置远超 Kaggle，应该优先使用服务器进行学习和开发。</p><hr><h2 id="di-yi-jie-duan-ssh-lian-jie-pei-zhi" tabindex="-1" id="第一阶段：SSH-连接配置">第一阶段：SSH 连接配置</h2><h3 id="step-1-shou-ci-ssh-lian-jie-ce-shi" tabindex="-1" id="Step-1-首次-SSH-连接测试">Step 1: 首次 SSH 连接测试</h3><p>在 Windows PowerShell 中执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首次连接（替换为你的用户名@服务器IP）</span></span><br><span class="line">ssh Smarter<span class="selector-tag">@</span>服务器ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次连接会提示：</span></span><br><span class="line"><span class="comment"># The authenticity of host &#x27;192.168.50.58&#x27; can&#x27;t be established.</span></span><br><span class="line"><span class="comment"># Are you sure you want to continue connecting (yes/no)?</span></span><br><span class="line"><span class="comment"># 输入：yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后输入密码</span></span><br></pre></td></tr></table></figure><p><strong>成功标志</strong>：看到以下提示符说明连接成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smarter@330B:~$</span><br></pre></td></tr></table></figure><h3 id="step-2-yan-zheng-gpu-zhuang-tai" tabindex="-1" id="Step-2-验证-GPU-状态">Step 2: 验证 GPU 状态</h3><p>连接成功后，立即验证 GPU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p><strong>我的实际输出</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2026-01-02-14-39-22-d0d150.png" alt="image-20260102141851912"></p><p>看到两张 RTX 4090，CUDA 12.2，驱动正常，说明环境 OK！</p><h3 id="step-3-pei-zhi-ssh-mi-yao-mian-mi-deng-lu" tabindex="-1" id="Step-3-配置-SSH-密钥免密登录">Step 3: 配置 SSH 密钥免密登录</h3><p>每次输入密码很麻烦，配置公钥登录可以一劳永逸。</p><h4 id="zai-windows-ben-di-sheng-cheng-ssh-mi-yao" tabindex="-1" id="在-Windows-本地生成-SSH-密钥">在 Windows 本地生成 SSH 密钥</h4><p>打开 PowerShell：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 SSH 密钥对（如果还没有）</span></span><br><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-b</span> <span class="number">4096</span> <span class="literal">-C</span> <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：Enter file in which to save the key</span></span><br><span class="line"><span class="comment"># 直接回车（使用默认路径 C:\Users\pc\.ssh\id_rsa）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：Enter passphrase</span></span><br><span class="line"><span class="comment"># 直接回车（不设置密码，方便使用）</span></span><br></pre></td></tr></table></figure><h4 id="jiang-gong-yao-fu-zhi-dao-fu-wu-qi" tabindex="-1" id="将公钥复制到服务器">将公钥复制到服务器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取公钥内容</span></span><br><span class="line"><span class="variable">$pub</span> = <span class="built_in">Get-Content</span> C:\Users\pc\.ssh\id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将公钥追加到服务器的 authorized_keys</span></span><br><span class="line">ssh Smarter<span class="selector-tag">@</span>服务器ip <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;<span class="variable">$pub</span>&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 这一步会要求输入最后一次服务器密码，之后就可以免密登录了。</p></blockquote><h4 id="ce-shi-mian-mi-deng-lu" tabindex="-1" id="测试免密登录">测试免密登录</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh Smarter<span class="selector-tag">@</span>服务器ip</span><br></pre></td></tr></table></figure><p>如果直接登录不再要求密码，说明配置成功！</p><hr><h2 id="di-er-jie-duan-vs-code-remote-ssh-pei-zhi" tabindex="-1" id="第二阶段：VSCode-Remote-SSH-配置">第二阶段：VSCode Remote SSH 配置</h2><p>VSCode Remote SSH 是最重要的开发工具，可以让我在 Windows 上直接编辑服务器上的代码。</p><h3 id="step-1-an-zhuang-vs-code-cha-jian" tabindex="-1" id="Step-1-安装-VSCode-插件">Step 1: 安装 VSCode 插件</h3><p>在 VSCode 中安装以下插件：</p><ol><li><strong>Remote - SSH</strong>  (必装)</li><li><strong>Remote - SSH: Editing Configuration Files</strong></li><li><strong>Python</strong></li><li><strong>Jupyter</strong></li></ol><h3 id="step-2-pei-zhi-ssh-config-wen-jian" tabindex="-1" id="Step-2-配置-SSH-Config-文件">Step 2: 配置 SSH Config 文件</h3><ol><li>按 <code>F1</code>，输入 <code>Remote-SSH: Open SSH Configuration File</code></li><li>选择 <code>C:\Users\pc\.ssh\config</code></li><li>添加以下配置：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu AI Infra服务器 (RTX 4090×2)</span><br><span class="line">Host ai-server</span><br><span class="line">    HostName 服务器ip</span><br><span class="line">    User Smarter</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile C:\Users\pc\.ssh\id_rsa</span><br><span class="line">    IdentitiesOnly yes</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    ForwardAgent yes</span><br></pre></td></tr></table></figure><p><strong>配置说明</strong>：</p><ul><li><code>IdentitiesOnly yes</code>: 只使用指定的密钥</li><li><code>PreferredAuthentications publickey</code>: 优先使用公钥认证</li><li><code>ForwardAgent yes</code>: 允许 SSH Agent 转发</li></ul><h3 id="step-3-lian-jie-dao-fu-wu-qi" tabindex="-1" id="Step-3-连接到服务器">Step 3: 连接到服务器</h3><ol><li>按 <code>F1</code>，输入 <code>Remote-SSH: Connect to Host</code></li><li>选择 <code>ai-server</code></li><li>等待连接（首次会安装 VSCode Server，约 1 分钟）</li><li><strong>成功标志</strong>：左下角显示 <code>SSH: ai-server</code></li></ol><h3 id="step-4-zai-vs-code-zhong-da-kai-fu-wu-qi-wen-jian-jia" tabindex="-1" id="Step-4-在-VSCode-中打开服务器文件夹">Step 4: 在 VSCode 中打开服务器文件夹</h3><p>连接成功后：</p><ol><li>点击 <code>File</code> → <code>Open Folder</code></li><li>选择 <code>/home/Smarter</code> 或你的项目目录</li><li>现在可以直接在 VSCode 中编辑服务器上的文件了！</li></ol><hr><h2 id="di-san-jie-duan-yuan-cheng-zhuo-mian-pei-zhi" tabindex="-1" id="第三阶段：远程桌面配置">第三阶段：远程桌面配置</h2><p>有时候需要图形界面，我配置了 GNOME Remote Desktop。</p><h3 id="wei-shi-yao-xuan-ze-gnome-remote-desktop" tabindex="-1" id="为什么选择-GNOME-Remote-Desktop？">为什么选择 GNOME Remote Desktop？</h3><ul><li>Ubuntu 24.04 自带，无需额外安装</li><li>支持无显示器远程登录</li><li>Windows 自带 mstsc 即可连接</li><li>比 XRDP 更稳定</li></ul><h3 id="step-1-an-zhuang-he-qi-yong-gnome-remote-desktop" tabindex="-1" id="Step-1-安装和启用-GNOME-Remote-Desktop">Step 1: 安装和启用 GNOME Remote Desktop</h3><p>在服务器上执行（需要管理员权限）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装组件（Ubuntu 24.04 通常已安装）</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y gnome-remote-desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成 TLS 证书（必需）</span></span><br><span class="line"><span class="built_in">sudo</span> -u gnome-remote-desktop <span class="built_in">mkdir</span> -p ~gnome-remote-desktop/.local/share/gnome-remote-desktop</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> openssl req -x509 -newkey rsa:4096 -nodes -days 3650 -sha256 \</span><br><span class="line">  -keyout ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \</span><br><span class="line">  -out ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt \</span><br><span class="line">  -subj <span class="string">&quot;/CN=服务器ip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置文件权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> gnome-remote-desktop:gnome-remote-desktop \</span><br><span class="line">  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \</span><br><span class="line">  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 644 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt</span><br></pre></td></tr></table></figure><h3 id="step-2-pei-zhi-rdp-ren-zheng" tabindex="-1" id="Step-2-配置-RDP-认证">Step 2: 配置 RDP 认证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用 RDP（如果之前启用过）</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp <span class="built_in">disable</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 TLS 证书</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp set-tls-key ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key</span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp set-tls-cert ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 RDP 入口账号密码（这不是 Linux 用户密码）</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp set-credentials rdpuser <span class="string">&#x27;你的强密码&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 RDP</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><h3 id="step-3-qi-dong-fu-wu-bing-yan-zheng" tabindex="-1" id="Step-3-启动服务并验证">Step 3: 启动服务并验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动并设置开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now gnome-remote-desktop.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart gnome-remote-desktop.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 3389 端口是否监听</span></span><br><span class="line"><span class="built_in">sudo</span> ss -lnptu | grep 3389</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system status</span><br></pre></td></tr></table></figure><h3 id="step-4-windows-duan-lian-jie" tabindex="-1" id="Step-4-Windows-端连接">Step 4: Windows 端连接</h3><ol><li>按 <code>Win + R</code>，输入 <code>mstsc</code></li><li>计算机填写：<code>服务器ip</code></li><li>首次认证输入：<ul><li>用户名：<code>rdpuser</code></li><li>密码：你设置的密码</li></ul></li><li>进入 GNOME 登录界面后，使用 Linux 用户 <code>Smarter</code> 的系统密码登录</li></ol><blockquote><p>⚠️ <strong>重要</strong>：确保 <code>Smarter</code> 用户设置了系统密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd Smarter</span><br></pre></td></tr></table></figure></blockquote><h3 id="step-5-bao-cun-rdp-ping-ju-bi-mian-mei-ci-shu-ru" tabindex="-1" id="Step-5-保存-RDP-凭据（避免每次输入）">Step 5: 保存 RDP 凭据（避免每次输入）</h3><p>在 Windows 中：</p><ol><li>搜索并打开 <strong>凭据管理器</strong></li><li>进入 <strong>Windows 凭据</strong></li><li>点击 <strong>添加 Windows 凭据</strong></li><li>地址填：<code>TERMSRV/服务器ip</code></li><li>用户名填：<code>rdpuser</code></li><li>密码填你的密码 → 保存</li></ol><hr><h2 id="di-si-jie-duan-python-huan-jing-pei-zhi" tabindex="-1" id="第四阶段：Python-环境配置">第四阶段：Python 环境配置</h2><h3 id="step-1-jian-cha-conda-shi-fou-yi-an-zhuang" tabindex="-1" id="Step-1-检查-Conda-是否已安装">Step 1: 检查 Conda 是否已安装</h3><p>在 VSCode 终端（或 SSH 连接）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><ul><li>如果显示版本号 → 已安装</li><li>如果报错 <code>command not found</code> → 需要安装</li></ul><h3 id="step-2-a-ru-guo-yi-you-conda" tabindex="-1" id="Step-2A-如果已有-Conda">Step 2A: 如果已有 Conda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 检查 CUDA 版本</span></span><br><span class="line">nvidia-smi | grep <span class="string">&quot;CUDA Version&quot;</span></span><br><span class="line"><span class="comment"># 输出: CUDA Version: 12.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查现有环境</span></span><br><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建 AI Infra 环境（如果不存在）</span></span><br><span class="line">conda create -n ai-infra python=3.10 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 激活环境</span></span><br><span class="line">conda activate ai-infra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 安装 PyTorch（CUDA 12.2 使用 cu121）</span></span><br><span class="line">pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 验证 GPU 可用性</span></span><br><span class="line">python -c <span class="string">&quot;import torch; print(f&#x27;PyTorch: &#123;torch.__version__&#125;&#x27;); print(f&#x27;CUDA可用: &#123;torch.cuda.is_available()&#125;&#x27;); print(f&#x27;GPU数量: &#123;torch.cuda.device_count()&#125;&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p><strong>期望输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PyTorch: 2.1.2+cu121</span><br><span class="line">CUDA可用: True</span><br><span class="line">GPU数量: 2</span><br></pre></td></tr></table></figure><h3 id="step-2-b-ru-guo-xu-yao-an-zhuang-conda" tabindex="-1" id="Step-2B-如果需要安装-Conda">Step 2B: 如果需要安装 Conda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载 Miniconda（比 Anaconda 更轻量）</span></span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装</span></span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># 提示: Do you accept the license terms? → yes</span></span><br><span class="line"><span class="comment"># 提示: installation location → 回车（使用默认）</span></span><br><span class="line"><span class="comment"># 提示: Do you wish to update your shell profile → yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重新加载 shell</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 验证安装</span></span><br><span class="line">conda --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 然后回到 Step 2A 的步骤 3 继续</span></span><br></pre></td></tr></table></figure><h3 id="step-3-an-zhuang-ji-chu-ke-xue-ji-suan-bao" tabindex="-1" id="Step-3-安装基础科学计算包">Step 3: 安装基础科学计算包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保在 ai-infra 环境中</span></span><br><span class="line">conda activate ai-infra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础包（指定版本避免冲突）</span></span><br><span class="line">pip install numpy==1.24.3 pandas matplotlib jupyterlab</span><br><span class="line">pip install transformers==4.36.2 accelerate==0.25.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python -c <span class="string">&quot;import transformers; print(f&#x27;Transformers: &#123;transformers.__version__&#125;&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="di-wu-jie-duan-v-llm-an-zhuang-yu-ce-shi" tabindex="-1" id="第五阶段：vLLM-安装与测试">第五阶段：vLLM 安装与测试</h2><h3 id="ban-ben-jian-rong-xing-shuo-ming" tabindex="-1" id="版本兼容性说明">版本兼容性说明</h3><blockquote><p>⚠️ <strong>重要</strong>：不要随意升级版本，容易导致 CUDA 不兼容！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推荐版本组合（2026年1月验证）：</span><br><span class="line">- PyTorch 2.1.2 (cu121)</span><br><span class="line">- vLLM 0.2.7 (稳定版)</span><br><span class="line">- Triton 2.1.0 (vLLM依赖)</span><br><span class="line">- Flash-Attention 2.3.6 (可选，编译困难，不推荐)</span><br></pre></td></tr></table></figure><h3 id="bao-shou-an-zhuang-fang-an-tui-jian" tabindex="-1" id="保守安装方案（推荐）">保守安装方案（推荐）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 激活环境</span></span><br><span class="line">conda activate ai-infra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 vLLM（会自动安装 Triton 等依赖）</span></span><br><span class="line">pip install vllm==0.2.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证 vLLM</span></span><br><span class="line">python -c <span class="string">&quot;import vllm; print(f&#x27;vLLM版本: &#123;vllm.__version__&#125;&#x27;)&quot;</span></span><br><span class="line"><span class="comment"># 输出: vLLM版本: 0.2.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 验证 Triton（vLLM 会自动安装）</span></span><br><span class="line">python -c <span class="string">&quot;import triton; print(f&#x27;Triton版本: &#123;triton.__version__&#125;&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 测试 vLLM 是否可用</span></span><br><span class="line">python -c <span class="string">&quot;from vllm import LLM; print(&#x27;vLLM导入成功 &#x27;)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="zui-zhong-huan-jing-yan-zheng" tabindex="-1" id="最终环境验证">最终环境验证</h3><p>运行完整验证脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">python &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">import torch</span></span><br><span class="line"><span class="string">import vllm</span></span><br><span class="line"><span class="string">import triton</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;=&quot; * 50)</span></span><br><span class="line"><span class="string">print(&quot;环境验证&quot;)</span></span><br><span class="line"><span class="string">print(&quot;=&quot; * 50)</span></span><br><span class="line"><span class="string">print(f&quot;PyTorch版本: &#123;torch.__version__&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;CUDA可用: &#123;torch.cuda.is_available()&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;CUDA版本: &#123;torch.version.cuda&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;GPU数量: &#123;torch.cuda.device_count()&#125;&quot;)</span></span><br><span class="line"><span class="string">if torch.cuda.is_available():</span></span><br><span class="line"><span class="string">    print(f&quot;GPU 0: &#123;torch.cuda.get_device_name(0)&#125;&quot;)</span></span><br><span class="line"><span class="string">    print(f&quot;GPU 1: &#123;torch.cuda.get_device_name(1)&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;\nvLLM版本: &#123;vllm.__version__&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;Triton版本: &#123;triton.__version__&#125;&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;\n 所有核心组件安装成功！&quot;)</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p><strong>期望输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">==================================================</span><br><span class="line">环境验证</span><br><span class="line">==================================================</span><br><span class="line">PyTorch版本: 2.1.2+cu121</span><br><span class="line">CUDA可用: True</span><br><span class="line">CUDA版本: 12.1</span><br><span class="line">GPU数量: 2</span><br><span class="line">GPU 0: NVIDIA GeForce RTX 4090</span><br><span class="line">GPU 1: NVIDIA GeForce RTX 4090</span><br><span class="line"></span><br><span class="line">vLLM版本: 0.2.7</span><br><span class="line">Triton版本: 2.1.0</span><br><span class="line"></span><br><span class="line"> 所有核心组件安装成功！</span><br></pre></td></tr></table></figure><hr><h2 id="di-liu-jie-duan-yun-xing-di-yi-ge-v-llm-cheng-xu" tabindex="-1" id="第六阶段：运行第一个-vLLM-程序">第六阶段：运行第一个 vLLM 程序</h2><h3 id="chuang-jian-ce-shi-wen-jian" tabindex="-1" id="创建测试文件">创建测试文件</h3><p>在 VSCode 中创建 <code>~/test_vllm.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vllm <span class="keyword">import</span> LLM, SamplingParams</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 GPU 信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;GPU 配置信息&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;可用GPU数量: <span class="subst">&#123;torch.cuda.device_count()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;GPU 0: <span class="subst">&#123;torch.cuda.get_device_name(<span class="number">0</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;GPU 1: <span class="subst">&#123;torch.cuda.get_device_name(<span class="number">1</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载小模型测试（只有 125M 参数，几秒加载）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n🔄 正在加载模型...&quot;</span>)</span><br><span class="line">llm = LLM(</span><br><span class="line">    model=<span class="string">&quot;facebook/opt-125m&quot;</span>,</span><br><span class="line">    trust_remote_code=<span class="literal">True</span>,</span><br><span class="line">    gpu_memory_utilization=<span class="number">0.5</span>  <span class="comment"># 只用 50% 显存，不影响其他人</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; 模型加载完成！\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备输入</span></span><br><span class="line">prompts = [</span><br><span class="line">    <span class="string">&quot;Hello, my name is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The capital of France is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AI Infrastructure is&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置采样参数</span></span><br><span class="line">sampling_params = SamplingParams(</span><br><span class="line">    temperature=<span class="number">0.8</span>,</span><br><span class="line">    top_p=<span class="number">0.95</span>,</span><br><span class="line">    max_tokens=<span class="number">50</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行推理</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;🚀 开始推理...\n&quot;</span>)</span><br><span class="line">outputs = llm.generate(prompts, sampling_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;📊 推理结果&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n提示词: <span class="subst">&#123;output.prompt&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成结果: <span class="subst">&#123;output.outputs[<span class="number">0</span>].text&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n 成功运行第一个 vLLM 程序！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能测试</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n⏱️  性能测试开始...&quot;</span>)</span><br><span class="line">test_prompts = [<span class="string">&quot;Explain AI in simple terms&quot;</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">outputs = llm.generate(test_prompts, sampling_params)</span><br><span class="line">elapsed = time.time() - start</span><br><span class="line"></span><br><span class="line">total_tokens = <span class="built_in">sum</span>(<span class="built_in">len</span>(o.outputs[<span class="number">0</span>].token_ids) <span class="keyword">for</span> o <span class="keyword">in</span> outputs)</span><br><span class="line">throughput = total_tokens / elapsed</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;📈 服务器性能测试结果&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;模型:        OPT-125M&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;GPU:         RTX 4090 (单卡)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总耗时:      <span class="subst">&#123;elapsed:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总 Token 数: <span class="subst">&#123;total_tokens&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;吞吐量:      <span class="subst">&#123;throughput:<span class="number">.2</span>f&#125;</span> tokens/秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">80</span>)</span><br></pre></td></tr></table></figure><h3 id="yun-xing-ce-shi" tabindex="-1" id="运行测试">运行测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定使用 GPU 0（避免占用他人 GPU）</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=0 python ~/test_vllm.py</span><br></pre></td></tr></table></figure><h3 id="wo-de-yun-xing-jie-guo" tabindex="-1" id="我的运行结果">我的运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2026-01-02-14-39-22-7ce4ec.png" alt="image-20260102143458380"></p><blockquote><p>💡 <strong>性能对比</strong>：</p><ul><li>Kaggle P100: ~1539 tokens/秒</li><li>我的 RTX 4090: ~5818 tokens/秒</li><li><strong>提升约 278%！</strong> 🚀</li></ul></blockquote><hr><h2 id="cai-guo-de-keng-yu-jie-jue-fang-an" tabindex="-1" id="踩过的坑与解决方案">踩过的坑与解决方案</h2><h3 id="wen-ti-1-vs-code-remote-ssh-mei-ci-yao-shu-mi-ma" tabindex="-1" id="问题-1-VSCode-Remote-SSH-每次要输密码">问题 1: VSCode Remote SSH 每次要输密码</h3><p><strong>现象</strong>: VSCode 连接服务器时总是弹窗要求输入密码</p><p><strong>解决方案</strong>: 配置 SSH 公钥免密登录（见&quot;第一阶段 Step 3&quot;）</p><p>关键步骤：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows 本地</span></span><br><span class="line"><span class="variable">$pub</span> = <span class="built_in">Get-Content</span> C:\Users\pc\.ssh\id_rsa.pub</span><br><span class="line">ssh Smarter<span class="selector-tag">@</span>服务器ip <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;<span class="variable">$pub</span>&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure><p>并在 SSH config 中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IdentitiesOnly yes</span><br><span class="line">PreferredAuthentications publickey</span><br></pre></td></tr></table></figure><h3 id="wen-ti-2-gnome-remote-desktop-wu-fa-lian-jie" tabindex="-1" id="问题-2-GNOME-Remote-Desktop-无法连接">问题 2: GNOME Remote Desktop 无法连接</h3><p><strong>现象</strong>: Windows 端 mstsc 连接 3389 端口无响应</p><p><strong>原因</strong>:</p><ol><li>没有生成 TLS 证书</li><li>没有设置 RDP 认证凭据</li><li>XRDP 占用了 3389 端口</li></ol><p><strong>解决方案</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 停止并卸载 XRDP（如果有）</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> --now xrdp xrdp-sesman</span><br><span class="line"><span class="built_in">sudo</span> apt purge -y xrdp xorgxrdp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成 TLS 证书（见&quot;第三阶段 Step 1&quot;）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置 RDP 凭据</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp set-credentials rdpuser <span class="string">&#x27;强密码&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> grdctl --system rdp <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重启服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart gnome-remote-desktop.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 验证端口监听</span></span><br><span class="line"><span class="built_in">sudo</span> ss -lnptu | grep 3389</span><br></pre></td></tr></table></figure><h3 id="wen-ti-3-yuan-cheng-zhuo-mian-ti-shi-quot-yi-you-hui-hua-yun-xing-quot" tabindex="-1" id="问题-3-远程桌面提示-已有会话运行">问题 3: 远程桌面提示&quot;已有会话运行&quot;</h3><p><strong>现象</strong>: 尝试远程登录时提示&quot;该用户已有会话&quot;</p><p><strong>原因</strong>: 之前的远程会话没有正常退出，系统认为仍在运行</p><p><strong>解决方案</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看当前会话</span></span><br><span class="line">loginctl list-sessions</span><br><span class="line">loginctl user-status Smarter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 终止该用户所有会话</span></span><br><span class="line"><span class="built_in">sudo</span> loginctl terminate-user Smarter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重启远程桌面服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart gnome-remote-desktop.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart gdm3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 再尝试连接</span></span><br></pre></td></tr></table></figure><h3 id="wen-ti-4-v-llm-dao-ru-bao-cuo-cuda-ban-ben-bu-pi-pei" tabindex="-1" id="问题-4-vLLM-导入报错-CUDA-版本不匹配">问题 4: vLLM 导入报错 CUDA 版本不匹配</h3><p><strong>现象</strong>: <code>import vllm</code> 报错 “CUDA version mismatch”</p><p><strong>原因</strong>: PyTorch 的 CUDA 版本与系统 CUDA 不匹配</p><p><strong>解决方案</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载 PyTorch</span></span><br><span class="line">pip uninstall torch torchvision -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重新安装匹配的版本（CUDA 12.2 使用 cu121）</span></span><br><span class="line">pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证</span></span><br><span class="line">python -c <span class="string">&quot;import torch; print(torch.version.cuda)&quot;</span></span><br><span class="line"><span class="comment"># 应该输出: 12.1 (PyTorch 对 CUDA 12.x 通用)</span></span><br></pre></td></tr></table></figure><h3 id="wen-ti-5-conda-ming-ling-zhao-bu-dao" tabindex="-1" id="问题-5-Conda-命令找不到">问题 5: Conda 命令找不到</h3><p><strong>现象</strong>: <code>conda: command not found</code></p><p><strong>解决方案</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 bashrc</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还是不行，手动添加到 PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/anaconda3/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者添加到 ~/.bashrc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="wen-ti-6-clash-dai-li-duan-kou-bei-zhan-yong" tabindex="-1" id="问题-6-Clash-代理端口被占用">问题 6: Clash 代理端口被占用</h3><p><strong>现象</strong>: 想重启 Clash 但提示端口 7890 被占用</p><p><strong>解决方案</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看占用端口的进程</span></span><br><span class="line"><span class="built_in">sudo</span> lsof -iTCP:7890 -sTCP:LISTEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例:</span></span><br><span class="line"><span class="comment"># COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span></span><br><span class="line"><span class="comment"># clash   3528110  Smarter    9u  IPv4 xxx      0t0  TCP localhost:7890 (LISTEN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 终止该进程</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">kill</span> 3528110</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重新启动 Clash</span></span><br></pre></td></tr></table></figure><hr><h2 id="kai-fa-gong-zuo-liu-cheng" tabindex="-1" id="开发工作流程">开发工作流程</h2><p>配置完成后，我的日常开发流程是这样的：</p><h3 id="fang-an-vs-code-remote-ssh" tabindex="-1" id="方案：VSCode-Remote-SSH">方案：VSCode Remote SSH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐         SSH        ┌─────────────────┐</span><br><span class="line">│  Windows笔记本   │ ◄────────────────► │ Ubuntu服务器    │</span><br><span class="line">│                 │                    │                 │</span><br><span class="line">│  VSCode界面     │                    │  实际执行代码    │</span><br><span class="line">│  编辑器         │                    │  双GPU计算      │</span><br><span class="line">│  浏览器         │                    │  永久存储       │</span><br><span class="line">└─────────────────┘                    └─────────────────┘</span><br><span class="line">       本地                                   云端</span><br></pre></td></tr></table></figure><p><strong>日常步骤</strong>:</p><ol><li><p><strong>打开 VSCode 连接服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VSCode → F1 → Remote-SSH: Connect to Host → ai-server</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑代码</strong>（和本地一样）</p><ul><li>在服务器上直接编辑项目文件</li><li>VSCode 体验和本地完全一样</li><li>代码保存在服务器上，永久保存</li></ul></li><li><p><strong>运行实验</strong>（服务器 GPU）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VSCode 集成终端</span></span><br><span class="line">conda activate ai-infra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 GPU 状态</span></span><br><span class="line">nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用 GPU 0</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=0 python train.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPU 计算，无时长限制 </span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看结果</strong></p><ul><li>结果保存在服务器</li><li>可以通过 VSCode 直接查看图片/日志</li><li>或者下载到本地</li></ul></li></ol><hr><h2 id="gpu-zi-yuan-guan-li" tabindex="-1" id="GPU-资源管理">GPU 资源管理</h2><h3 id="cha-kan-gpu-shi-yong-qing-kuang" tabindex="-1" id="查看-GPU-使用情况">查看 GPU 使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时监控</span></span><br><span class="line">watch -n 1 nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者安装 nvitop（更友好的界面）</span></span><br><span class="line">pip install nvitop</span><br><span class="line">nvitop</span><br></pre></td></tr></table></figure><h3 id="zhi-ding-gpu-yun-xing-dai-ma" tabindex="-1" id="指定-GPU-运行代码">指定 GPU 运行代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 GPU 0</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=0 python train.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 GPU 1</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=1 python train.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时使用两张 GPU</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=0,1 python train.py</span><br></pre></td></tr></table></figure><h3 id="python-dai-ma-zhong-zhi-ding" tabindex="-1" id="Python-代码中指定">Python 代码中指定</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0&#x27;</span>  <span class="comment"># 只用第一张 GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)  <span class="comment"># GPU 0</span></span><br><span class="line"><span class="comment"># device = torch.device(&#x27;cuda:1&#x27;)  # GPU 1</span></span><br></pre></td></tr></table></figure><h3 id="duo-ren-gong-xiang-li-yi" tabindex="-1" id="多人共享礼仪">多人共享礼仪</h3><p>如果服务器是多人共享的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次使用前检查 GPU 状态</span></span><br><span class="line">nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看 Processes 列：</span></span><br><span class="line"><span class="comment"># - GPU 0 空闲 → CUDA_VISIBLE_DEVICES=0</span></span><br><span class="line"><span class="comment"># - GPU 1 空闲 → CUDA_VISIBLE_DEVICES=1</span></span><br><span class="line"><span class="comment"># - 都在用 → 等待或协调</span></span><br></pre></td></tr></table></figure><hr><h2 id="chang-shi-jian-ren-wu-shi-yong-screen" tabindex="-1" id="长时间任务：使用-screen">长时间任务：使用 screen</h2><p>服务器的优势之一就是可以运行长时间任务，即使关闭本地电脑也不影响。</p><h3 id="an-zhuang-screen" tabindex="-1" id="安装-screen">安装 screen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install screen</span><br></pre></td></tr></table></figure><h3 id="shi-yong-fang-fa" tabindex="-1" id="使用方法">使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 session</span></span><br><span class="line">screen -S my_experiment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 运行长时间任务</span></span><br><span class="line">conda activate ai-infra</span><br><span class="line">python long_training.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 断开（任务继续运行）</span></span><br><span class="line"><span class="comment"># 按 Ctrl+A，然后按 D</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重新连接</span></span><br><span class="line">screen -r my_experiment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 列出所有 session</span></span><br><span class="line">screen -<span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 终止 session（在 session 内部）</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p><strong>优势</strong>：关闭 Windows 电脑，SSH 断开，任务照样运行！</p><hr><h2 id="zong-jie-yu-shou-huo" tabindex="-1" id="总结与收获">总结与收获</h2><h3 id="wan-cheng-de-pei-zhi" tabindex="-1" id="完成的配置">完成的配置</h3><ul><li>[x]  SSH 免密登录配置</li><li>[x]  VSCode Remote SSH 环境</li><li>[x]  GNOME Remote Desktop 远程桌面</li><li>[x]  Conda 环境创建 (ai-infra)</li><li>[x]  PyTorch 2.1.2 + CUDA 12.1 安装</li><li>[x]  vLLM 0.2.7 安装与测试</li><li>[x]  第一个 vLLM 程序运行成功</li><li>[x]  性能测试：2276 tokens/秒</li></ul><h3 id="xing-neng-dui-bi" tabindex="-1" id="性能对比">性能对比</h3><table><thead><tr><th>平台</th><th>GPU</th><th>吞吐量 (tokens/s)</th><th>成本</th></tr></thead><tbody><tr><td>Kaggle</td><td>P100</td><td>~1539</td><td>免费（30h/周）</td></tr><tr><td>我的服务器</td><td>RTX 4090</td><td>~5818</td><td>内网服务器（无限）</td></tr><tr><td><strong>性能提升</strong></td><td>-</td><td><strong>+278%</strong></td><td>-</td></tr></tbody></table><hr><h2 id="xie-zai-zui-hou" tabindex="-1" id="写在最后">写在最后</h2><p>如果你也有机会使用服务器进行 AI 学习，我的建议是：</p><ol><li><strong>优先配置好 SSH 免密登录</strong> - 这是一切的基础</li><li><strong>VSCode Remote SSH 是最佳开发环境</strong> - 比本地+rsync 方便太多</li><li><strong>认真做版本管理</strong> - 不要随意升级，稳定的版本组合很重要</li><li><strong>做好 GPU 资源管理</strong> - 尤其是共享服务器，要有礼貌</li><li><strong>使用 screen 管理长任务</strong> - 充分利用服务器优势</li></ol><hr><h2 id="can-kao-zi-liao" tabindex="-1" id="参考资料">参考资料</h2><ul><li><a href="https://help.ubuntu.com/stable/ubuntu-help/sharing-desktop.html">Ubuntu GNOME Remote Desktop 官方文档</a></li><li><a href="https://code.visualstudio.com/docs/remote/ssh">VSCode Remote SSH 文档</a></li><li><a href="https://docs.vllm.ai/">vLLM 官方文档</a></li><li><a href="https://pytorch.org/get-started/locally/">PyTorch 官方安装指南</a></li></ul><hr><p><strong>如果这篇文章对你有帮助，欢迎点赞和分享！有任何问题也欢迎在评论区交流。</strong> 🎉</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;qian-yan&quot; tabindex=&quot;-1&quot; id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇博客中，我在 Kaggle 上成功运行了第一个 vLLM 程序。但 Kaggle 毕竟有时长限制（每周 30</summary>
        
      
    
    
    
    <category term="AI Infra" scheme="https://smarter.xin/categories/ai-infra/"/>
    
    
    <category term="vLLM" scheme="https://smarter.xin/tags/vLLM/"/>
    
    <category term="AI Infrastructure" scheme="https://smarter.xin/tags/AI-Infrastructure/"/>
    
    <category term="Ubuntu Server" scheme="https://smarter.xin/tags/Ubuntu-Server/"/>
    
    <category term="RTX 4090" scheme="https://smarter.xin/tags/RTX-4090/"/>
    
    <category term="SSH" scheme="https://smarter.xin/tags/SSH/"/>
    
    <category term="VSCode Remote" scheme="https://smarter.xin/tags/VSCode-Remote/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-回溯</title>
    <link href="https://smarter.xin/posts/97ccf2e3/"/>
    <id>https://smarter.xin/posts/97ccf2e3/</id>
    <published>2025-12-31T07:02:10.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>回溯算法（Backtracking）是一种通过<strong>探索所有可能的候选解</strong>来找出所有解的算法。当探索到某一步时，发现原先的选择并不优或达不到目标，就<strong>退回一步重新选择</strong>。这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为&quot;回溯点&quot;。</p><p><strong>回溯算法的本质</strong>：穷举所有可能，然后选出我们想要的答案。</p><p><strong>适用场景</strong>：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，数独等等</li></ul><hr><h2 id="shi-yao-shi-hui-su-suan-fa" tabindex="-1" id="什么是回溯算法">什么是回溯算法</h2><h3 id="xing-xiang-hua-li-jie" tabindex="-1" id="形象化理解">形象化理解</h3><p>想象你在一个迷宫中寻找出口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">入口 → 岔路1 → 岔路2 → 死路 ✗</span><br><span class="line">     ↓</span><br><span class="line">     回退到岔路2</span><br><span class="line">     ↓</span><br><span class="line">     岔路2 → 岔路3 → 出口 ✓</span><br></pre></td></tr></table></figure><p>这就是回溯：<strong>尝试 → 失败 → 回退 → 再尝试</strong></p><h3 id="jue-ce-shu-ke-shi-hua" tabindex="-1" id="决策树可视化">决策树可视化</h3><p>回溯算法可以抽象为<strong>决策树的遍历过程</strong>：</p><pre><code class="highlight mermaid">graph TD    A[开始] --&gt; B[选择1]    A --&gt; C[选择2]    A --&gt; D[选择3]    B --&gt; E[选择1.1]    B --&gt; F[选择1.2]    C --&gt; G[选择2.1]    C --&gt; H[选择2.2]        style E fill:#90EE90    style H fill:#90EE90    style F fill:#FFB6C1    style G fill:#FFB6C1</code></pre><ul><li><strong>绿色节点</strong>：满足条件的解</li><li><strong>粉色节点</strong>：不满足条件，需要回溯</li></ul><hr><h2 id="hui-su-kuang-jia-mo-ban" tabindex="-1" id="回溯框架模板">回溯框架模板</h2><h3 id="tong-yong-mo-ban" tabindex="-1" id="通用模板">通用模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (满足结束条件) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(路径);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (选择 : 选择列表) &#123;</span><br><span class="line">        <span class="keyword">if</span> (不满足条件) <span class="keyword">continue</span>;  <span class="comment">// 剪枝</span></span><br><span class="line">        </span><br><span class="line">        做选择;</span><br><span class="line">        <span class="built_in">backtrack</span>(路径, 选择列表);  <span class="comment">// 递归</span></span><br><span class="line">        撤销选择;  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="san-yao-su" tabindex="-1" id="三要素">三要素</h3><ol><li><strong>路径（Path）</strong>：已经做出的选择</li><li><strong>选择列表（Choices）</strong>：当前可以做的选择</li><li><strong>结束条件（End Condition）</strong>：到达决策树底层，无法再做选择的条件</li></ol><pre><code class="highlight mermaid">graph LR    A[开始] --&gt; B&#123;满足结束条件?&#125;    B --&gt;|是| C[保存结果]    B --&gt;|否| D[遍历选择列表]    D --&gt; E&#123;是否有效?&#125;    E --&gt;|否| F[剪枝跳过]    E --&gt;|是| G[做选择]    G --&gt; H[递归调用]    H --&gt; I[撤销选择]    I --&gt; D    F --&gt; D    C --&gt; J[返回]    I --&gt; K&#123;还有选择?&#125;    K --&gt;|是| D    K --&gt;|否| J</code></pre><hr><h2 id="he-xin-si-xiang" tabindex="-1" id="核心思想">核心思想</h2><h3 id="hui-su-san-bu-qu" tabindex="-1" id="回溯三步曲">回溯三步曲</h3><ol><li><strong>做选择</strong>：将当前元素加入路径</li><li><strong>递归</strong>：基于当前选择继续探索</li><li><strong>撤销选择</strong>：将当前元素从路径中移除，尝试其他选择</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line">path.<span class="built_in">push_back</span>(choice);      <span class="comment">// 1. 做选择</span></span><br><span class="line"><span class="built_in">backtrack</span>(path, choices);    <span class="comment">// 2. 递归</span></span><br><span class="line">path.<span class="built_in">pop_back</span>();             <span class="comment">// 3. 撤销选择</span></span><br></pre></td></tr></table></figure><h3 id="guan-jian-te-xing" tabindex="-1" id="关键特性">关键特性</h3><ul><li><strong>时间换空间</strong>：通过回溯避免存储所有中间状态</li><li><strong>深度优先搜索（DFS）</strong>：本质上是DFS的一种实现</li><li><strong>剪枝优化</strong>：提前排除不可能的分支，提高效率</li></ul><hr><h2 id="jing-dian-wen-ti-xiang-jie" tabindex="-1" id="经典问题详解">经典问题详解</h2><h3 id="1-quan-pai-lie-wen-ti" tabindex="-1" id="1-全排列问题">1. 全排列问题</h3><blockquote><p><strong>LeetCode 46</strong>: 给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h4 id="jue-ce-shu" tabindex="-1" id="决策树">决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 []</span><br><span class="line">       /          |          \</span><br><span class="line">     [1]         [2]         [3]</span><br><span class="line">    /   \       /   \       /   \</span><br><span class="line"> [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]</span><br><span class="line">   |     |     |     |     |     |</span><br><span class="line">[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]</span><br></pre></td></tr></table></figure><h4 id="shi-xian" tabindex="-1" id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">permuteBacktrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; path, </span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="type">bool</span>&gt;&amp; used, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：路径长度等于数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;  <span class="comment">// 剪枝：已使用的元素跳过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">permuteBacktrack</span>(nums, path, used, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="zhi-xing-guo-cheng-shi-li" tabindex="-1" id="执行过程示例">执行过程示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3]</span><br><span class="line"></span><br><span class="line">步骤1: path=[], 选择1</span><br><span class="line">       path=[1], used=[T,F,F]</span><br><span class="line"></span><br><span class="line">步骤2: path=[1], 选择2</span><br><span class="line">       path=[1,2], used=[T,T,F]</span><br><span class="line"></span><br><span class="line">步骤3: path=[1,2], 选择3</span><br><span class="line">       path=[1,2,3], used=[T,T,T]</span><br><span class="line">       ✓ 找到一个解！</span><br><span class="line"></span><br><span class="line">步骤4: 回溯，撤销3</span><br><span class="line">       path=[1,2], used=[T,T,F]</span><br><span class="line"></span><br><span class="line">步骤5: 回溯，撤销2</span><br><span class="line">       path=[1], used=[T,F,F]</span><br><span class="line"></span><br><span class="line">步骤6: path=[1], 选择3</span><br><span class="line">       path=[1,3], used=[T,F,T]</span><br><span class="line">       ... (继续)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n × n!)<br><strong>空间复杂度</strong>：O(n)</p><hr><h3 id="2-n-huang-hou-wen-ti" tabindex="-1" id="2-N皇后问题">2. N皇后问题</h3><blockquote><p><strong>LeetCode 51</strong>: 在 n×n 的棋盘上放置 n 个皇后，使得它们不能相互攻击。</p></blockquote><p><strong>规则</strong>：皇后可以攻击同一行、同一列、同一对角线上的棋子。</p><h4 id="ke-shi-hua" tabindex="-1" id="可视化">可视化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4皇后的一个解：</span><br><span class="line"></span><br><span class="line">. Q . .     行0</span><br><span class="line">. . . Q     行1</span><br><span class="line">Q . . .     行2</span><br><span class="line">. . Q .     行3</span><br></pre></td></tr></table></figure><h4 id="jue-ce-shu-1" tabindex="-1" id="决策树-2">决策树</h4><pre><code class="highlight mermaid">graph TD    A[行0: 选择列] --&gt; B[列0]    A --&gt; C[列1]    A --&gt; D[列2]    A --&gt; E[列3]        C --&gt; F[行1: 列3]    F --&gt; G[行2: 列1]    G --&gt; H[行3: 列2 ✓]        B --&gt; I[行1: 检查...✗]    D --&gt; J[行1: 检查...✗]</code></pre><h4 id="shi-xian-1" tabindex="-1" id="实现-2">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nQueensBacktrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, </span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：所有行都放置了皇后</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = board[row].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidQueen</span>(board, row, col)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 剪枝：不合法位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">nQueensBacktrack</span>(board, row + <span class="number">1</span>, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidQueen</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查左上对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查右上对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n!)<br><strong>空间复杂度</strong>：O(n²)</p><hr><h3 id="3-zu-he-zong-he" tabindex="-1" id="3-组合总和">3. 组合总和</h3><blockquote><p><strong>LeetCode 39</strong>: 给定一个无重复元素的数组 <code>candidates</code> 和一个目标数 <code>target</code>，找出所有可以使数字和为 <code>target</code> 的组合。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br></pre></td></tr></table></figure><h4 id="jue-ce-shu-2" tabindex="-1" id="决策树-3">决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        []</span><br><span class="line">         /       |        |        \</span><br><span class="line">       [2]      [3]      [6]      [7]✓</span><br><span class="line">      / | \     / \       |</span><br><span class="line">  [2,2] ...  [3,3] ...  [6,?]</span><br><span class="line">   / \</span><br><span class="line">[2,2,2] [2,2,3]✓</span><br></pre></td></tr></table></figure><h4 id="shi-xian-2" tabindex="-1" id="实现-3">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">combinationBacktrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                          vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt; target) <span class="keyword">break</span>;  <span class="comment">// 剪枝：超过目标</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归（可重复使用，所以传入 i）</span></span><br><span class="line">        <span class="built_in">combinationBacktrack</span>(candidates, target - candidates[i], i, path, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>可以重复使用同一元素，所以递归时传入 <code>i</code> 而不是 <code>i+1</code></li><li>排序后可以提前剪枝</li></ul><hr><h3 id="4-zi-ji-wen-ti" tabindex="-1" id="4-子集问题">4. 子集问题</h3><blockquote><p><strong>LeetCode 78</strong>: 给定一个整数数组 <code>nums</code>，返回该数组所有可能的子集。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><h4 id="jue-ce-shu-3" tabindex="-1" id="决策树-4">决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 []✓</span><br><span class="line">       /          |          \</span><br><span class="line">     [1]✓        [2]✓        [3]✓</span><br><span class="line">    /   \          \</span><br><span class="line"> [1,2]✓ [1,3]✓   [2,3]✓</span><br><span class="line">   |</span><br><span class="line">[1,2,3]✓</span><br></pre></td></tr></table></figure><p><strong>关键</strong>：每个节点都是一个有效子集！</p><h4 id="shi-xian-3" tabindex="-1" id="实现-4">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsetsBacktrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个节点都是一个子集</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">subsetsBacktrack</span>(nums, i + <span class="number">1</span>, path, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n × 2ⁿ)<br><strong>空间复杂度</strong>：O(n)</p><hr><h3 id="5-gua-hao-sheng-cheng" tabindex="-1" id="5-括号生成">5. 括号生成</h3><blockquote><p><strong>LeetCode 22</strong>: 生成所有由 n 对括号组成的有效组合。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><h4 id="yue-shu-tiao-jian" tabindex="-1" id="约束条件">约束条件</h4><ol><li>左括号数量 ≤ n</li><li>右括号数量 ≤ 左括号数量</li></ol><h4 id="jue-ce-shu-4" tabindex="-1" id="决策树-5">决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        &quot;&quot;</span><br><span class="line">              /                    \</span><br><span class="line">            &quot;(&quot;                    ❌ &quot;)&quot; (违反规则2)</span><br><span class="line">       /         \</span><br><span class="line">    &quot;((&quot;        &quot;()&quot;</span><br><span class="line">   /   \       /   \</span><br><span class="line">&quot;(((&quot;  &quot;(()&quot; &quot;()&quot;  &quot;())&quot;❌</span><br></pre></td></tr></table></figure><h4 id="shi-xian-4" tabindex="-1" id="实现-5">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parenthesisBacktrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right,</span></span></span><br><span class="line"><span class="params"><span class="function">                          string&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加左括号</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">parenthesisBacktrack</span>(n, left + <span class="number">1</span>, right, path, result);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加右括号（剪枝）</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="built_in">parenthesisBacktrack</span>(n, left, right + <span class="number">1</span>, path, result);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(4ⁿ / √n)（卡特兰数）<br><strong>空间复杂度</strong>：O(n)</p><hr><h2 id="jian-zhi-you-hua-ji-qiao" tabindex="-1" id="剪枝优化技巧">剪枝优化技巧</h2><p>剪枝是提高回溯算法效率的关键！</p><h3 id="1-ti-qian-zhong-zhi" tabindex="-1" id="1-提前终止">1. 提前终止</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (当前状态已经不可能产生有效解) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 直接返回，不继续递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：组合总和中，如果当前和已经超过目标值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (candidates[i] &gt; target) <span class="keyword">break</span>;  <span class="comment">// 剪枝</span></span><br></pre></td></tr></table></figure><h3 id="2-pai-xu-you-hua" tabindex="-1" id="2-排序优化">2. 排序优化</h3><p>先排序，可以更早地剪枝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="3-bi-mian-zhong-fu" tabindex="-1" id="3-避免重复">3. 避免重复</h3><p>使用 <code>used</code> 数组或 <code>start</code> 索引避免重复计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列：used数组</span></span><br><span class="line"><span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合问题：start索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br></pre></td></tr></table></figure><h3 id="4-dui-cheng-xing-jian-zhi" tabindex="-1" id="4-对称性剪枝">4. 对称性剪枝</h3><p>利用问题的对称性减少搜索空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N皇后：只搜索一半，另一半通过对称获得</span></span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col &gt; n / <span class="number">2</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="jian-zhi-xiao-guo-dui-bi" tabindex="-1" id="剪枝效果对比">剪枝效果对比</h3><pre><code class="highlight mermaid">graph LR    A[无剪枝] --&gt;|搜索空间| B[10000节点]    C[有剪枝] --&gt;|搜索空间| D[100节点]        style B fill:#FFB6C1    style D fill:#90EE90</code></pre><hr><h2 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h2><h3 id="shi-jian-fu-za-du" tabindex="-1" id="时间复杂度">时间复杂度</h3><p>回溯算法的时间复杂度通常取决于：</p><ol><li><strong>决策树的深度</strong>：递归的层数</li><li><strong>每层的选择数量</strong>：for循环的次数</li></ol><table><thead><tr><th>问题</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>全排列</td><td>O(n × n!)</td><td>n层，每层最多n个选择</td></tr><tr><td>N皇后</td><td>O(n!)</td><td>每行选择递减</td></tr><tr><td>组合</td><td>O(2ⁿ)</td><td>每个元素选或不选</td></tr><tr><td>子集</td><td>O(n × 2ⁿ)</td><td>2ⁿ个子集，复制需要O(n)</td></tr></tbody></table><h3 id="kong-jian-fu-za-du" tabindex="-1" id="空间复杂度">空间复杂度</h3><p>主要考虑：</p><ol><li><strong>递归栈深度</strong>：O(深度)</li><li><strong>路径存储</strong>：O(路径长度)</li></ol><p>通常为 <strong>O(n)</strong> 或 <strong>O(树的高度)</strong></p><hr><h2 id="chang-jian-leet-code-ti-mu" tabindex="-1" id="常见LeetCode题目">常见LeetCode题目</h2><h3 id="ru-men-ji" tabindex="-1" id="入门级">入门级</h3><ul><li><a href="https://leetcode.com/problems/subsets/">LeetCode 78 - 子集</a></li><li><a href="https://leetcode.com/problems/combinations/">LeetCode 77 - 组合</a></li><li><a href="https://leetcode.com/problems/permutations/">LeetCode 46 - 全排列</a></li></ul><h3 id="zhong-ji" tabindex="-1" id="中级">中级</h3><ul><li><a href="https://leetcode.com/problems/combination-sum/">LeetCode 39 - 组合总和</a></li><li><a href="https://leetcode.com/problems/generate-parentheses/">LeetCode 22 - 括号生成</a></li><li><a href="https://leetcode.com/problems/palindrome-partitioning/">LeetCode 131 - 分割回文串</a></li></ul><h3 id="gao-ji" tabindex="-1" id="高级">高级</h3><ul><li><a href="https://leetcode.com/problems/n-queens/">LeetCode 51 - N皇后</a></li><li><a href="https://leetcode.com/problems/sudoku-solver/">LeetCode 37 - 解数独</a></li><li><a href="https://leetcode.com/problems/word-ladder-ii/">LeetCode 126 - 单词接龙 II</a></li></ul><hr><h2 id="hui-su-vs-dfs-vs-bfs" tabindex="-1" id="回溯-vs-DFS-vs-BFS">回溯 vs DFS vs BFS</h2><h3 id="dui-bi-biao" tabindex="-1" id="对比表">对比表</h3><table><thead><tr><th>特性</th><th>回溯</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>本质</td><td>带剪枝的DFS</td><td>深度优先搜索</td><td>广度优先搜索</td></tr><tr><td>数据结构</td><td>递归栈</td><td>栈/递归</td><td>队列</td></tr><tr><td>路径记录</td><td>显式维护</td><td>可选</td><td>可选</td></tr><tr><td>空间复杂度</td><td>O(h)</td><td>O(h)</td><td>O(w)</td></tr><tr><td>应用场景</td><td>所有解</td><td>单个解</td><td>最短路径</td></tr></tbody></table><blockquote><p>h = 树的高度, w = 树的宽度</p></blockquote><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>回溯 = 穷举 + 剪枝</strong></li><li><strong>三要素</strong>：路径、选择列表、结束条件</li><li><strong>三步曲</strong>：做选择 → 递归 → 撤销选择</li><li><strong>优化关键</strong>：剪枝！剪枝！剪枝！</li></ol><h3 id="jing-dian-mo-ban" tabindex="-1" id="经典模板">经典模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存储结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (选择 : 选择列表) &#123;</span><br><span class="line">        <span class="keyword">if</span> (剪枝条件) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        做选择;</span><br><span class="line">        <span class="built_in">backtrack</span>(新参数);</span><br><span class="line">        撤销选择;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xing-neng-you-hua-tips" tabindex="-1" id="性能优化-Tips">性能优化 Tips</h3><ol><li><strong>排序预处理</strong>：便于剪枝</li><li><strong>使用引用传参</strong>：减少复制开销</li><li><strong>位运算优化 used 数组</strong>：节省空间</li><li><strong>记忆化搜索</strong>：避免重复计算子问题</li></ol><blockquote><p>回溯算法是解决复杂搜索问题的利器。虽然时间复杂度较高，但通过巧妙的剪枝优化，可以在实际应用中取得很好的效果。掌握回溯算法，你将拥有解决大部分组合、排列、搜索类问题的能力！</p></blockquote><p><strong>推荐阅读</strong>：</p><ul><li><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 - 回溯算法</a></li><li><a href="https://leetcode.com/tag/backtracking/">LeetCode 精选回溯题目</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;yin-yan&quot; tabindex=&quot;-1&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="回溯" scheme="https://smarter.xin/tags/backtracking/"/>
    
    <category term="DFS" scheme="https://smarter.xin/tags/DFS/"/>
    
    <category term="递归" scheme="https://smarter.xin/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="剪枝" scheme="https://smarter.xin/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>AI Infra学习之旅-第一个vLLM程序</title>
    <link href="https://smarter.xin/posts/b21cbc80/"/>
    <id>https://smarter.xin/posts/b21cbc80/</id>
    <published>2025-12-31T05:31:59.000Z</published>
    <updated>2026-01-06T13:16:51.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qian-yan" tabindex="-1" id="前言">前言</h2><p>今天是我正式开始学习 AI Infrastructure 的第一天。作为一个对大模型推理充满好奇的初学者，我决定从实战开始——在免费的 Kaggle GPU 上运行 vLLM。这篇文章记录了我从零开始的完整过程，希望能帮助到和我一样的新手。</p><p><strong>核心目标</strong>: 今天就跑通第一个 vLLM 程序！</p><hr><h2 id="wei-shi-yao-xuan-ze-kaggle-v-llm" tabindex="-1" id="为什么选择-Kaggle-vLLM？">为什么选择 Kaggle + vLLM？</h2><p>在开始之前，我做了一些调研：</p><h3 id="wei-shi-yao-xuan-ze-kaggle" tabindex="-1" id="为什么选择-Kaggle？">为什么选择 Kaggle？</h3><ul><li>✅ <strong>完全免费</strong>: 每周 30 小时 GPU 时间</li><li>✅ <strong>无需配置</strong>: 预装了常用的深度学习库</li><li>✅ <strong>P100 GPU</strong>: 16GB 显存，足够运行中小型模型</li><li>✅ <strong>入门友好</strong>: 无需本地 GPU，浏览器即可使用</li></ul><h3 id="wei-shi-yao-xuan-ze-v-llm" tabindex="-1" id="为什么选择-vLLM？">为什么选择 vLLM？</h3><ul><li>✅ <strong>高性能</strong>: 比 HuggingFace Transformers 快数倍</li><li>✅ <strong>易用性</strong>: API 设计简洁，上手快</li><li>✅ <strong>工业级</strong>: 被多个公司用于生产环境</li><li>✅ <strong>学习价值</strong>: 涉及 PagedAttention 等前沿技术</li></ul><hr><h2 id="shi-zhan-bu-zou" tabindex="-1" id="实战步骤">实战步骤</h2><h3 id="step-1-zhu-ce-kaggle-zhang-hao" tabindex="-1" id="Step-1-注册-Kaggle-账号">Step 1: 注册 Kaggle 账号</h3><p>这一步非常简单：</p><ol><li>访问 <a href="https://www.kaggle.com">Kaggle 官网</a></li><li>使用 Google 账号快速注册</li><li><strong>重要</strong>: 验证手机号（这是使用 GPU 的必要条件，也可以使用Persona进行验证）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E7%AC%AC%E4%B8%80%E4%B8%AAvLLM%E7%A8%8B%E5%BA%8F/2025-12-31-13-59-25-d6c76c.png" alt="image-20251231134434642"></p><hr><h3 id="step-2-chuang-jian-gpu-notebook" tabindex="-1" id="Step-2-创建-GPU-Notebook">Step 2: 创建 GPU Notebook</h3><p>创建 Notebook 的步骤：</p><ol><li>点击右上角 <strong>“Create” → “New Notebook”</strong></li><li>在右侧设置面板中：<ul><li><strong>Accelerator</strong> → 选择 <code>GPU P100</code> ✅</li><li><strong>Internet</strong> → 打开 <code>On</code> ✅</li></ul></li><li>等待环境启动（大约 30 秒）</li></ol><p>启动后，在第一个 cell 中运行以下命令验证 GPU：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure><p>如果看到类似以下输出，说明 GPU 环境已就绪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 525.xx.xx    Driver Version: 525.xx.xx    CUDA Version: 12.0     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 |</span><br><span class="line">| N/A   37C    P0    26W / 250W |      0MiB / 16280MiB |      0%      Default |</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E7%AC%AC%E4%B8%80%E4%B8%AAvLLM%E7%A8%8B%E5%BA%8F/2025-12-31-13-59-25-ae1d61.png" alt="image-20251231134721197"></p><hr><h3 id="step-3-an-zhuang-v-llm" tabindex="-1" id="Step-3-安装-vLLM">Step 3: 安装 vLLM</h3><p>在新的 cell 中运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 vLLM</span></span><br><span class="line">!pip install vllm -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="keyword">import</span> vllm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;✅ vLLM 安装成功！版本: <span class="subst">&#123;vllm.__version__&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>安装可能需要 10-15 分钟，请耐心等待。安装完成后，你应该看到类似的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✅ vLLM 安装成功！版本: 0.x.x</span><br></pre></td></tr></table></figure><hr><h3 id="step-4-yun-xing-di-yi-ge-tui-li-cheng-xu" tabindex="-1" id="Step-4-运行第一个推理程序">Step 4: 运行第一个推理程序</h3><p>这是今天的重头戏！我使用 <code>facebook/opt-125m</code> 这个小模型进行测试（只有 125M 参数，加载速度快）。</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vllm <span class="keyword">import</span> LLM, SamplingParams</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【核心代码块1】加载模型</span></span><br><span class="line">llm = LLM(</span><br><span class="line">    model=<span class="string">&quot;facebook/opt-125m&quot;</span>,  <span class="comment"># 小模型,快速测试</span></span><br><span class="line">    trust_remote_code=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【核心代码块2】准备输入</span></span><br><span class="line">prompts = [</span><br><span class="line">    <span class="string">&quot;Hello, my name is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The capital of France is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The meaning of life is&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【核心代码块3】配置采样参数</span></span><br><span class="line">sampling_params = SamplingParams(</span><br><span class="line">    temperature=<span class="number">0.8</span>,</span><br><span class="line">    top_p=<span class="number">0.95</span>,</span><br><span class="line">    max_tokens=<span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【核心代码块4】执行推理</span></span><br><span class="line">outputs = llm.generate(prompts, sampling_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【核心代码块5】查看结果</span></span><br><span class="line"><span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">    prompt = output.prompt</span><br><span class="line">    generated_text = output.outputs[<span class="number">0</span>].text</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Prompt: <span class="subst">&#123;prompt!r&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Generated: <span class="subst">&#123;generated_text!r&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p><strong>我的运行结果</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E7%AC%AC%E4%B8%80%E4%B8%AAvLLM%E7%A8%8B%E5%BA%8F/2025-12-31-13-59-25-bf3b3c.png" alt="image-20251231135055273"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prompt: &#x27;Hello, my name is&#x27;</span><br><span class="line">Generated: &#x27; Joel, my dad is my friend and we are in a relationship...</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Prompt: &#x27;The capital of France is&#x27;</span><br><span class="line">Generated: &#x27; at an impasse with the French government over its future as the euro zone’s biggest economy...</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Prompt: &#x27;The meaning of life is&#x27;</span><br><span class="line">Generated: &quot; measured in the things that are accomplished in it.\nMost of the time...</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="step-5-xing-neng-ce-shi" tabindex="-1" id="Step-5-性能测试">Step 5: 性能测试</h3><p>为了了解 vLLM 的性能，我运行了一个简单的吞吐量测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备 10 个相同请求</span></span><br><span class="line">test_prompts = [<span class="string">&quot;Explain AI in simple terms&quot;</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试吞吐量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;⏱️  性能测试开始...&quot;</span>)</span><br><span class="line">start = time.time()</span><br><span class="line">outputs = llm.generate(test_prompts, sampling_params)</span><br><span class="line">elapsed = time.time() - start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算指标</span></span><br><span class="line">total_tokens = <span class="built_in">sum</span>(<span class="built_in">len</span>(o.outputs[<span class="number">0</span>].token_ids) <span class="keyword">for</span> o <span class="keyword">in</span> outputs)</span><br><span class="line">throughput = total_tokens / elapsed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span>*<span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;📈 我的第一次 vLLM 运行记录&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;模型:        OPT-125M&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;GPU:         Kaggle P100&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总耗时:      <span class="subst">&#123;elapsed:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总 Token 数: <span class="subst">&#123;total_tokens&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;吞吐量:      <span class="subst">&#123;throughput:<span class="number">.2</span>f&#125;</span> tokens/秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;日期:        <span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p><strong>我的性能数据</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/AI-Infra%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-%E7%AC%AC%E4%B8%80%E4%B8%AAvLLM%E7%A8%8B%E5%BA%8F/2025-12-31-13-59-25-f16f3d.png" alt="image-20251231135516539"></p><blockquote><table><thead><tr><th>指标</th><th>数值</th></tr></thead><tbody><tr><td>模型</td><td>OPT-125M</td></tr><tr><td>GPU</td><td>Kaggle P100</td></tr><tr><td>总耗时</td><td>0.58 秒</td></tr><tr><td>总 Token 数</td><td>892</td></tr><tr><td>吞吐量</td><td>1539.24 tokens/秒</td></tr></tbody></table></blockquote><hr><h2 id="cai-guo-de-keng-yu-jie-jue-fang-an" tabindex="-1" id="踩过的坑与解决方案">踩过的坑与解决方案</h2><h3 id="wen-ti-1-kaggle-gpu-bu-ke-yong" tabindex="-1" id="问题-1-Kaggle-GPU-不可用">问题 1: Kaggle GPU 不可用</h3><p><strong>现象</strong>: 设置中看不到 GPU 选项<br><strong>原因</strong>: 没有验证手机号<br><strong>解决</strong>: 在账号设置中完成手机验证</p><h3 id="wen-ti-2-v-llm-an-zhuang-chao-shi" tabindex="-1" id="问题-2-vLLM-安装超时">问题 2: vLLM 安装超时</h3><p><strong>现象</strong>: <code>pip install vllm</code> 一直卡住<br><strong>解决</strong>: 重启 Notebook，或者切换到 Google Colab</p><h3 id="wen-ti-3-mo-xing-xia-zai-su-du-man" tabindex="-1" id="问题-3-模型下载速度慢">问题 3: 模型下载速度慢</h3><p><strong>现象</strong>: 加载模型时长时间无响应<br><strong>解决</strong>: 使用 HuggingFace 镜像站</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;HF_ENDPOINT&#x27;</span>] = <span class="string">&#x27;https://hf-mirror.com&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="xie-zai-zui-hou" tabindex="-1" id="写在最后">写在最后</h2><p>第一天的学习让我深刻体会到：<strong>AI Infrastructure 并不遥远，动手实践才是最好的老师</strong>。</p><p>如果你也想开始学习 AI Infra，我的建议是：</p><ol><li><strong>不要被理论吓倒</strong> - 先跑起来，再慢慢理解</li><li><strong>选择免费资源</strong> - Kaggle/Colab 足够初学者使用</li><li><strong>从小模型开始</strong> - 125M 参数的模型几秒就能加载</li><li><strong>记录每一步</strong> - 写博客是最好的复习方式</li></ol><p><strong>记住</strong>: 慢一点没关系，停下来才可惜。💪</p><hr><h2 id="can-kao-zi-liao" tabindex="-1" id="参考资料">参考资料</h2><ul><li><a href="https://docs.vllm.ai/">vLLM 官方文档</a></li><li><a href="https://www.kaggle.com/docs/notebooks">Kaggle GPU 使用指南</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;qian-yan&quot; tabindex=&quot;-1&quot; id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天是我正式开始学习 AI Infrastructure 的第一天。作为一个对大模型推理充满好奇的初学者，我决定从实战开始——在免费的 Kaggle GPU 上运行</summary>
        
      
    
    
    
    <category term="AI Infra" scheme="https://smarter.xin/categories/ai-infra/"/>
    
    
    <category term="vLLM" scheme="https://smarter.xin/tags/vLLM/"/>
    
    <category term="AI Infrastructure" scheme="https://smarter.xin/tags/AI-Infrastructure/"/>
    
    <category term="Kaggle" scheme="https://smarter.xin/tags/Kaggle/"/>
    
    <category term="GPU" scheme="https://smarter.xin/tags/GPU/"/>
    
    <category term="大模型推理" scheme="https://smarter.xin/tags/llm-inference/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++</title>
    <link href="https://smarter.xin/posts/162e86b7/"/>
    <id>https://smarter.xin/posts/162e86b7/</id>
    <published>2025-12-22T02:53:59.000Z</published>
    <updated>2026-01-06T13:16:51.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="effective-modern-c-42-tiao-gai-shan-c-11-he-c-14-dai-ma-de-jian-yi" tabindex="-1">Effective Modern C++：42条改善C++11和C++14代码的建议</h1><blockquote><p>深入理解 Effective Modern C++ 的核心思想，掌握现代C++最佳实践</p></blockquote><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>《Effective Modern C++》是 Scott Meyers 的经典著作，提供了 42 条改善 C++11 和 C++14 代码的具体建议。本文总结这些核心要点，帮助你写出更现代、更高效的 C++ 代码。</p><p><strong>核心主题</strong>：</p><ul><li>类型推导的陷阱与最佳实践</li><li>auto 的正确使用</li><li>移动语义和完美转发</li><li>智能指针的选择</li><li>Lambda 表达式的优化</li><li>并发编程</li></ul><hr><h2 id="di-yi-zhang-lei-xing-tui-dao" tabindex="-1" id="第一章：类型推导">第一章：类型推导</h2><h3 id="item-1-li-jie-mo-ban-lei-xing-tui-dao" tabindex="-1" id="Item-1-理解模板类型推导">Item 1: 理解模板类型推导</h3><p>模板类型推导有三种情况，取决于 ParamType 的形式。</p><p><strong>规则总结</strong>：</p><pre><code class="highlight mermaid">graph TD    A[模板推导] --&gt; B&#123;ParamType类型&#125;    B --&gt;|指针/引用| C[保留const]    B --&gt;|万能引用| D[左值/右值分别推导]    B --&gt;|按值传递| E[丢弃const和引用]</code></pre><p><strong>关键要点</strong>：</p><ul><li>引用和指针不同时，const 被保留</li><li>万能引用（T&amp;&amp;）区分左值和右值</li><li>按值传递会忽略 const 和引用</li></ul><h3 id="item-2-li-jie-auto-lei-xing-tui-dao" tabindex="-1" id="Item-2-理解-auto-类型推导">Item 2: 理解 auto 类型推导</h3><p><code>auto</code> 与模板推导几乎完全相同，唯一例外是花括号初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;     <span class="comment">// int</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;      <span class="comment">// int  </span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;   <span class="comment">// std::initializer_list&lt;int&gt; ❌陷阱！</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;      <span class="comment">// C++17: int, C++14: std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p><strong>要记住的事</strong>：</p><ul><li>auto 推导通常与模板推导相同</li><li>auto 假定花括号初始化代表 std::initializer_list</li><li>函数返回值或 lambda 参数中的 auto 使用模板推导规则</li></ul><h3 id="item-3-li-jie-decltype" tabindex="-1" id="Item-3-理解-decltype">Item 3: 理解 decltype</h3><p><code>decltype</code> 总是返回表达式的确切类型，不会丢失 const 或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i;           <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(i) d = i;    <span class="comment">// const int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 的 decltype(auto)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];  <span class="comment">// 完美转发返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>括号陷阱</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x)   t1;   <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) t2;   <span class="comment">// int&amp; ⚠️ 危险！</span></span><br></pre></td></tr></table></figure><h3 id="item-4-xue-hui-cha-kan-lei-xing-tui-dao-jie-guo" tabindex="-1" id="Item-4-学会查看类型推导结果">Item 4: 学会查看类型推导结果</h3><p>三种方法：</p><ol><li><strong>IDE 编辑器</strong>：快速但可能不准</li><li><strong>编译器诊断</strong>：利用编译错误</li><li><strong>运行时输出</strong>：typeid 和 Boost.TypeIndex</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最可靠的方法：故意制造编译错误</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;  <span class="comment">// Type Displayer</span></span><br><span class="line"></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;  <span class="comment">// 编译器会显示类型</span></span><br></pre></td></tr></table></figure><hr><h2 id="di-er-zhang-auto" tabindex="-1" id="第二章：auto">第二章：auto</h2><h3 id="item-5-you-xian-shi-yong-auto-er-fei-xian-shi-lei-xing-sheng-ming" tabindex="-1" id="Item-5-优先使用-auto-而非显式类型声明">Item 5: 优先使用 auto 而非显式类型声明</h3><p><strong>优点</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 避免未初始化变量</span></span><br><span class="line"><span class="type">int</span> x;        <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">0</span>;   <span class="comment">// 必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 避免类型不匹配</span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：每次迭代都拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确：零拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 简化复杂类型</span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;, </span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt; func;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化为</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; lhs, <span class="type">const</span> <span class="keyword">auto</span>&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> *lhs &lt; *rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>性能优势</strong>：</p><table><thead><tr><th>场景</th><th>显式类型</th><th>auto</th><th>性能</th></tr></thead><tbody><tr><td>Lambda</td><td>std::function</td><td>auto</td><td>auto 快 2-10倍</td></tr><tr><td>容器遍历</td><td>可能类型错误</td><td>总是正确</td><td>避免拷贝</td></tr><tr><td>闭包</td><td>无法表达</td><td>完美捕获</td><td>零开销</td></tr></tbody></table><h3 id="item-6-dang-auto-tui-dao-chu-fei-yu-qi-lei-xing-shi-shi-yong-xian-shi-lei-xing-chu-shi-hua" tabindex="-1" id="Item-6-当-auto-推导出非预期类型时使用显式类型初始化">Item 6: 当 auto 推导出非预期类型时使用显式类型初始化</h3><p><strong>代理类陷阱</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];  <span class="comment">// ❌ 返回代理对象</span></span><br><span class="line"><span class="comment">// highPriority 不是 bool，而是临时的代理类</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];  <span class="comment">// ✓ 正确</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：显式类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p><strong>其他代理类场景</strong>：</p><ul><li><code>std::vector&lt;bool&gt;::reference</code></li><li><code>Matrix</code> 表达式模板</li><li>智能指针的代理</li></ul><hr><h2 id="di-san-zhang-zhuan-xiang-xian-dai-c" tabindex="-1" id="第三章：转向现代C">第三章：转向现代C++</h2><h3 id="item-7-chuang-jian-dui-xiang-shi-qu-fen-he" tabindex="-1" id="Item-7-创建对象时区分-和">Item 7: 创建对象时区分 () 和 {}</h3><p><strong>三种初始化语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;     <span class="comment">// 圆括号</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;    <span class="comment">// 等号</span></span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;     <span class="comment">// 花括号（统一初始化）</span></span><br></pre></td></tr></table></figure><p><strong>花括号优点</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 可用于任何初始化场景</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;      <span class="comment">// ✓ 成员初始化</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;     <span class="comment">// ✓ 也可以</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;      <span class="comment">// ❌ 不行</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 禁止隐式窄化转换</span></span><br><span class="line"><span class="type">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> y&#123;x&#125;;      <span class="comment">// ❌ 编译错误，禁止窄化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(x)</span></span>;      <span class="comment">// ⚠️ 允许，但丢失精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 免疫最令人烦恼的解析</span></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;    <span class="comment">// ❌ 函数声明！</span></span><br><span class="line">Widget w3&#123;&#125;;    <span class="comment">// ✓ 调用默认构造函数</span></span><br></pre></td></tr></table></figure><p><strong>陷阱</strong>：std::initializer_list 构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">// 10个元素，每个值为20</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;  <span class="comment">// 2个元素：10和20</span></span><br></pre></td></tr></table></figure><h3 id="item-8-you-xian-shi-yong-nullptr-er-fei-0-huo-null" tabindex="-1" id="Item-8-优先使用-nullptr-而非-0-或-NULL">Item 8: 优先使用 nullptr 而非 0 或 NULL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);        <span class="comment">// 调用 f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);     <span class="comment">// 可能不编译，或调用 f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用 f(void*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板中的优势</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">call</span><span class="params">(FuncType func, PtrType ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">call</span>(f, <span class="number">0</span>);        <span class="comment">// 错误：推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">call</span>(f, <span class="literal">nullptr</span>);  <span class="comment">// ✓ 正确</span></span><br></pre></td></tr></table></figure><h3 id="item-9-you-xian-shi-yong-bie-ming-sheng-ming-er-fei-typedef" tabindex="-1" id="Item-9-优先使用别名声明而非-typedef">Item 9: 优先使用别名声明而非 typedef</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef</span></span><br><span class="line"><span class="keyword">typedef</span> std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;</span><br><span class="line">    UPtrMapSS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using (更清晰)</span></span><br><span class="line"><span class="keyword">using</span> UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板别名 - typedef 无法做到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;  <span class="comment">// ✓ 简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 需要</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;  <span class="comment">// ❌ 繁琐</span></span><br></pre></td></tr></table></figure><h3 id="item-10-11-you-xian-shi-yong-xian-yu-enum-he-deleted-han-shu" tabindex="-1" id="Item-10-11-优先使用限域-enum-和-deleted-函数">Item 10-11: 优先使用限域 enum 和 deleted 函数</h3><p><strong>限域枚举</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 enum：不限域</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;  <span class="comment">// ❌ 错误！white 已被定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 enum class：限域</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;           <span class="comment">// ✓ OK</span></span><br><span class="line">Color c = Color::white;       <span class="comment">// 必须限定</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;        <span class="comment">// 也可以</span></span><br></pre></td></tr></table></figure><p><strong>deleted 函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止隐式转换</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;   <span class="comment">// 拒绝 char</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;   <span class="comment">// 拒绝 bool</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝 double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;  <span class="comment">// const char* 也被拒绝</span></span><br></pre></td></tr></table></figure><h3 id="item-12-15-te-shu-cheng-yuan-han-shu-he-you-hua" tabindex="-1" id="Item-12-15-特殊成员函数和优化">Item 12-15: 特殊成员函数和优化</h3><p><strong>noexcept 的重要性</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs) <span class="keyword">noexcept</span>  <span class="comment">// ✓ 推荐</span></span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(rhs.name);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// noexcept 让 std::vector 使用移动而非拷贝</span></span><br><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">vw.<span class="built_in">push_back</span>(<span class="built_in">Widget</span>());  <span class="comment">// 如果没有 noexcept，会拷贝而非移动</span></span><br></pre></td></tr></table></figure><hr><h2 id="di-si-zhang-zhi-neng-zhi-zhen" tabindex="-1" id="第四章：智能指针">第四章：智能指针</h2><h3 id="item-18-shi-yong-std-unique-ptr-guan-li-du-zhan-suo-you-quan-zi-yuan" tabindex="-1" id="Item-18-使用-std-unique-ptr-管理独占所有权资源">Item 18: 使用 std::unique_ptr 管理独占所有权资源</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> : <span class="keyword">public</span> Investment &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Stock&gt;();  <span class="comment">// C++14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function">        <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 创建 Stock */</span>)</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>零开销（与裸指针相同大小）</li><li>独占所有权</li><li>可转换为 shared_ptr</li></ul><h3 id="item-19-shi-yong-std-shared-ptr-guan-li-gong-xiang-suo-you-quan-zi-yuan" tabindex="-1" id="Item-19-使用-std-shared-ptr-管理共享所有权资源">Item 19: 使用 std::shared_ptr 管理共享所有权资源</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">    <span class="keyword">delete</span> pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(loggingDel)</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;  <span class="comment">// 删除器是类型的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt;</span></span><br><span class="line"><span class="function">    <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;  <span class="comment">// 删除器不是类型的一部分</span></span><br></pre></td></tr></table></figure><p><strong>引用计数机制</strong>：</p><pre><code class="highlight mermaid">graph LR    A[shared_ptr 1] --&gt; C[控制块]    B[shared_ptr 2] --&gt; C    C --&gt; D[对象]    C --&gt; E[引用计数: 2]    C --&gt; F[弱引用计数]    C --&gt; G[删除器]</code></pre><p><strong>性能开销</strong>：</p><ul><li>控制块动态分配</li><li>引用计数原子操作</li><li>虚函数调用（删除器）</li></ul><h3 id="item-20-shi-yong-std-weak-ptr-jie-jue-xuan-kong-zhi-zhen" tabindex="-1" id="Item-20-使用-std-weak-ptr-解决悬空指针">Item 20: 使用 std::weak_ptr 解决悬空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;  <span class="comment">// wpw 指向 Widget</span></span><br><span class="line"></span><br><span class="line">spw = <span class="literal">nullptr</span>;  <span class="comment">// Widget 被销毁，wpw 悬空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spw == <span class="literal">nullptr</span>) &#123;  <span class="comment">// ✓ 检测共享指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>()) &#123;   <span class="comment">// ✓ 检测弱指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子检查并访问</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw2 = wpw.<span class="built_in">lock</span>();  <span class="comment">// 如果 wpw 过期则返回 null</span></span><br><span class="line"><span class="keyword">auto</span> spw3 = wpw.<span class="built_in">lock</span>();</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：</p><ol><li><strong>缓存</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();  <span class="comment">// 尝试从缓存获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                   <span class="comment">// 不在缓存中</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);</span><br><span class="line">        cache[id] = objPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>观察者模式</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; wo : observers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> o = wo.<span class="built_in">lock</span>()) &#123;  <span class="comment">// 检查观察者是否存活</span></span><br><span class="line">                o-&gt;<span class="built_in">update</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="item-21-you-xian-shi-yong-std-make-unique-he-std-make-shared" tabindex="-1" id="Item-21-优先使用-std-make-unique-和-std-make-shared">Item 21: 优先使用 std::make_unique 和 std::make_shared</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不推荐</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 推荐</span></span><br><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点1: 异常安全</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());</span><br><span class="line"><span class="comment">// ⚠️ 可能泄漏：new Widget 可能在 computePriority() 抛异常后完成</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), <span class="built_in">computePriority</span>());</span><br><span class="line"><span class="comment">// ✓ 安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点2: 性能更好</span></span><br><span class="line"><span class="keyword">auto</span> spw1 = std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget);  <span class="comment">// 2次分配</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();            <span class="comment">// 1次分配</span></span><br></pre></td></tr></table></figure><p><strong>不能使用 make 函数的情况</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> deleter = [](Widget* pw) &#123; <span class="keyword">delete</span> pw; &#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget <span class="title">decltype</span><span class="params">(deleter)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, deleter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 花括号初始化</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">// 10个20</span></span><br><span class="line"><span class="comment">// 想要&#123;10, 20&#125;只能：</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure><hr><h2 id="di-wu-zhang-you-zhi-yin-yong-yi-dong-yu-yi-he-wan-mei-zhuan-fa" tabindex="-1" id="第五章：右值引用、移动语义和完美转发">第五章：右值引用、移动语义和完美转发</h2><h3 id="item-23-li-jie-std-move-he-std-forward" tabindex="-1" id="Item-23-理解-std-move-和-std-forward">Item 23: 理解 std::move 和 std::forward</h3><p><strong>std::move 无条件转换为右值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)),</span><br><span class="line">          <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p)) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move 的实现（简化）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::forward 条件转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;   <span class="comment">// 处理左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;        <span class="comment">// 处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对比</strong>：</p><table><thead><tr><th>特性</th><th>std::move</th><th>std::forward</th></tr></thead><tbody><tr><td>用途</td><td>无条件转右值</td><td>条件转发</td></tr><tr><td>参数</td><td>通用引用</td><td>通用引用</td></tr><tr><td>使用场景</td><td>移动构造/赋值</td><td>完美转发</td></tr></tbody></table><h3 id="item-24-qu-fen-mo-neng-yin-yong-he-you-zhi-yin-yong" tabindex="-1" id="Item-24-区分万能引用和右值引用">Item 24: 区分万能引用和右值引用</h3><p><strong>万能引用的判断标准</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// 万能引用（有类型推导）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;  <span class="comment">// 万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>;  <span class="comment">// 右值引用（无类型推导）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">// 右值引用（不是 T&amp;&amp;）</span></span><br></pre></td></tr></table></figure><h3 id="item-25-dui-you-zhi-yin-yong-shi-yong-std-move-dui-mo-neng-yin-yong-shi-yong-std-forward" tabindex="-1" id="Item-25-对右值引用使用-std-move，对万能引用使用-std-forward">Item 25: 对右值引用使用 std::move，对万能引用使用 std::forward</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)) &#123;&#125;  <span class="comment">// rhs 是右值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);  <span class="comment">// newName 是万能引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>错误示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不要对右值引用使用 forward</span></span><br><span class="line"><span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">name</span>(std::forward&lt;Widget&gt;(rhs).name) &#123;&#125;  <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不要对万能引用使用 move</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">// 可能移动左值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-26-bi-mian-zhong-zai-mo-neng-yin-yong" tabindex="-1" id="Item-26-避免重载万能引用">Item 26: 避免重载万能引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 问题代码</span></span><br><span class="line">std::multiset&lt;std::string&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));  <span class="comment">// ✓</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);                 <span class="comment">// ✓</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">logAndAdd</span>(petName);  <span class="comment">// ✓ 拷贝左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> nameIdx = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx);  <span class="comment">// ❌ 问题：T 推导为 short&amp;，不会转换为 string</span></span><br></pre></td></tr></table></figure><h3 id="item-27-30-shou-xi-wan-mei-zhuan-fa-shi-bai-de-qing-kuang" tabindex="-1" id="Item-27-30-熟悉完美转发失败的情况">Item 27-30: 熟悉完美转发失败的情况</h3><p><strong>完美转发失败的情况</strong>：</p><ol><li><strong>花括号初始化</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);  <span class="comment">// ✓ OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);  <span class="comment">// ❌ 错误：无法推导</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案</span></span><br><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fwd</span>(il);  <span class="comment">// ✓</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>0 或 NULL 作为空指针</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(<span class="literal">NULL</span>);  <span class="comment">// ❌ 推导为整数</span></span><br><span class="line"><span class="built_in">fwd</span>(<span class="number">0</span>);     <span class="comment">// ❌ 推导为整数</span></span><br><span class="line"><span class="built_in">fwd</span>(<span class="literal">nullptr</span>);  <span class="comment">// ✓</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>仅声明的 static const 成员变量</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; widgetData;</span><br><span class="line">widgetData.<span class="built_in">reserve</span>(Widget::MinVals);  <span class="comment">// ✓</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals);  <span class="comment">// ❌ 链接错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>重载函数名和模板名</strong></li><li><strong>位域</strong></li></ol><hr><h2 id="di-liu-zhang-lambda-biao-da-shi" tabindex="-1" id="第六章：Lambda表达式">第六章：Lambda表达式</h2><h3 id="item-31-bi-mian-mo-ren-bu-huo-mo-shi" tabindex="-1" id="Item-31-避免默认捕获模式">Item 31: 避免默认捕获模式</h3><p><strong>按值捕获的问题</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line">    </span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;  <span class="comment">// ❌ 悬空引用</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针捕获的问题</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="comment">// ❌ 捕获的是 this 指针，不是 divisor</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> divisor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> divisorCopy = divisor;  <span class="comment">// 拷贝数据成员</span></span><br><span class="line">        </span><br><span class="line">        filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [divisorCopy](<span class="type">int</span> value) &#123;  <span class="comment">// ✓ 显式捕获副本</span></span><br><span class="line">                <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="item-32-shi-yong-chu-shi-hua-bu-huo-jiang-dui-xiang-yi-ru-bi-bao" tabindex="-1" id="Item-32-使用初始化捕获将对象移入闭包">Item 32: 使用初始化捕获将对象移入闭包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14: 初始化捕获</span></span><br><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)] &#123;  <span class="comment">// 移动进闭包</span></span><br><span class="line">    <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11: 使用 bind 模拟</span></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">    [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; pw) &#123;</span><br><span class="line">        <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    std::<span class="built_in">make_unique</span>&lt;Widget&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="item-33-34-lambda-yu-std-function" tabindex="-1" id="Item-33-34-Lambda-与-std-function">Item 33-34: Lambda 与 std::function</h3><p><strong>优先使用 auto 而非 std::function</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::function</span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; func1 = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto</span></span><br><span class="line"><span class="keyword">auto</span> func2 = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;;</span><br></pre></td></tr></table></figure><p><strong>性能对比</strong>：</p><table><thead><tr><th>特性</th><th>std::function</th><th>auto</th></tr></thead><tbody><tr><td>内存</td><td>固定大小，可能堆分配</td><td>闭包大小</td></tr><tr><td>内联</td><td>几乎不可能</td><td>容易内联</td></tr><tr><td>性能</td><td>慢</td><td>快</td></tr></tbody></table><hr><h2 id="di-qi-zhang-bing-fa-api" tabindex="-1" id="第七章：并发API">第七章：并发API</h2><h3 id="item-35-you-xian-shi-yong-ji-yu-ren-wu-er-fei-ji-yu-xian-cheng-de-bian-cheng" tabindex="-1" id="Item-35-优先使用基于任务而非基于线程的编程">Item 35: 优先使用基于任务而非基于线程的编程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;  <span class="comment">// ❌ 无法获取返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于任务</span></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork);  <span class="comment">// ✓ 可以获取返回值</span></span><br><span class="line"><span class="keyword">auto</span> result = fut.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p><strong>std::async 的优势</strong>：</p><ul><li>自动管理线程</li><li>可以获取返回值</li><li>可以传播异常</li><li>避免过度订阅</li></ul><h3 id="item-36-40-bing-fa-bian-cheng-zui-jia-shi-jian" tabindex="-1" id="Item-36-40-并发编程最佳实践">Item 36-40: 并发编程最佳实践</h3><p><strong>使用 std::atomic 而非 volatile</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ volatile 不提供原子性</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++counter;  <span class="comment">// 不是原子的！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ atomic 提供原子性</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++counter;  <span class="comment">// 原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>避免在 std::atomic 上使用复制操作</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> y = x;  <span class="comment">// ❌ 错误：deleted</span></span><br><span class="line"><span class="keyword">auto</span> y = x.<span class="built_in">load</span>();  <span class="comment">// ✓ 显式读取</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">z = x; <span class="comment">// ❌ 错误：deleted</span></span><br><span class="line">z.<span class="built_in">store</span>(x.<span class="built_in">load</span>());  <span class="comment">// ✓ 显式存储</span></span><br></pre></td></tr></table></figure><hr><h2 id="di-ba-zhang-wei-diao" tabindex="-1" id="第八章：微调">第八章：微调</h2><h3 id="item-41-dui-yu-ke-kao-bei-de-xing-can-dang-yi-dong-cheng-ben-di-qie-zong-hui-bei-kao-bei-shi-kao-lu-an-zhi-chuan-di" tabindex="-1" id="Item-41-对于可拷贝的形参，当移动成本低且总会被拷贝时，考虑按值传递">Item 41: 对于可拷贝的形参，当移动成本低且总会被拷贝时，考虑按值传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方案1: 重载左值和右值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案2: 万能引用</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案3: 按值传递（在某些情况下最优）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>性能对比</strong>：</p><table><thead><tr><th>调用方式</th><th>重载</th><th>万能引用</th><th>按值传递</th></tr></thead><tbody><tr><td>左值</td><td>1次拷贝</td><td>1次拷贝</td><td>1次拷贝+1次移动</td></tr><tr><td>右值</td><td>1次移动</td><td>1次移动</td><td>1次移动+1次移动</td></tr></tbody></table><h3 id="item-42-kao-lu-shi-yong-zhi-ru-er-fei-cha-ru" tabindex="-1" id="Item-42-考虑使用置入而非插入">Item 42: 考虑使用置入而非插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);  <span class="comment">// 创建临时对象，然后移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 置入</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);  <span class="comment">// 直接在容器中构造，避免临时对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能对比</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>));  <span class="comment">// 1个临时对象</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);             <span class="comment">// 无临时对象，直接构造</span></span><br></pre></td></tr></table></figure><p><strong>何时使用置入</strong>：</p><ul><li>值被构造进容器，而非赋值</li><li>传递的参数类型与容器元素类型不同</li><li>容器不太可能拒绝新值（如 set）</li></ul><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian-zong-jie" tabindex="-1" id="核心要点总结">核心要点总结</h3><pre><code class="highlight mermaid">graph TD    A[Effective Modern C++] --&gt; B[类型推导]    A --&gt; C[auto]    A --&gt; D[移动语义]    A --&gt; E[智能指针]    A --&gt; F[Lambda]    A --&gt; G[并发]        B --&gt; B1[模板推导3种情况]    B --&gt; B2[decltype陷阱]        C --&gt; C1[优先使用auto]    C --&gt; C2[注意代理类]        D --&gt; D1[move无条件转右值]    D --&gt; D2[forward条件转发]    D --&gt; D3[完美转发失败情况]        E --&gt; E1[unique_ptr独占]    E --&gt; E2[shared_ptr共享]    E --&gt; E3[weak_ptr观察]        F --&gt; F1[避免默认捕获]    F --&gt; F2[初始化捕获]    F --&gt; F3[优先auto]        G --&gt; G1[基于任务]    G --&gt; G2[atomic不是volatile]</code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;effective-modern-c-42-tiao-gai-shan-c-11-he-c-14-dai-ma-de-jian-yi&quot; tabindex=&quot;-1&quot;&gt;Effective Modern</summary>
        
      
    
    
    
    <category term="知识分享" scheme="https://smarter.xin/categories/knowledge-sharing/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="Effective Modern C++" scheme="https://smarter.xin/tags/Effective-Modern-C/"/>
    
    <category term="C++11" scheme="https://smarter.xin/tags/C-11/"/>
    
    <category term="C++14" scheme="https://smarter.xin/tags/C-14/"/>
    
    <category term="现代C++" scheme="https://smarter.xin/tags/modern-cpp/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统知识点总结</title>
    <link href="https://smarter.xin/posts/aac6e27d/"/>
    <id>https://smarter.xin/posts/aac6e27d/</id>
    <published>2025-12-22T02:34:13.000Z</published>
    <updated>2026-01-06T13:16:51.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shen-ru-li-jie-ji-suan-ji-xi-tong-cong-cheng-xu-yuan-shi-jiao-kan-ji-suan-ji" tabindex="-1">深入理解计算机系统：从程序员视角看计算机</h1><blockquote><p>基于经典教材 CSAPP 的系统知识全面总结</p></blockquote><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective, CSAPP) 是一本从程序员视角审视计算机系统的经典教材。本书不仅仅教授理论知识，更强调理解计算机系统如何影响程序的<strong>正确性、性能和实用性</strong>。</p><p><strong>核心理念</strong>：</p><ul><li>程序员必须理解系统才能写出高效、可靠的代码</li><li>硬件和软件的边界越来越模糊</li><li>系统知识是成为优秀程序员的必备技能</li></ul><hr><h2 id="di-yi-bu-fen-cheng-xu-jie-gou-he-zhi-xing" tabindex="-1" id="第一部分：程序结构和执行">第一部分：程序结构和执行</h2><h3 id="xin-xi-de-biao-shi-he-chu-li" tabindex="-1" id="信息的表示和处理">信息的表示和处理</h3><h4 id="1-xin-xi-cun-chu" tabindex="-1" id="1-信息存储">1. 信息存储</h4><p>计算机中的所有信息都以<strong>位 (bit)</strong> 的形式存储和处理。</p><p><strong>关键概念</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字节 (Byte) = 8 位</span><br><span class="line">字 (Word) = 机器字长（32位或64位系统）</span><br><span class="line"></span><br><span class="line">地址空间：</span><br><span class="line">- 32位系统：2^32 = 4GB</span><br><span class="line">- 64位系统：2^64 = 16EB (理论上)</span><br></pre></td></tr></table></figure><p><strong>字节序 (Endianness)</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">大端序 (Big Endian):    高位字节存储在低地址</span><br><span class="line">小端序 (Little Endian): 低位字节存储在低地址</span><br><span class="line"></span><br><span class="line">示例：整数 0x01234567</span><br><span class="line">地址:     0x100  0x101  0x102  0x103</span><br><span class="line">大端:      01     23     45     67</span><br><span class="line">小端:      67     45     23     01</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph LR    A[数据 0x01234567] --&gt; B&#123;字节序&#125;    B --&gt;|大端| C[01 23 45 67]    B --&gt;|小端| D[67 45 23 01]</code></pre><h4 id="2-zheng-shu-biao-shi" tabindex="-1" id="2-整数表示">2. 整数表示</h4><p><strong>无符号编码</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">范围: [0, 2^w - 1]</span><br><span class="line">示例 (8位): 0 ~ 255</span><br></pre></td></tr></table></figure><p><strong>补码编码</strong> (最常用的有符号数表示)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范围: [-2^(w-1), 2^(w-1) - 1]</span><br><span class="line">示例 (8位): -128 ~ 127</span><br><span class="line"></span><br><span class="line">补码规则：</span><br><span class="line">- 正数：与无符号数相同</span><br><span class="line">- 负数：按位取反加1</span><br><span class="line"></span><br><span class="line">-1 的补码 (8位): 11111111</span><br><span class="line">-128 的补码 (8位): 10000000</span><br></pre></td></tr></table></figure><p><strong>关键陷阱</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有符号数与无符号数混合运算</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;  <span class="comment">// ❌ 永远为 false!</span></span><br><span class="line">    <span class="comment">// a 会被转换为无符号数，变成很大的正数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数溢出</span></span><br><span class="line"><span class="type">int</span> max = INT_MAX;</span><br><span class="line"><span class="type">int</span> overflow = max + <span class="number">1</span>;  <span class="comment">// 溢出，变成负数</span></span><br></pre></td></tr></table></figure><h4 id="3-fu-dian-shu-biao-shi" tabindex="-1" id="3-浮点数表示">3. 浮点数表示</h4><p><strong>IEEE 754 标准</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单精度 (32位):</span><br><span class="line">[符号位 1位][指数 8位][尾数 23位]</span><br><span class="line"></span><br><span class="line">双精度 (64位):</span><br><span class="line">[符号位 1位][指数 11位][尾数 52位]</span><br><span class="line"></span><br><span class="line">值 = (-1)^s × M × 2^E</span><br></pre></td></tr></table></figure><p><strong>特殊值</strong>：</p><table><thead><tr><th>值</th><th>指数</th><th>尾数</th></tr></thead><tbody><tr><td>0</td><td>全0</td><td>全0</td></tr><tr><td>∞</td><td>全1</td><td>全0</td></tr><tr><td>NaN</td><td>全1</td><td>非0</td></tr></tbody></table><p><strong>浮点数陷阱</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.3</span>) &#123;  <span class="comment">// ❌ 可能为 false</span></span><br><span class="line">    <span class="comment">// 浮点数精度问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a - <span class="number">0.3</span>) &lt; <span class="number">1e-6</span>) &#123;  <span class="comment">// ✓</span></span><br><span class="line">    <span class="comment">// 使用误差范围比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="cheng-xu-de-ji-qi-ji-biao-shi" tabindex="-1" id="程序的机器级表示">程序的机器级表示</h3><h4 id="1-hui-bian-yu-yan-ji-chu" tabindex="-1" id="1-汇编语言基础">1. 汇编语言基础</h4><p><strong>x86-64 寄存器</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器 (64位):</span><br><span class="line">%rax - 返回值</span><br><span class="line">%rbx - 被调用者保存</span><br><span class="line">%rcx - 第4个参数</span><br><span class="line">%rdx - 第3个参数</span><br><span class="line">%rsi - 第2个参数</span><br><span class="line">%rdi - 第1个参数</span><br><span class="line">%rbp - 帧指针</span><br><span class="line">%rsp - 栈指针</span><br><span class="line">%r8~%r15 - 额外寄存器</span><br></pre></td></tr></table></figure><p><strong>AT&amp;T 语法 vs Intel 语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; AT&amp;T 语法 (GCC 默认)</span><br><span class="line">movq $5, %rax          # 将立即数5移到rax</span><br><span class="line">movq %rax, %rbx        # 源在前，目的在后</span><br><span class="line"></span><br><span class="line">; Intel 语法 (Windows 常用)</span><br><span class="line">mov rax, 5             ; 目的在前，源在后</span><br><span class="line">mov rbx, rax</span><br></pre></td></tr></table></figure><h4 id="2-han-shu-diao-yong-yue-ding" tabindex="-1" id="2-函数调用约定">2. 函数调用约定</h4><p><strong>栈帧结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">+------------------+</span><br><span class="line">| 参数7            |</span><br><span class="line">| 参数6            |</span><br><span class="line">| 返回地址         |  &lt;- 调用者的栈帧</span><br><span class="line">+------------------+</span><br><span class="line">| 保存的%rbp       |  &lt;- %rbp 指向这里</span><br><span class="line">| 局部变量         |</span><br><span class="line">| ...              |</span><br><span class="line">+------------------+  &lt;- %rsp 指向这里</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph TD    A[调用者] --&gt; B[保存参数1-6到寄存器]    B --&gt; C[额外参数压栈]    C --&gt; D[call指令]    D --&gt; E[被调用者]    E --&gt; F[保存旧rbp]    F --&gt; G[分配栈帧]    G --&gt; H[执行函数]    H --&gt; I[恢复栈帧]    I --&gt; J[ret返回]</code></pre><p><strong>参数传递规则</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前6个参数: %rdi, %rsi, %rdx, %rcx, %r8, %r9</span><br><span class="line">第7+参数: 通过栈传递</span><br><span class="line">返回值: %rax (整数), %xmm0 (浮点数)</span><br></pre></td></tr></table></figure><h4 id="3-shu-zu-he-jie-gou-ti" tabindex="-1" id="3-数组和结构体">3. 数组和结构体</h4><p><strong>数组访问</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *ptr = &amp;<span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编实现</span></span><br><span class="line"><span class="comment">// array[i] 的地址 = base + i * sizeof(element)</span></span><br><span class="line">leaq (%rdi,%rsi,<span class="number">4</span>), %rax  <span class="meta"># rax = rdi + rsi*4</span></span><br></pre></td></tr></table></figure><p><strong>结构体对齐</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">int</span> i;      <span class="comment">// 4字节，需要对齐</span></span><br><span class="line">    <span class="type">char</span> d;     <span class="comment">// 1字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实际大小：12字节 (因为对齐)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">char</span> d;     <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">int</span> i;      <span class="comment">// 4字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实际大小：8字节 (更好的排列)</span></span><br></pre></td></tr></table></figure><hr><h3 id="chu-li-qi-ti-xi-jie-gou" tabindex="-1" id="处理器体系结构">处理器体系结构</h3><h4 id="1-zhi-ling-ji-jia-gou-isa" tabindex="-1" id="1-指令集架构-ISA">1. 指令集架构 (ISA)</h4><p><strong>CISC vs RISC</strong>：</p><table><thead><tr><th>特性</th><th>CISC (x86)</th><th>RISC (ARM, RISC-V)</th></tr></thead><tbody><tr><td>指令复杂度</td><td>复杂，功能强大</td><td>简单，固定长度</td></tr><tr><td>寻址模式</td><td>多种</td><td>较少</td></tr><tr><td>寄存器数量</td><td>较少</td><td>较多</td></tr><tr><td>示例</td><td>x86, x86-64</td><td>ARM, MIPS, RISC-V</td></tr></tbody></table><h4 id="2-liu-shui-xian-pipeline" tabindex="-1" id="2-流水线-Pipeline">2. 流水线 (Pipeline)</h4><p><strong>5级流水线</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 取指 (Fetch)</span><br><span class="line">2. 译码 (Decode)</span><br><span class="line">3. 执行 (Execute)</span><br><span class="line">4. 访存 (Memory)</span><br><span class="line">5. 写回 (Write-back)</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph LR    A[指令1] --&gt; B[取指]    B --&gt; C[译码]    C --&gt; D[执行]    D --&gt; E[访存]    E --&gt; F[写回]</code></pre><p><strong>流水线冒险</strong>：</p><ol><li><strong>结构冒险</strong>：硬件资源冲突</li><li><strong>数据冒险</strong>：指令间存在数据依赖</li><li><strong>控制冒险</strong>：分支指令导致的不确定性</li></ol><p><strong>分支预测</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] &gt;= <span class="number">128</span>) &#123;  <span class="comment">// 分支点</span></span><br><span class="line">        sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对排序后的数据，分支预测器表现更好</span></span><br><span class="line"><span class="comment">// 因为分支模式更规律</span></span><br></pre></td></tr></table></figure><hr><h3 id="you-hua-cheng-xu-xing-neng" tabindex="-1" id="优化程序性能">优化程序性能</h3><h4 id="1-xing-neng-zhi-biao" tabindex="-1" id="1-性能指标">1. 性能指标</h4><p><strong>CPU 性能公式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序执行时间 = 指令数 × CPI × 时钟周期</span><br><span class="line"></span><br><span class="line">CPI (Cycles Per Instruction): 每条指令的平均时钟周期数</span><br></pre></td></tr></table></figure><p><strong>关键优化原则</strong>：</p><ol><li><strong>减少指令数</strong></li><li><strong>降低 CPI</strong></li><li><strong>提高时钟频率</strong></li></ol><h4 id="2-bian-yi-qi-you-hua" tabindex="-1" id="2-编译器优化">2. 编译器优化</h4><p><strong>优化级别</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0  <span class="comment"># 无优化，便于调试</span></span><br><span class="line">gcc -O1  <span class="comment"># 基本优化</span></span><br><span class="line">gcc -O2  <span class="comment"># 推荐优化级别</span></span><br><span class="line">gcc -O3  <span class="comment"># 激进优化</span></span><br></pre></td></tr></table></figure><p><strong>常见优化技术</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 循环展开</span></span><br><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后（展开4次）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">    sum += a[i] + a[i<span class="number">+1</span>] + a[i<span class="number">+2</span>] + a[i<span class="number">+3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 消除冗余计算</span></span><br><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[i] = <span class="built_in">sqrt</span>(x) * array[i];  <span class="comment">// sqrt(x) 重复计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="type">double</span> temp = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[i] = temp * array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-nei-cun-xing-neng-you-hua" tabindex="-1" id="3-内存性能优化">3. 内存性能优化</h4><p><strong>局部性原理</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 差的局部性 - 按列访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sum += array[i][j];  <span class="comment">// 跳跃访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 好的局部性 - 按行访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        sum += array[i][j];  <span class="comment">// 连续访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="di-er-bu-fen-zai-xi-tong-shang-yun-xing-cheng-xu" tabindex="-1" id="第二部分：在系统上运行程序">第二部分：在系统上运行程序</h2><h3 id="cun-chu-qi-ceng-ci-jie-gou" tabindex="-1" id="存储器层次结构">存储器层次结构</h3><h4 id="1-cun-chu-qi-ceng-ci" tabindex="-1" id="1-存储器层次">1. 存储器层次</h4><pre><code class="highlight mermaid">graph TD    A[CPU寄存器] --&gt; B[L1缓存]    B --&gt; C[L2缓存]    C --&gt; D[L3缓存]    D --&gt; E[主存DRAM]    E --&gt; F[本地磁盘]    F --&gt; G[远程存储]</code></pre><p><strong>典型参数</strong>：</p><table><thead><tr><th>层次</th><th>容量</th><th>访问时间</th><th>价格</th></tr></thead><tbody><tr><td>寄存器</td><td>&lt;1KB</td><td>0.25ns</td><td>最贵</td></tr><tr><td>L1缓存</td><td>32-64KB</td><td>1ns</td><td>很贵</td></tr><tr><td>L2缓存</td><td>256KB-1MB</td><td>4ns</td><td>贵</td></tr><tr><td>L3缓存</td><td>8-32MB</td><td>10-20ns</td><td>较贵</td></tr><tr><td>主存</td><td>4-16GB</td><td>100ns</td><td>适中</td></tr><tr><td>SSD</td><td>256GB-2TB</td><td>100μs</td><td>便宜</td></tr><tr><td>HDD</td><td>1-10TB</td><td>10ms</td><td>很便宜</td></tr></tbody></table><h4 id="2-huan-cun-yuan-li" tabindex="-1" id="2-缓存原理">2. 缓存原理</h4><p><strong>缓存映射方式</strong>：</p><ol><li><strong>直接映射</strong>：每个内存块只能映射到一个缓存行</li><li><strong>全相联</strong>：内存块可以映射到任意缓存行</li><li><strong>组相联</strong>：折中方案，最常用</li></ol><p><strong>缓存写策略</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写命中:</span><br><span class="line">- 写直达 (Write-through): 同时写缓存和内存</span><br><span class="line">- 写回 (Write-back): 只写缓存，延迟写回内存</span><br><span class="line"></span><br><span class="line">写缺失:</span><br><span class="line">- 写分配 (Write-allocate): 加载到缓存再写</span><br><span class="line">- 非写分配 (Not-write-allocate): 直接写内存</span><br></pre></td></tr></table></figure><h4 id="3-huan-cun-you-hao-de-dai-ma" tabindex="-1" id="3-缓存友好的代码">3. 缓存友好的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 缓存不友好 - 矩阵转置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose_bad</span><span class="params">(<span class="type">int</span> src[N][N], <span class="type">int</span> dst[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            dst[j][i] = src[i][j];  <span class="comment">// dst 跳跃访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 缓存友好 - 分块优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose_good</span><span class="params">(<span class="type">int</span> src[N][N], <span class="type">int</span> dst[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> B = <span class="number">8</span>;  <span class="comment">// 块大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += B) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j += B) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt; i + B; ii++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt; j + B; jj++) &#123;</span><br><span class="line">                    dst[jj][ii] = src[ii][jj];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="lian-jie" tabindex="-1" id="链接">链接</h3><h4 id="1-lian-jie-guo-cheng" tabindex="-1" id="1-链接过程">1. 链接过程</h4><pre><code class="highlight mermaid">graph LR    A[源文件.c] --&gt; B[预处理]    B --&gt; C[编译]    C --&gt; D[汇编]    D --&gt; E[目标文件.o]    E --&gt; F[链接器]    G[库文件] --&gt; F    F --&gt; H[可执行文件]</code></pre><p><strong>目标文件格式 (ELF)</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ELF Header</span><br><span class="line">+------------------+</span><br><span class="line">| .text   | 代码段  |</span><br><span class="line">| .data   | 数据段  |</span><br><span class="line">| .bss    | 未初始化 |</span><br><span class="line">| .rodata | 只读数据 |</span><br><span class="line">| .symtab | 符号表  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h4 id="2-fu-hao-jie-xi" tabindex="-1" id="2-符号解析">2. 符号解析</h4><p><strong>符号类型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">42</span>;           <span class="comment">// 强符号，已初始化</span></span><br><span class="line"><span class="type">int</span> global_uninit;             <span class="comment">// 弱符号，未初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_var = <span class="number">10</span>;     <span class="comment">// 本地符号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> external_var;       <span class="comment">// 外部引用</span></span><br></pre></td></tr></table></figure><p><strong>链接规则</strong>：</p><ol><li>多个强符号：错误</li><li>一个强符号，多个弱符号：选择强符号</li><li>多个弱符号：任选一个（危险！）</li></ol><h4 id="3-jing-tai-ku-yu-dong-tai-ku" tabindex="-1" id="3-静态库与动态库">3. 静态库与动态库</h4><p><strong>静态库 (.a)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建静态库</span></span><br><span class="line">ar rcs libmylib.a file1.o file2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line">gcc main.c -L. -lmylib -o app</span><br></pre></td></tr></table></figure><p><strong>动态库 (.so / .dll)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建动态库</span></span><br><span class="line">gcc -shared -fPIC -o libmylib.so file1.c file2.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line">gcc main.c -L. -lmylib -o app</span><br></pre></td></tr></table></figure><p><strong>对比</strong>：</p><table><thead><tr><th>特性</th><th>静态库</th><th>动态库</th></tr></thead><tbody><tr><td>链接时间</td><td>编译时</td><td>运行时</td></tr><tr><td>文件大小</td><td>大</td><td>小</td></tr><tr><td>更新</td><td>需重编译</td><td>只需替换库</td></tr><tr><td>启动速度</td><td>快</td><td>慢</td></tr></tbody></table><hr><h3 id="yi-chang-kong-zhi-liu" tabindex="-1" id="异常控制流">异常控制流</h3><h4 id="1-yi-chang-fen-lei" tabindex="-1" id="1-异常分类">1. 异常分类</h4><pre><code class="highlight mermaid">graph TD    A[异常] --&gt; B[中断]    A --&gt; C[陷阱]    A --&gt; D[故障]    A --&gt; E[终止]        B --&gt; F[异步IO设备]    C --&gt; G[同步系统调用]    D --&gt; H[可恢复错误]    E --&gt; I[不可恢复错误]</code></pre><p><strong>异常示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中断: 键盘输入，网络数据包</span><br><span class="line">陷阱: 系统调用 (read, write, fork)</span><br><span class="line">故障: 缺页异常，除零错误</span><br><span class="line">终止: 硬件错误，非法指令</span><br></pre></td></tr></table></figure><h4 id="2-jin-cheng-kong-zhi" tabindex="-1" id="2-进程控制">2. 进程控制</h4><p><strong>创建进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程 PID = %d\n&quot;</span>, getpid());</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程，子PID = %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-xin-hao" tabindex="-1" id="3-信号">3. 信号</h4><p><strong>常见信号</strong>：</p><table><thead><tr><th>信号</th><th>默认行为</th><th>触发条件</th></tr></thead><tbody><tr><td>SIGINT</td><td>终止</td><td>Ctrl+C</td></tr><tr><td>SIGKILL</td><td>终止</td><td>kill -9</td></tr><tr><td>SIGSEGV</td><td>终止</td><td>段错误</td></tr><tr><td>SIGCHLD</td><td>忽略</td><td>子进程终止</td></tr></tbody></table><p><strong>信号处理</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获信号 %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="xu-ni-nei-cun" tabindex="-1" id="虚拟内存">虚拟内存</h3><h4 id="1-xu-ni-di-zhi-kong-jian" tabindex="-1" id="1-虚拟地址空间">1. 虚拟地址空间</h4><p><strong>Linux 进程地址空间</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">+------------------+</span><br><span class="line">| 内核空间         |</span><br><span class="line">+------------------+</span><br><span class="line">| 栈 ↓            |</span><br><span class="line">|                  |</span><br><span class="line">| ↑ 堆            |</span><br><span class="line">+------------------+</span><br><span class="line">| .bss 段         |</span><br><span class="line">| .data 段        |</span><br><span class="line">| .text 段        |</span><br><span class="line">+------------------+</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h4 id="2-ye-biao" tabindex="-1" id="2-页表">2. 页表</h4><p><strong>地址转换</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址 = [虚拟页号 VPN | 页内偏移]</span><br><span class="line">           ↓ 页表转换</span><br><span class="line">物理地址 = [物理页号 PPN | 页内偏移]</span><br><span class="line"></span><br><span class="line">页大小: 4KB (2^12)</span><br></pre></td></tr></table></figure><p><strong>多级页表</strong>：</p><pre><code class="highlight mermaid">graph LR    A[虚拟地址] --&gt; B[一级页表]    B --&gt; C[二级页表]    C --&gt; D[三级页表]    D --&gt; E[物理页]</code></pre><h4 id="3-nei-cun-ying-she" tabindex="-1" id="3-内存映射">3. 内存映射</h4><p><strong>mmap 系统调用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, file_size, PROT_READ, </span><br><span class="line">                 MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用映射的内存</span></span><br><span class="line"><span class="type">char</span> ch = ((<span class="type">char</span>*)ptr)[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">munmap(ptr, file_size);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h2 id="di-san-bu-fen-cheng-xu-jian-de-jiao-hu-he-tong-xin" tabindex="-1" id="第三部分：程序间的交互和通信">第三部分：程序间的交互和通信</h2><h3 id="xi-tong-ji-i-o" tabindex="-1" id="系统级I-O">系统级I/O</h3><h4 id="1-unix-i-o-mo-xing" tabindex="-1" id="1-Unix-I-O-模型">1. Unix I/O 模型</h4><p><strong>文件描述符</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准文件描述符</span></span><br><span class="line"><span class="number">0</span> - <span class="built_in">stdin</span></span><br><span class="line"><span class="number">1</span> - <span class="built_in">stdout</span></span><br><span class="line"><span class="number">2</span> - <span class="built_in">stderr</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">ssize_t</span> n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4 id="2-i-o-duo-lu-fu-yong" tabindex="-1" id="2-I-O-多路复用">2. I/O 多路复用</h4><p><strong>select 示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(sockfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span> =</span> &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ready = select(sockfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ready &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(sockfd, &amp;readfds)) &#123;</span><br><span class="line">    <span class="comment">// socket 有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="wang-luo-bian-cheng" tabindex="-1" id="网络编程">网络编程</h3><h4 id="1-tao-jie-zi-bian-cheng" tabindex="-1" id="1-套接字编程">1. 套接字编程</h4><p><strong>TCP 服务器</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建socket</span></span><br><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听</span></span><br><span class="line">listen(listenfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接受连接</span></span><br><span class="line"><span class="type">int</span> connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 读写</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">read(connfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(connfd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">close(connfd);</span><br><span class="line">close(listenfd);</span><br></pre></td></tr></table></figure><p><strong>TCP 三次握手</strong>：</p><pre><code class="highlight mermaid">sequenceDiagram    participant C as 客户端    participant S as 服务器        C-&gt;&gt;S: SYN    S-&gt;&gt;C: SYN+ACK    C-&gt;&gt;S: ACK    Note over C,S: 连接建立</code></pre><hr><h3 id="bing-fa-bian-cheng" tabindex="-1" id="并发编程">并发编程</h3><h4 id="1-xian-cheng" tabindex="-1" id="1-线程">1. 线程</h4><p><strong>创建线程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程运行中\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-tong-bu-ji-zhi" tabindex="-1" id="2-同步机制">2. 同步机制</h4><p><strong>互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">counter++;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line">sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;sem);  <span class="comment">// P操作</span></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">sem_post(&amp;sem);  <span class="comment">// V操作</span></span><br></pre></td></tr></table></figure><h4 id="3-jing-dian-wen-ti" tabindex="-1" id="3-经典问题">3. 经典问题</h4><p><strong>生产者-消费者</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> empty, full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-si-xiang" tabindex="-1" id="核心思想">核心思想</h3><ol><li><strong>抽象层次</strong>：理解系统的多层抽象</li><li><strong>性能优化</strong>：缓存、局部性、并行性</li><li><strong>正确性保证</strong>：理解底层避免bug</li><li><strong>系统思维</strong>：程序在系统中运行</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;shen-ru-li-jie-ji-suan-ji-xi-tong-cong-cheng-xu-yuan-shi-jiao-kan-ji-suan-ji&quot;</summary>
        
      
    
    
    
    <category term="知识分享" scheme="https://smarter.xin/categories/knowledge-sharing/"/>
    
    
    <category term="计算机系统" scheme="https://smarter.xin/tags/computer-system/"/>
    
    <category term="性能优化" scheme="https://smarter.xin/tags/performance-optimization/"/>
    
    <category term="系统编程" scheme="https://smarter.xin/tags/system-programming/"/>
    
    <category term="操作系统" scheme="https://smarter.xin/tags/operating-system/"/>
    
    <category term="CSAPP" scheme="https://smarter.xin/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>现代C++</title>
    <link href="https://smarter.xin/posts/c396c10e/"/>
    <id>https://smarter.xin/posts/c396c10e/</id>
    <published>2025-12-20T07:39:59.000Z</published>
    <updated>2026-01-06T13:16:51.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xian-dai-c-he-xin-te-xing-xiang-jie-cong-lei-xing-tui-dao-dao-wan-mei-zhuan-fa" tabindex="-1">现代C++核心特性详解：从类型推导到完美转发</h1><blockquote><p>深入理解现代 C++ 的核心机制，掌握高性能编程的关键技术</p></blockquote><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>现代 C++（C++11/14/17/20）引入了许多强大的特性，其中<strong>类型推导</strong>、<strong>移动语义</strong>和<strong>完美转发</strong>是构建高性能应用的基石。本文将深入剖析这些核心概念，帮助你写出更高效、更安全的C++代码。</p><hr><h2 id="di-yi-bu-fen-lei-xing-tui-dao-ji-zhi" tabindex="-1" id="第一部分：类型推导机制">第一部分：类型推导机制</h2><h3 id="mo-ban-lei-xing-tui-dao" tabindex="-1" id="模板类型推导">模板类型推导</h3><p>模板类型推导是理解现代 C++ 的第一步。对于模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr); <span class="comment">// 编译器根据 expr 推导 T 和 ParamType</span></span><br></pre></td></tr></table></figure><p>推导规则分为三种情况：</p><h4 id="qing-kuang-yi-param-type-shi-yin-yong-huo-zhi-zhen" tabindex="-1" id="情况一：ParamType-是引用或指针">情况一：ParamType 是引用或指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">// T 是 int,       param 是 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">// T 是 const int, param 是 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">// T 是 const int, param 是 const int&amp;</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：<code>const</code> 被保留，引用性质在推导前被忽略。</p><h4 id="qing-kuang-er-param-type-shi-mo-neng-yin-yong-t-amp-amp" tabindex="-1" id="情况二：ParamType-是万能引用（T-）">情况二：ParamType 是万能引用（T&amp;&amp;）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">// x 是左值  -&gt; T 是 int&amp;,       param 是 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);  <span class="comment">// 27 是右值 -&gt; T 是 int,        param 是 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>这是<strong>完美转发</strong>的基础，也是最重要的推导规则。</p><h4 id="qing-kuang-san-param-type-shi-an-zhi-chuan-can" tabindex="-1" id="情况三：ParamType-是按值传参">情况三：ParamType 是按值传参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">// T 是 int</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">// T 是 int (const 被丢弃)</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">// T 是 int (引用和 const 都被丢弃)</span></span><br></pre></td></tr></table></figure><p><strong>特殊情况</strong>：指针的 const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr = <span class="string">&quot;Fun&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(ptr);</span><br><span class="line"><span class="comment">// T 是 const char* (指针本身的 const 被丢弃，指向内容的 const 保留)</span></span><br></pre></td></tr></table></figure><h4 id="tui-dao-gui-ze-dui-bi-biao" tabindex="-1" id="推导规则对比表">推导规则对比表</h4><table><thead><tr><th>ParamType 形式</th><th>传入左值</th><th>传入右值</th><th>const 属性</th><th>适用场景</th></tr></thead><tbody><tr><td><code>T&amp;</code></td><td>✓</td><td>✗</td><td>保留</td><td>需要修改参数，或大对象只读</td></tr><tr><td><code>T&amp;&amp;</code></td><td>推导为 <code>T&amp;</code></td><td>推导为 <code>T</code></td><td>保留</td><td><strong>完美转发</strong></td></tr><tr><td><code>T</code></td><td>拷贝</td><td>移动/拷贝</td><td>丢弃</td><td>标量类型，或极小对象</td></tr></tbody></table><hr><h3 id="auto-lei-xing-tui-dao" tabindex="-1" id="auto-类型推导">auto 类型推导</h3><p><code>auto</code> 类型推导与模板推导机制<strong>99%相同</strong>，唯一例外是花括号初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;    <span class="comment">// x1 是 int</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;     <span class="comment">// x2 是 int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;  <span class="comment">// ⚠️ x3 是 std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;     <span class="comment">// C++17: int, C++14: std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h4 id="han-shu-fan-hui-zhi-de-auto" tabindex="-1" id="函数返回值的-auto">函数返回值的 auto</h4><p>当 <code>auto</code> 用于函数返回值时，使用的是<strong>模板推导规则</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create_dims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// ❌ 编译错误！模板推导不支持 &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create_dims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// ✓</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="decltype-xiang-jie" tabindex="-1" id="decltype-详解">decltype 详解</h3><p><code>decltype</code> 是&quot;诚实的复读机&quot;，它返回表达式的<strong>确切类型</strong>，不会丢弃引用和 const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = i;            <span class="comment">// a 是 int (const 被丢弃)</span></span><br><span class="line"><span class="keyword">decltype</span>(i) d = i;     <span class="comment">// d 是 const int (原样保留)</span></span><br></pre></td></tr></table></figure><h4 id="decltype-auto-wan-mei-zhuan-fa-fan-hui-zhi" tabindex="-1" id="decltype-auto-：完美转发返回值">decltype(auto)：完美转发返回值</h4><p>这是 C++14 的杀手级特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">authAndAccess</span>(vec, <span class="number">0</span>) = <span class="number">100</span>;  <span class="comment">// 返回 int&amp;，可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">authAndAccess</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">0</span>);  <span class="comment">// 返回 int，移动语义</span></span><br></pre></td></tr></table></figure><h4 id="decltype-de-xian-jing-gua-hao-de-mo-li" tabindex="-1" id="decltype-的陷阱：括号的魔力">decltype 的陷阱：括号的魔力</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(x)   t1;   <span class="comment">// t1 是 int</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) t2;   <span class="comment">// t2 是 int&amp; ⚠️ 危险！</span></span><br></pre></td></tr></table></figure><p><strong>关键规则</strong>：</p><ul><li><code>decltype(name)</code> → 返回声明类型</li><li><code>decltype((name))</code> → 返回引用（因为 <code>(name)</code> 是左值表达式）</li></ul><pre><code class="highlight mermaid">graph TD    A[decltype 推导] --&gt; B&#123;是名字还是表达式?&#125;    B --&gt;|名字| C[返回声明类型]    B --&gt;|表达式| D&#123;是否为左值?&#125;    D --&gt;|是| E[返回引用类型]    D --&gt;|否| F[返回值类型]</code></pre><hr><h3 id="cha-kan-lei-xing-tui-dao-jie-guo" tabindex="-1" id="查看类型推导结果">查看类型推导结果</h3><h4 id="fang-fa-yi-bian-yi-qi-bao-cuo-zui-tui-jian" tabindex="-1" id="方法一：编译器报错（最推荐）">方法一：编译器报错（最推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;  <span class="comment">// 只声明，不定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; debug;  <span class="comment">// 编译错误会显示：TD&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h4 id="fang-fa-er-yun-xing-shi-typeid-you-keng" tabindex="-1" id="方法二：运行时-typeid（有坑）">方法二：运行时 typeid（有坑）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>缺陷</strong>：会忽略引用和 const！</p><h4 id="fang-fa-san-ide-ti-shi-kuai-dan-bu-yi-ding-zhun" tabindex="-1" id="方法三：IDE-提示（快但不一定准）">方法三：IDE 提示（快但不一定准）</h4><p>鼠标悬停在 <code>auto</code> 上查看类型，对简单类型有效。</p><hr><h2 id="di-er-bu-fen-yin-yong-yu-yi-dong-yu-yi" tabindex="-1" id="第二部分：引用与移动语义">第二部分：引用与移动语义</h2><h3 id="mo-neng-yin-yong-vs-you-zhi-yin-yong" tabindex="-1" id="万能引用-vs-右值引用">万能引用 vs 右值引用</h3><p><strong>判断规则</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有类型推导 → 万能引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// 万能引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var = value;                       <span class="comment">// 万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无类型推导 → 右值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp; param)</span></span>;                      <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure><h4 id="mo-neng-yin-yong-shi-li" tabindex="-1" id="万能引用示例">万能引用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// param 可以绑定左值或右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">process</span>(x);   <span class="comment">// T 推导为 int&amp;，  param 是 int&amp;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">10</span>);  <span class="comment">// T 推导为 int，   param 是 int&amp;&amp;</span></span><br><span class="line">graph LR</span><br><span class="line">    A[T&amp;&amp;] --&gt; B&#123;有类型推导?&#125;</span><br><span class="line">    B --&gt;|是| C[万能引用]</span><br><span class="line">    B --&gt;|否| D[右值引用]</span><br><span class="line">    </span><br><span class="line">    C --&gt; E[可以绑定左值]</span><br><span class="line">    C --&gt; F[可以绑定右值]</span><br><span class="line">    </span><br><span class="line">    D --&gt; G[只能绑定右值]</span><br></pre></td></tr></table></figure><hr><h3 id="std-move-he-std-forward" tabindex="-1" id="std-move-和-std-forward">std::move 和 std::forward</h3><h4 id="std-move-wu-tiao-jian-zhuan-wei-you-zhi" tabindex="-1" id="std-move：无条件转为右值">std::move：无条件转为右值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1);  <span class="comment">// str1 被清空</span></span><br></pre></td></tr></table></figure><p><strong>本质</strong>：<code>std::move</code> 不移动任何东西，只是类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-forward-you-tiao-jian-di-bao-chi-zhi-lei-bie" tabindex="-1" id="std-forward：有条件地保持值类别">std::forward：有条件地保持值类别</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持左值/右值属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么需要 forward？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用 forward</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">badAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];  <span class="comment">// 总是返回左值引用！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forward</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">goodAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">    <span class="comment">// 左值容器 → 返回左值引用</span></span><br><span class="line">    <span class="comment">// 右值容器 → 返回右值引用（可移动）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dui-bi-zong-jie" tabindex="-1" id="对比总结">对比总结</h4><table><thead><tr><th>特性</th><th><code>std::move</code></th><th><code>std::forward</code></th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>无条件转为右值</td><td>有条件保持值类别</td></tr><tr><td><strong>使用场景</strong></td><td>确定要移动对象</td><td>完美转发模板参数</td></tr><tr><td><strong>返回值</strong></td><td>总是右值引用</td><td>可能是左值或右值引用</td></tr></tbody></table><hr><h3 id="zuo-zhi-yu-you-zhi-de-ben-zhi" tabindex="-1" id="左值与右值的本质">左值与右值的本质</h3><h4 id="he-xin-gui-ze" tabindex="-1" id="核心规则">核心规则</h4><p><strong>有名字的右值引用是左值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Resource&amp;&amp; rref)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rref 是右值引用类型，但 rref 本身是左值</span></span><br><span class="line">    Resource r1 = rref;              <span class="comment">// ❌ 调用拷贝构造</span></span><br><span class="line">    Resource r2 = std::<span class="built_in">move</span>(rref);   <span class="comment">// ✓ 调用移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yi-dong-gou-zao-han-shu-zhong-de-std-move" tabindex="-1" id="移动构造函数中的-std-move">移动构造函数中的 std::move</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;  <span class="comment">// 必须使用 std::move</span></span><br><span class="line">        <span class="comment">// other.data 是左值，需要转为右值才能触发移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>类型分析</strong>：</p><table><thead><tr><th>表达式</th><th>类型</th><th>值类别</th><th>需要 move？</th></tr></thead><tbody><tr><td><code>other</code></td><td><code>Resource&amp;&amp;</code></td><td>左值</td><td>是</td></tr><tr><td><code>other.data</code></td><td><code>std::vector&lt;int&gt;&amp;</code></td><td>左值</td><td>是</td></tr><tr><td><code>std::move(other)</code></td><td><code>Resource&amp;&amp;</code></td><td>右值</td><td>-</td></tr></tbody></table><pre><code class="highlight mermaid">graph TD    A[右值引用参数] --&gt; B[有名字的变量]    B --&gt; C[是左值]    C --&gt; D[访问成员]    D --&gt; E[成员也是左值]    E --&gt; F&#123;要移动吗?&#125;    F --&gt;|是| G[使用 std::move]    F --&gt;|否| H[直接使用 - 拷贝]</code></pre><hr><h2 id="di-san-bu-fen-auto-de-zui-jia-shi-jian" tabindex="-1" id="第三部分：auto-的最佳实践">第三部分：auto 的最佳实践</h2><h3 id="you-xian-shi-yong-auto-de-li-you" tabindex="-1" id="优先使用-auto-的理由">优先使用 auto 的理由</h3><h4 id="1-bi-mian-yin-xing-de-lei-xing-zhuan-huan" tabindex="-1" id="1-避免隐形的类型转换">1. 避免隐形的类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：每次循环都拷贝！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : map) &#123;</span><br><span class="line">    <span class="comment">// map 的元素类型是 std::pair&lt;const std::string, int&gt;</span></span><br><span class="line">    <span class="comment">// 类型不匹配，发生拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确：零拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : map) &#123;</span><br><span class="line">    <span class="comment">// 编译器推导为 std::pair&lt;const std::string, int&gt;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-qiang-zhi-chu-shi-hua" tabindex="-1" id="2-强制初始化">2. 强制初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;       <span class="comment">// 未初始化，可能是垃圾值</span></span><br><span class="line"><span class="keyword">auto</span> x;      <span class="comment">// ❌ 编译错误</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">0</span>;  <span class="comment">// ✓ 必须初始化</span></span><br></pre></td></tr></table></figure><h4 id="3-ke-yi-zhi-xing" tabindex="-1" id="3-可移植性">3. 可移植性</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">unsigned</span> sz = v.<span class="built_in">size</span>();  <span class="comment">// ⚠️ 32位系统可能溢出</span></span><br><span class="line"><span class="keyword">auto</span> sz = v.<span class="built_in">size</span>();      <span class="comment">// ✓ 总是正确</span></span><br></pre></td></tr></table></figure><hr><h3 id="std-function-vs-auto" tabindex="-1" id="std-function-vs-auto">std::function vs auto</h3><h4 id="xing-neng-dui-bi" tabindex="-1" id="性能对比">性能对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::function：类型擦除，有开销</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto：零开销，可内联</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br></pre></td></tr></table></figure><p><strong>性能差异</strong>：</p><table><thead><tr><th>特性</th><th><code>std::function</code></th><th><code>auto</code></th></tr></thead><tbody><tr><td>大小</td><td>固定（24-64字节）</td><td>等于实际对象</td></tr><tr><td>调用开销</td><td>间接调用</td><td>直接调用，可内联</td></tr><tr><td>内存分配</td><td>可能堆分配</td><td>无额外分配</td></tr><tr><td>性能</td><td>慢 2-5 倍</td><td>最优</td></tr></tbody></table><h4 id="shi-yong-chang-jing" tabindex="-1" id="使用场景">使用场景</h4><p><strong>使用 std::function</strong>：</p><ul><li>需要存储不同类型的可调用对象</li><li>运行时替换回调</li><li>公共 API 接口</li></ul><p><strong>使用 auto</strong>：</p><ul><li>局部变量</li><li>性能关键代码</li><li>模板函数参数</li></ul><pre><code class="highlight mermaid">graph TD    A[需要存储可调用对象?] --&gt; B&#123;类型统一?&#125;    B --&gt;|否| C[std::function]    B --&gt;|是| D&#123;性能关键?&#125;    D --&gt;|是| E[auto/模板]    D --&gt;|否| F[两者皆可]        C --&gt; G[容器存储]    C --&gt; H[回调系统]        E --&gt; I[局部使用]    E --&gt; J[可内联]</code></pre><hr><h3 id="lei-xing-ca-chu-yu-bi-bao" tabindex="-1" id="类型擦除与闭包">类型擦除与闭包</h3><h4 id="lei-xing-ca-chu" tabindex="-1" id="类型擦除">类型擦除</h4><p>将不同类型的对象放入统一接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同的类型</span></span><br><span class="line"><span class="keyword">auto</span> lambda1 = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> lambda2 = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + <span class="number">5</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一的&quot;盒子&quot;（类型擦除）</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; box;</span><br><span class="line">box = lambda1;  <span class="comment">// ✓</span></span><br><span class="line">box = lambda2;  <span class="comment">// ✓</span></span><br></pre></td></tr></table></figure><p><strong>实现原理</strong>（简化版）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>&lt;<span class="built_in">R</span>(Args...)&gt; &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CallableBase</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> R <span class="title">call</span><span class="params">(Args...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">CallableBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CallableImpl</span> : CallableBase &#123;</span><br><span class="line">        F f;</span><br><span class="line">        <span class="function">R <span class="title">call</span><span class="params">(Args... args)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(args...); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CallableBase* callable;  <span class="comment">// 多态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="bi-bao" tabindex="-1" id="闭包">闭包</h4><p>闭包 = 函数 + 环境</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> [count]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> counter1 = <span class="built_in">makeCounter</span>();</span><br><span class="line"><span class="keyword">auto</span> counter2 = <span class="built_in">makeCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">counter1</span>();  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">counter1</span>();  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">counter2</span>();  <span class="comment">// 1 (独立环境)</span></span><br></pre></td></tr></table></figure><p><strong>编译器生成的等价类</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__Closure</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 捕获的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __Closure(<span class="type">int</span> c) : <span class="built_in">count</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++count; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>捕获方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[a, b]()      <span class="comment">// 值捕获</span></span><br><span class="line">[&amp;a, &amp;b]()    <span class="comment">// 引用捕获</span></span><br><span class="line">[=]()         <span class="comment">// 全部值捕获</span></span><br><span class="line">[&amp;]()         <span class="comment">// 全部引用捕获</span></span><br><span class="line">[=, &amp;a]()     <span class="comment">// a 引用，其他值捕获</span></span><br><span class="line">[value = a + b]()  <span class="comment">// 初始化捕获（C++14）</span></span><br></pre></td></tr></table></figure><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>模板推导</strong>：理解三种情况（引用、万能引用、按值），万能引用是完美转发的基础</li><li><strong>auto vs decltype</strong>：auto 会去引用，decltype 保留原样</li><li><strong>std::move vs std::forward</strong>：move 无条件转右值，forward 条件保持值类别</li><li><strong>优先使用 auto</strong>：避免拷贝、强制初始化、更好的可移植性</li><li><strong>std::function vs auto</strong>：性能关键用 auto，需要类型擦除用 std::function</li></ol><h3 id="ji-yi-kou-jue" tabindex="-1" id="记忆口诀">记忆口诀</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万能引用：T&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// 左值右值都能绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">use</span>(std::<span class="built_in">move</span>(w));  <span class="comment">// 右值引用 → move</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">other</span>(std::forward&lt;T&gt;(param));  <span class="comment">// 万能引用 → forward</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="zui-jia-shi-jian" tabindex="-1" id="最佳实践">最佳实践</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✓ 推荐</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : container) &#123; &#125;      <span class="comment">// 避免拷贝</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;  <span class="comment">// 性能最优</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> expr; &#125;         <span class="comment">// 完美转发返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 避免</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Type&amp; item : container) &#123; &#125;      <span class="comment">// 可能类型不匹配</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f = [...];          <span class="comment">// 非必要的开销</span></span><br><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                         <span class="comment">// 意外的 initializer_list</span></span><br></pre></td></tr></table></figure><hr><h2 id="can-kao-zi-yuan" tabindex="-1" id="参考资源">参考资源</h2><ul><li>《Effective Modern C++》- Scott Meyers</li><li><a href="https://en.cppreference.com/">C++ Reference</a></li><li><a href="https://www.youtube.com/user/CppCon">CppCon Talks</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;xian-dai-c-he-xin-te-xing-xiang-jie-cong-lei-xing-tui-dao-dao-wan-mei-zhuan-fa&quot;</summary>
        
      
    
    
    
    <category term="知识分享" scheme="https://smarter.xin/categories/knowledge-sharing/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="现代C++" scheme="https://smarter.xin/tags/modern-cpp/"/>
    
    <category term="性能优化" scheme="https://smarter.xin/tags/performance-optimization/"/>
    
    <category term="类型推导" scheme="https://smarter.xin/tags/type-deduction/"/>
    
    <category term="移动语义" scheme="https://smarter.xin/tags/move-semantics/"/>
    
    <category term="完美转发" scheme="https://smarter.xin/tags/perfect-forwarding/"/>
    
  </entry>
  
  <entry>
    <title>常见算法-KMP</title>
    <link href="https://smarter.xin/posts/d26e9827/"/>
    <id>https://smarter.xin/posts/d26e9827/</id>
    <published>2025-12-20T06:42:11.000Z</published>
    <updated>2026-01-06T13:16:51.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmp-zi-fu-chuan-pi-pei-suan-fa-xiang-jie-cong-yuan-li-dao-shi-xian" tabindex="-1">KMP 字符串匹配算法详解：从原理到实现</h1><blockquote><p>深入理解 KMP 算法的核心思想，掌握高效字符串匹配的关键技术</p></blockquote><hr><h2 id="yin-yan" tabindex="-1" id="引言">引言</h2><p>KMP（Knuth-Morris-Pratt）算法是计算机科学中最经典的字符串匹配算法之一，由 Donald Knuth、Vaughan Pratt 和 James H. Morris 在 1977 年共同发明。该算法通过预处理模式串，避免了暴力匹配中的重复比较，将时间复杂度从 O(m×n) 优化到 O(m+n)。</p><p><strong>适用场景</strong>：</p><ul><li>文本编辑器的查找功能</li><li>DNA 序列匹配</li><li>网络数据包检测</li><li>编译器词法分析</li></ul><hr><h2 id="wen-ti-bei-jing" tabindex="-1" id="问题背景">问题背景</h2><h3 id="zi-fu-chuan-pi-pei-wen-ti-ding-yi" tabindex="-1" id="字符串匹配问题定义">字符串匹配问题定义</h3><p>给定两个字符串：</p><ul><li><strong>主串（文本串）</strong>：需要被搜索的字符串，长度为 n</li><li><strong>模式串（模板串）</strong>：要查找的子串，长度为 m</li></ul><p><strong>目标</strong>：在主串中找到第一次出现模式串的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主串：  ABABDABACDABABCABAB</span><br><span class="line">模式串：      ABABCABAB</span><br></pre></td></tr></table></figure><hr><h2 id="bao-li-pi-pei-de-ju-xian-xing" tabindex="-1" id="暴力匹配的局限性">暴力匹配的局限性</h2><h3 id="bao-li-suan-fa-liu-cheng" tabindex="-1" id="暴力算法流程">暴力算法流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bruteForce</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; text[i + j] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i;  <span class="comment">// 找到匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bao-li-pi-pei-de-wen-ti" tabindex="-1" id="暴力匹配的问题">暴力匹配的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">主串：  A B A B A B C</span><br><span class="line">模式串：A B A B C</span><br><span class="line"></span><br><span class="line">步骤1：  A B A B A B C</span><br><span class="line">        A B A B C</span><br><span class="line">        ✓ ✓ ✓ ✓ ✗ (第5位失配)</span><br><span class="line"></span><br><span class="line">步骤2：  A B A B A B C</span><br><span class="line">          A B A B C</span><br><span class="line">          ✗ (第1位就失配，浪费！)</span><br><span class="line"></span><br><span class="line">步骤3：  A B A B A B C</span><br><span class="line">            A B A B C</span><br><span class="line">            ✓ ✓ ✓ ✓ ✓ (成功)</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：失配后，模式串从头开始，主串回退，导致<strong>重复比较</strong>。</p><pre><code class="highlight mermaid">graph TD    A[主串位置 i] --&gt; B&#123;text i == pattern j?&#125;    B --&gt;|是| C[i++, j++]    B --&gt;|否| D[i 回退到 i-j+1]    D --&gt; E[j 重置为 0]    E --&gt; F[重新匹配]</code></pre><p><strong>时间复杂度</strong>：O(m×n)，最坏情况下每个位置都要尝试完整匹配。</p><hr><h2 id="kmp-he-xin-si-xiang" tabindex="-1" id="KMP-核心思想">KMP 核心思想</h2><h3 id="guan-jian-dong-cha" tabindex="-1" id="关键洞察">关键洞察</h3><p>当失配发生时，我们已经知道了<strong>前面已经匹配的部分</strong>，可以利用这些信息避免回退。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主串：  A B A B A B C</span><br><span class="line">模式串：A B A B C</span><br><span class="line">        ✓ ✓ ✓ ✓ ✗</span><br><span class="line"></span><br><span class="line">已知：前4个字符 &quot;ABAB&quot; 已匹配</span><br><span class="line">观察：模式串的前缀 &quot;AB&quot; 等于已匹配部分的后缀 &quot;AB&quot;</span><br><span class="line">结论：可以直接将模式串滑动到对齐位置，无需回退主串指针</span><br></pre></td></tr></table></figure><h3 id="kmp-de-liang-da-chuang-xin" tabindex="-1" id="KMP-的两大创新">KMP 的两大创新</h3><ol><li><strong>主串指针不回退</strong>：<code>i</code> 只向前移动，永不后退</li><li><strong>模式串智能跳转</strong>：通过 <code>next</code> 数组确定失配后模式串应该跳到哪里</li></ol><pre><code class="highlight mermaid">graph LR    A[失配发生] --&gt; B[查询 next 数组]    B --&gt; C[模式串跳转]    C --&gt; D[继续匹配]    D --&gt; E&#123;匹配成功?&#125;    E --&gt;|是| F[完成]    E --&gt;|否| B</code></pre><hr><h2 id="next-shu-zu-xiang-jie" tabindex="-1" id="Next-数组详解">Next 数组详解</h2><h3 id="next-shu-zu-de-ding-yi" tabindex="-1" id="Next-数组的定义">Next 数组的定义</h3><p><code>next[i]</code> 表示：<strong>模式串中以位置 <code>i</code> 结尾的子串的最长相等前后缀的长度</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模式串：A B A B C A B A B</span><br><span class="line">索引：  0 1 2 3 4 5 6 7 8</span><br><span class="line">next：  0 0 1 2 0 1 2 3 4</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>next[0] = 0</code>：单个字符没有前后缀</li><li><code>next[1] = 0</code>：<code>AB</code> 没有相等的前后缀</li><li><code>next[2] = 1</code>：<code>ABA</code> 的最长相等前后缀是 <code>A</code>（长度1）</li><li><code>next[3] = 2</code>：<code>ABAB</code> 的最长相等前后缀是 <code>AB</code>（长度2）</li><li><code>next[4] = 0</code>：<code>ABABC</code> 没有相等的前后缀</li><li><code>next[7] = 3</code>：<code>ABABCAB</code> 的最长相等前后缀是 <code>AB</code>（长度2）… 等等</li></ul><h3 id="qian-zhui-he-hou-zhui-de-gai-nian" tabindex="-1" id="前缀和后缀的概念">前缀和后缀的概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串：A B C D</span><br><span class="line"></span><br><span class="line">前缀：A, AB, ABC     (不包含最后一个字符)</span><br><span class="line">后缀：D, CD, BCD     (不包含第一个字符)</span><br></pre></td></tr></table></figure><h3 id="next-shu-zu-de-gou-jian" tabindex="-1" id="Next-数组的构建">Next 数组的构建</h3><p><strong>核心思想</strong>：利用已经计算出的 <code>next</code> 值来计算新的值（动态规划思想）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 第一个字符的 next 值为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// j 表示当前最长相等前后缀的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果不匹配，回退 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果匹配，增加前后缀长度</span></span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gou-jian-guo-cheng-shi-li" tabindex="-1" id="构建过程示例">构建过程示例</h3><p>模式串：<code>ABABCABAB</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">i=0: pattern[0]=&#x27;A&#x27;</span><br><span class="line">     next[0] = 0</span><br><span class="line"></span><br><span class="line">i=1: pattern[1]=&#x27;B&#x27;, pattern[0]=&#x27;A&#x27;</span><br><span class="line">     不匹配，j=0</span><br><span class="line">     next[1] = 0</span><br><span class="line"></span><br><span class="line">i=2: pattern[2]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;</span><br><span class="line">     匹配！j=1</span><br><span class="line">     next[2] = 1</span><br><span class="line"></span><br><span class="line">i=3: pattern[3]=&#x27;B&#x27;, pattern[1]=&#x27;B&#x27;</span><br><span class="line">     匹配！j=2</span><br><span class="line">     next[3] = 2</span><br><span class="line"></span><br><span class="line">i=4: pattern[4]=&#x27;C&#x27;, pattern[2]=&#x27;A&#x27;</span><br><span class="line">     不匹配，j回退到next[1]=0</span><br><span class="line">     pattern[4]=&#x27;C&#x27;, pattern[0]=&#x27;A&#x27;</span><br><span class="line">     不匹配，j=0</span><br><span class="line">     next[4] = 0</span><br><span class="line"></span><br><span class="line">i=5: pattern[5]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;</span><br><span class="line">     匹配！j=1</span><br><span class="line">     next[5] = 1</span><br><span class="line"></span><br><span class="line">... (以此类推)</span><br></pre></td></tr></table></figure><p><strong>最终结果</strong>：</p><table><thead><tr><th>索引</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>字符</td><td>A</td><td>B</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>A</td><td>B</td></tr><tr><td>next</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><pre><code class="highlight mermaid">graph TD    A[开始: i=1, j=0] --&gt; B&#123;pattern i == pattern j?&#125;    B --&gt;|是| C[j++]    C --&gt; D[next i = j]    D --&gt; E[i++]        B --&gt;|否| F&#123;j &gt; 0?&#125;    F --&gt;|是| G[j = next j-1]    G --&gt; B    F --&gt;|否| H[next i = 0]    H --&gt; E        E --&gt; I&#123;i &lt; n?&#125;    I --&gt;|是| B    I --&gt;|否| J[完成]</code></pre><hr><h2 id="suan-fa-shi-xian" tabindex="-1" id="算法实现">算法实现</h2><h3 id="wan-zheng-shi-xian" tabindex="-1" id="完整实现">完整实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建 next 数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> next;</span><br><span class="line">        </span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 失配时回退</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 匹配时前进</span></span><br><span class="line">            <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KMP 搜索</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">buildNext</span>(pattern);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 模式串指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 主串指针</span></span><br><span class="line">            <span class="comment">// 失配时，模式串回退</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 匹配时，模式串前进</span></span><br><span class="line">            <span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 完全匹配</span></span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;  <span class="comment">// 返回起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KMP kmp;</span><br><span class="line">    </span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos = kmp.<span class="built_in">search</span>(text, pattern);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在位置 &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; 找到模式串&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主串：&quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配：&quot;</span> &lt;&lt; <span class="built_in">string</span>(pos, <span class="string">&#x27; &#x27;</span>) &lt;&lt; pattern &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到模式串&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在位置 10 找到模式串</span><br><span class="line">主串：ABABDABACDABABCABAB</span><br><span class="line">匹配：          ABABCABAB</span><br></pre></td></tr></table></figure><hr><h2 id="fu-za-du-fen-xi" tabindex="-1" id="复杂度分析">复杂度分析</h2><h3 id="shi-jian-fu-za-du" tabindex="-1" id="时间复杂度">时间复杂度</h3><ol><li><p><strong>构建 next 数组</strong>：O(m)</p><ul><li>外层循环：遍历模式串 m 个字符</li><li>内层 while 循环：j 最多回退 m 次（均摊分析）</li></ul></li><li><p><strong>匹配过程</strong>：O(n)</p><ul><li>外层循环：遍历主串 n 个字符</li><li>内层 while 循环：j 最多回退 n 次（均摊分析）</li></ul></li></ol><p><strong>总时间复杂度</strong>：<strong>O(m + n)</strong></p><h3 id="kong-jian-fu-za-du" tabindex="-1" id="空间复杂度">空间复杂度</h3><p><strong>O(m)</strong>：需要存储 next 数组。</p><h3 id="yu-bao-li-suan-fa-dui-bi" tabindex="-1" id="与暴力算法对比">与暴力算法对比</h3><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>主串指针</th></tr></thead><tbody><tr><td>暴力匹配</td><td>O(m×n)</td><td>O(1)</td><td>会回退</td></tr><tr><td>KMP</td><td>O(m+n)</td><td>O(m)</td><td>不回退</td></tr></tbody></table><p><strong>性能提升</strong>：</p><p>对于长度为 1000 的主串和长度为 100 的模式串：</p><ul><li>暴力：最坏 100,000 次比较</li><li>KMP：最多 1,100 次比较</li></ul><hr><h2 id="zong-jie" tabindex="-1" id="总结">总结</h2><h3 id="he-xin-yao-dian" tabindex="-1" id="核心要点">核心要点</h3><ol><li><strong>KMP 的本质</strong>：利用已匹配信息，避免无效回退</li><li><strong>Next 数组</strong>：记录最长相等前后缀，是算法的核心</li><li><strong>时间复杂度</strong>：O(m+n)，主串指针不回退</li><li><strong>适用场景</strong>：单模式串匹配，需要高效查找</li></ol><h3 id="you-que-dian-dui-bi" tabindex="-1" id="优缺点对比">优缺点对比</h3><p><strong>优点</strong>：</p><ul><li>✓ 时间复杂度优秀：O(m+n)</li><li>✓ 主串指针不回退，适合流式处理</li><li>✓ 易于理解和实现</li></ul><p><strong>缺点</strong>：</p><ul><li>✗ 需要额外空间：O(m)</li><li>✗ 多模式匹配需要多次调用</li><li>✗ 对于短模式串，可能不如暴力快（常数因子）</li></ul><h3 id="yu-qi-ta-suan-fa-dui-bi" tabindex="-1" id="与其他算法对比">与其他算法对比</h3><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>暴力</td><td>O(m×n)</td><td>O(1)</td><td>短串、简单场景</td></tr><tr><td>KMP</td><td>O(m+n)</td><td>O(m)</td><td>单模式、长串</td></tr><tr><td>BM</td><td>O(n/m)</td><td>O(m)</td><td>长模式串</td></tr><tr><td>AC自动机</td><td>O(n+m+k)</td><td>O(m×字符集)</td><td>多模式匹配</td></tr></tbody></table><h3 id="kuo-zhan-yue-du" tabindex="-1" id="扩展阅读">扩展阅读</h3><ul><li><a href="https://dl.acm.org/doi/10.1137/0206024">KMP 算法原始论文</a></li><li>Boyer-Moore 算法</li><li>Aho-Corasick 自动机（多模式匹配）</li><li>Sunday 算法</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;kmp-zi-fu-chuan-pi-pei-suan-fa-xiang-jie-cong-yuan-li-dao-shi-xian&quot; tabindex=&quot;-1&quot;&gt;KMP 字符串匹配算法详解：从原理到实现&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;深入理解</summary>
        
      
    
    
    
    <category term="算法" scheme="https://smarter.xin/categories/algorithm/"/>
    
    
    <category term="C++" scheme="https://smarter.xin/tags/C/"/>
    
    <category term="LeetCode" scheme="https://smarter.xin/tags/LeetCode/"/>
    
    <category term="数据结构" scheme="https://smarter.xin/tags/data-structure/"/>
    
    <category term="KMP" scheme="https://smarter.xin/tags/KMP/"/>
    
    <category term="字符串匹配" scheme="https://smarter.xin/tags/string-matching/"/>
    
    <category term="动态规划" scheme="https://smarter.xin/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>关于Clash开启TUN无法联网的问题</title>
    <link href="https://smarter.xin/posts/78c6fb80/"/>
    <id>https://smarter.xin/posts/78c6fb80/</id>
    <published>2025-12-19T08:19:26.000Z</published>
    <updated>2026-01-06T13:16:51.570Z</updated>
    
    <content type="html"><![CDATA[<p>之前我一直在用 Clash for Windows 科学上网。后来为了使用 Google 的反重力（Antigravity）软件，需要开启 <strong>TUN 模式</strong>，但我这边出现了一个非常折磨人的问题：<strong>只要一打开 TUN，就直接断网</strong>。</p><p>这期间我在网上翻了无数帖子、试了无数“玄学设置”，都没能根治。中间还换过同门的一款 CFW（确实能开 TUN 正常用），但它有一个新毛病：<strong>会随机掉网</strong>——有时一瞬间，有时持续十几秒，尤其在和 AI 对话时，断一下就可能导致长回答直接中断，反复重试也很浪费时间。</p><p>于是我决定换到口碑更好、且仍在维护的 <strong>Clash Verge Rev</strong>。结果安装后发现：<strong>开启 TUN 依然无法联网</strong>。这让我意识到：问题不在某一款软件，而在我的网络环境/路由策略上。</p><p>直到某次我无意间翻日志，看到了“不太一样”的提示（大意是内核选择的出口接口/路由不对），我才突然反应过来——</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-934972.png" alt="image-20251219163432701"></p><blockquote><p><strong>我的以太网（Ethernet）连的是内网</strong>。<br>如果系统默认把“以太网”当成更优先的出口，Clash 开启 TUN 后把流量按默认路由丢给以太网，那怎么可能访问公网？</p></blockquote><p>所以真正要解决的不是“怎么调 Clash”，而是：<br><strong>让系统默认出口走 WLAN（Wi-Fi），而不是以太网。</strong></p><p>下面记录两种我亲测有效的方案。</p><hr><h2 id="zheng-zhuang-biao-xian" tabindex="-1" id="症状表现">症状表现</h2><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-346098.png" alt="image-20251219163709107"></p><ul><li>Clash Verge Rev（或其他支持 TUN 的客户端）开启 TUN 后：<ul><li>浏览器打不开网页 / 全局断网</li><li>或日志里出现 IP/路由相关报错（比如出口接口选择异常、路由不可达等）</li></ul></li><li>关闭 TUN 一切恢复正常</li></ul><hr><h2 id="gen-yin-mo-ren-lu-you-jie-kou-you-xian-ji-xuan-cuo-liao" tabindex="-1" id="根因：默认路由-接口优先级选错了">根因：默认路由/接口优先级选错了</h2><p>Windows 在多网卡并存时，会根据 <strong>接口跃点数（Interface Metric）</strong>、路由表等规则决定默认出口。<br>如果你的 <strong>以太网优先级高于 Wi-Fi</strong>，系统就可能优先走以太网默认路由——而你这条以太网只通内网，不通公网，于是“看起来像是 TUN 把网搞没了”。</p><hr><h2 id="fang-an-yi-jin-yong-yi-tai-wang-you-fu-zuo-yong" tabindex="-1" id="方案一：禁用以太网（有副作用）">方案一：禁用以太网（有副作用）</h2><p>适用场景：你暂时不需要访问内网服务，只想立刻恢复公网。</p><h3 id="cao-zuo-bu-zou" tabindex="-1" id="操作步骤">操作步骤</h3><ol><li><code>Win + R</code> 输入 <code>ncpa.cpl</code> 回车（打开“网络连接”）</li><li>找到 <strong>以太网（Ethernet）</strong> → 右键 → <strong>禁用</strong></li><li>再打开 Clash 的 TUN，通常就能直接联网</li></ol><h3 id="que-dian" tabindex="-1" id="缺点">缺点</h3><ul><li>禁用后 <strong>无法访问内网资源</strong>（例如内网服务器、NAS、实验室网段等）</li><li>需要内网时还得手动启用回来</li></ul><hr><h2 id="fang-an-er-ti-sheng-wlan-you-xian-ji-tui-jian" tabindex="-1" id="方案二：提升-WLAN-优先级（推荐）">方案二：提升 WLAN 优先级（推荐）</h2><p>核心思路：把 <strong>Wi-Fi 的 Metric 调小</strong>（优先级更高），把 <strong>以太网的 Metric 调大</strong>（优先级更低）。<br>这样默认出口走 Wi-Fi，但你访问内网网段时，依然可以走以太网（只要路由存在）。</p><h3 id="fang-fa-a-tu-xing-jie-mian-xiu-gai-wen-ding-zhi-guan" tabindex="-1" id="方法-A：图形界面修改（稳定、直观）">方法 A：图形界面修改（稳定、直观）</h3><blockquote><p>建议 IPv4 和 IPv6 都改一下，避免某些环境下“IPv6 先走错”。</p></blockquote><ol><li><p><code>Win + R</code> → 输入 <code>ncpa.cpl</code></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-95e9fb.png" alt="image-20251219163613103"></p></li><li><p>右键 <strong>Wi-Fi</strong> → 属性</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-5a3276.png" alt="image-20251219163831982"></p><ul><li><p>双击 <code>Internet 协议版本 4 (TCP/IPv4)</code> → “高级…”</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-79869f.png" alt="image-20251219163902234"></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-786871.png" alt="image-20251219163919794"></p></li><li><p>取消勾选 <strong>自动跃点数（Automatic metric）</strong></p></li><li><p>在“接口跃点数”填一个较小值，例如：<code>5</code> 或 <code>10</code></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-aaf494.png" alt="image-20251219164047302"></p></li><li><p>IPv6（TCP/IPv6）同样操作一遍（可选但推荐）</p></li></ul></li><li><p>右键 <strong>以太网</strong> → 属性</p><blockquote><p>操作同上</p></blockquote><ul><li>同样进入 IPv4/IPv6 高级设置</li><li>取消自动跃点数</li><li>设置一个较大的值，例如：<code>50</code> / <code>100</code></li></ul></li></ol><p>修改后一般无需重启，断开重连 Wi-Fi/以太网或重启 Clash 即可。</p><hr><h3 id="fang-fa-b-ming-ling-xing-xiu-gai-gua-he-ji-lu-jiao-ben-hua" tabindex="-1" id="方法-B：命令行修改（适合记录-脚本化）">方法 B：命令行修改（适合记录/脚本化）</h3><p>以管理员身份打开 PowerShell，然后：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前接口与跃点数</span></span><br><span class="line"><span class="built_in">Get-NetIPInterface</span> | <span class="built_in">Sort-Object</span> InterfaceMetric | <span class="built_in">Format-Table</span> ifIndex,InterfaceAlias,AddressFamily,InterfaceMetric</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 Wi-Fi 提高优先级（metric 更小）</span></span><br><span class="line"><span class="built_in">Set-NetIPInterface</span> <span class="literal">-InterfaceAlias</span> <span class="string">&quot;WLAN&quot;</span> <span class="literal">-AddressFamily</span> IPv4 <span class="literal">-InterfaceMetric</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">Set-NetIPInterface</span> <span class="literal">-InterfaceAlias</span> <span class="string">&quot;WLAN&quot;</span> <span class="literal">-AddressFamily</span> IPv6 <span class="literal">-InterfaceMetric</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 Ethernet 降低优先级（metric 更大）</span></span><br><span class="line"><span class="built_in">Set-NetIPInterface</span> <span class="literal">-InterfaceAlias</span> <span class="string">&quot;以太网&quot;</span> <span class="literal">-AddressFamily</span> IPv4 <span class="literal">-InterfaceMetric</span> <span class="number">50</span></span><br><span class="line"><span class="built_in">Set-NetIPInterface</span> <span class="literal">-InterfaceAlias</span> <span class="string">&quot;以太网&quot;</span> <span class="literal">-AddressFamily</span> IPv6 <span class="literal">-InterfaceMetric</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-e5d36a.png" alt="image-20251219164726644"></p><p>这是我修改后的配置</p><blockquote><p>注意：不同机器网卡名称可能不是 <code>WLAN</code> / <code>以太网</code>，以你 <code>Get-NetIPInterface</code> 里看到的 <code>InterfaceAlias</code> 为准。</p></blockquote><h2 id="jin-jie-yong-proxifier-gei-ai-gong-ju-zuo-ying-yong-ji-dai-li-jian-shao-dui-hua-duan-lian" tabindex="-1" id="进阶：用-Proxifier-给-AI-工具做应用级代理，减少对话断连">进阶：用 Proxifier 给 AI 工具做应用级代理，减少对话断连</h2><p>即便把 TUN 问题解决了，我还遇到过 <strong>AI 工具网络不稳定、对话偶发中断</strong> 的情况。很多 AI 客户端/IDE 插件并不总是“乖乖走系统代理”，或者在网络切换时连接更容易抖动。</p><p>我的做法是：<strong>不用全局折腾，把 AI 相关进程强制走 Clash 的本地 SOCKS5 代理</strong>（应用级代理），让它们的网络路径更一致，从而减少断连。</p><p>下面以我当前配置为例：</p><h3 id="1-zai-proxifier-tian-jia-clash-de-socks-5-dai-li" tabindex="-1" id="1）在-Proxifier-添加-Clash-的-SOCKS5-代理">1）在 Proxifier 添加 Clash 的 SOCKS5 代理</h3><p>打开 Proxifier：</p><ul><li><p><code>Profile</code> → <code>Proxy Servers...</code> → <code>Add...</code></p><p>或点击图中位置</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-8914cf.png" alt="image-20251219165528874"></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-74f503.png" alt="image-20251219165634467"></p></li><li><p>按如下填写：</p><ul><li><p><strong>Address</strong>：<code>127.0.0.1</code></p></li><li><p><strong>Port</strong>：<code>7897</code></p></li><li><p><strong>Protocol</strong>：<code>SOCKS Version 5</code></p></li><li><p>Authentication 不用勾（一般 Clash 本地不需要）</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-315358.png" alt="image-20251219165712957"></p></li></ul></li><li><p>点 <code>Check</code> 测试连通性，确认 OK</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-b43fbe.png" alt="image-20251219165741786"></p></li></ul><blockquote><p>提醒：<code>7897</code> 是我这边 Clash 的 SOCKS 端口，你的端口以 Clash/Verge 的端口设置为准。</p></blockquote><h3 id="2-xin-zeng-yi-tiao-ai-gui-ze-zhi-dai-li-zhi-ding-cheng-xu" tabindex="-1" id="2）新增一条“AI”规则，只代理指定程序">2）新增一条“AI”规则，只代理指定程序</h3><ul><li><p><code>Profile</code> → <code>Proxification Rules...</code> → <code>Add...</code></p><p>或点击图中位置</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-ccb281.png" alt="image-20251219165831617"></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-b3841a.png" alt="image-20251219165908706"></p></li><li><p><strong>Name</strong>：<code>AI</code>（勾选 Enabled）</p></li><li><p><strong>Applications</strong>：填入需要强制走代理的程序：</p><ul><li><code>antigravity.exe; language_server_windows_x64.exe; cursor.exe</code></li></ul></li><li><p><strong>Target hosts</strong>：留空（表示不限制域名）</p></li><li><p><strong>Target ports</strong>：<code>Any</code></p></li><li><p><strong>Action</strong>：选择刚才创建的代理</p><ul><li><code>Proxy SOCKS5 127.0.0.1</code></li></ul></li></ul><p>最后把 <strong>AI 规则放到 Default 规则之上</strong>（规则是从上往下匹配的），避免被默认规则抢先匹配。</p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-db930e.png" alt="image-20251219165956692"></p><p><img src="https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/%E5%85%B3%E4%BA%8EClash%E5%BC%80%E5%90%AFTUN%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/2025-12-19-17-07-35-f8cbd4.png" alt="image-20251219170115699"></p><h3 id="3-xiao-guo" tabindex="-1" id="3）效果">3）效果</h3><ul><li>只有 AI 相关进程走代理</li><li>内网/其他软件照常走直连或按你自己的规则走</li><li>对话连接更稳定：不会因为某些程序绕过系统代理而“时通时不通”，也更不容易在长对话时突然断掉</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前我一直在用 Clash for Windows 科学上网。后来为了使用 Google 的反重力（Antigravity）软件，需要开启 &lt;strong&gt;TUN 模式&lt;/strong&gt;，但我这边出现了一个非常折磨人的问题：&lt;strong&gt;只要一打开</summary>
        
      
    
    
    
    <category term="Clash" scheme="https://smarter.xin/categories/clash/"/>
    
    
    <category term="Clash" scheme="https://smarter.xin/tags/Clash/"/>
    
    <category term="Proxifier" scheme="https://smarter.xin/tags/Proxifier/"/>
    
    <category term="Tun" scheme="https://smarter.xin/tags/Tun/"/>
    
  </entry>
  
</feed>
