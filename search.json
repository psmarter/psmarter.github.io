[{"title":"AI Infra学习之旅-PagedAttention详解","url":"/posts/fbab2bc4/","content":"PagedAttention：大语言模型推理的内存管理革命\n\n借鉴操作系统虚拟内存思想，实现LLM推理的高效KV Cache管理\n\n\n引言\n在大语言模型(LLM)快速发展的今天，如何高效地进行模型推理成为了一个关键问题。随着模型规模的不断扩大，内存管理成为制约推理性能的重要瓶颈。本文将深入介绍PagedAttention技术——一种受操作系统虚拟内存管理启发的创新性内存管理方法，它极大地提升了LLM推理的效率和throughput。\n一、背景：LLM推理中的内存挑战\n1.1 KV Cache的作用\n在Transformer架构的自回归生成过程中，每个token的生成都需要用到之前所有token的Key和Value向量。为了避免重复计算，这些K、V向量会被缓存起来，这就是KV Cache。\n输入序列: &quot;今天天气&quot;生成过程:- 生成&quot;很&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;的KV- 生成&quot;好&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;、&quot;很&quot;的KV- ...依次类推\n1.2 传统方法的问题\n传统的KV Cache管理方法存在严重的内存浪费问题：\n\n\n\n外部碎片化（External Fragmentation）\n\n必须为每个请求预先分配一个连续的内存块\n由于无法预知生成序列的最终长度，通常按最大序列长度分配\n实际使用长度远小于分配长度时，造成大量浪费\n\n\n\n内部碎片化（Internal Fragmentation）\n\n批处理中不同请求的序列长度不同\n必须按批次中最长序列分配内存\n短序列的剩余空间无法被其他请求使用\n\n\n\n研究表明，传统方法的内存浪费率高达60%-80%，这严重限制了批处理大小和系统吞吐量。\ngraph LR\n    subgraph 传统方法\n        A[请求1] --&gt; B[预分配大块连续内存]\n        A2[请求2] --&gt; B2[预分配大块连续内存]\n        B --&gt; C[大量浪费:60-80%]\n        B2 --&gt; C\n    end\n    \n    subgraph PagedAttention\n        D[请求1] --&gt; E[按需分配小块]\n        D2[请求2] --&gt; E2[按需分配小块]\n        E --&gt; F[极少浪费:&lt;4%]\n        E2 --&gt; F\n    end\n    \n    style C fill:#FFB6C1\n    style F fill:#90EE90\n\n二、PagedAttention核心原理\n2.1 操作系统的启发\nPagedAttention的设计灵感来源于操作系统中的虚拟内存分页机制：\n\n\n\n操作系统虚拟内存\nPagedAttention\n\n\n\n\n虚拟内存页\n逻辑KV块\n\n\n物理内存页\n物理KV块\n\n\n页表\n块表(Block Table)\n\n\n按需分页\n动态块分配\n\n\n写时复制\nKV块共享\n\n\n\n\n2.2 核心设计\n2.2.1 块状存储\nPagedAttention将KV Cache划分为固定大小的块(Block)：\n\n每个块存储固定数量token的KV向量（通常16-128个token）\n块可以在物理内存中非连续存储\n每个序列的KV Cache由多个块组成\n\n逻辑序列: [Token1, Token2, ..., Token100]         ↓物理存储: [Block0: Token1-16] → 物理地址 0x1000         [Block1: Token17-32] → 物理地址 0x3000         [Block2: Token33-48] → 物理地址 0x2000         ...\n\n2.2.2 块表映射\n每个序列维护一个块表(Block Table)，记录逻辑块到物理块的映射：\n# 伪代码示例class BlockTable:    def __init__(self):        self.logical_to_physical = &#123;&#125;  # 逻辑块号 -&gt; 物理块地址        def get_physical_block(self, logical_block_id):        return self.logical_to_physical[logical_block_id]\n\n2.2.3 动态分配\n\n按需分配：只在需要时分配新块\n精细粒度：以块为单位分配，而非整个序列\n即时回收：序列完成后立即释放所有块\n\n2.3 Attention计算的适配\n在PagedAttention中，Attention计算需要根据块表来访问KV Cache：\n# 传统Attention（伪代码）def traditional_attention(Q, K_cache, V_cache):    scores = Q @ K_cache.T  # 直接访问连续内存    attention_weights = softmax(scores)    output = attention_weights @ V_cache    return output# PagedAttention（伪代码）def paged_attention(Q, block_table, physical_blocks):    output = 0    for logical_block_id in block_table:        # 通过块表查找物理块        physical_block = physical_blocks[block_table[logical_block_id]]        K_block, V_block = physical_block                # 在每个块上计算Attention        scores = Q @ K_block.T        attention_weights = softmax(scores)        output += attention_weights @ V_block        return output\n三、PagedAttention的关键优势\n3.1 近乎零的内存浪费\n通过块状动态分配，PagedAttention实现了：\n\n外部碎片 ≈ 0：无需预分配最大长度\n内部碎片 &lt; 4%：只有最后一个未满的块存在浪费\n\n这将内存利用率从传统的20-40%提升到96%以上！\n3.2 高吞吐量提升\n更高的内存利用率意味着：\n\n可以容纳更大的批处理大小\nGPU利用率显著提升\n系统吞吐量提升2-24倍\n\n\n\n\n对比系统\n吞吐量提升\n\n\n\n\nHuggingFace Transformers\n24x\n\n\nFasterTransformer\n3.5x\n\n\nOrca\n2-4x\n\n\n\n3.3 高效的内存共享\nPagedAttention支持多种场景下的KV Cache共享：\n3.3.1 并行采样（Parallel Sampling）\n当需要为同一个prompt生成多个不同的响应时：\n请求: &quot;写一首关于春天的诗&quot;     ↓共享Prompt的KV Cache     ↓生成多个不同版本：版本1、版本2、版本3...\n通过**写时复制(Copy-on-Write)**机制，多个生成序列可以共享相同prompt的KV块。\n\n3.3.2 Beam Search\n在Beam Search中，多个候选序列共享大部分前缀KV Cache：\nBeam 1: &quot;春天来了&quot; → &quot;万物复苏&quot;Beam 2: &quot;春天来了&quot; → &quot;花开满园&quot;  ← 共享&quot;春天来了&quot;的KVBeam 3: &quot;春天来了&quot; → &quot;鸟语花香&quot;\n\n3.3.3 共享系统Prompt\n多个用户请求可能共享相同的系统提示词：\nSystem Prompt: &quot;你是一个helpful的AI助手...&quot;              ↓ (多个请求共享)User1: &quot;今天天气怎么样？&quot;User2: &quot;帮我写个代码&quot;User3: &quot;翻译这段文字&quot;\n\n3.4 支持长上下文\n\n无需预分配连续大内存块\n可以处理远超单次分配限制的超长序列\n动态扩展，按需增长\n\n四、vLLM：PagedAttention的工程实现\n4.1 vLLM架构概述\nvLLM是首个基于PagedAttention的开源LLM推理引擎，实现了：\n┌─────────────────────────────────────┐│        Request Manager              ││   (调度、批处理、优先级管理)          │└──────────────┬──────────────────────┘               │┌──────────────▼──────────────────────┐│     KV Cache Manager                ││  - 块池管理                          ││  - 块表维护                          ││  - 自动前缀缓存(Automatic Prefix Cache)│└──────────────┬──────────────────────┘               │┌──────────────▼──────────────────────┐│    Model Executor                   ││  (PagedAttention Kernel)            │└─────────────────────────────────────┘\n4.2 KV Cache Manager\n核心功能：\n\n块池管理：维护可用物理块的池\n块分配：为新token分配块\n块回收：释放完成请求的块\n引用计数：支持块共享的引用计数机制\n\n# vLLM块管理器简化示例class BlockManager:    def __init__(self, block_size, num_blocks):        self.block_size = block_size        self.free_blocks = set(range(num_blocks))        self.ref_counts = defaultdict(int)        def allocate_block(self):        if not self.free_blocks:            return None  # 内存不足        block_id = self.free_blocks.pop()        self.ref_counts[block_id] = 1        return block_id        def share_block(self, block_id):        # 写时复制：增加引用计数        self.ref_counts[block_id] += 1        def free_block(self, block_id):        self.ref_counts[block_id] -= 1        if self.ref_counts[block_id] == 0:            self.free_blocks.add(block_id)            del self.ref_counts[block_id]\n4.3 自动前缀缓存\nvLLM实现了**自动前缀缓存(Automatic Prefix Caching)**功能：\n\n使用哈希表管理KV块\n自动检测和复用相同的前缀\n无需用户手动指定\n\n# 自动前缀缓存原理class PrefixCache:    def __init__(self):        self.hash_table = &#123;&#125;  # token_hash -&gt; block_id        def lookup(self, token_sequence):        token_hash = hash(tuple(token_sequence))        return self.hash_table.get(token_hash)        def insert(self, token_sequence, block_id):        token_hash = hash(tuple(token_sequence))        self.hash_table[token_hash] = block_id\n4.4 调度策略\nvLLM支持多种调度策略：\n\nFCFS（First-Come-First-Serve）：先到先服务\n优先级调度：根据请求优先级\n抢占和交换：内存不足时可以将部分请求的KV Cache交换到CPU\n\n五、技术细节与实现要点\n5.1 块大小的选择\n块大小的权衡：\n\n\n较小块（如16 tokens）：\n\n✅ 内存碎片更少\n❌ 块表开销大，查找次数多\n\n\n\n较大块（如128 tokens）：\n\n✅ 块表开销小\n❌ 最后一块可能浪费较多\n\n\n\n实践中通常选择16-64之间\n5.2 CUDA Kernel优化\nPagedAttention需要高效的CUDA kernel来处理非连续内存访问：\n// PagedAttention CUDA Kernel简化示例__global__ void paged_attention_kernel(    const float* Q,          // Query    const float* K_blocks,   // 所有K块    const float* V_blocks,   // 所有V块    const int* block_table,  // 块表    float* output,    int num_blocks) &#123;    // 1. 遍历块表中的每个块    for (int i = 0; i &lt; num_blocks; i++) &#123;        int physical_block_id = block_table[i];                // 2. 从物理块加载KV        const float* K_block = &amp;K_blocks[physical_block_id * BLOCK_SIZE];        const float* V_block = &amp;V_blocks[physical_block_id * BLOCK_SIZE];                // 3. 计算attention score        float score = compute_attention(Q, K_block, V_block);                // 4. 累加到输出        accumulate_output(output, score);    &#125;&#125;\n5.3 内存预算与OOM处理\n# 内存管理策略class MemoryManager:    def can_allocate(self, num_blocks_needed):        return len(self.free_blocks) &gt;= num_blocks_needed        def evict_if_needed(self, num_blocks_needed):        &quot;&quot;&quot;内存不足时的驱逐策略&quot;&quot;&quot;        if not self.can_allocate(num_blocks_needed):            # 将低优先级请求的KV Cache迁移到CPU            self.swap_to_cpu(num_blocks_needed)        def swap_to_cpu(self, num_blocks):        &quot;&quot;&quot;将GPU块交换到CPU内存&quot;&quot;&quot;        # 选择要交换的请求（如最久未使用）        victims = self.select_victims(num_blocks)        for victim in victims:            self.move_blocks_to_cpu(victim)            self.free_blocks.extend(victim.blocks)\n六、与其他优化技术的对比\n6.1 Flash Attention\n\n\n\n特性\nFlash Attention\nPagedAttention\n\n\n\n\n优化目标\n计算效率（减少HBM访问）\n内存管理效率\n\n\n主要技术\nTiling + 重计算\n块状内存分配\n\n\n加速场景\n训练 &amp; 推理\n主要用于推理\n\n\n是否兼容\n✅ 可结合使用\n✅ 可结合使用\n\n\n\n两者可以结合：vLLM可以同时使用Flash Attention和PagedAttention！\n6.2 量化技术（INT8/INT4）\n\n\n\n特性\n量化\nPagedAttention\n\n\n\n\n优化维度\n减少每个参数的存储位数\n优化内存分配方式\n\n\n内存节省\n模型权重和激活\nKV Cache\n\n\n是否互补\n✅ 高度互补\n✅ 高度互补\n\n\n\n6.3 推测解码（Speculative Decoding）\nPagedAttention与推测解码也可结合：\n\n推测解码：通过小模型加速生成\nPagedAttention：提升内存利用率和吞吐量\n\n七、总结\nPagedAttention是大语言模型推理领域的一项重要创新：\n核心贡献\n\n✅ 近乎零浪费的内存管理：将浪费率从60-80%降低到&lt;4%\n✅ 显著的吞吐量提升：2-24倍的性能提升\n✅ 灵活的KV共享机制：支持并行采样、Beam Search等复杂场景\n✅ 工程化落地：vLLM已成为业界主流推理引擎\n\n参考资料\n\n原始论文：“Efficient Memory Management for Large Language Model Serving with PagedAttention” (2023)\nvLLM GitHub: https://github.com/vllm-project/vllm\nvLLM官方文档: https://docs.vllm.ai/\nPagedAttention博客系列（多个技术博客）\n\n","categories":["AI Infra"],"tags":["vLLM","LLM","PagedAttention","KV Cache","AI系统","AI Infrastructure","内存管理"]},{"title":"AI Infra学习之旅-Transformer知识地图","url":"/posts/4854dc00/","content":"AI Infra学习路线\n\n写给刚入门AI Infrastructure的同学：你真的需要搞懂Transformer的每个细节吗？\n\n写在前面\n最近跟几个刚开始学AI Infra的朋友聊天，大家都有个共同的困惑：明明是搞基础设施的，为什么老有人让我们先把Transformer学透？\n说实话，我刚开始也纠结过。看了一堆Transformer的论文和教程，什么Attention机制、位置编码、残差连接…感觉自己要变成算法工程师了。后来跑了几个月的vLLM、搞了一些推理优化，才慢慢想明白：\nAI Infra工程师确实要懂Transformer，但不是全懂，而是要懂对地方。\n今天这篇文章，我想跟你聊聊：作为AI Infra的学习者，到底应该重点关注Transformer的哪些部分，哪些可以暂时放一放，以及不同方向（推理优化、模型部署、系统架构）的学习侧重点。\n一、为什么AI Infra一定要学Transformer？\n在回答&quot;学什么&quot;之前，先说说&quot;为什么要学&quot;。\n1.1 现代AI系统的核心就是Transformer\n看看你做AI Infra会接触的东西：\n\n推理框架：vLLM、TensorRT-LLM、TGI、…\n优化技术：Flash Attention、PagedAttention、KV量化、…\n部署工具：Triton Inference Server、Ray Serve、…\n\n这些东西，100%都是围绕Transformer模型设计的。\n如果你不了解Transformer的工作原理，就像是开飞机但不知道飞机怎么飞的——能起飞，但出了问题根本不知道从哪查。\n1.2 &quot;搞硬件&quot;也要懂模型\n有人会说：“我是做基础设施的，GPU、内存、网络这些才是我该关心的吧？”\n没错，但问题是：\n\n内存优化：为什么要优化？因为KV Cache太大了。KV Cache是啥？Transformer推理过程中产生的。\n计算优化：为什么要Flash Attention？因为原生Attention太慢了。为什么慢？要看Transformer的计算流程。\n并行策略：为什么要张量并行？因为单卡放不下大模型。为什么放不下？要看Transformer的参数分布。\n\n你优化的对象就是Transformer模型，不懂它怎么优化？\n1.3 一个真实的例子\n给你讲个我自己的例子。\n前阵子我在用vLLM跑一个模型，发现GPU内存占用特别高，batch size稍微大一点就OOM了。当时我只会调参数，试了半天没用。\n后来静下心来看了Transformer的KV Cache机制，才明白：\n\n每个token都要生成K和V向量\n这些向量要一直存在GPU显存里\n序列越长，batch越大，KV Cache占用呈指数级增长\n\n理解了这个，我才知道为什么PagedAttention能省内存（块状分配减少碎片），为什么要用Multi-Query Attention（减少KV头数）。\n不懂原理，就只能瞎调参。\n二、AI Infra视角下的Transformer知识地图\n好了，既然要学，那到底学什么？\n我把Transformer的知识点分成三个层级，告诉你哪些必须学、哪些重要、哪些了解就行。\n核心必学\n这部分不学，你做AI Infra基本寸步难行。\n2.1 KV Cache机制\n为什么必学？\nKV Cache是AI Infra优化的头号目标。不夸张地说，现代LLM推理优化的一半技术都在优化KV Cache。\n必须理解的点：\n\nKV Cache是怎么产生的？\n\n在Transformer的自回归生成过程中（比如GPT生成文本），每生成一个新token，都需要用到之前所有token的Key和Value向量。\n生成第1个词: 需要prompt的KV生成第2个词: 需要prompt + 第1个词的KV生成第3个词: 需要prompt + 第1个词 + 第2个词的KV...\n为了避免重复计算，这些KV向量会被缓存起来——这就是KV Cache。\n\nKV Cache有多占内存？\n\n假设一个7B参数的模型，hidden size是4096，有32层：\n\n每个token的KV向量：2 × 4096 × 32 × 2字节(FP16) ≈ 512KB\n生成1000个token：512KB × 1000 ≈ 512MB\nBatch size = 32：512MB × 32 = 16GB\n\n16GB！这还只是KV Cache，不包括模型权重和其他激活值。所以你会看到大batch推理很容易OOM。\n\n怎么优化KV Cache？\n\n\nPagedAttention：像操作系统的虚拟内存一样，分块管理KV Cache，减少内存碎片（这就是vLLM的核心技术）\nMulti-Query Attention (MQA)：让所有Query头共享一组KV，大幅减少KV Cache大小\nKV量化：把KV向量从FP16量化到INT8甚至INT4\nPrefix Caching：多个请求共享相同的系统prompt对应的KV\n\n实践建议：\n去看vLLM的源码，重点看CacheEngine和BlockManager这两个模块。跑一个模型，用nvidia-smi监控显存占用，你会对KV Cache有直观的感受。\n2.2 Attention计算流程\n为什么必学？\nAttention计算是Transformer的性能瓶颈。你做推理优化，90%的时间都在优化Attention。\n必须理解的点：\n\nAttention的四步计算\n\n# 伪代码scores = Q @ K.T  / sqrt(d_k)     # 1. 点积 + 缩放attention_weights = softmax(scores)  # 2. Softmax归一化  output = attention_weights @ V       # 3. 加权求和\n\n为什么Attention慢？\n\n\n内存瓶颈：Q、K、V都是大矩阵，频繁在HBM（显存）和SRAM（缓存）之间搬运数据\n计算复杂度：O(n²)，序列越长越慢\n\n\n优化方向\n\n\nFlash Attention：重新组织计算顺序，减少HBM访问次数（vLLM已经集成）\n稀疏Attention：不是所有token都需要关注所有其他token\nKernel融合：把多个小算子融合成一个大kernel，减少数据搬运\n\n实践建议：\n对比一下开启和关闭Flash Attention的性能差异。在vLLM里很简单：\n# 开启Flash Attention（默认）llm = LLM(model=&quot;facebook/opt-125m&quot;)# 关闭Flash Attentionllm = LLM(model=&quot;facebook/opt-125m&quot;, disable_flash_attn=True)\n跑个benchmark，你会发现差距很明显。\n2.3 Batch处理与序列并行\n为什么必学？\n提升推理系统吞吐量的核心手段。\n必须理解的点：\n\n静态Batching vs 动态Batching\n\n传统方法：等凑够32个请求再一起推理。问题是：第1个请求可能要等很久。\nContinuous Batching（vLLM用的）：来一个处理一个，动态调整batch。\n\n为什么Transformer适合Batching？\n\n因为Attention是独立的！处理batch中的第1个序列和第2个序列，计算是并行的。\n实践建议：\n用vLLM跑两个实验：\n\n单请求推理：测latency（延迟）\n批量请求推理：测throughput（吞吐量）\n\n你会发现throughput可以提升10倍+，但latency只增加了一点点。\n\n重要理解\n这部分不是立刻就用，但理解了能帮你少走弯路。\n2.4 位置编码（Positional Encoding）\n为什么要关注？\n影响模型处理长上下文的能力。\nTransformer的Self-Attention本身不感知位置，&quot;我爱你&quot;和&quot;你爱我&quot;对它来说是一样的。所以需要位置编码来告诉模型词的顺序。\nAI Infra关心什么？\n\n原始位置编码（Sinusoidal）：有长度限制，不适合超长上下文\nRoPE（Rotary Position Embedding）：很多新模型（LLaMA等）用这个，支持外推到更长序列\nALiBi：另一种方案，不需要额外参数\n\n如果你要部署一个支持32K上下文的模型，位置编码方案会直接影响性能和效果。\n2.5 Multi-Head Attention\n为什么要关注？\n影响模型并行策略。\n多头注意力意味着计算可以并行。如果一个模型有32个头，你可以把它们分到多个GPU上（张量并行）。\nAI Infra关心什么？\n\n头数是2的幂次（8、16、32）方便切分\nMQA/GQA（Multi-Query/Grouped-Query Attention）用更少的头，更省内存\n\n2.6 Encoder vs Decoder 架构\n为什么要关注？\n不同架构的推理特性完全不同。\n\n\nEncoder-only (BERT类)：\n\n输入一段文本，输出一段表示\n没有自回归生成，不需要KV Cache\n推理很快，适合分类、检索任务\n\n\n\nDecoder-only (GPT类)：\n\n自回归生成，每个词依赖前面所有词\n需要大量KV Cache\n推理慢，但生成能力强\n\n\n\nAI Infra关心什么？\n你部署BERT和GPT，优化策略完全不同：\n\nBERT：重点优化计算（算子融合、量化）\nGPT：重点优化内存（KV Cache管理、Paged Attention）\n\n\n了解即可\n这部分主要是训练相关，推理时影响不大。\n2.7 Masked Attention\n训练时用来防止模型&quot;偷看&quot;未来的词。推理时生成本来就是一个词一个词来的，不存在这个问题。\n了解就行，不用深究。\n2.8 残差连接 &amp; Layer Norm\n这些是为了稳定训练过程。推理时它们就是网络的一部分，你优化时treat it as a black box就行。\n如果做算子优化，可能会关注Layer Norm的实现。\n三、不同AI Infra方向的学习侧重\n根据你的具体方向，学习重点不太一样。\n推理优化工程师\n你的日常工作：\n让模型跑得更快、用更少资源、支持更大batch。\nTransformer知识优先级：\n\n\nKV Cache管理：必须吃透\n\nKV的产生、存储、读取全流程\nPagedAttention原理和实现\nPrefix Caching、KV量化\n\n\n\nAttention计算优化：核心战场\n\nFlash Attention的原理（至少懂为什么快）\nMulti-Query Attention的效果\nSparse Attention的适用场景\n\n\n\n量化对Transformer的影响：必备技能\n\n哪些部分可以量化（权重、激活、KV Cache）\n量化后的精度损失\n量化算子的实现\n\n\n\n学习路线：\n第1周：搞透KV Cache\n\n看vLLM的CacheEngine源码\n画出KV Cache的生命周期图\n跑实验：监控不同batch下的KV占用\n\n第2-3周：实践优化技术\n\n开启/关闭Flash Attention对比\n尝试不同的block size（PagedAttention参数）\n实现一个简单的KV Cache管理器（Python即可）\n\n第4周+：深入一个方向\n\n如果做kernel优化：学CUDA，看Flash Attention源码\n如果做系统优化：学调度策略，看vLLM的scheduler\n如果做量化：学INT8/INT4 kernel实现\n\n模型部署工程师\n你的日常工作：\n让模型在生产环境稳定运行，支持高并发请求。\nTransformer知识优先级：\n\n\n模型架构与框架对应：必须清楚\n\nEncoder-only vs Decoder-only的部署差异\n不同框架对Transformer的支持（TensorRT-LLM、vLLM、TGI）\n模型格式转换（PyTorch → ONNX → TensorRT）\n\n\n\nBatch处理机制：影响吞吐量\n\nDynamic Batching的实现\nContinuous Batching（vLLM的核心）\nBatch size与latency的trade-off\n\n\n\n长上下文支持：客户常问的问题\n\n位置编码方案（RoPE、ALiBi）\n长上下文下的内存管理\nSliding Window Attention\n\n\n\n学习路线：\n第1周：熟悉部署流程\n\n在vLLM上部署一个模型\n尝试不同的推理框架（TGI、TensorRT-LLM）\n对比它们的API和性能\n\n第2周：理解架构差异\n\n部署一个BERT模型（如果做任务推理）\n部署一个GPT模型\n总结两者的部署要点差异\n\n第3周：优化并发性能\n\n测试不同max_batch_size的影响\n配置动态batching参数\n监控GPU利用率\n\n第4周+：生产化\n\n加入监控（Prometheus + Grafana）\n实现自动扩缩容\n做故障演练\n\nAI系统架构师\n你的日常工作：\n设计支持千亿参数模型的分布式推理系统。\nTransformer知识优先级：\n\n\n模型并行策略：核心技能\n\n张量并行（Tensor Parallelism）在Transformer中的应用\n流水线并行（Pipeline Parallelism）的切分点\n序列并行（Sequence Parallelism）的适用场景\n\n\n\n内存墙与计算墙：系统瓶颈\n\nTransformer哪些操作是compute-bound，哪些是memory-bound\n不同硬件（A100 vs H100）的特性\n通信开销的计算\n\n\n\n端到端推理流程：全局视角\n\n从接收请求到返回结果的完整路径\n各阶段的瓶颈和优化点\nSLA保证策略\n\n\n\n学习路线：\n第1-2周：理解并行策略\n\n阅读Megatron-LM、DeepSpeed论文\n理解Transformer各层如何切分\n画出并行策略的拓扑图\n\n第3周：分析瓶颈\n\n用Nsight分析Transformer的kernel性能\n区分compute-bound和memory-bound操作\n计算不同配置下的理论性能上限\n\n第4周+：设计系统\n\n设计一个支持千亿参数模型的推理集群\n考虑成本、延迟、吞吐量的trade-off\n写技术方案文档\n\n四、学习建议与避坑指南\n推荐做法\n1. 从实践入手\n不要上来就啃论文。先跑起来一个vLLM程序，看看KV Cache在哪，占了多少内存。有了直观感受，再看原理会轻松很多。\n2. 关注&quot;为什么影响性能&quot;\n学每个概念，都问自己：这个东西为什么会影响推理性能？是影响内存、计算还是通信？\n比如学位置编码，AI Infra关心的不是数学公式，而是：\n\nRoPE为什么比Sinusoidal支持更长上下文？\n这对内存有什么影响？\n\n3. 动手实验\n理论只是理论，跑个实验印象深刻一百倍。\n推荐实验：\n\n监控KV Cache占用随序列长度的变化\n对比Flash Attention开启前后的速度\n测试不同batch size对吞吐量的影响\n\n4. 看开源代码\nvLLM、TensorRT-LLM、TGI的代码都开源的。看不懂C++/CUDA没关系，先看Python部分的逻辑。\n重点看：\n\nKV Cache的管理逻辑\nBatch调度策略\n内存分配器\n\n写在最后\n回到开头的问题：AI Infra工程师要不要学Transformer？\n要学，但要聪明地学。\n不要试图把Transformer的每个细节都搞懂，那是算法工程师的事。你要做的是：\n\n抓住核心：KV Cache、Attention计算、Batch处理\n理解影响：每个设计为什么影响性能\n动手实践：跑起来，监控起来，优化起来\n\n记住，AI Infra的价值不是&quot;我懂Transformer&quot;，而是&quot;我能让Transformer跑得又快又稳&quot;。\n\n参考资料\n\n\n我的其他文章：\n\n《Transformer详解》 - Transformer基础原理\n《PagedAttention解析》 - KV Cache优化的核心技术\n《第一个vLLM程序》 - 实践入门\n\n\n\n推荐阅读：\n\nAttention Is All You Need - Transformer原论文\nThe Illustrated Transformer - 最好的可视化教程\nvLLM: Easy, Fast, and Cheap LLM Serving with PagedAttention - vLLM原论文\nFlash Attention - Attention优化技术\n\n\n\n开源项目：\n\nvLLM\nTensorRT-LLM\nText Generation Inference (TGI)\n\n\n\n","categories":["AI Infra"],"tags":["KV Cache","AI Infrastructure","Transformer","推理优化","模型部署","学习路线"]},{"title":"AI Infra学习之旅-Transformer详解","url":"/posts/db1cf321/","content":"Transformer深度解析：从零开始理解&quot;注意力就是你所需要的一切&quot;\n\n如果你关注AI领域，ChatGPT、BERT、GPT这些名字应该不陌生。它们背后有个共同的&quot;老祖宗&quot;——Transformer。我最初看到这个架构时，觉得有点复杂，但当我真正理解了它的设计思想后，突然发现一切都说得通了。今天我想用最直白的方式，和你聊聊这个改变了整个深度学习游戏规则的架构。\n\n写在前面\n2017年，Google的研究团队发了一篇论文，标题叫《Attention Is All You Need》。第一次看到这个标题时我就觉得，这帮人可真敢说——“注意力就是你所需要的一切”，口气未免太大了吧？但几年过去了，事实证明他们是对的。这篇论文提出的Transformer架构，不仅彻底改写了NLP的规则，还渗透到了CV、语音、甚至生物信息学等各个领域。\n在扎进技术细节之前，我想先说说Transformer为什么会出现。毕竟，任何技术的诞生都是为了解决某个实际问题。\n一、RNN的困境：我们为什么需要新架构？\n在Transformer横空出世之前，处理序列数据（比如文本、语音）的主流方案是RNN（循环神经网络）以及它的改进版LSTM、GRU。\nRNN怎么工作的？\n你可以把RNN想象成这样一个场景：你在读一本侦探小说。RNN的处理方式就是一个字一个字地往下读，每读一个字都会更新对剧情的理解。\n输入: &quot;我 爱 北京 天安门&quot;处理: 我 → 我爱 → 我爱北京 → 我爱北京天安门\n听起来挺合理的，对吧？但这里有个致命的问题：必须按顺序处理，没法跳着来。\nRNN的两大硬伤\n1. 没法并行计算\n要处理第3个词，你必须先把第1、2个词处理完。这就像高速公路只有一条车道，不管你有多少辆车（GPU核心），也只能排队一辆一辆过。对于动辄几百万、上亿参数的模型来说，这种串行处理简直是灾难。训练一个大模型可能要好几周，谁受得了？\n2. 长距离依赖问题\n来看这个句子：\n\n“那只猫，它在花园里追蝴蝶的时候不小心撞到了树，后来躺在沙发上休息了一下午，最后终于恢复了精神，它开心地喵喵叫。”\n\n你肯定一眼就能看出最后的&quot;它&quot;指的是开头的&quot;猫&quot;。但对RNN来说，这可太难了。&quot;猫&quot;这个信息得像接力赛一样，一站一站地传到&quot;它&quot;那里。传递链越长，信息损失越严重——就像小时候玩传话游戏，传到最后往往都变味了。\n理论上LSTM通过门控机制缓解了这个问题，但也只是&quot;缓解&quot;，并没有根治。\nTransformer的出现，就是为了一刀切掉这两个问题。\n二、注意力机制：Transformer的核心武器\n在正式拆解Transformer之前，得先搞懂它最核心的部分——自注意力机制（Self-Attention）。这东西听起来玄乎，其实思想很直观。\n先来个直观的例子\n假设有这么一句话：\n\n“那只动物没能过马路，因为它太累了。”\n\n当你读到&quot;它&quot;的时候，你的大脑会做什么？会自动&quot;回看&quot;前面的内容，判断&quot;它&quot;指的是啥。你会把更多注意力分配给&quot;动物&quot;，而不是&quot;马路&quot;或&quot;因为&quot;。\n自注意力机制做的就是这件事：在处理每个词的时候，让模型能&quot;看到&quot;句子里所有其他词，并自动决定该给每个词分配多少注意力。\nQuery、Key、Value：三个关键角色\n自注意力的实现靠三个向量：Query（查询）、Key（键）、Value（值）。\n我第一次看到这三个概念时也很懵，后来发现用图书馆来比喻特别好理解：\n\nQuery：你想找的书的描述，比如&quot;关于深度学习的入门书&quot;\nKey：每本书的标签/索引，比如&quot;深度学习&quot;、“CV”、“烹饪”\nValue：书的实际内容\n\n找书的过程是这样的：\n\n拿着你的Query（需求描述），去和书架上每本书的Key（标签）对比\n标签越匹配，说明这本书越相关\n根据相关性高低，从对应的Value（书的内容）中提取信息\n最后你得到的是一个&quot;混合信息&quot;——相关性高的书提供更多内容，相关性低的书提供较少内容\n\n在Transformer里，每个词都会生成自己的Q、K、V向量。这些向量怎么来的？很简单，就是把词向量和三个可学习的权重矩阵相乘：\nQ = 词向量 × WqK = 词向量 × Wk  V = 词向量 × Wv\n这三个矩阵Wq、Wk、Wv是模型训练过程中学习出来的。\n注意力分数怎么算？\n有了Q、K、V，注意力的计算就是四步走：\n第一步：计算相关性分数\n用当前词的Query和所有词（包括自己）的Key做点积。点积值越大，说明两个词越相关。\n分数 = Q · K^T\n这里为什么用点积？因为点积本质上衡量的是两个向量的相似度。方向越接近，点积越大。\n第二步：缩放（Scaling）\n直接用点积会有个问题：如果向量维度很大（比如512维），点积的结果也会很大。这些大数值经过softmax后，会导致梯度极小（想象一下softmax把一个很大的数映射成接近1，其他数映射成接近0，梯度基本就没了）。\n所以论文里做了个简单粗暴的处理：除以√dk（Key向量维度的平方根）。\n缩放后的分数 = Q·K^T / √dk\n为什么是平方根？论文附录里有数学推导，简单说就是：假设Q和K的每个元素均值为0、方差为1，那么d维向量点积的方差就是d。除以√d可以把方差拉回到1，保持数值稳定。\n第三步：Softmax归一化\n把分数转成概率分布，让所有注意力权重加起来等于1。\n注意力权重 = softmax(缩放后的分数)\n经过softmax后，相关性高的词得到更大的权重，相关性低的词权重接近0。\n第四步：加权求和\n用注意力权重对所有Value向量进行加权求和。\n输出 = 注意力权重 × V\n整个过程可以用一个公式搞定：\nAttention(Q, K, V) = softmax(QK^T / √dk) × V\n来个具体例子\n假设我们有三个词：“我”、“爱”、“你”，每个词的向量是2维（实际中通常是512维或更高，这里为了方便演示用2维）。\n假设&quot;爱&quot;这个词的Query是[1, 0]，三个词的Key分别是：\n\n“我”：[0.8, 0.2]\n“爱”：[1.0, 0.0]\n“你”：[0.6, 0.5]\n\n计算&quot;爱&quot;对三个词的注意力：\n\n\n计算点积：\n\n爱→我：1×0.8 + 0×0.2 = 0.8\n爱→爱：1×1.0 + 0×0.0 = 1.0\n爱→你：1×0.6 + 0×0.5 = 0.6\n\n\n\n缩放（√2 ≈ 1.41）：\n\n爱→我：0.8/1.41 ≈ 0.57\n爱→爱：1.0/1.41 ≈ 0.71\n爱→你：0.6/1.41 ≈ 0.42\n\n\n\nSoftmax后大约是：\n\n爱→我：0.31\n爱→爱：0.38\n爱→你：0.31\n\n\n\n用这些权重对Value向量加权求和，得到&quot;爱&quot;的新表示\n\n\n这个例子说明，“爱&quot;这个词对自己的注意力最高（0.38），但也会关注&quot;我&quot;和&quot;你”（各0.31左右）。这很合理，因为动词往往需要同时关注主语和宾语。\n\n多头注意力：从多个视角看问题\n单个注意力机制就像从一个角度看东西。但理解一句话，可能需要同时考虑语法结构、语义关系、指代关系等多个维度。\n多头注意力（Multi-Head Attention） 就是这个思路：\n\n把Q、K、V分别切成多个&quot;头&quot;（原论文用了8个头）\n每个头独立计算注意力\n把所有头的结果拼起来，再做一次线性变换\n\nMultiHead(Q,K,V) = Concat(head₁, head₂, ..., head₈) × Wo其中 headᵢ = Attention(QWᵢq, KWᵢk, VWᵢv)\n每个头有自己独立的Wq、Wk、Wv权重矩阵，所以能学到不同类型的关系。\n举个例子，在翻译句子时：\n\n第1个头可能专注于主谓关系\n第2个头可能专注于修饰关系（形容词和名词）\n第3个头可能专注于位置关系（前后词的相对位置）\n…\n\n把这些不同视角的信息综合起来，模型对句子的理解就更全面了。\n\n三、Transformer架构全貌\n搞懂了注意力机制，就理解了Transformer的核心。现在我们把整个架构拼起来。\nTransformer采用经典的编码器-解码器（Encoder-Decoder） 结构，左边是Encoder，右边是Decoder。\n\n原论文中的Transformer由6层Encoder和6层Decoder堆叠而成。\n编码器（Encoder）\n每一层Encoder包含两个子层：\n\n多头自注意力层：让每个词都能&quot;看到&quot;输入序列中的所有其他词\n前馈神经网络（FFN）：其实就是两层全连接网络，对每个位置的表示做进一步变换\n\n关键的是，每个子层都包了两个&quot;保护壳&quot;：\n\n残差连接（Residual Connection）：把输入直接加到输出上，这样梯度可以&quot;直通&quot;回去，缓解深层网络的梯度消失问题\n层归一化（Layer Normalization）：把每一层的输出归一化，稳定训练过程\n\n整个流程可以写成：\n输出 = LayerNorm(x + SubLayer(x))\n先对x做变换（MultiHead Attention或FFN），然后和原来的x相加（残差连接），最后归一化。\n6层Encoder叠在一起，就像是对输入做了6次&quot;提炼&quot;，每一层都在之前的基础上提取更抽象的特征。\n解码器（Decoder）\n解码器比编码器多一个子层，总共三个：\n\n带掩码的多头自注意力层（Masked Multi-Head Attention）\n编码器-解码器注意力层（Cross-Attention）：让解码器能够&quot;查阅&quot;编码器的输出\n前馈神经网络\n\n为什么需要掩码（Mask）？\n这是个关键问题。在训练翻译模型时，我们已经有了完整的目标句子。比如把&quot;我爱中国&quot;翻译成&quot;I love China&quot;，训练时我们知道完整的目标是&quot;I love China&quot;。\n但我们希望模型学会的是：根据已生成的词，预测下一个词。如果模型在预测&quot;love&quot;的时候能&quot;偷看&quot;到后面的&quot;China&quot;，那就作弊了——测试时哪有未来的词给你看啊？\n掩码的作用就是在自注意力计算时，遮住未来位置的信息。具体做法是：在softmax之前，把未来位置的分数设为负无穷（-∞）。这样经过softmax后，那些位置的注意力权重就变成0了。\n比如在生成&quot;love&quot;时：\n\n可以看到&lt;start&gt;和&quot;I&quot;\n看不到&quot;love&quot;后面的&quot;China&quot;\n\n\n编码器-解码器注意力\n这是Decoder特有的第二个子层。它让解码器在生成每个词时，可以&quot;查阅&quot;编码器的输出。\n这里的Query来自解码器，Key和Value来自编码器。这样解码器就能根据自己当前的状态（Query），去编码后的源句子里找相关信息（Key），并提取相应内容（Value）。\n比如翻译&quot;我爱中国&quot;→&quot;I love China&quot;时：\n\n生成&quot;I&quot;时，主要关注&quot;我&quot;\n生成&quot;love&quot;时，主要关注&quot;爱&quot;\n生成&quot;China&quot;时，主要关注&quot;中国&quot;\n\n当然，实际情况会更复杂，因为不是所有语言都是一一对应的词序。\n位置编码：告诉模型词的顺序\n自注意力有个&quot;缺陷&quot;：它是位置无关的。\n什么意思？对于自注意力来说，&quot;我爱你&quot;和&quot;你爱我&quot;如果只看词本身，处理方式是一样的——因为它只计算词与词之间的关系，不管它们的位置。\n但词的位置显然很重要啊！&quot;狗咬人&quot;和&quot;人咬狗&quot;完全是两码事。\n怎么办？把位置信息&quot;编码&quot;进输入向量里。\n位置编码（Positional Encoding） 用正弦和余弦函数生成：\nPE(pos, 2i)   = sin(pos / 10000^(2i/d))PE(pos, 2i+1) = cos(pos / 10000^(2i/d))\n其中：\n\npos是词在句子中的位置（0, 1, 2, …）\ni是维度索引（0到d/2）\nd是向量维度（比如512）\n\n为什么用正弦/余弦函数？主要是因为它们有几个好性质：\n\n值域有界：始终在[-1, 1]之间，不会因为位置太大而爆炸\n每个位置唯一：不同位置的编码不会重复\n能表示相对位置：利用三角函数的性质，PE(pos+k)可以表示为PE(pos)的线性组合，这让模型更容易学到&quot;相对位置关系&quot;（比如&quot;前面第2个词&quot;）\n可以泛化到更长序列：训练时见过100个词的句子，测试时来了150个词，位置编码依然能算出来\n\n位置编码会直接加到词嵌入向量上，作为模型的最终输入。\n\n四、实际应用：机器翻译的完整流程\n理论说了一堆，我们来看个具体例子。假设要把&quot;我爱中国&quot;翻译成&quot;I love China&quot;。\n编码阶段\n第一步：输入表示\n\n把&quot;我&quot;、“爱”、&quot;中国&quot;转成词向量（比如用Word2Vec或直接学习Embedding）\n给每个词向量加上位置编码（&quot;我&quot;是位置0，&quot;爱&quot;是位置1，&quot;中国&quot;是位置2）\n\n第二步：经过6层Encoder\n\n第1层：通过自注意力，“爱&quot;这个词能看到&quot;我&quot;和&quot;中国”，理解到这是个主谓宾结构\n第2层：在第1层的基础上进一步提炼，可能学到&quot;我爱X&quot;这种情感表达模式\n…\n第6层：得到包含丰富上下文信息的最终编码\n\n每经过一层，词的表示就更&quot;丰富&quot;一些，包含的上下文信息就更多一些。\n解码阶段\n第一步：开始标记\n输入&lt;start&gt;标记，告诉模型&quot;该生成句子了&quot;。\n第二步：生成&quot;I&quot;\n\n解码器接收&lt;start&gt;\n通过掩码自注意力处理&lt;start&gt;（虽然只有一个词，也要走这个流程）\n通过编码器-解码器注意力，关注编码后的源句子，发现&quot;我&quot;最相关\n经过FFN，输出一个概率分布\n概率最高的词是&quot;I&quot;\n\n第三步：生成&quot;love&quot;\n\n解码器接收&lt;start&gt; I\n掩码确保&quot;I&quot;只能看到自己和&lt;start&gt;，看不到未来\n再次查阅编码器输出，这次主要关注&quot;爱&quot;\n预测下一个词：“love”\n\n第四步：生成&quot;China&quot;\n\n解码器接收&lt;start&gt; I love\n关注编码器中的&quot;中国&quot;\n预测：“China”\n\n第五步：结束\n\n解码器接收&lt;start&gt; I love China\n预测下一个词是&lt;end&gt;，翻译结束\n\n实际使用中，我们不一定每次都选概率最高的词（这叫Greedy Decoding），更常用Beam Search：保留top-k个候选序列，最后选总概率最高的那个。\n\n五、为什么Transformer这么成功？\n回顾一下，Transformer为什么能在短短几年内席卷整个AI领域？\n1. 真·并行计算\n这是最直接的优势。RNN必须一个词一个词地算，Transformer可以一次性算完整个句子。\n假设一个句子有100个词，RNN需要100步串行计算；Transformer可以一步算完所有词的self-attention（当然内部还是有矩阵运算，但这些可以完美并行）。\n在GPU上，这个优势太明显了。GPU有成千上万个核心，就是为并行计算设计的。Transformer充分发挥了硬件优势，训练速度比RNN快了几个数量级。\n2. 长距离依赖不再是问题\n在Transformer里，任意两个词之间的&quot;距离&quot;都是1——一次注意力计算就能直接建立联系。\n不像RNN，信息要一站一站传递。句子开头的词，要传100步才能影响结尾的词；Transformer里，开头直接看到结尾。\n这让模型能轻松捕捉长距离依赖，比如指代消解、长篇文档的主题理解等。\n3. 可解释性更好\n注意力权重可以可视化。你可以画个热力图，看到模型在翻译&quot;China&quot;时，把80%的注意力放在了源句子的&quot;中国&quot;上。\n这比RNN的隐状态好理解多了。RNN的隐状态是一堆数字，你根本不知道它记住了啥、忘了啥。\n4. 极强的可扩展性\nTransformer的架构非常&quot;scalable&quot;。想要更强的模型？简单：\n\n加深：6层→12层→24层→96层\n加宽：512维→1024维→2048维\n加头：8 heads→16 heads→32 heads\n\n从BERT-base（110M参数）到GPT-3（175B参数），再到最新的模型（千亿级），都是Transformer架构。只是层数、维度不同而已。\n而且有个神奇的现象：参数越大，效果往往越好（当然数据也要跟上）。这就是大模型时代的基石。\n六、Transformer的后代们\nTransformer提出后，基于它的各种变体和改进模型层出不穷。这里介绍几个最有影响力的：\n\n\n\n模型\n架构\n特点\n典型应用\n\n\n\n\nBERT\n只用Encoder\n双向编码，擅长理解文本\n搜索引擎、问答系统、文本分类\n\n\nGPT系列\n只用Decoder\n自回归生成，擅长创造文本\nChatGPT、代码生成、创意写作\n\n\nT5\n完整Encoder-Decoder\n把所有NLP任务都转成&quot;文本到文本&quot;\n翻译、摘要、QA统一框架\n\n\nVision Transformer (ViT)\nEncoder-only\n把图像切成patch当词处理\n图像分类、目标检测\n\n\nDALL-E / Stable Diffusion\n改进的Transformer\n文生图、多模态\nAI绘画、图像编辑\n\n\n\nBERT vs GPT：一个理解，一个生成\n\n\nBERT：只用Encoder，训练时随机遮住一些词让模型猜（Masked Language Modeling）。因为能同时看到上下文，所以擅长&quot;理解&quot;任务——给它一篇文章，它能告诉你情感是正面还是负面，能回答文章相关问题。\n\n\nGPT：只用Decoder，训练时根据前面的词预测下一个词。因为只能看到之前的内容，所以擅长&quot;生成&quot;任务——给它一个开头，它能续写出连贯的文章。\n\n\n这也解释了为什么ChatGPT用的是GPT架构，而不是BERT——因为聊天需要生成回复嘛。\n可以说，现代AI的大部分突破，都直接或间接站在Transformer的肩膀上。\n写在最后\n回头看看我们都聊了些啥：\n\n为什么需要Transformer：RNN的并行化困难和长距离依赖问题\n核心机制：Self-Attention通过Query、Key、Value实现对上下文的灵活建模\n多头注意力：从多个角度理解输入\n整体架构：Encoder-Decoder结构，加上位置编码、残差连接、层归一化等关键组件\n实际应用：翻译、生成、理解，无所不能的基础架构\n\nTransformer的影响已经远超当初的机器翻译。从ChatGPT到Stable Diffusion，从AlphaFold到代码补全工具GitHub Copilot，Transformer无处不在。\n说实话，当初读论文时，我没想到这个架构能火成现在这样。它并不完美——比如注意力的O(n²)复杂度在处理超长序列时还是个问题——但它的设计思想实在太优雅了。用注意力机制让模型自己决定关注什么，这个想法简单却强大。\n如果你想深入学习AI，Transformer绝对是绕不过去的一关。理解了它，你就掌握了现代AI的基石。\n希望这篇文章能帮你建立起对Transformer的直观理解。如果有任何疑问，欢迎留言讨论！\n\n参考资料\n\nVaswani, A., et al. (2017). “Attention is all you need.” Advances in Neural Information Processing Systems. 原论文链接\nThe Illustrated Transformer - Jay Alammar 的可视化教程，强烈推荐：http://jalammar.github.io/illustrated-transformer/\nAnnotated Transformer - Harvard NLP的带注释实现，适合动手实践：https://nlp.seas.harvard.edu/annotated-transformer/\nBERT论文: Devlin, J., et al. (2018). “BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding.”\nGPT-3论文: Brown, T., et al. (2020). “Language Models are Few-Shot Learners.”\n\n","categories":["AI Infra"],"tags":["Transformer","注意力机制","深度学习","NLP","人工智能"]},{"title":"AI Infra学习之旅-服务器环境配置","url":"/posts/a8ee689e/","content":"前言\n在上一篇博客中，我在 Kaggle 上成功运行了第一个 vLLM 程序。但 Kaggle 毕竟有时长限制（每周 30 小时），而且每次都要重新配置环境。这次，我有机会使用一台配备双 RTX 4090 的 Ubuntu 服务器，这是一次从云端到本地服务器的重要升级！\n这篇文章将详细记录我从零开始配置这台服务器的完整过程，包括：\n\nSSH 免密登录配置\nVSCode Remote SSH 开发环境搭建\n远程桌面访问（GNOME Remote Desktop）\nPython + vLLM 环境安装\n实际踩过的坑与解决方案\n\n希望这篇文章能帮助到同样需要配置 AI 开发服务器的朋友们。\n\n服务器配置信息\n硬件配置\nGPU型号: 2 × NVIDIA GeForce RTX 4090显存: 24GB × 2 = 48GB 总显存CUDA版本: 12.2驱动版本: 535.274.02\n系统信息\n操作系统: Ubuntu 24.04 LTS用户名: Smarter主机名: 330B内网IP: 服务器ip \n与 Kaggle 对比\n\n\n\n维度\n我的服务器 (RTX 4090×2)\nKaggle/Colab\n\n\n\n\nGPU型号\nRTX 4090 (旗舰)\n⚠️ P100/T4 (中低端)\n\n\n显存\n48GB\n⚠️ 16GB\n\n\nGPU时长\n无限制\n⚠️ 30h/周\n\n\n环境持久化\n永久保存\n❌ 每次重装\n\n\n性能\n独享双卡\n⚠️ 共享单卡\n\n\n适合长实验\n\n❌\n\n\n\n结论: 服务器配置远超 Kaggle，应该优先使用服务器进行学习和开发。\n\n第一阶段：SSH 连接配置\nStep 1: 首次 SSH 连接测试\n在 Windows PowerShell 中执行：\n# 首次连接（替换为你的用户名@服务器IP）ssh Smarter@服务器ip# 首次连接会提示：# The authenticity of host &#x27;192.168.50.58&#x27; can&#x27;t be established.# Are you sure you want to continue connecting (yes/no)?# 输入：yes# 然后输入密码\n成功标志：看到以下提示符说明连接成功\nSmarter@330B:~$\nStep 2: 验证 GPU 状态\n连接成功后，立即验证 GPU：\nnvidia-smi\n我的实际输出：\n\n看到两张 RTX 4090，CUDA 12.2，驱动正常，说明环境 OK！\nStep 3: 配置 SSH 密钥免密登录\n每次输入密码很麻烦，配置公钥登录可以一劳永逸。\n在 Windows 本地生成 SSH 密钥\n打开 PowerShell：\n# 生成 SSH 密钥对（如果还没有）ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# 提示：Enter file in which to save the key# 直接回车（使用默认路径 C:\\Users\\pc\\.ssh\\id_rsa）# 提示：Enter passphrase# 直接回车（不设置密码，方便使用）\n将公钥复制到服务器\n# 读取公钥内容$pub = Get-Content C:\\Users\\pc\\.ssh\\id_rsa.pub# 将公钥追加到服务器的 authorized_keysssh Smarter@服务器ip &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;$pub&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;\n\n💡 这一步会要求输入最后一次服务器密码，之后就可以免密登录了。\n\n测试免密登录\nssh Smarter@服务器ip\n如果直接登录不再要求密码，说明配置成功！\n\n第二阶段：VSCode Remote SSH 配置\nVSCode Remote SSH 是最重要的开发工具，可以让我在 Windows 上直接编辑服务器上的代码。\nStep 1: 安装 VSCode 插件\n在 VSCode 中安装以下插件：\n\nRemote - SSH  (必装)\nRemote - SSH: Editing Configuration Files\nPython\nJupyter\n\nStep 2: 配置 SSH Config 文件\n\n按 F1，输入 Remote-SSH: Open SSH Configuration File\n选择 C:\\Users\\pc\\.ssh\\config\n添加以下配置：\n\n# Ubuntu AI Infra服务器 (RTX 4090×2)Host ai-server    HostName 服务器ip    User Smarter    Port 22    IdentityFile C:\\Users\\pc\\.ssh\\id_rsa    IdentitiesOnly yes    PreferredAuthentications publickey    ForwardAgent yes\n配置说明：\n\nIdentitiesOnly yes: 只使用指定的密钥\nPreferredAuthentications publickey: 优先使用公钥认证\nForwardAgent yes: 允许 SSH Agent 转发\n\nStep 3: 连接到服务器\n\n按 F1，输入 Remote-SSH: Connect to Host\n选择 ai-server\n等待连接（首次会安装 VSCode Server，约 1 分钟）\n成功标志：左下角显示 SSH: ai-server\n\nStep 4: 在 VSCode 中打开服务器文件夹\n连接成功后：\n\n点击 File → Open Folder\n选择 /home/Smarter 或你的项目目录\n现在可以直接在 VSCode 中编辑服务器上的文件了！\n\n\n第三阶段：远程桌面配置\n有时候需要图形界面，我配置了 GNOME Remote Desktop。\n为什么选择 GNOME Remote Desktop？\n\nUbuntu 24.04 自带，无需额外安装\n支持无显示器远程登录\nWindows 自带 mstsc 即可连接\n比 XRDP 更稳定\n\nStep 1: 安装和启用 GNOME Remote Desktop\n在服务器上执行（需要管理员权限）：\n# 1. 安装组件（Ubuntu 24.04 通常已安装）sudo apt updatesudo apt install -y gnome-remote-desktop# 2. 生成 TLS 证书（必需）sudo -u gnome-remote-desktop mkdir -p ~gnome-remote-desktop/.local/share/gnome-remote-desktopsudo openssl req -x509 -newkey rsa:4096 -nodes -days 3650 -sha256 \\  -keyout ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \\  -out ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt \\  -subj &quot;/CN=服务器ip&quot;# 3. 设置文件权限sudo chown gnome-remote-desktop:gnome-remote-desktop \\  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \\  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crtsudo chmod 600 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.keysudo chmod 644 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt\nStep 2: 配置 RDP 认证\n# 禁用 RDP（如果之前启用过）sudo grdctl --system rdp disable 2&gt;/dev/null || true# 设置 TLS 证书sudo grdctl --system rdp set-tls-key ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.keysudo grdctl --system rdp set-tls-cert ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt# 设置 RDP 入口账号密码（这不是 Linux 用户密码）sudo grdctl --system rdp set-credentials rdpuser &#x27;你的强密码&#x27;# 启用 RDPsudo grdctl --system rdp enable\nStep 3: 启动服务并验证\n# 启动并设置开机自启sudo systemctl enable --now gnome-remote-desktop.service# 重启服务sudo systemctl restart gnome-remote-desktop.service# 验证 3389 端口是否监听sudo ss -lnptu | grep 3389# 查看状态sudo grdctl --system status\nStep 4: Windows 端连接\n\n按 Win + R，输入 mstsc\n计算机填写：服务器ip\n首次认证输入：\n\n用户名：rdpuser\n密码：你设置的密码\n\n\n进入 GNOME 登录界面后，使用 Linux 用户 Smarter 的系统密码登录\n\n\n⚠️ 重要：确保 Smarter 用户设置了系统密码：\nsudo passwd Smarter\n\nStep 5: 保存 RDP 凭据（避免每次输入）\n在 Windows 中：\n\n搜索并打开 凭据管理器\n进入 Windows 凭据\n点击 添加 Windows 凭据\n地址填：TERMSRV/服务器ip\n用户名填：rdpuser\n密码填你的密码 → 保存\n\n\n第四阶段：Python 环境配置\nStep 1: 检查 Conda 是否已安装\n在 VSCode 终端（或 SSH 连接）中：\nconda --version\n\n如果显示版本号 → 已安装\n如果报错 command not found → 需要安装\n\nStep 2A: 如果已有 Conda\n# 1. 检查 CUDA 版本nvidia-smi | grep &quot;CUDA Version&quot;# 输出: CUDA Version: 12.2# 2. 检查现有环境conda env list# 3. 创建 AI Infra 环境（如果不存在）conda create -n ai-infra python=3.10 -y# 4. 激活环境conda activate ai-infra# 5. 安装 PyTorch（CUDA 12.2 使用 cu121）pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121# 6. 验证 GPU 可用性python -c &quot;import torch; print(f&#x27;PyTorch: &#123;torch.__version__&#125;&#x27;); print(f&#x27;CUDA可用: &#123;torch.cuda.is_available()&#125;&#x27;); print(f&#x27;GPU数量: &#123;torch.cuda.device_count()&#125;&#x27;)&quot;\n期望输出：\nPyTorch: 2.1.2+cu121CUDA可用: TrueGPU数量: 2\nStep 2B: 如果需要安装 Conda\n# 1. 下载 Miniconda（比 Anaconda 更轻量）wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh# 2. 安装bash Miniconda3-latest-Linux-x86_64.sh# 提示: Do you accept the license terms? → yes# 提示: installation location → 回车（使用默认）# 提示: Do you wish to update your shell profile → yes# 3. 重新加载 shellsource ~/.bashrc# 4. 验证安装conda --version# 5. 然后回到 Step 2A 的步骤 3 继续\nStep 3: 安装基础科学计算包\n# 确保在 ai-infra 环境中conda activate ai-infra# 安装基础包（指定版本避免冲突）pip install numpy==1.24.3 pandas matplotlib jupyterlabpip install transformers==4.36.2 accelerate==0.25.0# 验证安装python -c &quot;import transformers; print(f&#x27;Transformers: &#123;transformers.__version__&#125;&#x27;)&quot;\n\n第五阶段：vLLM 安装与测试\n版本兼容性说明\n\n⚠️ 重要：不要随意升级版本，容易导致 CUDA 不兼容！\n\n推荐版本组合（2026年1月验证）：- PyTorch 2.1.2 (cu121)- vLLM 0.2.7 (稳定版)- Triton 2.1.0 (vLLM依赖)- Flash-Attention 2.3.6 (可选，编译困难，不推荐)\n保守安装方案（推荐）\n# 1. 激活环境conda activate ai-infra# 2. 安装 vLLM（会自动安装 Triton 等依赖）pip install vllm==0.2.7# 3. 验证 vLLMpython -c &quot;import vllm; print(f&#x27;vLLM版本: &#123;vllm.__version__&#125;&#x27;)&quot;# 输出: vLLM版本: 0.2.7# 4. 验证 Triton（vLLM 会自动安装）python -c &quot;import triton; print(f&#x27;Triton版本: &#123;triton.__version__&#125;&#x27;)&quot;# 5. 测试 vLLM 是否可用python -c &quot;from vllm import LLM; print(&#x27;vLLM导入成功 &#x27;)&quot;\n最终环境验证\n运行完整验证脚本：\npython &lt;&lt;EOFimport torchimport vllmimport tritonprint(&quot;=&quot; * 50)print(&quot;环境验证&quot;)print(&quot;=&quot; * 50)print(f&quot;PyTorch版本: &#123;torch.__version__&#125;&quot;)print(f&quot;CUDA可用: &#123;torch.cuda.is_available()&#125;&quot;)print(f&quot;CUDA版本: &#123;torch.version.cuda&#125;&quot;)print(f&quot;GPU数量: &#123;torch.cuda.device_count()&#125;&quot;)if torch.cuda.is_available():    print(f&quot;GPU 0: &#123;torch.cuda.get_device_name(0)&#125;&quot;)    print(f&quot;GPU 1: &#123;torch.cuda.get_device_name(1)&#125;&quot;)print(f&quot;\\nvLLM版本: &#123;vllm.__version__&#125;&quot;)print(f&quot;Triton版本: &#123;triton.__version__&#125;&quot;)print(&quot;\\n 所有核心组件安装成功！&quot;)EOF\n期望输出：\n==================================================环境验证==================================================PyTorch版本: 2.1.2+cu121CUDA可用: TrueCUDA版本: 12.1GPU数量: 2GPU 0: NVIDIA GeForce RTX 4090GPU 1: NVIDIA GeForce RTX 4090vLLM版本: 0.2.7Triton版本: 2.1.0 所有核心组件安装成功！\n\n第六阶段：运行第一个 vLLM 程序\n创建测试文件\n在 VSCode 中创建 ~/test_vllm.py：\nfrom vllm import LLM, SamplingParamsimport torchimport time# 显示 GPU 信息print(&quot;=&quot; * 80)print(&quot;GPU 配置信息&quot;)print(&quot;=&quot; * 80)print(f&quot;可用GPU数量: &#123;torch.cuda.device_count()&#125;&quot;)print(f&quot;GPU 0: &#123;torch.cuda.get_device_name(0)&#125;&quot;)print(f&quot;GPU 1: &#123;torch.cuda.get_device_name(1)&#125;&quot;)print(&quot;=&quot; * 80)# 加载小模型测试（只有 125M 参数，几秒加载）print(&quot;\\n🔄 正在加载模型...&quot;)llm = LLM(    model=&quot;facebook/opt-125m&quot;,    trust_remote_code=True,    gpu_memory_utilization=0.5  # 只用 50% 显存，不影响其他人)print(&quot; 模型加载完成！\\n&quot;)# 准备输入prompts = [    &quot;Hello, my name is&quot;,    &quot;The capital of France is&quot;,    &quot;AI Infrastructure is&quot;]# 配置采样参数sampling_params = SamplingParams(    temperature=0.8,    top_p=0.95,    max_tokens=50)# 执行推理print(&quot;🚀 开始推理...\\n&quot;)outputs = llm.generate(prompts, sampling_params)# 查看结果print(&quot;=&quot; * 80)print(&quot;📊 推理结果&quot;)print(&quot;=&quot; * 80)for output in outputs:    print(f&quot;\\n提示词: &#123;output.prompt&#125;&quot;)    print(f&quot;生成结果: &#123;output.outputs[0].text&#125;&quot;)    print(&quot;-&quot; * 80)print(&quot;\\n 成功运行第一个 vLLM 程序！&quot;)# 性能测试print(&quot;\\n⏱️  性能测试开始...&quot;)test_prompts = [&quot;Explain AI in simple terms&quot;] * 10start = time.time()outputs = llm.generate(test_prompts, sampling_params)elapsed = time.time() - starttotal_tokens = sum(len(o.outputs[0].token_ids) for o in outputs)throughput = total_tokens / elapsedprint(&quot;\\n&quot; + &quot;=&quot; * 80)print(&quot;📈 服务器性能测试结果&quot;)print(&quot;=&quot; * 80)print(f&quot;模型:        OPT-125M&quot;)print(f&quot;GPU:         RTX 4090 (单卡)&quot;)print(f&quot;总耗时:      &#123;elapsed:.2f&#125; 秒&quot;)print(f&quot;总 Token 数: &#123;total_tokens&#125;&quot;)print(f&quot;吞吐量:      &#123;throughput:.2f&#125; tokens/秒&quot;)print(&quot;=&quot; * 80)\n运行测试\n# 指定使用 GPU 0（避免占用他人 GPU）CUDA_VISIBLE_DEVICES=0 python ~/test_vllm.py\n我的运行结果\n\n\n💡 性能对比：\n\nKaggle P100: ~1539 tokens/秒\n我的 RTX 4090: ~5818 tokens/秒\n提升约 278%！ 🚀\n\n\n\n踩过的坑与解决方案\n问题 1: VSCode Remote SSH 每次要输密码\n现象: VSCode 连接服务器时总是弹窗要求输入密码\n解决方案: 配置 SSH 公钥免密登录（见&quot;第一阶段 Step 3&quot;）\n关键步骤：\n# Windows 本地$pub = Get-Content C:\\Users\\pc\\.ssh\\id_rsa.pubssh Smarter@服务器ip &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;$pub&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;\n并在 SSH config 中添加：\nIdentitiesOnly yesPreferredAuthentications publickey\n问题 2: GNOME Remote Desktop 无法连接\n现象: Windows 端 mstsc 连接 3389 端口无响应\n原因:\n\n没有生成 TLS 证书\n没有设置 RDP 认证凭据\nXRDP 占用了 3389 端口\n\n解决方案:\n# 1. 停止并卸载 XRDP（如果有）sudo systemctl disable --now xrdp xrdp-sesmansudo apt purge -y xrdp xorgxrdp# 2. 生成 TLS 证书（见&quot;第三阶段 Step 1&quot;）# 3. 设置 RDP 凭据sudo grdctl --system rdp set-credentials rdpuser &#x27;强密码&#x27;sudo grdctl --system rdp enable# 4. 重启服务sudo systemctl restart gnome-remote-desktop.service# 5. 验证端口监听sudo ss -lnptu | grep 3389\n问题 3: 远程桌面提示&quot;已有会话运行&quot;\n现象: 尝试远程登录时提示&quot;该用户已有会话&quot;\n原因: 之前的远程会话没有正常退出，系统认为仍在运行\n解决方案:\n# 1. 查看当前会话loginctl list-sessionsloginctl user-status Smarter# 2. 终止该用户所有会话sudo loginctl terminate-user Smarter# 3. 重启远程桌面服务sudo systemctl restart gnome-remote-desktop.servicesudo systemctl restart gdm3# 4. 再尝试连接\n问题 4: vLLM 导入报错 CUDA 版本不匹配\n现象: import vllm 报错 “CUDA version mismatch”\n原因: PyTorch 的 CUDA 版本与系统 CUDA 不匹配\n解决方案:\n# 1. 卸载 PyTorchpip uninstall torch torchvision -y# 2. 重新安装匹配的版本（CUDA 12.2 使用 cu121）pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121# 3. 验证python -c &quot;import torch; print(torch.version.cuda)&quot;# 应该输出: 12.1 (PyTorch 对 CUDA 12.x 通用)\n问题 5: Conda 命令找不到\n现象: conda: command not found\n解决方案:\n# 重新加载 bashrcsource ~/.bashrc# 如果还是不行，手动添加到 PATHexport PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;# 或者添加到 ~/.bashrcecho &#x27;export PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc\n问题 6: Clash 代理端口被占用\n现象: 想重启 Clash 但提示端口 7890 被占用\n解决方案:\n# 1. 查看占用端口的进程sudo lsof -iTCP:7890 -sTCP:LISTEN# 输出示例:# COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME# clash   3528110  Smarter    9u  IPv4 xxx      0t0  TCP localhost:7890 (LISTEN)# 2. 终止该进程sudo kill 3528110# 3. 重新启动 Clash\n\n开发工作流程\n配置完成后，我的日常开发流程是这样的：\n方案：VSCode Remote SSH\n┌─────────────────┐         SSH        ┌─────────────────┐│  Windows笔记本   │ ◄────────────────► │ Ubuntu服务器    ││                 │                    │                 ││  VSCode界面     │                    │  实际执行代码    ││  编辑器         │                    │  双GPU计算      ││  浏览器         │                    │  永久存储       │└─────────────────┘                    └─────────────────┘       本地                                   云端\n日常步骤:\n\n\n打开 VSCode 连接服务器\nVSCode → F1 → Remote-SSH: Connect to Host → ai-server\n\n\n编辑代码（和本地一样）\n\n在服务器上直接编辑项目文件\nVSCode 体验和本地完全一样\n代码保存在服务器上，永久保存\n\n\n\n运行实验（服务器 GPU）\n# VSCode 集成终端conda activate ai-infra# 检查 GPU 状态nvidia-smi# 指定使用 GPU 0CUDA_VISIBLE_DEVICES=0 python train.py# GPU 计算，无时长限制 \n\n\n查看结果\n\n结果保存在服务器\n可以通过 VSCode 直接查看图片/日志\n或者下载到本地\n\n\n\n\nGPU 资源管理\n查看 GPU 使用情况\n# 实时监控watch -n 1 nvidia-smi# 或者安装 nvitop（更友好的界面）pip install nvitopnvitop\n指定 GPU 运行代码\n# 使用 GPU 0CUDA_VISIBLE_DEVICES=0 python train.py# 使用 GPU 1CUDA_VISIBLE_DEVICES=1 python train.py# 同时使用两张 GPUCUDA_VISIBLE_DEVICES=0,1 python train.py\nPython 代码中指定\nimport osos.environ[&#x27;CUDA_VISIBLE_DEVICES&#x27;] = &#x27;0&#x27;  # 只用第一张 GPU# 或者import torchdevice = torch.device(&#x27;cuda:0&#x27;)  # GPU 0# device = torch.device(&#x27;cuda:1&#x27;)  # GPU 1\n多人共享礼仪\n如果服务器是多人共享的：\n# 每次使用前检查 GPU 状态nvidia-smi# 看 Processes 列：# - GPU 0 空闲 → CUDA_VISIBLE_DEVICES=0# - GPU 1 空闲 → CUDA_VISIBLE_DEVICES=1# - 都在用 → 等待或协调\n\n长时间任务：使用 screen\n服务器的优势之一就是可以运行长时间任务，即使关闭本地电脑也不影响。\n安装 screen\nsudo apt install screen\n使用方法\n# 1. 创建 sessionscreen -S my_experiment# 2. 运行长时间任务conda activate ai-infrapython long_training.py# 3. 断开（任务继续运行）# 按 Ctrl+A，然后按 D# 4. 重新连接screen -r my_experiment# 5. 列出所有 sessionscreen -ls# 6. 终止 session（在 session 内部）exit\n优势：关闭 Windows 电脑，SSH 断开，任务照样运行！\n\n总结与收获\n完成的配置\n\n[x]  SSH 免密登录配置\n[x]  VSCode Remote SSH 环境\n[x]  GNOME Remote Desktop 远程桌面\n[x]  Conda 环境创建 (ai-infra)\n[x]  PyTorch 2.1.2 + CUDA 12.1 安装\n[x]  vLLM 0.2.7 安装与测试\n[x]  第一个 vLLM 程序运行成功\n[x]  性能测试：2276 tokens/秒\n\n性能对比\n\n\n\n平台\nGPU\n吞吐量 (tokens/s)\n成本\n\n\n\n\nKaggle\nP100\n~1539\n免费（30h/周）\n\n\n我的服务器\nRTX 4090\n~5818\n内网服务器（无限）\n\n\n性能提升\n-\n+278%\n-\n\n\n\n\n写在最后\n如果你也有机会使用服务器进行 AI 学习，我的建议是：\n\n优先配置好 SSH 免密登录 - 这是一切的基础\nVSCode Remote SSH 是最佳开发环境 - 比本地+rsync 方便太多\n认真做版本管理 - 不要随意升级，稳定的版本组合很重要\n做好 GPU 资源管理 - 尤其是共享服务器，要有礼貌\n使用 screen 管理长任务 - 充分利用服务器优势\n\n\n参考资料\n\nUbuntu GNOME Remote Desktop 官方文档\nVSCode Remote SSH 文档\nvLLM 官方文档\nPyTorch 官方安装指南\n\n\n如果这篇文章对你有帮助，欢迎点赞和分享！有任何问题也欢迎在评论区交流。 🎉\n","categories":["AI Infra"],"tags":["vLLM","AI Infrastructure","Ubuntu Server","RTX 4090","SSH","VSCode Remote"]},{"title":"AI Infra学习之旅-第一个vLLM程序","url":"/posts/b21cbc80/","content":"前言\n今天是我正式开始学习 AI Infrastructure 的第一天。作为一个对大模型推理充满好奇的初学者，我决定从实战开始——在免费的 Kaggle GPU 上运行 vLLM。这篇文章记录了我从零开始的完整过程，希望能帮助到和我一样的新手。\n核心目标: 今天就跑通第一个 vLLM 程序！\n\n为什么选择 Kaggle + vLLM？\n在开始之前，我做了一些调研：\n为什么选择 Kaggle？\n\n✅ 完全免费: 每周 30 小时 GPU 时间\n✅ 无需配置: 预装了常用的深度学习库\n✅ P100 GPU: 16GB 显存，足够运行中小型模型\n✅ 入门友好: 无需本地 GPU，浏览器即可使用\n\n为什么选择 vLLM？\n\n✅ 高性能: 比 HuggingFace Transformers 快数倍\n✅ 易用性: API 设计简洁，上手快\n✅ 工业级: 被多个公司用于生产环境\n✅ 学习价值: 涉及 PagedAttention 等前沿技术\n\n\n实战步骤\nStep 1: 注册 Kaggle 账号\n这一步非常简单：\n\n访问 Kaggle 官网\n使用 Google 账号快速注册\n重要: 验证手机号（这是使用 GPU 的必要条件，也可以使用Persona进行验证）\n\n\n\nStep 2: 创建 GPU Notebook\n创建 Notebook 的步骤：\n\n点击右上角 “Create” → “New Notebook”\n在右侧设置面板中：\n\nAccelerator → 选择 GPU P100 ✅\nInternet → 打开 On ✅\n\n\n等待环境启动（大约 30 秒）\n\n启动后，在第一个 cell 中运行以下命令验证 GPU：\n!nvidia-smi\n如果看到类似以下输出，说明 GPU 环境已就绪：\n+-----------------------------------------------------------------------------+| NVIDIA-SMI 525.xx.xx    Driver Version: 525.xx.xx    CUDA Version: 12.0     ||-------------------------------+----------------------+----------------------+| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. ||                               |                      |               MIG M. ||===============================+======================+======================||   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 || N/A   37C    P0    26W / 250W |      0MiB / 16280MiB |      0%      Default |\n\n\nStep 3: 安装 vLLM\n在新的 cell 中运行：\n# 安装 vLLM!pip install vllm -q# 验证安装import vllmprint(f&quot;✅ vLLM 安装成功！版本: &#123;vllm.__version__&#125;&quot;)\n安装可能需要 10-15 分钟，请耐心等待。安装完成后，你应该看到类似的输出：\n✅ vLLM 安装成功！版本: 0.x.x\n\nStep 4: 运行第一个推理程序\n这是今天的重头戏！我使用 facebook/opt-125m 这个小模型进行测试（只有 125M 参数，加载速度快）。\n完整代码如下：\nfrom vllm import LLM, SamplingParams# 【核心代码块1】加载模型llm = LLM(    model=&quot;facebook/opt-125m&quot;,  # 小模型,快速测试    trust_remote_code=True)# 【核心代码块2】准备输入prompts = [    &quot;Hello, my name is&quot;,    &quot;The capital of France is&quot;,    &quot;The meaning of life is&quot;]# 【核心代码块3】配置采样参数sampling_params = SamplingParams(    temperature=0.8,    top_p=0.95,    max_tokens=100)# 【核心代码块4】执行推理outputs = llm.generate(prompts, sampling_params)# 【核心代码块5】查看结果for output in outputs:    prompt = output.prompt    generated_text = output.outputs[0].text    print(f&quot;Prompt: &#123;prompt!r&#125;&quot;)    print(f&quot;Generated: &#123;generated_text!r&#125;&quot;)    print(&quot;-&quot; * 80)\n我的运行结果:\n\n\nPrompt: &#x27;Hello, my name is&#x27;Generated: &#x27; Joel, my dad is my friend and we are in a relationship...-------------------------------------------------Prompt: &#x27;The capital of France is&#x27;Generated: &#x27; at an impasse with the French government over its future as the euro zone’s biggest economy...-------------------------------------------------Prompt: &#x27;The meaning of life is&#x27;Generated: &quot; measured in the things that are accomplished in it.\\nMost of the time...\n\n\nStep 5: 性能测试\n为了了解 vLLM 的性能，我运行了一个简单的吞吐量测试：\nimport time# 准备 10 个相同请求test_prompts = [&quot;Explain AI in simple terms&quot;] * 10# 测试吞吐量print(&quot;⏱️  性能测试开始...&quot;)start = time.time()outputs = llm.generate(test_prompts, sampling_params)elapsed = time.time() - start# 计算指标total_tokens = sum(len(o.outputs[0].token_ids) for o in outputs)throughput = total_tokens / elapsed# 打印结果print(&quot;\\n&quot; + &quot;=&quot;*80)print(&quot;📈 我的第一次 vLLM 运行记录&quot;)print(&quot;=&quot;*80)print(f&quot;模型:        OPT-125M&quot;)print(f&quot;GPU:         Kaggle P100&quot;)print(f&quot;总耗时:      &#123;elapsed:.2f&#125; 秒&quot;)print(f&quot;总 Token 数: &#123;total_tokens&#125;&quot;)print(f&quot;吞吐量:      &#123;throughput:.2f&#125; tokens/秒&quot;)print(f&quot;日期:        &#123;time.strftime(&#x27;%Y-%m-%d&#x27;)&#125;&quot;)print(&quot;=&quot;*80)\n我的性能数据:\n\n\n\n\n\n指标\n数值\n\n\n\n\n模型\nOPT-125M\n\n\nGPU\nKaggle P100\n\n\n总耗时\n0.58 秒\n\n\n总 Token 数\n892\n\n\n吞吐量\n1539.24 tokens/秒\n\n\n\n\n\n踩过的坑与解决方案\n问题 1: Kaggle GPU 不可用\n现象: 设置中看不到 GPU 选项\n原因: 没有验证手机号\n解决: 在账号设置中完成手机验证\n问题 2: vLLM 安装超时\n现象: pip install vllm 一直卡住\n解决: 重启 Notebook，或者切换到 Google Colab\n问题 3: 模型下载速度慢\n现象: 加载模型时长时间无响应\n解决: 使用 HuggingFace 镜像站\nimport osos.environ[&#x27;HF_ENDPOINT&#x27;] = &#x27;https://hf-mirror.com&#x27;\n\n写在最后\n第一天的学习让我深刻体会到：AI Infrastructure 并不遥远，动手实践才是最好的老师。\n如果你也想开始学习 AI Infra，我的建议是：\n\n不要被理论吓倒 - 先跑起来，再慢慢理解\n选择免费资源 - Kaggle/Colab 足够初学者使用\n从小模型开始 - 125M 参数的模型几秒就能加载\n记录每一步 - 写博客是最好的复习方式\n\n记住: 慢一点没关系，停下来才可惜。💪\n\n参考资料\n\nvLLM 官方文档\nKaggle GPU 使用指南\n\n","categories":["AI Infra"],"tags":["vLLM","AI Infrastructure","Kaggle","GPU","大模型推理"]},{"title":"Effective Modern C++","url":"/posts/162e86b7/","content":"Effective Modern C++：42条改善C++11和C++14代码的建议\n\n深入理解 Effective Modern C++ 的核心思想，掌握现代C++最佳实践\n\n引言\n《Effective Modern C++》是 Scott Meyers 的经典著作，提供了 42 条改善 C++11 和 C++14 代码的具体建议。本文总结这些核心要点，帮助你写出更现代、更高效的 C++ 代码。\n核心主题：\n\n类型推导的陷阱与最佳实践\nauto 的正确使用\n移动语义和完美转发\n智能指针的选择\nLambda 表达式的优化\n并发编程\n\n\n第一章：类型推导\nItem 1: 理解模板类型推导\n模板类型推导有三种情况，取决于 ParamType 的形式。\n规则总结：\ngraph TD\n    A[模板推导] --&gt; B&#123;ParamType类型&#125;\n    B --&gt;|指针/引用| C[保留const]\n    B --&gt;|万能引用| D[左值/右值分别推导]\n    B --&gt;|按值传递| E[丢弃const和引用]\n关键要点：\n\n引用和指针不同时，const 被保留\n万能引用（T&amp;&amp;）区分左值和右值\n按值传递会忽略 const 和引用\n\nItem 2: 理解 auto 类型推导\nauto 与模板推导几乎完全相同，唯一例外是花括号初始化。\nauto x1 = 27;     // intauto x2(27);      // int  auto x3 = &#123;27&#125;;   // std::initializer_list&lt;int&gt; ❌陷阱！auto x4&#123;27&#125;;      // C++17: int, C++14: std::initializer_list&lt;int&gt;\n要记住的事：\n\nauto 推导通常与模板推导相同\nauto 假定花括号初始化代表 std::initializer_list\n函数返回值或 lambda 参数中的 auto 使用模板推导规则\n\nItem 3: 理解 decltype\ndecltype 总是返回表达式的确切类型，不会丢失 const 或引用。\nconst int i = 0;auto a = i;           // intdecltype(i) d = i;    // const int// C++14 的 decltype(auto)template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];  // 完美转发返回类型&#125;\n括号陷阱：\nint x = 10;decltype(x)   t1;   // intdecltype((x)) t2;   // int&amp; ⚠️ 危险！\nItem 4: 学会查看类型推导结果\n三种方法：\n\nIDE 编辑器：快速但可能不准\n编译器诊断：利用编译错误\n运行时输出：typeid 和 Boost.TypeIndex\n\n// 最可靠的方法：故意制造编译错误template&lt;typename T&gt;class TD;  // Type DisplayerTD&lt;decltype(x)&gt; xType;  // 编译器会显示类型\n\n第二章：auto\nItem 5: 优先使用 auto 而非显式类型声明\n优点：\n// 1. 避免未初始化变量int x;        // 未初始化auto x = 0;   // 必须初始化// 2. 避免类型不匹配std::unordered_map&lt;std::string, int&gt; m;// ❌ 错误：每次迭代都拷贝for (const std::pair&lt;std::string, int&gt;&amp; p : m) &#123; &#125;// ✓ 正确：零拷贝for (const auto&amp; p : m) &#123; &#125;// 3. 简化复杂类型std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;,                    const std::unique_ptr&lt;Widget&gt;&amp;)&gt; func;// 简化为auto func = [](const auto&amp; lhs, const auto&amp; rhs) &#123;    return *lhs &lt; *rhs;&#125;;\n性能优势：\n\n\n\n场景\n显式类型\nauto\n性能\n\n\n\n\nLambda\nstd::function\nauto\nauto 快 2-10倍\n\n\n容器遍历\n可能类型错误\n总是正确\n避免拷贝\n\n\n闭包\n无法表达\n完美捕获\n零开销\n\n\n\nItem 6: 当 auto 推导出非预期类型时使用显式类型初始化\n代理类陷阱：\nstd::vector&lt;bool&gt; features(const Widget&amp; w);auto highPriority = features(w)[5];  // ❌ 返回代理对象// highPriority 不是 bool，而是临时的代理类bool highPriority = features(w)[5];  // ✓ 正确\n解决方案：显式类型转换\nauto highPriority = static_cast&lt;bool&gt;(features(w)[5]);\n其他代理类场景：\n\nstd::vector&lt;bool&gt;::reference\nMatrix 表达式模板\n智能指针的代理\n\n\n第三章：转向现代C++\nItem 7: 创建对象时区分 () 和 {}\n三种初始化语法：\nint x(0);     // 圆括号int y = 0;    // 等号int z&#123;0&#125;;     // 花括号（统一初始化）\n花括号优点：\n// 1. 可用于任何初始化场景struct Widget &#123;    int x&#123;0&#125;;      // ✓ 成员初始化    int y = 0;     // ✓ 也可以    int z(0);      // ❌ 不行&#125;;// 2. 禁止隐式窄化转换double x = 3.14;int y&#123;x&#125;;      // ❌ 编译错误，禁止窄化int z(x);      // ⚠️ 允许，但丢失精度// 3. 免疫最令人烦恼的解析Widget w1(10);  // 调用构造函数Widget w2();    // ❌ 函数声明！Widget w3&#123;&#125;;    // ✓ 调用默认构造函数\n陷阱：std::initializer_list 构造函数\nstd::vector&lt;int&gt; v1(10, 20);  // 10个元素，每个值为20std::vector&lt;int&gt; v2&#123;10, 20&#125;;  // 2个元素：10和20\nItem 8: 优先使用 nullptr 而非 0 或 NULL\nvoid f(int);void f(bool);void f(void*);f(0);        // 调用 f(int)f(NULL);     // 可能不编译，或调用 f(int)f(nullptr);  // 调用 f(void*)// 模板中的优势template&lt;typename FuncType, typename PtrType&gt;decltype(auto) call(FuncType func, PtrType ptr) &#123;    return func(ptr);&#125;auto result1 = call(f, 0);        // 错误：推导为 intauto result2 = call(f, nullptr);  // ✓ 正确\nItem 9: 优先使用别名声明而非 typedef\n// typedeftypedef std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;    UPtrMapSS;// using (更清晰)using UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;// 模板别名 - typedef 无法做到template&lt;typename T&gt;using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;MyAllocList&lt;Widget&gt; lw;  // ✓ 简洁// typedef 需要template&lt;typename T&gt;struct MyAllocList &#123;    typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;&#125;;MyAllocList&lt;Widget&gt;::type lw;  // ❌ 繁琐\nItem 10-11: 优先使用限域 enum 和 deleted 函数\n限域枚举：\n// C++98 enum：不限域enum Color &#123; black, white, red &#125;;auto white = false;  // ❌ 错误！white 已被定义// C++11 enum class：限域enum class Color &#123; black, white, red &#125;;auto white = false;           // ✓ OKColor c = Color::white;       // 必须限定auto c = Color::white;        // 也可以\ndeleted 函数：\n// 防止隐式转换bool isLucky(int number);bool isLucky(char) = delete;   // 拒绝 charbool isLucky(bool) = delete;   // 拒绝 boolbool isLucky(double) = delete; // 拒绝 double// 禁止模板实例化template&lt;typename T&gt;void processPointer(T* ptr);template&lt;&gt;void processPointer&lt;void&gt;(void*) = delete;template&lt;&gt;void processPointer&lt;char&gt;(char*) = delete;  // const char* 也被拒绝\nItem 12-15: 特殊成员函数和优化\nnoexcept 的重要性：\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs) noexcept  // ✓ 推荐        : name(std::move(rhs.name)) &#123;&#125;        Widget&amp; operator=(Widget&amp;&amp; rhs) noexcept &#123;        name = std::move(rhs.name);        return *this;    &#125;    private:    std::string name;&#125;;// noexcept 让 std::vector 使用移动而非拷贝std::vector&lt;Widget&gt; vw;vw.push_back(Widget());  // 如果没有 noexcept，会拷贝而非移动\n\n第四章：智能指针\nItem 18: 使用 std::unique_ptr 管理独占所有权资源\nclass Investment &#123; &#125;;class Stock : public Investment &#123; &#125;;// 工厂函数auto makeInvestment() &#123;    return std::make_unique&lt;Stock&gt;();  // C++14&#125;// 自定义删除器auto delInvmt = [](Investment* pInvestment) &#123;    makeLogEntry(pInvestment);    delete pInvestment;&#125;;template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;makeInvestment(Ts&amp;&amp;... params) &#123;    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;        pInv(nullptr, delInvmt);        if (/* 创建 Stock */)        pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...));        return pInv;&#125;\n特点：\n\n零开销（与裸指针相同大小）\n独占所有权\n可转换为 shared_ptr\n\nItem 19: 使用 std::shared_ptr 管理共享所有权资源\nauto loggingDel = [](Widget *pw) &#123;    makeLogEntry(pw);    delete pw;&#125;;std::unique_ptr&lt;Widget, decltype(loggingDel)&gt;    upw(new Widget, loggingDel);  // 删除器是类型的一部分std::shared_ptr&lt;Widget&gt;    spw(new Widget, loggingDel);  // 删除器不是类型的一部分\n引用计数机制：\ngraph LR\n    A[shared_ptr 1] --&gt; C[控制块]\n    B[shared_ptr 2] --&gt; C\n    C --&gt; D[对象]\n    C --&gt; E[引用计数: 2]\n    C --&gt; F[弱引用计数]\n    C --&gt; G[删除器]\n性能开销：\n\n控制块动态分配\n引用计数原子操作\n虚函数调用（删除器）\n\nItem 20: 使用 std::weak_ptr 解决悬空指针\nauto spw = std::make_shared&lt;Widget&gt;();std::weak_ptr&lt;Widget&gt; wpw(spw);  // wpw 指向 Widgetspw = nullptr;  // Widget 被销毁，wpw 悬空if (spw == nullptr) &#123;  // ✓ 检测共享指针&#125;if (wpw.expired()) &#123;   // ✓ 检测弱指针&#125;// 原子检查并访问std::shared_ptr&lt;Widget&gt; spw2 = wpw.lock();  // 如果 wpw 过期则返回 nullauto spw3 = wpw.lock();\n应用场景：\n\n缓存：\n\nstd::shared_ptr&lt;const Widget&gt; fastLoadWidget(WidgetID id) &#123;    static std::unordered_map&lt;WidgetID, std::weak_ptr&lt;const Widget&gt;&gt; cache;        auto objPtr = cache[id].lock();  // 尝试从缓存获取        if (!objPtr) &#123;                   // 不在缓存中        objPtr = loadWidget(id);        cache[id] = objPtr;    &#125;    return objPtr;&#125;\n\n观察者模式：\n\nclass Subject &#123;    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers;public:    void notify() &#123;        for (auto&amp; wo : observers) &#123;            if (auto o = wo.lock()) &#123;  // 检查观察者是否存活                o-&gt;update();            &#125;        &#125;    &#125;&#125;;\nItem 21: 优先使用 std::make_unique 和 std::make_shared\n// ❌ 不推荐std::shared_ptr&lt;Widget&gt; spw(new Widget);// ✓ 推荐auto spw = std::make_shared&lt;Widget&gt;();// 优点1: 异常安全processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority());// ⚠️ 可能泄漏：new Widget 可能在 computePriority() 抛异常后完成processWidget(std::make_shared&lt;Widget&gt;(), computePriority());// ✓ 安全// 优点2: 性能更好auto spw1 = std::shared_ptr&lt;Widget&gt;(new Widget);  // 2次分配auto spw2 = std::make_shared&lt;Widget&gt;();            // 1次分配\n不能使用 make 函数的情况：\n// 1. 自定义删除器auto deleter = [](Widget* pw) &#123; delete pw; &#125;;std::unique_ptr&lt;Widget decltype(deleter)&gt; upw(new Widget, deleter);// 2. 花括号初始化auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(10, 20);  // 10个20// 想要&#123;10, 20&#125;只能：auto initList = &#123;10, 20&#125;;auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(initList);\n\n第五章：右值引用、移动语义和完美转发\nItem 23: 理解 std::move 和 std::forward\nstd::move 无条件转换为右值：\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs)        : name(std::move(rhs.name)),          p(std::move(rhs.p)) &#123;&#125;    private:    std::string name;    std::shared_ptr&lt;int&gt; p;&#125;;// move 的实现（简化）template&lt;typename T&gt;decltype(auto) move(T&amp;&amp; param) &#123;    using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param);&#125;\nstd::forward 条件转换：\nvoid process(const Widget&amp; lvalArg);   // 处理左值void process(Widget&amp;&amp; rvalArg);        // 处理右值template&lt;typename T&gt;void logAndProcess(T&amp;&amp; param) &#123;    auto now = std::chrono::system_clock::now();    makeLogEntry(&quot;Calling &#x27;process&#x27;&quot;, now);    process(std::forward&lt;T&gt;(param));  // 完美转发&#125;\n对比：\n\n\n\n特性\nstd::move\nstd::forward\n\n\n\n\n用途\n无条件转右值\n条件转发\n\n\n参数\n通用引用\n通用引用\n\n\n使用场景\n移动构造/赋值\n完美转发\n\n\n\nItem 24: 区分万能引用和右值引用\n万能引用的判断标准：\ntemplate&lt;typename T&gt;void f(T&amp;&amp; param);  // 万能引用（有类型推导）auto&amp;&amp; var2 = var1;  // 万能引用void f(Widget&amp;&amp; param);  // 右值引用（无类型推导）template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param);  // 右值引用（不是 T&amp;&amp;）\nItem 25: 对右值引用使用 std::move，对万能引用使用 std::forward\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs)        : name(std::move(rhs.name)) &#123;&#125;  // rhs 是右值引用    template&lt;typename T&gt;    void setName(T&amp;&amp; newName) &#123;        name = std::forward&lt;T&gt;(newName);  // newName 是万能引用    &#125;    private:    std::string name;&#125;;\n错误示例：\n// ❌ 不要对右值引用使用 forwardWidget(Widget&amp;&amp; rhs)    : name(std::forward&lt;Widget&gt;(rhs).name) &#123;&#125;  // 错误// ❌ 不要对万能引用使用 movetemplate&lt;typename T&gt;void setName(T&amp;&amp; newName) &#123;    name = std::move(newName);  // 可能移动左值！&#125;\nItem 26: 避免重载万能引用\n// ❌ 问题代码std::multiset&lt;std::string&gt; names;template&lt;typename T&gt;void logAndAdd(T&amp;&amp; name) &#123;    auto now = std::chrono::system_clock::now();    log(now, &quot;logAndAdd&quot;);    names.emplace(std::forward&lt;T&gt;(name));&#125;logAndAdd(std::string(&quot;Persephone&quot;));  // ✓logAndAdd(&quot;Patty Dog&quot;);                 // ✓std::string petName(&quot;Darla&quot;);logAndAdd(petName);  // ✓ 拷贝左值short nameIdx = 22;logAndAdd(nameIdx);  // ❌ 问题：T 推导为 short&amp;，不会转换为 string\nItem 27-30: 熟悉完美转发失败的情况\n完美转发失败的情况：\n\n花括号初始化：\n\nvoid f(const std::vector&lt;int&gt;&amp; v);f(&#123;1, 2, 3&#125;);  // ✓ OKtemplate&lt;typename T&gt;void fwd(T&amp;&amp; param) &#123;    f(std::forward&lt;T&gt;(param));&#125;fwd(&#123;1, 2, 3&#125;);  // ❌ 错误：无法推导// 解决方案auto il = &#123;1, 2, 3&#125;;fwd(il);  // ✓\n\n0 或 NULL 作为空指针：\n\nfwd(NULL);  // ❌ 推导为整数fwd(0);     // ❌ 推导为整数fwd(nullptr);  // ✓\n\n仅声明的 static const 成员变量：\n\nclass Widget &#123;public:    static const std::size_t MinVals = 28;  // 声明&#125;;std::vector&lt;int&gt; widgetData;widgetData.reserve(Widget::MinVals);  // ✓fwd(Widget::MinVals);  // ❌ 链接错误\n\n重载函数名和模板名\n位域\n\n\n第六章：Lambda表达式\nItem 31: 避免默认捕获模式\n按值捕获的问题：\nusing FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters;void addDivisorFilter() &#123;    auto calc1 = computeSomeValue1();    auto calc2 = computeSomeValue2();    auto divisor = computeDivisor(calc1, calc2);        filters.emplace_back(        [=](int value) &#123; return value % divisor == 0; &#125;  // ❌ 悬空引用    );&#125;\n指针捕获的问题：\nclass Widget &#123;public:    void addFilter() const &#123;        filters.emplace_back(            [=](int value) &#123; return value % divisor == 0; &#125;            // ❌ 捕获的是 this 指针，不是 divisor        );    &#125;private:    int divisor;&#125;;\n正确做法：\nclass Widget &#123;public:    void addFilter() const &#123;        auto divisorCopy = divisor;  // 拷贝数据成员                filters.emplace_back(            [divisorCopy](int value) &#123;  // ✓ 显式捕获副本                return value % divisorCopy == 0;            &#125;        );    &#125;&#125;;\nItem 32: 使用初始化捕获将对象移入闭包\n// C++14: 初始化捕获auto pw = std::make_unique&lt;Widget&gt;();auto func = [pw = std::move(pw)] &#123;  // 移动进闭包    return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();&#125;;// C++11: 使用 bind 模拟auto func = std::bind(    [](const std::unique_ptr&lt;Widget&gt;&amp; pw) &#123;        return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();    &#125;,    std::make_unique&lt;Widget&gt;());\nItem 33-34: Lambda 与 std::function\n优先使用 auto 而非 std::function：\n// std::functionstd::function&lt;bool(int)&gt; func1 = [](int x) &#123; return x &gt; 0; &#125;;// autoauto func2 = [](int x) &#123; return x &gt; 0; &#125;;\n性能对比：\n\n\n\n特性\nstd::function\nauto\n\n\n\n\n内存\n固定大小，可能堆分配\n闭包大小\n\n\n内联\n几乎不可能\n容易内联\n\n\n性能\n慢\n快\n\n\n\n\n第七章：并发API\nItem 35: 优先使用基于任务而非基于线程的编程\n// 基于线程int doAsyncWork();std::thread t(doAsyncWork);  // ❌ 无法获取返回值// 基于任务auto fut = std::async(doAsyncWork);  // ✓ 可以获取返回值auto result = fut.get();\nstd::async 的优势：\n\n自动管理线程\n可以获取返回值\n可以传播异常\n避免过度订阅\n\nItem 36-40: 并发编程最佳实践\n使用 std::atomic 而非 volatile：\n// ❌ volatile 不提供原子性volatile int counter = 0;void increment() &#123;    ++counter;  // 不是原子的！&#125;// ✓ atomic 提供原子性std::atomic&lt;int&gt; counter(0);void increment() &#123;    ++counter;  // 原子操作&#125;\n避免在 std::atomic 上使用复制操作：\nstd::atomic&lt;int&gt; x(0);auto y = x;  // ❌ 错误：deletedauto y = x.load();  // ✓ 显式读取std::atomic&lt;int&gt; z(0);z = x; // ❌ 错误：deletedz.store(x.load());  // ✓ 显式存储\n\n第八章：微调\nItem 41: 对于可拷贝的形参，当移动成本低且总会被拷贝时，考虑按值传递\nclass Widget &#123;public:    // 方案1: 重载左值和右值    void setName(const std::string&amp; newName) &#123;        name = newName;    &#125;    void setName(std::string&amp;&amp; newName) &#123;        name = std::move(newName);    &#125;        // 方案2: 万能引用    template&lt;typename T&gt;    void setName(T&amp;&amp; newName) &#123;        name = std::forward&lt;T&gt;(newName);    &#125;        // 方案3: 按值传递（在某些情况下最优）    void setName(std::string newName) &#123;        name = std::move(newName);    &#125;    private:    std::string name;&#125;;\n性能对比：\n\n\n\n调用方式\n重载\n万能引用\n按值传递\n\n\n\n\n左值\n1次拷贝\n1次拷贝\n1次拷贝+1次移动\n\n\n右值\n1次移动\n1次移动\n1次移动+1次移动\n\n\n\nItem 42: 考虑使用置入而非插入\nstd::vector&lt;std::string&gt; vs;// 插入vs.push_back(&quot;xyzzy&quot;);  // 创建临时对象，然后移动// 置入vs.emplace_back(&quot;xyzzy&quot;);  // 直接在容器中构造，避免临时对象// 性能对比vs.push_back(std::string(50, &#x27;x&#x27;));  // 1个临时对象vs.emplace_back(50, &#x27;x&#x27;);             // 无临时对象，直接构造\n何时使用置入：\n\n值被构造进容器，而非赋值\n传递的参数类型与容器元素类型不同\n容器不太可能拒绝新值（如 set）\n\n\n总结\n核心要点总结\ngraph TD\n    A[Effective Modern C++] --&gt; B[类型推导]\n    A --&gt; C[auto]\n    A --&gt; D[移动语义]\n    A --&gt; E[智能指针]\n    A --&gt; F[Lambda]\n    A --&gt; G[并发]\n    \n    B --&gt; B1[模板推导3种情况]\n    B --&gt; B2[decltype陷阱]\n    \n    C --&gt; C1[优先使用auto]\n    C --&gt; C2[注意代理类]\n    \n    D --&gt; D1[move无条件转右值]\n    D --&gt; D2[forward条件转发]\n    D --&gt; D3[完美转发失败情况]\n    \n    E --&gt; E1[unique_ptr独占]\n    E --&gt; E2[shared_ptr共享]\n    E --&gt; E3[weak_ptr观察]\n    \n    F --&gt; F1[避免默认捕获]\n    F --&gt; F2[初始化捕获]\n    F --&gt; F3[优先auto]\n    \n    G --&gt; G1[基于任务]\n    G --&gt; G2[atomic不是volatile]\n","categories":["知识分享"],"tags":["C++","Effective Modern C++","C++11","C++14","现代C++"]},{"title":"LeetCode热题100(25.09.29)","url":"/posts/8c812416/","content":"一：两数之和\n\n1. 暴力\n不写\n2. 哈希表\n哈希表通过用空间换时间，使用哈希函数将任意长度的键转换为一个固定范围的数组下标，时间复杂度为O(1)O(1)O(1)\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; hashMap;        for(int i = 0; i &lt; nums.size(); ++i)        &#123;            auto it = hashMap.find(target - nums[i]);       // 返回迭代器            if(it != hashMap.end())             // 和尾后迭代器比对            &#123;                return &#123;it-&gt;second, i&#125;;         // 找到就返回下标            &#125;            hashMap[nums[i]] = i;               // 没找到就把数据添加进hash表        &#125;        return &#123;&#125;;    &#125;&#125;;\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashMap = dict()        for i, num in enumerate(nums):          # 遍历            if target - nums[i] in hashMap:     # 是否存在，可把nums[i]改为num                return [hashMap[target - num], i]            hashMap[nums[i]] = i        return []        \nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;();         // 初始化一个哈希表        for( int i = 0; i &lt; nums.length; ++i)        &#123;            if(hashMap.containsKey(target - nums[i]))           // 这里的K大写            &#123;                return new int[]&#123;hashMap.get(target - nums[i]), i&#125;;            &#125;            hashMap.put(nums[i], i);        &#125;        return new int[0];              // 返回为空    &#125;&#125;\n\n二：移动零\n\n1. 双指针\n题目要求不能复制，同时保证原有序列的顺序不变，因此只能交换非零值和零值的位置。\n\n思路一：处理零值，将零和右边非零值进行交换\n思路二：处理非零值，将非零值和左边零值进行交换\n\n方式一需要不断寻找非零值，性能稍差，因此采用方式二\nclass Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int Left = 0, Right = 0;                // Left的左边均为非零值，其指向第一个零值。Right的右边为未处理的序列，当前指向用于判断零值和非零值        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            if (nums[i])            &#123;                swap(nums[Left], nums[Right]);              // 交换位置                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;;\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        Left = Right = 0        for num in nums:            if num:                nums[Left], nums[Right] = nums[Right], nums[Left]                Left += 1            Right += 1\nclass Solution &#123;    public void moveZeroes(int[] nums) &#123;        int Left = 0;        int Right = 0;        int temp;        for (int i = 0; i &lt; nums.length; ++i)        &#123;            if (nums[i] != 0)            &#123;                temp = nums[Left];                nums[Left] = nums[Right];                nums[Right] = temp;                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;\n\n三：相交链表\n1. Hash表\n将其中一个链表的数据放入哈希表，第二个链表依次判断是否包含即可\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode *&gt; hashTalble;        while (headA)        &#123;            hashTalble.insert(headA);            headA = headA-&gt;next;        &#125;        while (headB)        &#123;            if (hashTalble.count(headB))            &#123;                return headB;            &#125;            headB = headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        hashTable = set()        while headA:            hashTable.add(headA)            headA = headA.next              # 使用.运算符不是-&gt;，非指针                while headB:            if headB in hashTable:                return headB            headB = headB.next        return None             # 空为None        \npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (headA != null)               // 不能直接判断headA        &#123;            hashTable.add(headA);            headA = headA.next;             // 使用.        &#125;        while (headB != null)        &#123;            if (hashTable.contains(headB))            &#123;                return headB;            &#125;            headB = headB.next;        &#125;        return null;            // 使用null    &#125;&#125;\n\n2. 双指针\n使用两个指针指向两个链表的头结点，判断两个指针是否相等，走到末尾如果两者不相同则将指针赋值为另一个链表的头结点继续遍历，如果有相交结点，在不超过第二次遍历一定会在相交结点使两个指针相等\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *pA = headA;        ListNode *pB = headB;        if (!pA || !pB)        &#123;            return nullptr;        &#125;        while (pA != pB)        &#123;            if (pA == nullptr) pA = headB;          // 可用三元运算符替代            else pA = pA-&gt;next;            if (pB == nullptr) pB = headA;            else pB = pB-&gt;next;        &#125;        return pA;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        pA = headA        pB = headB        while pA != pB:             # 也可以用is not            if not pA:              # 或if pA is None:                pA = headB            else:                pA = pA.next            if not pB:                pB = headA            else:                pB = pB.next        return pA\npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if (headA == null || headB == null)            return null;        ListNode pA = headA, pB = headB;        while (pA != pB)        &#123;            pA = (pA == null) ? headB : pA.next;            pB = pB == null ? headA : pB.next;        &#125;        return pA;    &#125;&#125;\n\n四：反转链表\n\n\n1. 迭代反转\n根据头结点可获取到下一个结点，头结点的先前结点为空，可依次遍历将当前结点的指向进行反转，题目要求输出的结果也是反转的，因此需要返回最后一个结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre\n\n2. 递归反转\n依次传入下一个结点，并返回最后一个结点，与上一个解法的区别在于由后向前反转，此时不需要前继结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (!head || !head-&gt;next)            // 链表为空或只有单结点        &#123;            return head;        &#125;        ListNode *Last = reverseList(head-&gt;next);           // 最后一个结点在这里        head-&gt;next-&gt;next = head;        // 这里不能用Last，因为Last不动，而head一直向前        head-&gt;next = nullptr;\t\t\t// 必须设为空，否则第一个结点和第二个结点将互指        return Last;            // 一直返回最后一个结点    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null)        &#123;            return head;        &#125;        ListNode Last = reverseList(head.next);        head.next.next = head;        head.next = null;        return Last;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head or not head.next:            return head        Last = self.reverseList(head.next)\t\t\t// 这里要用self        head.next.next = head        head.next = None        return Last\n\n五：回文链表\n\n1. 数组\n将链表中的数据复制到数组中，然后将数组反转或遍历第一个和最后一个数据进行比较\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        while (head)        &#123;            vals.emplace_back(head-&gt;val);            head = head-&gt;next;        &#125;        for (int i = 0, j = static_cast&lt;int&gt;(vals.size() - 1); i &lt; j; ++i, --j)        &#123;            if (vals[i] != vals[j]) return false;        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();        while (head != null)        &#123;            vals.add(head.val);            head = head.next;        &#125;        for (int i = 0, j = vals.size() - 1; i &lt; j; ++i, --j)        &#123;            if (vals.get(i) != vals.get(j)) return false;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        vals = []        while head:            vals.append(head.val)            head = head.next        return vals == vals[::-1]\t\t\t# 可直接利用反转列表来比对\n\n2. 递归\n递归可以从后往前遍历，但是也需要从前往后的一个结点来进行对比\nclass Solution &#123;private:    ListNode *frontIteration = nullptr;\t\t\t// 从前往后public:    bool isPalindrome(ListNode* head) &#123;        frontIteration = head;        return recursion(frontIteration);    &#125;    bool recursion(ListNode* head)    &#123;        if (head)        &#123;            if (!recursion(head-&gt;next))\t\t// false继续返回false                &#123;                    return false;                &#125;            if (head-&gt;val != frontIteration-&gt;val) return false;\t\t// true则进行比对            frontIteration = frontIteration-&gt;next;\t\t\t// 每一层向后遍历        &#125;        return true;\t\t// 末尾返回true    &#125;&#125;;\nclass Solution &#123;    private ListNode frontIteration = null;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        frontIteration = head;        return recursion(head);    &#125;    public boolean recursion(ListNode head)    &#123;        if (head != null)        &#123;            if (!recursion(head.next))            &#123;                return false;            &#125;            if (head.val != frontIteration.val) return false;            frontIteration = frontIteration.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        self.frontIteration = head              # 成员变量的初始化，如果不在这里需要在__init__中        return self._recursion(head)    def _recursion(self, head: Optional[ListNode]) -&gt; bool:         # _表明内部使用，Optional表示可能的类型，-&gt; bool返回类型        if head:            if not self._recursion(head.next):                return False            if head.val != self.frontIteration.val:                return False            self.frontIteration = self.frontIteration.next        return True\n\n3.快慢指针\n该方法主要是寻找到链表的中间结点，然后将前半部分或者后半部分反转，对两部分进行比较，由于中间需要修改链表，并发处理下需要锁定其他线程或进程对链表的访问。快慢的意思则是通过两个指针，一个步长为2，另一个为1，当快指针到达尾节点时，慢指针到达中间结点，从而减少重复遍历的时间。反转可以使用之前的代码\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if (!head) return true;        ListNode *lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != nullptr)        &#123;            if (head-&gt;val != lastNode-&gt;val) return false;            head = head-&gt;next;            lastNode = lastNode-&gt;next;        &#125;        return true;    &#125;    // 寻找中间节点，    ListNode* interMediateNode(ListNode* head)    &#123;        ListNode *fastNode = head;        ListNode *slowNode = head;        while (fastNode != nullptr &amp;&amp; fastNode-&gt;next-&gt;next != nullptr)        &#123;            fastNode = fastNode-&gt;next-&gt;next;            slowNode = slowNode-&gt;next;        &#125;        return slowNode;    &#125;    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        if (head == null) return true;        ListNode lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != null)        &#123;            if (head.val != lastNode.val) return false;            head = head.next;            lastNode = lastNode.next;        &#125;        return true;    &#125;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;    public ListNode interMediateNode(ListNode head)    &#123;        ListNode fastNode = head;        ListNode slowNode = head;        while (fastNode != null &amp;&amp; fastNode.next.next != null)        &#123;            fastNode = fastNode.next.next;            slowNode = slowNode.next;        &#125;        return slowNode;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        if (not head):            return True        lastNode = self.reverseList(self.interMediateNode(head))        while (head != lastNode and head):            if head.val != lastNode.val:                return False            head = head.next            lastNode = lastNode.next        return True    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre        def interMediateNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fastNode = head        slowNode = head        while fastNode and fastNode.next.next:            fastNode = fastNode.next.next            slowNode = slowNode.next        return slowNode\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.09.30)","url":"/posts/5c81f568/","content":"一：环形链表\n\n1. 哈希表\n遍历节点并将节点存入哈希表，判断表中是否存在之前的节点即可\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return true;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return false;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return true;\t\t\t// 或if (!hashTable.add(head)) return true;            hashTable.add(head);            head = head.next;        &#125;        return false;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        hashTable = set()        while head:            if head in hashTable:                return True            hashTable.add(head)            head = head.next        return False\n\n2. 快慢指针\n通过两个不同的指针来表示行进速度，差值为1，从初始到最后相遇相当于快指针多走了一个环\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return false;        ListNode* fastNode = head-&gt;next;        // 相差一个起始位置，从而进入循环        ListNode* slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return false;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;        &#125;        return true;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        ListNode fastNode = head.next;        // 相差一个起始位置，从而进入循环        ListNode slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == null || fastNode.next == null) return false;            slowNode = slowNode.next;            fastNode = fastNode.next.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        if head is None or head.next is None:            return False        fastNode = head.next;        # 相差一个起始位置，从而进入循环        slowNode = head        while slowNode != fastNode:            if fastNode is None or fastNode.next is None:                return false            slowNode = slowNode.next            fastNode = fastNode.next.next        return True\n\n二：合并两个有序链表\n\n1. 迭代\n依次比较两个链表中的值，较小值放在较大值的前面\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 递归\n根据最小值按照相反方向逐一返回\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (!list1) return list2;        if (!list2) return list1;        if (list1-&gt;val &lt; list2-&gt;val)        &#123;            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);            return list1;        &#125; else        &#123;            list2-&gt;next = mergeTwoLists(list2-&gt;next, list1);            return list2;        &#125;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        if (list1 == null) return list2;        if (list2 == null) return list1;        if (list1.val &lt; list2.val)        &#123;            list1.next = mergeTwoLists(list1.next, list2);            return list1;        &#125; else        &#123;            list2.next = mergeTwoLists(list2.next, list1);            return list2;        &#125;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if list1 == None:            return list2        if list2 == None:            return list1        if list1.val &lt; list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list2.next, list1)            return list2\n\n三：二叉树的中序遍历\n\n1. 递归\n先逐层访问左节点，然后保存当前值，再访问右节点\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        recursion(root);        return nodes;    &#125;    void recursion(TreeNode* root)    &#123;        if (!root) return;        recursion(root-&gt;left);        nodes.emplace_back(root-&gt;val);        recursion(root-&gt;right);    &#125;&#125;;\nclass Solution &#123;    private List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();\t\t// 需要new    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        recursion(root);        return nodes;    &#125;    public void recursion(TreeNode root)    &#123;        if (root == null) return;        recursion(root.left);        nodes.add(root.val);        recursion(root.right);    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        self.nodes = []        self._recursion(root)        return self.nodes    def _recursion(self, root: Optional[TreeNode]):        if not root:            return        self._recursion(root.left)        self.nodes.append(root.val)\t\t\t\t# 这里使用append        self._recursion(root.right)\n\n2. 迭代\n这里需要一个栈来维护树的层次\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            nodes.emplace_back(root-&gt;val);            treeStack.pop();                    // 拿到数据出栈            root = root-&gt;right;       &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            nodes.add(root.val);            root = root.right;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            nodes.append(root.val)            root = root.right        return nodes\n\n3. Morris 中序遍历\n查找第一个左节点，然后遍历该结点的右节点，将最后一个右节点指向根节点，依次循环，访问时向右遍历即可\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        TreeNode* cur = nullptr;        while (root)        &#123;            if (root-&gt;left)            &#123;                cur = root-&gt;left;                while (cur-&gt;right != nullptr &amp;&amp; cur-&gt;right != root )                &#123;                    cur = cur-&gt;right;                &#125;                if (cur-&gt;right == nullptr)                &#123;                    cur-&gt;right = root;                    root = root-&gt;left;                &#125; else                &#123;                    nodes.emplace_back(root-&gt;val);                    cur-&gt;right = nullptr;           // 要赋空，否则死循环                    root = root-&gt;right;                &#125;            &#125; else             &#123;                nodes.emplace_back(root-&gt;val);                root = root-&gt;right;            &#125;        &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        TreeNode cur = null;        while (root != null)        &#123;            if (root.left != null)            &#123;                cur = root.left;                while (cur.right != null &amp;&amp; cur.right != root)     // cur.right != root必须有                &#123;                    cur = cur.right;                &#125;                if (cur.right == null)                &#123;                    cur.right = root;                    root = root.left;                &#125; else                &#123;                    nodes.add(root.val);                    cur.right = null;           // 要赋空，否则死循环                    root = root.right;                &#125;            &#125; else             &#123;                nodes.add(root.val);                root = root.right;            &#125;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        cur = None        while root is not None:            if root.left is not None:                cur = root.left                while cur.right is not None and cur.right is not root:     # cur.right is not root必须有                    cur = cur.right                if cur.right == None:                    cur.right = root                    root = root.left                else:                    nodes.append(root.val)                    cur.right = None           # 要赋空，否则死循环                    root = root.right            else:                nodes.append(root.val)                root = root.right          return nodes\n\n四：二叉树的最大深度\n\n1. 深度优先搜索\n利用递归依次遍历左右节点，取其中的较大值\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; // 使用Math.max    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\t\t# 加self\n\n2. 广度优先搜索\n用队列维护\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(root);        int depth = 0;        while (!treeQueue.empty())        &#123;            int size = treeQueue.size();            while (size &gt; 00)            &#123;                TreeNode* root = treeQueue.front();                treeQueue.pop();                if (root-&gt;left) treeQueue.push(root-&gt;left);                if (root-&gt;right) treeQueue.push(root-&gt;right);                --size;            &#125;            ++depth;        &#125;        return depth    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;();        treeQueue.offer(root);      // 使用offer        int depth = 0;        while (treeQueue.isEmpty() == false)        &#123;            int size = treeQueue.size();            while (size &gt; 0)            &#123;                TreeNode newroot = treeQueue.poll();       // 使用poll                if (newroot.left != null) treeQueue.offer(newroot.left);                if (newroot.right != null) treeQueue.offer(newroot.right);                --size;            &#125;            ++depth;        &#125;        return depth;    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        treeQueue = deque([root])         # 使用deque            depth = 0        while treeQueue:            size = len(treeQueue)            while size &gt; 0:                newroot = treeQueue.popleft()       # 使用popleft                if newroot.left:                    treeQueue.append(newroot.left)      # 使用append                if newroot.right:                    treeQueue.append(newroot.right)                size -= 1            depth += 1        return depth\n\n五：翻转二叉树\n\n1. 递归\n左右节点依次递归，找到叶子节点，然后交换左右位置\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        TreeNode* temp = root-&gt;left;        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = invertTree(temp);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        TreeNode temp = root.left;        root.left = invertTree(root.right);        root.right = invertTree(temp);        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        temp = root.left\t\t# 或平行赋值        root.left = self.invertTree(root.right)        root.right = self.invertTree(temp)        return root\n\n2. 迭代\n用队列维护\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        stack&lt;TreeNode*&gt; treeStack;        TreeNode* cur = nullptr;        TreeNode* temp = nullptr;        treeStack.push(root);        while (!treeStack.empty())        &#123;            cur = treeStack.top();            treeStack.pop();            if (cur-&gt;left != nullptr) treeStack.push(cur-&gt;left);            if (cur-&gt;right != nullptr) treeStack.push(cur-&gt;right);            temp = cur-&gt;left;            cur-&gt;left = cur-&gt;right;            cur-&gt;right = temp;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        Stack&lt;TreeNode&gt; treeStack = new Stack&lt;&gt;();        treeStack.add(root);        TreeNode cur = null;        TreeNode temp = null;        while (!treeStack.isEmpty())        &#123;            cur = treeStack.pop();            if (cur.left != null) treeStack.add(cur.left);            if (cur.right != null) treeStack.add(cur.right);            temp = cur.left;            cur.left = cur.right;            cur.right = temp;        &#125;        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        treeStack = []        treeStack.append(root)        while treeStack:            cur = treeStack.pop()            if cur.left != None: treeStack.append(cur.left)            if cur.right != None: treeStack.append(cur.right)            cur.left, cur.right = cur.right, cur.left        return root\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.1)","url":"/posts/2bc0b0cc/","content":"一：对称二叉树\n1. 递归\n每次访问左右两个节点，不相同则为false\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return recursion(root-&gt;left, root-&gt;right);    &#125;    bool recursion(TreeNode* left, TreeNode* right)    &#123;        if (left == nullptr &amp;&amp; right == nullptr) return true;       // 都为空        if (left == nullptr || right == nullptr) return false;      // 其中一个为空        return left-&gt;val == right-&gt;val &amp;&amp; recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left);   // 左节点的左节点与右节点的右节点，左节点的右节点与右节点的左节点    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return recursion(root.left, root.right);    &#125;    public boolean recursion(TreeNode left, TreeNode right)    &#123;        if (left == null &amp;&amp; right == null) return true;              if (left == null || right == null) return false;             return left.val == right.val &amp;&amp; recursion(left.left, right.right) &amp;&amp; recursion(left.right, right.left);       &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._recursion(root.left, root.right)    def _recursion(self, left: Optional[TreeNode], right: Optional[TreeNode]) -&gt; bool:        if left == None and right == None: return True              if (left == None or right == None): return False             return left.val == right.val and self._recursion(left.left, right.right) and self._recursion(left.right, right.left)  \n\n2. 迭代\n使用队列管理左右节点\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return iteration(root, root);    &#125;    bool iteration(TreeNode* left, TreeNode* right)    &#123;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(left);        treeQueue.push(right);        while (!treeQueue.empty())        &#123;            left = treeQueue.front();       // 先进先出            treeQueue.pop();            right = treeQueue.front();            treeQueue.pop();            if (left == nullptr &amp;&amp; right == nullptr) continue;            if (left == nullptr || right == nullptr || left-&gt;val != right-&gt;val) return false;            treeQueue.push(left-&gt;left);            treeQueue.push(right-&gt;right);            treeQueue.push(left-&gt;right);            treeQueue.push(right-&gt;left);        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return iteration(root, root);    &#125;    public boolean iteration(TreeNode left, TreeNode right)    &#123;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        treeQueue.offer(left);        treeQueue.offer(right);        while (!treeQueue.isEmpty())        &#123;            left = treeQueue.poll();       // 先进先出            right = treeQueue.poll();            if (left == null &amp;&amp; right == null) continue;            if (left == null || right == null || left.val != right.val) return false;            treeQueue.offer(left.left);            treeQueue.offer(right.right);            treeQueue.offer(left.right);            treeQueue.offer(right.left);        &#125;        return true;    &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._iteration(root, root)    def _iteration(self, left, right) -&gt; bool:        treeQueue = []        treeQueue.append(left)        treeQueue.append(right)        while (treeQueue):            left = treeQueue.pop()                  right = treeQueue.pop()            if (left == None and right == None): continue            if (left == None or right == None or left.val != right.val): return False            treeQueue.append(left.left)            treeQueue.append(right.right)            treeQueue.append(left.right)            treeQueue.append(right.left)        return True    \n\n二：二叉树的直径\n\n1. 深度优先\n长度为节点数减1，通过递归可获得左右子树的深度，左右子树的深度+1则为经过的节点数\nclass Solution &#123;public:    int diameterOfBinaryTree(TreeNode* root) &#123;        int nodeNum = 1;    // 初始节点为1，也可设为0表示长度        recursion(nodeNum, root);        return  nodeNum - 1;    // 返回长度    &#125;    int recursion(int&amp; nodeNum, TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftNum = recursion(nodeNum, node-&gt;left);        int rightNum = recursion(nodeNum, node-&gt;right);        nodeNum = max(nodeNum, leftNum + rightNum + 1);     // 拿到最大节点        return max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;;\nclass Solution &#123;    public int nodeNum = 0; // 初始长度为0    public int diameterOfBinaryTree(TreeNode root) &#123;        recursion(root);        return  nodeNum;    // 返回长度    &#125;    public int recursion(TreeNode node)    &#123;        if (node == null) return 0;        int leftNum = recursion(node.left);        int rightNum = recursion(node.right);        nodeNum = Math.max(nodeNum, leftNum + rightNum);     // 拿到最大长度        return Math.max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;\nclass Solution:    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:        self.nodeNum = 0        self._recursion(root)        return  self.nodeNum        def _recursion(self, node) -&gt; int:        if (node == None): return 0        leftNum = self._recursion(node.left)        rightNum = self._recursion(node.right)        self.nodeNum = max(self.nodeNum, leftNum + rightNum)             return max(leftNum, rightNum) + 1      \n\n三：将有序数组转换为二叉搜索树\n\n1. 左边中序遍历\n给定升序数组，对于二叉搜索树则是中序遍历，可将数组的中间数据或偏左作为根节点，左右两段分别为左右子树\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);\t\t// 使用length    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n2. 中间中序遍历\n这里是用中间位置或偏右作为中间结点\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + 1) / 2;       // 这里加1        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right + 1) / 2;              TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + 1) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n3. 右边中序遍历\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + rand() % 2) / 2;       // 随机，rand返回一个伪随机的整数        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        Random rand = new Random();         // 随机对象        int mid = (left + right + rand.nextInt(2)) / 2;       // 返回这个范围(2)内的随机整数        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + randint(0, 1)) // 2       # 随机整数的范围，包括起点和终点        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n四：搜索插入位置\n\n1. 二分\n根据二分查找的思想，依次比较中间点\nclass Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2; // 避免溢出的写法，也可使用java的方法            if (nums[mid] == target) &#123;                return mid;             &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;             &#125; else &#123;                right = mid - 1;             &#125;        &#125;        // 循环结束后，left 指针就是目标应该插入的位置        return left;    &#125;&#125;;\nclass Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target &lt;= nums[mid])            &#123;                cur = mid;                right = mid - 1;            &#125; else            &#123;                left = mid + 1;            &#125;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1         cur = right + 1        while (left &lt;= right):            mid = ((right - left) // 2) + left                  if (target &lt;= nums[mid]):                cur = mid                right = mid - 1            else:                left = mid + 1        return cur\n\n五：有效的括号\n\n1. 栈\n先把左括号放入栈中，遇到右括号则弹出栈顶，判断是否相同\nclass Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 != 0) return false;        unordered_map&lt;char, char&gt; unMap = &#123;            &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,            &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;,             &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;&#125;;        // 遇到右括号寻找左括号        stack&lt;char&gt; chStk;        for (auto ch : s)        &#123;            if (unMap.count(ch))            &#123;                if (chStk.empty()) return false;                char top = chStk.top();                chStk.pop();                if (unMap[ch] != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.empty();    &#125;&#125;;\nclass Solution &#123;    public boolean isValid(String s) &#123;        if (s.length() % 2 != 0) return false;        Map&lt;Character, Character&gt; unMap = new HashMap&lt;&gt;();          // 使用Character而非char        unMap.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);        unMap.put(&#x27;]&#x27;, &#x27;[&#x27;);        unMap.put(&#x27;)&#x27;, &#x27;(&#x27;);        Deque&lt;Character&gt; chStk = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; s.length(); ++i)        &#123;            char ch = s.charAt(i);            if (unMap.containsKey(ch))            &#123;                if (chStk.isEmpty()) return false;                char top = chStk.peek();                chStk.pop();                if (unMap.get(ch) != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.isEmpty();    &#125;&#125;\nclass Solution:    def isValid(self, s: str) -&gt; bool:        if (len(s) % 2 != 0): return False        unMap = &#123;            &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,            &#x27;]&#x27;: &#x27;[&#x27;,            &#x27;)&#x27;: &#x27;(&#x27;,        &#125;              chStk =[]        for ch in s:            if (ch in unMap):                if (not chStk): return False                top = chStk[-1]     # 最后一个值                chStk.pop()         # 弹出                if (unMap[ch] != top): return False            else:                chStk.append(ch)        return not chStk\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.10)","url":"/posts/994990d2/","content":"一：实现Trie（前缀树）\n\n1. 字典树\n这是一种用边表示数据的图，节点主要包含两部分，一个是子节点指针，另一部分是用数组模拟的字符数据\nclass Trie &#123;public:    vector&lt;Trie*&gt; sub;    bool endFlag;    Trie() :sub(26), endFlag(false) &#123;&#125;        void insert(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr)        // 不存在子节点，创建新的                root-&gt;sub[ch - &#x27;a&#x27;] = new Trie();            root = root-&gt;sub[ch - &#x27;a&#x27;];       // 移动到子节点        &#125;        root-&gt;endFlag = true;       // 单词结尾标识    &#125;        bool search(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return root-&gt;endFlag;    &#125;        bool startsWith(string prefix) &#123;        Trie* root = this;        for (auto&amp; ch : prefix)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return true;    &#125;&#125;;\n\n二：全排列\n\n1. 回溯\n其本质很像递归和深度优先搜索，类似于走迷宫，先选择一条路，直到达到目标或者发现无法走通进行回退，主要分为三部分：选择、探索、恢复选择\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        recursion(nums, 0, nums.size());        return result;    &#125;    void recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right)        &#123;            result.emplace_back(nums);            return;        &#125;        for (int i = left; i &lt; right; ++i)        &#123;            swap(nums[i], nums[left]);            recursion(nums, left + 1, right);            swap(nums[left], nums[i]);        &#125;    &#125;&#125;;\n\n三：子集\n\n1. 二进制迭代\n假如数组包含n个元素，子集的所有可能为2n2^n2n，因此可以使用一个数值来表示该二进制，然后求出对应的子集\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; (1 &lt;&lt; len); ++i)\t\t\t// 2^n        &#123;            vector&lt;int&gt; temp;            for (int j = 0; j &lt; len; ++j)            &#123;                if (i &amp; (1 &lt;&lt; j)) temp.emplace_back(nums[j]);\t\t\t// 判断第j位的值            &#125;            ans.emplace_back(temp);        &#125;        return ans;    &#125;&#125;;\n\n2. 递归枚举\n逐字符处理，需要考虑每个字符的两种状态\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        recursion(0, nums);        return ans;    &#125;    void recursion(int cur, vector&lt;int&gt;&amp; nums)    &#123;        if (cur == nums.size())        &#123;            ans.emplace_back(temp);            return;        &#125;        temp.emplace_back(nums[cur]);       // 添加字符，存在的情况        recursion(cur + 1, nums);       // 下一个        temp.pop_back();            // 该字符不存在的情况        recursion(cur + 1, nums);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.11)","url":"/posts/8052a193/","content":"一：电话号码的字母组合\n\n1. 回溯\n这道题的思路和子集很相似，不过需要使用哈希表处理映射关系\nclass Solution &#123;public:    vector&lt;string&gt; ans;    string sub;    unordered_map&lt;char, string&gt; map&#123;            &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;,            &#123;&#x27;3&#x27;, &quot;def&quot;&#125;,            &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;,            &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;,            &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,            &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;,            &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;,            &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;        &#125;;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if (digits.empty()) return ans;        recursion(digits, 0);        return ans;    &#125;    void recursion(string&amp; digits, int cur)    &#123;        if (cur == digits.size())        &#123;            ans.emplace_back(sub);            return;        &#125;        char ch = digits[cur];        auto&amp; subLetter = map.at(ch);        for (auto&amp; ch : subLetter)        &#123;            sub.push_back(ch);            recursion(digits, cur + 1);            sub.pop_back();        &#125;    &#125;&#125;;\n\n二：组合总和\n\n1. 搜索回溯\n这道题的思路也和子集很相似，区别在于子集只有选和不选，必须进入下一层，而当前题目可以包含重复值，可以一直选择一个元素\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; temp;        recursion(candidates, target - 0, ans, temp, 0);        return ans;    &#125;    void recursion(vector&lt;int&gt;&amp; candidates, int&amp;&amp; target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; temp, int cur)    &#123;        if (cur == candidates.size()) return;        if (target == 0)        &#123;            ans.emplace_back(temp);            return;        &#125;        recursion(candidates, target - 0, ans, temp, cur + 1);      // 跳过        if (target - candidates[cur] &gt;= 0)        &#123;            temp.emplace_back(candidates[cur]);     // 选择            recursion(candidates, target - candidates[cur], ans, temp, cur);      // 下一层            temp.pop_back();        &#125;    &#125;&#125;;\n\n三：括号生成\n\n1. 暴力\n使用暴力将所有组合生成并检测是否是有效字符串\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            if (isValid(cur)) ans.emplace_back(cur);            return;        &#125;        cur.push_back(&#x27;(&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();        cur.push_back(&#x27;)&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();    &#125;    bool isValid(string&amp; str)    &#123;        int index = 0;        for (auto&amp; ch : str)        &#123;            if (ch == &#x27;(&#x27;) ++index;     // 左括号加一，右括号减一            else --index;            if (index &lt; 0) return false;        // 说明前面的字符串右括号多于左括号，肯定不是有效字符串        &#125;        return index == 0;    &#125;&#125;;\n\n2. 回溯\n暴力充斥了很多无效的字符串直到最后才做判断，可以在递归过程中就对字符串进行检查\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2, 0, 0);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n, int left, int right)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            ans.emplace_back(cur);            return;        &#125;        if (left &lt; n / 2)        &#123;            cur.push_back(&#x27;(&#x27;);            gengerateAll(ans, cur, n, left + 1, right);            cur.pop_back();        &#125;        if (right &lt; left)        &#123;               cur.push_back(&#x27;)&#x27;);            gengerateAll(ans, cur, n, left, right + 1);            cur.pop_back();        &#125;    &#125;&#125;;\n\n3. 按括号序列的长度递归\n每个有效字符串必是’(‘开头，某个’)'结尾，其组成为“(A)B”，A的可能性为i对，则B为n-i-1对\nclass Solution &#123;public:    shared_ptr&lt;vector&lt;string&gt;&gt; cache[10] = &#123;nullptr&#125;;    vector&lt;string&gt; generateParenthesis(int n) &#123;        return *generate(n);    &#125;    shared_ptr&lt;vector&lt;string&gt;&gt; generate(int n) &#123;        if (cache[n] != nullptr)            return cache[n];        if (n == 0) &#123;            cache[0] = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;&#123;&quot;&quot;&#125;);        &#125; else &#123;            auto result = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;);            for (int i = 0; i != n; ++i) &#123;                auto lefts = generate(i);                auto rights = generate(n - i - 1);                for (const string&amp; left : *lefts)                    for (const string&amp; right : *rights)                        result -&gt; push_back(&quot;(&quot; + left + &quot;)&quot; + right);            &#125;            cache[n] = result;        &#125;        return cache[n];    &#125;&#125;;\n\n四：单词搜索\n\n1. 回溯\n使用dfs来逐个访问节点，已访问的需要标记，并在访问后恢复，因为后续还会访问\nclass Solution &#123;public:    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;        int row = board.size();        int col = board[0].size();        vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col));        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (recursion(board, visited, i, j, word, 0)) return true;        return false;    &#125;    bool recursion(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; word, int cur)    &#123;        if (board[i][j] != word[cur]) return false;        else if (cur == word.size() - 1) return true;\t\t// 应当减少size的调用        visited[i][j] = 1;\t\t // 原地标记更快，不需要额外内存        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\t\t// 这里可使用static提高运行速度        for (auto&amp; dir : directions)        &#123;            int newi = i + dir.first;            int newj = j + dir.second;            if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size())                if (!visited[newi][newj])                    if (recursion(board, visited, newi, newj, word, cur + 1)) return true;        &#125;        visited[i][j] = 0;        return false;    &#125;&#125;;\n\n五：分割回文串\n\n1. 回溯+动态规划\n本题的难点在于状态转移方程\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len, true));        for (int i = len - 1; i &gt;= 0; --i)            for (int j = i + 1; j &lt; len; ++j)                flag[i][j] = (s[i] == s[j]) &amp;&amp; flag[i + 1][j - 1];        // i需要减，j需要加，形成上三角矩阵，这是本题的关键        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (flag[i][j])            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;&#125;;\n\n2. 回溯+记忆化搜索\n这里不使用数组来表示子字符串的状态，而是在递归时不断更新\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len));        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (IsPalindrome(s, i, j) == 1)            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;    int IsPalindrome(string&amp; s, int i, int j)      // 0 、1、-1    &#123;        if (flag[i][j]) return flag[i][j];        if (i &gt;= j) return flag[i][j] = 1;        return flag[i][j] = (s[i] == s[j] ? IsPalindrome(s, i + 1, j - 1) : -1);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.12)","url":"/posts/ab7ff250/","content":"一：搜索二维矩阵\n\n1. 两次查找\n第一次在每行的第一个元素查找，然后在该行中查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        auto row = upper_bound(matrix.begin(), matrix.end(), target, [](int target, vector&lt;int&gt;&amp; row)&#123;return target &lt; row[0];&#125;);  // 需要自定义比较函数，因为一个值无法与数组比较        if (row == matrix.begin()) return false;        --row;        return binary_search(row-&gt;begin(), row-&gt;end(), target);    &#125;&#125;;\n\n2. 一次查找\n将二位矩阵展开为一维，然后把索引转换为二维去处理\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int row = matrix.size();        int col = matrix[0].size();        int left = 0, right = row * col - 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;            int cur = matrix[mid / col][mid % col];     // 对列处理            if (cur &gt; target) right = mid - 1;            else if (cur &lt; target) left = mid + 1;            else return true;        &#125;        return false;    &#125;&#125;;\n\n二：在排序数组中查找元素的第一个和最后一个位置\n\n1. 二分查找\n先查找左边界，然后寻找右边界，最后验证\nclass Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = BinarySearch(nums, target, true);        int right = BinarySearch(nums, target, false) - 1;        if (left &gt;= 0 &amp;&amp; left &lt;= right &amp;&amp; right &lt; nums.size() &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)            return vector&lt;int&gt;&#123;left, right&#125;;        return vector&lt;int&gt;&#123;-1, -1&#125;;    &#125;    int BinarySearch(vector&lt;int&gt;&amp; nums, int target, int lowFlag)    &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        int ans = nums.size();        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &gt; target || (nums[mid] &gt;= target &amp;&amp; lowFlag))            &#123;                right = mid - 1;                ans = mid;            &#125;            else                left = mid + 1;        &#125;        return ans;    &#125;&#125;;\n\n三：搜索旋转排序数组\n\n1. 二分查找\n这题比普通的二分稍微复杂一些，主要在于取中间点后，中间点可能大于也可能小于起始元素，但有一边一定是有序的\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int len = nums.size();        if (len == 0) return false;        if (len == 1) return target == nums[0] ? 0 : -1;        int left = 0, right = len - 1;        int mid = 0;        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] == target) return mid;            if (nums[0] &lt;= nums[mid])            &#123;                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid])                    right = mid - 1;                else                    left = mid + 1;            &#125; else            &#123;                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[len - 1])                    left = mid + 1;                else                       right = right -1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n四：寻找旋转排序数组中的最小值\n\n1. 二分查找\n这题和上题类似，主要利用划分后最小值可能存在的位置，左边或者右边\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        while (left &lt; right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &lt; nums[right])                right = mid;            else                left = mid + 1;        &#125;        return nums[left];    &#125;&#125;;\n\n五：最小栈\n\n1. 辅助栈\n栈的实现可以直接使用stack，但这里需要记录最小值，并且常数查找，因此使用辅助栈来记录每一个元素对应的最小值\nclass MinStack &#123;    stack&lt;int&gt; value;    stack&lt;int&gt; min;public:    MinStack() &#123;        min.push(INT_MAX);    &#125;        void push(int val) &#123;        value.push(val);        min.push(std::min(val, min.top()));    &#125;        void pop() &#123;        value.pop();        min.pop();    &#125;        int top() &#123;        return value.top();    &#125;        int getMin() &#123;        return min.top();    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.13)","url":"/posts/b264c311/","content":"一：字符串解码\n\n1. 栈操作\n将数字和左括号入栈，遇到右括号对数据进行处理\nclass Solution &#123;public:    string decodeString(string s) &#123;        vector&lt;string&gt; stk;        int cur = 0;        string digits;        while (cur &lt; s.size())        &#123;            char ch = s[cur];            if (isdigit(ch))            &#123;                digits = GetDigits(s, cur, digits);                stk.push_back(digits);            &#125; else if (isalpha(ch) || ch == &#x27;[&#x27;)                stk.push_back(string(1, s[cur++]));            else            &#123;                ++cur;      // ]直接略过                string sub;                string temp;                while (stk.back() != &quot;[&quot;)                &#123;                    sub = stk.back() + sub;                    stk.pop_back();                &#125;                //reverse(sub.begin(), sub.end());                stk.pop_back();     // 左括号略过                int count = stoi(stk.back());                stk.pop_back();                 while (count--) temp += sub;                stk.push_back(temp);            &#125;        &#125;        string result;        for (auto&amp; s : stk) result += s;        return result;    &#125;    string&amp; GetDigits(string&amp; s, int&amp; cur, string&amp; digits)    &#123;        digits.clear();        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return digits;    &#125;&#125;;\n\n2. 递归\n对数字仍做上述处理，左括号过滤，然后递归处理字符，右括号也过滤\nclass Solution &#123;public:    string s;    int cur = 0;    string decodeString(string s) &#123;        this-&gt;s = s;        return GetString();    &#125;    int GetDigits()    &#123;        string digits;        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return stoi(digits);    &#125;    string GetString()    &#123;        if (cur == s.size() || s[cur] == &#x27;]&#x27;) return &quot;&quot;;        char ch = s[cur];        string sub;        if (isdigit(ch))        &#123;            int repeatTime = GetDigits();            ++cur;            string str = GetString();            ++cur;            while (repeatTime--) sub += str;        &#125; else if(isalpha(ch))        &#123;            sub = string(1, ch);            ++cur;        &#125;        return sub + GetString();    &#125;&#125;;\n\n二：每日温度\n\n1. 暴力\n该题通过使用一个温度数组来记录当前温度的索引，其中温度为下标，值为数组中的索引，通过向前遍历来记录温度的情况\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        vector&lt;int&gt; record(101, INT_MAX);        for (int i = len - 1; i &gt;= 0; --i)        &#123;            int index = INT_MAX;            for (int j = temperatures[i] + 1; j &lt;= 100; ++j)                index = min(index, record[j]);            if (index != INT_MAX)                result[i] = (index - i);            record[temperatures[i]] = i;        &#125;        return result;    &#125;&#125;;\n\n2. 单调栈\n使用一个栈来维护温度，使温度递减，如果温度大于栈顶，则把栈顶弹出，并更新天数，因为此时为栈顶索引遇到的第一个升温天气\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        stack&lt;int&gt; stk;        int temp;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()])            &#123;                temp = stk.top();                stk.pop();                result[temp] = i - temp;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n三：数组中的第K个最大元素\n\n1. 基于快速排序的选择方法\n寻找第K大的元素意味着寻找第n - k小的元素，利用快速排序分治的思想不断递归，可以找到元素所在的位置\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        return QuickChoose(nums, len - k, 0, len - 1);    &#125;    int QuickChoose(vector&lt;int&gt;&amp; nums, int index, int left, int right)    &#123;        if (left == right) return nums[left];        int i = left - 1;        int j = right + 1;        int numFlag = nums[left];        while (i &lt; j)        &#123;            do ++i; while (nums[i] &lt; numFlag);            do --j; while (nums[j] &gt; numFlag);            if (i &lt; j) swap(nums[i], nums[j]);        &#125;        if ( index &lt;= j) return QuickChoose(nums, index, left, j);        else return QuickChoose(nums, index, j + 1, right);    &#125;&#125;;\n\n2. 基于堆排序的选择方法\n选择当前数组作为最大堆，然后将其从第一个非叶子节点重新构建，之后逐个删除顶端元素\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size(), size = len;        BuildHeap(nums, len);        for (int i = len - 1; i &gt; len - k; --i)        &#123;            swap(nums[0], nums[i]);            --size;            Heapify(nums, size, 0);        &#125;        return nums[0];    &#125;    void BuildHeap(vector&lt;int&gt;&amp; nums, int size)    &#123;        for (int i = size / 2 - 1; i &gt;= 0; --i)            Heapify(nums, size, i);    &#125;    void Heapify(vector&lt;int&gt;&amp; nums, int size, int cur)    &#123;        int leftNode = cur * 2 + 1;        int rightNode = cur * 2 + 2;        int largest = cur;        if (leftNode &lt; size &amp;&amp; nums[leftNode] &gt; nums[largest]) largest = leftNode;         if (rightNode &lt; size &amp;&amp; nums[rightNode] &gt; nums[largest]) largest = rightNode;         if (cur != largest)        &#123;            swap(nums[largest], nums[cur]);            Heapify(nums, size, largest);        &#125;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.14)","url":"/posts/fd2555d6/","content":"一：前K个高频元素\n\n1. 堆\n可以使用哈希表将元素出现的次数记录下来，然后对出现次数排序，复杂度为O(nlog⁡(n))O(n\\log(n))O(nlog(n))。但题目要求优于O(nlog⁡(n))O(n\\log(n))O(nlog(n))，需要使用其他方案。这里的时间主要花在了排序上，可以使用堆或快排来对元素进行不完全排序，从而降低时间复杂度。该方法使用最小堆将出现次数小的元素放在栈顶\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        auto commpare = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;return a.second &gt; b.second;&#125;;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(commpare)&gt; pq(commpare);        for (auto&amp; [num, count] : occour)        &#123;            if (pq.size() &lt; k) pq.emplace(num, count);            else if (pq.top().second &lt; count)             &#123;                pq.pop();                pq.emplace(num, count);            &#125;        &#125;        while (!pq.empty())        &#123;            result.emplace_back(pq.top().first);            pq.pop();        &#125;        return result;    &#125;&#125;;\n\n2. 基于快速排序\n其核心思想在于快排的一次循环过后能够将数据按照选定的某个值分为≥和≤两部分，通过比较左右长度便可判断前k最大值所在位置\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; value : occour) values.emplace_back(value);        QuickChoose(values, k, 0, values.size() - 1, result);        return result;    &#125;    void QuickChoose(vector&lt;pair&lt;int, int&gt;&gt;&amp; values, int k, int left, int right, vector&lt;int&gt;&amp; result)    &#123;        if (left &gt; right) return;        if (left == right) &#123;                 // 基本情形            result.push_back(values[left].first);            return;        &#125;        int picked = rand() % (right - left + 1) + left;        swap(values[picked], values[left]);        int pivot = values[left].second;        int i = left - 1;        int j = right + 1;        while (i &lt; j)        &#123;            do ++i; while (values[i].second &gt; pivot);            do --j; while (values[j].second &lt; pivot);            if (i &lt; j) swap(values[i], values[j]);        &#125;        int leftCount = j - left + 1;          if (k &lt;= leftCount) QuickChoose(values, k, left, j, result);        else         &#123;            for (int i = left; i &lt;= j; ++i)                result.emplace_back(values[i].first);            QuickChoose(values, k - leftCount, j + 1, right, result);        &#125;    &#125;&#125;;\n\n二：跳跃游戏\n\n1. 贪心\n假设当前位于x，那么x+nums[x]范围内的元素都是可达的，因此我们只需要维护一个最大的可达范围即可，如果该范围能够覆盖终点，则意味着终点可达\nclass Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int maxSkip = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if ( i &lt;= maxSkip) maxSkip = max(maxSkip, i + nums[i]);            if (maxSkip &gt;= len - 1) return true;        &#125;        return false;    &#125;&#125;;\n\n三：跳跃游戏Ⅱ\n\n1. 反向查找出发位置\n我们从最后一个点出发，先找出最后一步到达终点的前面所有点，取最远位置，然后循环直到出发点即可。为什么可行？我们假设终点为n - 1，其最远距离为x，那么x~n - 1区间内的所有位置都是可达的，假设区间中存在一个点的第二步的上一个位置为y，那么y~该点的距离一定包含x，所以x的第二步一定大于等于y，所以求解出来的步数最优\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int cur = len;        int step = 0;        while (cur &gt; 0)        &#123;            for (int i = 0; i &lt;= cur; ++i)            &#123;                if (i + nums[i] &gt;= cur)                &#123;                    cur = i;                    ++step;                    break;                &#125;            &#125;        &#125;        return step;    &#125;&#125;;\n\n2. 正向查找可到达的最大位置\n这里假设第一步的距离为x，由题意知一定会到达终点，那么第二步应该选择0~x之间能够跳出最远的位置，理论和上一个方法相同，最远位置一定包含其中的点，步骤只会小于等于其他元素\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int step = 0, maxStep = 0, end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt;= maxStep)                maxStep = max(maxStep, i + nums[i]);            if (i == end)            &#123;                end = maxStep;                ++step;            &#125;        &#125;        return step;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.15)","url":"/posts/e43e6497/","content":"一：划分字母区间\n\n1. 贪心\n该题的思路为通过遍历字符串，得到每一个字符最后出现的位置，然后维护一个起始指针，再次遍历字符串更新结束位置，如果达到end则意味着这个子字符串可划分\nclass Solution &#123;public:    vector&lt;int&gt; partitionLabels(string s) &#123;        int array[26];        int len = s.size();        vector&lt;int&gt; result;        for (int i = 0; i &lt; len; ++i)            array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)] = i;        int start = 0, end = 0;        int size = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            size = max(size, array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)]);            end = size;            if (i == end)            &#123;                result.emplace_back(end - start + 1);                start = end + 1;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：颜色分类\n\n1. 单指针\n使用该方式需要两次遍历，一次用于交换0，一次用于交换1，交换其他数据也可以\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;    &#125;&#125;;\n\n2. 双指针\n使用双指针可以同时交换两个数据，比如同时交换0和1，但需要注意交换顺序和对后续交换的影响\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur1 = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur1]);                ++cur1;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                if (cur0 &lt; cur1)                     swap(nums[i], nums[cur1]);                ++cur0;                ++cur1;            &#125;        &#125;    &#125;&#125;;\n\n3. 双指针\n这里我们使用两端用于交换，但是交换之后的数据可能仍然需要交换，因此需要额外处理，知道它不需要交换\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur2 = len - 1;        for (int i = 0; i &lt;= cur2; ++i)        &#123;            while (i &lt;= cur2 &amp;&amp; nums[i] == 2)            &#123;                swap(nums[i], nums[cur2]);                --cur2;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                ++cur0;            &#125;        &#125;    &#125;&#125;;\n\n4. 直接遍历\n该题最简单的方式是将数组遍历得到每个元素的数量然后修改原来的数组即可\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int red = 0, white = 0, blue = 0;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0) ++red;            if (nums[i] == 1) ++white;            if (nums[i] == 2) ++blue;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt; red) nums[i] = 0;            if (i &gt;= red&amp;&amp; i &lt; red + white) nums[i] = 1;            if (i &gt;= red + white &amp;&amp; i &lt; red + white + blue) nums[i] = 2;        &#125;    &#125;&#125;;\n\n三：下一个排列\n\n1. 两遍扫描\n该题需要从后向前找到第一个升序的位置，然后将其与该位置之后的最后一个大于自己的数据进行交换，同时需要对该位置之后的数据重排为升序\n\nclass Solution &#123;public:    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int start = len - 2;        while (start &gt;= 0 &amp;&amp; nums[start] &gt;= nums[start + 1])            --start;        if (start &gt;= 0)        &#123;            int j = len - 1;            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[start])                --j;            swap(nums[start], nums[j]);        &#125;        reverse(nums.begin() + start + 1, nums.end());    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.16)","url":"/posts/cf133754/","content":"一：寻找重复数\n\n1. 二分查找\n最简单的方式应该直接对其排序，然后遍历一遍找出重复值，但是题目要求不能修改原数组且使用常量空间，因此不能应用。这里我们可以注意到值的范围，如果我们把该范围的中间值作为一个临界值，那么数组应该被分为大致相等的两部分，存在重复值的一部分会稍大\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int left = 1, right = len - 1;        int mid = 0;        int ans = -1;        while (left &lt;= right)        &#123;            int count = 0;            mid = ((right - left) &gt;&gt; 1) + left;            for (int i = 0; i &lt; len; ++i)                if (nums[i] &lt;= mid) ++count;            if (count &lt;= mid) left = mid + 1;            else             &#123;                ans = mid;                right = mid - 1;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2. 二进制\n该方法使用二进制位来记录数组中不同元素的二进制位并与值域的二进制位比较\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int ans = 0;        int bitCnt = 0;        int temp = len - 1;        while (temp &gt;&gt;= 1) ++bitCnt;        for (int i = 0; i &lt;= bitCnt; ++i)        &#123;            int x = 0, y = 0;            for (int j = 0; j &lt; len; ++j)            &#123;                if (nums[j] &amp; (1 &lt;&lt; i)) ++x;                if (j &gt; 0 &amp;&amp; (j &amp; (1 &lt;&lt; i))) ++y;            &#125;            if (x &gt; y) ans |= (1 &lt;&lt; i);        &#125;        return ans;    &#125;&#125;;\n\n3. 快慢指针\n数组的索引为0~n-1，值域为1~n-1，那么每个索引都会对应一个值域，至少存在一个值域被两个索引指向，此时构建从索引到值的环，环的入口就是重复节点\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int slow = 0, fast = 0;        do         &#123;            slow = nums[slow];            fast = nums[nums[fast]];        &#125; while (slow != fast);        slow = 0;        while (slow != fast)        &#123;            slow = nums[slow];            fast = nums[fast];        &#125;        return slow;    &#125;&#125;;\n\n二：打家劫舍\n\n1. 动态规划\n由题目可知，一间房子和两间房子的情况是确定的，也就是我们的边界条件，对于房间k，我们有偷和不偷两个选项，但要取其中的较大值\nclass Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        vector&lt;int&gt; sum(len, 0);        sum[0] = nums[0];        sum[1] = max(nums[0], nums[1]);        for (int i = 2; i &lt; len; ++i)        &#123;            sum[i] = max(sum[i - 1], nums[i] + sum[i - 2]);        &#125;        return sum.back();    &#125;&#125;;// 滚动数组优化空间class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        int pre = nums[0], next = max(nums[1], nums[0]);        int temp = 0;        for (int i = 2; i &lt; len; ++i)        &#123;            temp = next;            next = max(next, nums[i] + pre);            pre = temp;        &#125;        return next;    &#125;&#125;;\n\n三：完全平方数\n\n1. 动态规划\n该题需要寻找一个索引使得n - j * j的平方和的数量最小\nclass Solution &#123;public:    int numSquares(int n) &#123;        vector&lt;int&gt; step(n + 1);\t\t// 索引0作为辅助        for (int i = 1; i &lt;= n; ++i)        &#123;            int minStep = INT_MAX;            for (int j = 1; j * j &lt;= i; ++j)            &#123;                minStep = min(minStep, step[i - j * j]);            &#125;            step[i] = minStep + 1;         &#125;        return step[n];    &#125;&#125;;\n\n2. 数学\n四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。\n同时四平方和定理包含了一个更强的结论：当且仅当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，nnn 可以被表示为至多三个正整数的平方和。\n因此，当 n=4k×(8m+7)n = 4^k \\times (8m+7)n=4k×(8m+7) 时，(n) 只能被表示为四个正整数的平方和。此时我们可以直接返回 4。\n当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，我们需要判断到底多少个完全平方数能够表示 nnn。我们知道答案只会是 (1,2,3) 中的一个\nclass Solution &#123;public:    int numSquares(int n) &#123;        if (static_cast&lt;int&gt;(sqrt(n)) * static_cast&lt;int&gt;(sqrt(n)) == n) return 1;        if (IsFormat(n)) return 4;        for (int i = 1; i * i &lt;= n; ++i)        &#123;            int j = n - i * i;            if (static_cast&lt;int&gt;(sqrt(j)) * static_cast&lt;int&gt;(sqrt(j)) == j) return 2;        &#125;        return 3;    &#125;    bool IsFormat(int x)    &#123;        while (x % 4 == 0) x /= 4;        return x % 8 == 7;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.17)","url":"/posts/d6080615/","content":"一：零钱兑换\n\n1. 记忆化搜索\n本质上属于迭代，找出子目标数据的最小值，自顶向下\nclass Solution &#123;public:    vector&lt;int&gt; count;    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        count.resize(amount);        return recursion(coins, amount);    &#125;    int recursion(vector&lt;int&gt;&amp; coins, int amount)    &#123;        if (amount == 0) return 0;        if (amount &lt; 0) return -1;        if (count[amount - 1] != 0) return count[amount - 1];        int minNum = INT_MAX;        for (auto&amp; coin : coins)        &#123;            int temp = recursion(coins, amount - coin);            if (temp &gt;= 0 &amp;&amp; temp &lt; minNum)                minNum = temp + 1;        &#125;        count[amount - 1] = minNum == INT_MAX ? -1 : minNum;        return count[amount - 1];    &#125;&#125;;\n\n2. 动态规划\n使用动态规划的关键点在于找出状态转移方程，该题目可求出当前硬币对应的上一个目标值的最小硬币数量\nclass Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int max = amount + 1;      // 不能使用INT_MAX，见下        vector&lt;int&gt; count(amount + 1, max);     // 这里使用+1把0也算入        count[0] = 0;        for (int i = 1; i &lt;= amount; ++i)        &#123;            for (auto&amp; coin : coins)            &#123;                if (coin &lt;= i)                &#123;                    count[i] = min(count[i], count[i - coin] + 1);      // INT_MAX这里会超出范围                &#125;            &#125;        &#125;        return count[amount] = count[amount] == amount + 1 ? -1 : count[amount];    &#125;&#125;;\n\n二：单词拆分\n\n1. 动态规划\n假设当前位于x，对于0 ~ x的子串需要寻找一个位置 j，使0 ~ j位于给定数组中，然后再判断j + 1 ~ x是否位于数组中\nclass Solution &#123;public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        unordered_set&lt;string&gt; hashWord;        int len = s.size();        for (auto&amp; word : wordDict) hashWord.insert(word);        vector&lt;bool&gt; dp(len + 1);        dp[0] = true;        for (int i = 1; i &lt;= len; ++i)            for (int j = 0; j &lt; i; ++j)                if (dp[j] &amp;&amp; hashWord.find(s.substr(j, i - j)) != hashWord.end())                &#123;                    dp[i] = true;                    break;                &#125;        return dp[len];    &#125;&#125;;\n\n三：最长递增子序列\n\n1. 动态规划\n使用一个数组来记录以给定数组的每个元素结尾的子序列的长度，如果当前值大于某个最长子序列的最后一个值，则把它加入\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        vector&lt;int&gt; dp(len, 1);        for (int i = 0; i &lt; len; ++i)            for (int j = 0; j &lt; i; ++j)                if (nums[i] &gt; nums[j])                    dp[i] = max(dp[i], dp[j] + 1);        return *max_element(dp.begin(), dp.end());    &#125;&#125;;\n\n2. 贪心+二分查找\n使用一个数组来维护最长子序列的最后一个值，如果下个值大于最后一个值则加入，如果不大于则替换数组中首个大于该元素的值\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int size = 1;        vector&lt;int&gt; dp(len + 1, 0);        dp[size] = nums[0];        for (int i = 1; i &lt; len; ++i)        &#123;            if (nums[i] &gt; dp[size])                dp[++size] = nums[i];            else            &#123;                int left = 1, right = size;                int pos = 0;                while (left &lt;= right)                &#123;                    int mid = (left + right) &gt;&gt; 1;                    if (dp[mid] &lt; nums[i])                    &#123;                        pos = mid;                        left = mid + 1;                    &#125; else                        right = mid - 1;                &#125;                dp[pos + 1] = nums[i];            &#125;        &#125;        return size;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.18)","url":"/posts/51901ada/","content":"一：乘积最大子数组\n\n1. 动态规划\n该题的难点在于需要同时处理正值和负值，以x结尾的子串乘上下一个元素有可能继续增大，也有可能变得很小，但如果一个负数乘一个负数可能得出一个很大的结果，因此我们同时维护以x结尾的子串的最大值和最小值\nclass Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;long long&gt; maxM(nums.begin(), nums.end());        vector&lt;long long&gt; minM(nums.begin(), nums.end());        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxM[i] = max(maxM[i - 1] * nums[i], max(minM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM[i] = min(minM[i - 1] * nums[i], min(maxM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));        &#125;        return *max_element(maxM.begin(), maxM.end());    &#125;&#125;;// 滚动数组空间优化class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        long long maxM = nums[0];        long long maxT = nums[0];        long long minM = nums[0];        long long minT = nums[0];        long long ans = nums[0];        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxT = maxM, minT = minM;            maxM = max(maxT * nums[i], max(minT * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM = min(minT * nums[i], min(maxT * nums[i], static_cast&lt;long long&gt;(nums[i])));            ans = max(maxM, ans);        &#125;        return static_cast&lt;int&gt;(ans);    &#125;&#125;;\n\n二：分割等和子集\n\n1. 动态规划\n该题使用二维数组来存储子序列能否目标值，除了前置条件，后一个的判断需要根据先前的结果来判断\nclass Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(target + 1, 0));        for (int i = 0; i &lt; len; ++i)            dp[i][0] = true;        dp[0][nums[0]] = true;        for (int i = 1; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = 1; j &lt;= target; ++j)                if (temp &lt;= j)                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - temp];                else                    dp[i][j] = dp[i - 1][j];        &#125;        return dp[len - 1][target];    &#125;&#125;;// 空间优化class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;int&gt; dp(target + 1, 0);        dp[0] = true;        for (int i = 0; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = target; j &gt;= temp; --j)                dp[j] = dp[j] | dp[j - temp];        &#125;        return dp[target];    &#125;&#125;;\n\n三：不同路径\n\n1. 动态规划\n使用二维数组来存储每个位置的步数，当前位置的步数等于上一行和左边位置的和\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        for (int i = 0; i &lt; m; ++i) dp[i][0] = 1;        for (int i = 0; i &lt; n; ++i) dp[0][i] = 1;        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        return dp[m - 1][n - 1];    &#125;&#125;;// 空间优化class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;int&gt; dp(n);        dp[0] = 1;        for (int i = 0; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[j] = dp[j] + dp[j - 1];        return dp[n - 1];    &#125;&#125;;\n\n2. 组合数学\n对于一个m∗nm*nm∗n的二维数组，本质上有m−1m-1m−1次向下移动和n−1n-1n−1次向右移动，因此属于排列组合\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        long long result = 1;        for (int x = n, y = 1; y &lt; m; ++x, ++y)            result = result * x / y;        return static_cast&lt;int&gt;(result);    &#125;&#125;;\n\n四：最小路径和\n\n1. 动态规划\n该题与上题类似，不过每个元素的值可能不相等，但当前点只能由上和左两个位置得到，选用其中一个最小值和自身值相加即可得到当前点的最小值\nclass Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m = grid.size();        int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i - 1][0] + grid[i][0];        for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i - 1] + grid[0][i];        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = min(dp[i - 1][j] , dp[i][j - 1]) + grid[i][j];        return dp[m - 1][n - 1];    &#125;&#125;;\n\n五：最长回文子串\n\n1. 动态规划\n假设每个字符都为一个回文，对于一个从x到y的字符串，其是否为回文依赖于x+1x+1x+1和y−1y-1y−1是否为字符串，同时需要处理长度为2和为3的情况如“aa”，“bab”\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int len = s.size();        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));        if (len &lt; 2) return s;        for (int i = 0; i &lt; len; ++i) dp[i][i] = true;        int maxLen = 1;        int begin = 0;        for (int l = 2; l &lt;= len; ++l)        &#123;            for (int i = 0; i &lt; len; ++i)            &#123;                int right = l + i - 1;                if (right &gt;= len) break;                if (s[i] != s[right]) dp[i][right] = false;                else                &#123;                    if (right - i &lt; 3) dp[i][right] = true;                    else                    &#123;                        dp[i][right] = dp[i + 1][right - 1];                    &#125;                 &#125;                if (dp[i][right] &amp;&amp; right - i + 1 &gt; maxLen)                &#123;                    maxLen = right - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;\n\n2. 中心扩展算法\n我们以每个字符或者每两个字符为中心然后左右不断扩展，同时用起始位置来维护最大的长度\nclass Solution &#123;public:    int len;    string longestPalindrome(string s) &#123;        len = s.size();        int begin = 0;        int end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            auto [left1, right1] = Expand(s, i, i);            auto [left2, right2] = Expand(s, i, i + 1);            if (right1 - left1 &gt; end - begin)            &#123;                begin = left1;                end = right1;            &#125;            if (right2 - left2 &gt; end - begin)            &#123;                begin = left2;                end = right2;            &#125;        &#125;        return s.substr(begin, end - begin + 1);    &#125;    pair&lt;int, int&gt; Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return &#123;left + 1, right - 1&#125;;    &#125;&#125;;\n\n3. Manacher算法\n这个题非常巧妙，利用了回文的对称性，从而大量降低了重复的计算\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int begin = 0;        int end = -1;       // 取-1为了下面正确的判断，从而使单个字符能够满足条件        string temp = &quot;#&quot;;        for (auto&amp; ch : s)        &#123;            temp += ch;            temp += &#x27;#&#x27;;        &#125;        s = temp;        int len = s.size();        vector&lt;int&gt; arm;        int right = -1, cur = -1;        for (int i = 0; i &lt; len; ++i)        &#123;            int curArm;            if (right &gt;= i)            &#123;                int isysm = 2 * cur - i;                int minArm = min(arm[isysm], right - i);                curArm = Expand(s, i - minArm, i + minArm);             &#125; else            &#123;                curArm = Expand(s, i, i);            &#125;            arm.emplace_back(curArm);            if (i + curArm &gt; right)            &#123;                cur = i;                right = i + curArm;            &#125;            if (curArm * 2 + 1 &gt; end - begin)            &#123;                begin = i - curArm;                end = i + curArm;            &#125;        &#125;        string result;        for (int i = begin; i &lt;= end; ++i)            if (s[i] != &#x27;#&#x27;) result += s[i];        return result;    &#125;    int Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return (right - left - 2)  &gt;&gt; 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.19)","url":"/posts/488b2b9b/","content":"一：最长公共子序列\n\n1. 动态规划\n使用一个二维数组来记录以x和y长度的两个字符串的最大子串\nclass Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        int m = text1.size();        int n = text2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 1; i &lt;= m; ++i)        &#123;            for (int j = 1; j &lt;= n; ++j)                if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;        return dp[m][n];    &#125;&#125;;\n\n二：编辑距离\n\n1. 动态规划\n一共有三种替换方式，对于增加和删除是相对于原数据加1，替换有可能不增加，需要对三种方式取最小值，这里主要使用距离来表示两个字符串的差异\nclass Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m = word1.size();        int n = word2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 0; i &lt;= m; ++i)            dp[i][0] = i;        for (int i = 0; i &lt;= n; ++i)            dp[0][i] = i;        for (int i = 1; i &lt;= m; ++i)            for (int j = 1; j &lt;= n; ++j)            &#123;                int add = dp[i - 1][j] + 1;                int del = dp[i][j - 1] + 1;                int tak = dp[i - 1][j -1];                if (word1[i - 1] != word2[j - 1]) ++tak;                dp[i][j] = min(add, min(del, tak));            &#125;        return dp[m][n];    &#125;&#125;;\n\n三：最长有效括号\n\n1. 动态规划\n使用一个数组来表示以右括号结尾的子串的长度，那么左括号必为0，此时右括号有两种情况\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        vector&lt;int&gt; dp(len, 0);        int result = 0;        for (int i = 1; i &lt; len; ++i)         &#123;            if (s[i] == &#x27;)&#x27;)                if (s[i - 1] == &#x27;(&#x27; &amp;&amp; i &gt;= 2)                    dp[i] = dp[i - 2] + 2;                else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;)                &#123;                    dp[i] = dp[i - 1] + 2;                    int pre = i - dp[i - 1] - 2;                    if (pre &gt;= 0) dp[i] += dp[pre];                &#125;                result = max(result, dp[i]);        &#125;        return result;    &#125;&#125;;\n\n2. 栈\n这个方法相对容易但也需要一些技巧，我们使用索引放入堆栈作为未匹配字符，遇到右括号表明存在匹配从而弹出栈顶数据，使用当前位置减去栈顶未匹配索引即为所求字符串的长度\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        stack&lt;int&gt; stk;        int result = 0;        stk.push(-1);        for (int i = 0; i &lt; len; ++i)            if (s[i] == &#x27;(&#x27;) stk.push(i);            else            &#123;                stk.pop();                if (stk.empty()) stk.push(i);        // 保证有数据作为未匹配字符                else result = max(result, i - stk.top());            &#125;        return result;    &#125;&#125;;\n\n3. 不需要额外的空间\n对于一个有效的字符串一定满足两个条件，一：左右括号数量相等，二：前缀子串的左括号数不小于右括号、后缀子串右括号不小于左括号\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        int result = 0;        int left = 0, right = 0;        for (int i = 0; i &lt; len; ++i)\t\t// 无法处理左括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (right &gt; left) left = right = 0;         // 不合法，重置        &#125;        left = right = 0;        for (int i = len - 1; i &gt;= 0; --i)\t\t\t// 无法处理右括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (left &gt; right) left = right = 0;         // 不合法，重置        &#125;        return result;    &#125;&#125;;\n\n四：数据流的中位数\n\n1. 优先队列\n使用大顶堆和小顶堆来维护有序数组，同时保证大顶堆的长度不小于小顶堆\nclass MedianFinder &#123;public:    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; priLess;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; priGreater;    MedianFinder() &#123;&#125;        void addNum(int num) &#123;        if (priLess.empty() || num &lt;= priLess.top())        &#123;            priLess.push(num);            if (priLess.size() &gt; priGreater.size() + 1)            &#123;                priGreater.push(priLess.top());                priLess.pop();            &#125;        &#125; else        &#123;            priGreater.push(num);            if (priGreater.size() &gt; priLess.size())            &#123;                priLess.push(priGreater.top());                priGreater.pop();            &#125;        &#125;    &#125;    double findMedian() &#123;        if (priLess.size() &gt; priGreater.size()) return priLess.top();        return (static_cast&lt;long long&gt;(priLess.top()) + static_cast&lt;long long&gt;(priGreater.top())) / 2.0;\t// 这里提升精度，否则有可能报错    &#125;&#125;;\n\n2. 有序集合+双指针\n使用multiset来维护一个有序数组，使用两个指针维护中位数，需要对双指针进行较多判断\nclass MedianFinder &#123;public:    multiset&lt;int&gt; nums;    multiset&lt;int&gt;::iterator left, right;    MedianFinder() &#123;left = nums.end(); right = nums.end();&#125;    void addNum(int num) &#123;        int len = nums.size();        nums.insert(num);        if (len == 0) left = right = nums.begin();        else if (len &amp; 1)             if (num &lt; *left) --left;            else ++right;        else            if (num &gt;= *right) ++left;            else if (num &gt;= *left &amp;&amp; num &lt; *right)             &#123;                ++left;                --right;            &#125;            else                --right;    &#125;    double findMedian() &#123;        return (static_cast&lt;long long&gt;(*left) + static_cast&lt;long long&gt;(*right)) / 2.0;    &#125;&#125;;\n\n五：柱状图中最大的矩形\n\n1. 单调栈\n使用两个数组来存储当前元素左右两边高度比自己小的索引，该方法需要维护一个单调栈，剔除比自己大的元素，从而方便查找比自己小的值\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len), right(len);        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            left[i] = stk.empty() ? -1 : stk.top();            stk.push(i);        &#125;        stk = std::stack&lt;int&gt;();        for (int i = len - 1; i &gt;= 0; --i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            right[i] = stk.empty() ? len : stk.top();            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n2. 单调栈+常数优化\n上个方法使用了两个循环，考虑第一个循环是否发现栈顶值被弹出说明它此时已经找到了比它小的右边界，但此时需要对存储右边界的数组的初始值进行限制\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len, -1), right(len, len);\t\t// 从前到后只能正确处理左边界，右边界需要限定        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])\t\t// 考虑递增的数组，此时无法找到元素的右边界            &#123;                right[stk.top()] = i;                stk.pop();            &#125;            left[i] = stk.empty() ? -1 : stk.top();\t\t// 只能处理左边界            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.2)","url":"/posts/ede30f/","content":"一：买卖股票的最佳时机\n\n1. 暴力\n不写\n2. 一次遍历\n记录最低值和利润最高值\nclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int maxP = 0;           // 后面的最大利润        int minP = 1e9;         // 之前的最低值        for (auto price : prices)        &#123;            maxP = max(maxP, price - minP);            minP = min(minP, price);        &#125;        return maxP;    &#125;&#125;;\nclass Solution &#123;    public int maxProfit(int[] prices) &#123;        int maxP = 0;                   int minP = Integer.MAX_VALUE;                 for (int i =  0; i &lt; prices.length; ++i)        &#123;            int price = prices[i];            maxP = Math.max(maxP, price - minP);            minP = Math.min(minP, price);        &#125;        return maxP;    &#125;&#125;\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        maxP = 0                   minP = 1e9                 for price in prices:            maxP = max(maxP, price - minP)            minP = min(minP, price)        return maxP\n\n二：爬楼梯\n\n1. 动态规划\nf(x)=f(x−1)+f(x−2)f(x)=f(x−1)+f(x−2)\nf(x)=f(x−1)+f(x−2)\n爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和，f(0)=1f(0)=1f(0)=1，f(1)=1f(1)=1f(1)=1，对空间的优化使用滚动数组\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;\t\t// 赋值顺序不能反            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sPre, pre, cur = 0, 0, 1        # 赋值        for _ in range(n):      # 遍历，_不使用            sPre = pre            pre = cur            cur = sPre + pre        return cur\n\n2. 矩阵快速幂\n[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix} = \\begin{bmatrix} f(n)+f(n-1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix}\n[11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]\n[f(n+1)f(n)]=[1110]n[f(1)f(0)]\\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n} \\begin{bmatrix} f(1) \\\\ f(0) \\end{bmatrix}\n[f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]\nM=[1110]M = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\nM=[11​10​]\n常规计算M的n次方时间复杂度同上，这里使用快速幂\n**快速幂是一种用于在 O(log⁡n)O(\\log n)O(logn) 时间内计算 ana^nan 的高效算法。它利用了指数的二进制表示来减少乘法运算的次数，通常用于解决指数非常大时可能导致超时的问题。\n基本思想\n传统方法计算 ana^nan 需要进行 n−1n-1n−1 次乘法（即 a×a×⋯×aa \\times a \\times \\dots \\times aa×a×⋯×a）。快速幂则利用以下数学性质：\n\n如果 nnn 是偶数，an=an/2×an/2a^n = a^{n/2} \\times a^{n/2}an=an/2×an/2。\n如果 nnn 是奇数，an=a(n−1)/2×a(n−1)/2×aa^n = a^{(n-1)/2} \\times a^{(n-1)/2} \\times aan=a(n−1)/2×a(n−1)/2×a。\n\n这个思想的核心是将指数 nnn 不断折半。通过将 nnn 转换为二进制形式，我们可以将 ana^nan 的计算分解为一系列乘法和平方操作。例如，要计算 a13a^{13}a13，因为 131313 的二进制是 110111011101，即 13=8+4+113 = 8 + 4 + 113=8+4+1，所以：\na13=a8+4+1=a8×a4×a1a^{13} = a^{8+4+1} = a^8 \\times a^4 \\times a^1a13=a8+4+1=a8×a4×a1\n我们只需要计算 a1,a2,a4,a8a^1, a^2, a^4, a^8a1,a2,a4,a8（通过不断平方得到），然后将这些项相乘即可。这比直接进行 12 次乘法要快得多。\n算法步骤\n\n初始化结果 res = 1。\n将底数 base 设为 aaa。\n当指数 n&gt;0n &gt; 0n&gt;0 时循环：\n\n如果 nnn 的二进制最后一位是 1（即 nnn 为奇数），将 res 乘以 base。\n将 base 自身相乘（base = base * base）。\n将 nnn 右移一位（n = n &gt;&gt; 1），相当于 n=n/2n = n / 2n=n/2。\n\n\n返回 res。\n\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;vector&lt;long long&gt;&gt; init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        vector&lt;vector&lt;long long&gt;&gt; result = matrixPow(init, n);        return result[0][0];    &#125;    vector&lt;vector&lt;long long&gt;&gt; multiplication(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b)      // 二阶矩阵乘法    &#123;         vector&lt;vector&lt;long long&gt;&gt; c(2, vector&lt;long long&gt;(2));        for (int i = 0; i &lt; a.size(); ++i)        &#123;            for (int j = 0; j &lt; b[0].size(); ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    vector&lt;vector&lt;long long&gt;&gt; matrixPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int n)    &#123;        vector&lt;vector&lt;long long&gt;&gt; unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int[][] init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        // 使用int[][]或long        int[][] result = matrixPow(init, n);        return result[0][0];    &#125;    public int[][] multiplication(int[][] a, int[][] b)      // 二阶矩阵乘法    &#123;         int[][] c = new int[2][2];         // 基本数据类型        for (int i = 0; i &lt; a.length; ++i)        &#123;            for (int j = 0; j &lt; b[0].length; ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    public int[][] matrixPow(int[][] a, int n)    &#123;        int[][] unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        init = [[1, 1], [1, 0]]                result = self._matrixPow(init, n)        return result[0][0]    def multiplication(self, a, b):            c = [[1, 1], [1, 0]]              for i in range(2):            for j in range(2):                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]        return c    def _matrixPow(self, a, n):        unit = [[1, 0], [0, 1]]          while n &gt; 0:            if ((n &amp; 1) == 1): unit = self.multiplication(unit, a)            a = self.multiplication(a, a)            n &gt;&gt;= 1        return unit\n\n3. 通项公式\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        double sqrt5 = sqrt(5);        return static_cast&lt;int&gt;(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        double sqrt5 = Math.sqrt(5);        return (int)(Math.round((Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sqrt5 = sqrt(5)        return (int)(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5))\n\n三：杨辉三角\n\n1. 数学分析\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; result(numRows);        for (int i= 0; i &lt; numRows; ++i)        &#123;            result[i].resize(i + 1);            result[i][0] = result[i][i] = 1;            for (int j = 1; j &lt; i; ++j)            &#123;                result[i][j] = result[i - 1][j] + result[i - 1][j - 1];            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        for (int i= 0; i &lt; numRows; ++i)        &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            for (int j = 0; j &lt;= i; ++j)            &#123;                if (j == 0 || j == i) row.add(1);                else row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));            &#125;            result.add(row);        &#125;        return result;    &#125;&#125;\nclass Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        result = []        for i in range(numRows):            row = []            for j in range(0, i + 1):       # 0-i                if j == 0 or j == i: row.append(1)                else: row.append(result[i - 1][j] + result[i - 1][j - 1])            result.append(row)        return result\n\n四：只出现一次的数字\n\n1. 位运算\n题目要求使用空间复杂度为常量，因此常规解法不可用。这里采用异或，性质如下\n\nclass Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result = 0;        for (auto num : nums)            result ^=num;        return result;    &#125;&#125;;\nclass Solution &#123;    public int singleNumber(int[] nums) &#123;        int result = 0;        for (int num : nums)        // 没有auto            result ^=num;        return result;    &#125;&#125;\nclass Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        result = 0        for num in nums:                   result ^=num        return result\t\t# return reduce(lambda x, y: x ^ y, nums) 使用lambda，reduce从可迭代对象中取出第一个和第二个元素，用指定的函数进行计算，将计算结果与第三个元素再次进行计算，直到所有元素处理完毕\n\n五：多数元素\n\n1. 哈希表\n数组的值作为键，出现的次数作为值\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; hashMap;        int count = 0, numberous = 0;        for (auto num : nums)        &#123;            ++hashMap[num];            if (hashMap[num] &gt; count)\t\t// 通过该方式无需再次遍历哈希表            &#123;                count = hashMap[num];                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        int count = 0, numberous = 0;        for (int num : nums)        &#123;            if (hashMap.containsKey(num)) hashMap.put(num, hashMap.get(num) + 1);            else hashMap.put(num, 1);                        if (hashMap.get(num) &gt; count)            &#123;                count = hashMap.get(num) ;                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)\t\t# 统计每个元素的个数，保存为字典        return max(counts.keys(), key = counts.get)\t\t\t# 根据键取出对应的值的最大值\n\n2. 排序\n由于多数总是超过元素总和的二分之一，那么排序后中间的元素一定是多数（奇偶均可）\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)        return max(counts.keys(), key = counts.get)\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Arrays.sort(nums);      // 使用Arrays        return nums[nums.length / 2];    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // 2]\n\n3. 随机化\n随机挑选一个元素作为多数，然后统计\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        while (true)        &#123;            int count = 0;            int right = nums[rand() % nums.size()];\t\t// 也可以假设第一个为多数，依次尝试，比随机时间稍低，因为不会重复            for (auto num : nums)                if (num == right) ++count;            if (count &gt; nums.size() / 2) return right;        &#125;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Random rand = new Random();        while (true)        &#123;            int right = nums[rand.nextInt(nums.length)];            int count = 0;            for (int num : nums)                if (num == right) ++count;            if (count &gt; nums.length / 2) return right;        &#125;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        while True:            right = random.choice(nums)            count = 0            for num in nums:\t\t# 或if sum(1 for elem in nums if elem == candidate) &gt; majority_count:                if num == right: count += 1            if count &gt; len(nums) // 2: return right\n\n4. 分治\n将数据分为两组，多数一定会存在其中一组\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    int recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);\t\t// 两者相等可以直接返回了leftNum == rightNum        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(vector&lt;int&gt;&amp; nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    public int recursion(int[] nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(int[] nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1)    def recursion(self, nums, left, right):        if (left == right): return nums[left]        mid = ((right - left) // 2) + left        leftNum = self.recursion(nums, left, mid)        rightNum = self.recursion(nums, mid + 1, right)        if (self.countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2): return leftNum        if (self.countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2): return rightNum        return -1    def countNum(self, nums, target, lo, hi):        count = 0        for num in nums:            if (num == target):                count +=1        return count    # 官方写法class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        def majority_elem在·ent_rec(lo, hi) -&gt; int:            if lo == hi:                return nums[lo]                        mid = (hi - lo) // 2 + lo            left = majority_element_rec(lo, mid)            right = majority_element_rec(mid + 1, hi)            if left == right:                return left            left_count = sum(1 for i in range(lo, hi + 1) if nums[i] == left)            right_count = sum(1 for i in range(lo, hi + 1) if nums[i] == right)            return left if left_count &gt; right_count else right        return majority_element_rec(0, len(nums) - 1)\n\n5. Boyer-Moore 投票算法\n\n利用多数大于二分之一的性质，所有元素加减之后一定大于零，最后一个零出现的位置意味着之后的第一个元素一定是多数，因为如果不是多数，后面还会出现零\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int right = -1;    int count = 0;    for (auto num : nums)    &#123;        if (count == 0) right = num;        if (num == right) ++count;        else --count;    &#125;    return right;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int right = -1;        int count = 0;        for (int num : nums)        &#123;            if (count == 0) right = num;            if (num == right) ++count;            else --count;        &#125;        return right;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        right = -1        count = 0        for num in nums:            if (count == 0): right = num            if (num == right): count += 1            else: count -= 1        return right\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.20)","url":"/posts/9b0f2e8b/","content":"一：寻找两个正序数组的中位数\n\n1. 二分查找\n寻找两个数组的中位数即是寻找第 k 小的数，那么对于每一个数组求k / 2 - 1，小的一个元素的左边值应当被排除，更新K值和索引\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        int total = m + n;        if (total &amp; 1) return GetKvalue(nums1, nums2, (total + 1) / 2);        else return ((GetKvalue(nums1, nums2, total / 2) + GetKvalue(nums1, nums2, total / 2 + 1)) / 2.0);    &#125;    int GetKvalue(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)    &#123;        int m = nums1.size();        int n = nums2.size();        int index1 = 0;        int index2 = 0;        while (true)        &#123;            if (index1 == m) return nums2[index2 + k - 1];            if (index2 == n) return nums1[index1 + k - 1];            if (k == 1) return min(nums1[index1], nums2[index2]);            int newIndex1 = min(index1 + k / 2 - 1, m - 1);            int newIndex2 = min(index2 + k / 2 - 1, n - 1);            int pre1 = nums1[newIndex1];            int pre2 = nums2[newIndex2];            if (pre1 &lt;= pre2)            &#123;                k = k - (newIndex1 - index1 + 1);                index1 = newIndex1 + 1;            &#125; else            &#123;                k = k - (newIndex2 - index2 + 1);                index2 = newIndex2 + 1;            &#125;        &#125;    &#125;&#125;;\n\n2. 划分数组\n这个题有点难，将两个数组进行划分，通常左边的最大值如果小于右边的最小值，那么中位数即可判断\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        if (m &gt; n) return findMedianSortedArrays(nums2, nums1);     // 保证第一个数组小        int left = 0, right = m;        // 二分范围        int median1 = 0;        int median2 = 0;        while (left &lt;= right)        &#123;            int i = (left + right) &gt;&gt; 1;        // 第一个数组的中间值            int j = ((m + n + 1) &gt;&gt; 1) - i;       // 第二个数组的中间值            int i_1 = i == 0 ? INT_MIN : nums1[i - 1];            int iNew = i == m ? INT_MAX : nums1[i];            int j_1 = j == 0 ? INT_MIN : nums2[j - 1];            int jNew = j == n ? INT_MAX : nums2[j];            if (i_1 &lt;= jNew)            &#123;                median1 = max(i_1, j_1);                median2 = min(iNew, jNew);                left = i + 1;            &#125; else                right = i - 1;        &#125;        return (m + n) &amp; 1 ? median1 : (median1 + median2) / 2.0;    &#125;&#125;;\n\n二：N 皇后\n\n1. 基于集合的回溯\n使用回溯需要三步，选择、递归、撤销选择，在选择时需要避免行、列以及两个斜线不能冲突\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    unordered_set&lt;int&gt; col;    unordered_set&lt;int&gt; diaR;    unordered_set&lt;int&gt; diaL;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, board);        return result;    &#125;    void recursion(int row, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);     // 全部填充            return;        &#125;         for (int i = 0; i &lt; len; ++i)       // 对当前行遍历可行的列        &#123;            if (col.count(i) || diaR.count(row - i) || diaL.count(row + i)) continue;       // 冲突则下一列            board[row][i] = &#x27;Q&#x27;;        // 选择            col.insert(i);            diaR.insert(row - i);            diaL.insert(row + i);            recursion(row + 1, board);      // 递归            board[row][i] = &#x27;.&#x27;;        // 撤销            col.erase(i);            diaR.erase(row - i);            diaL.erase(row + i);        &#125;    &#125;&#125;;\n\n2. 基于位运算的回溯\n这里使用二进制来表示每一列和斜边的位置情况\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, 0, 0, 0, board);        return result;    &#125;    void recursion(int row, int col, int digR, int digL, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);                return;        &#125;         int avail = ((1 &lt;&lt; len) - 1) &amp; (~(col | digR | digL));\t\t// 可用位置        while (avail != 0)        &#123;            int p = avail &amp; (-avail);\t\t// 最低位的可用位置            int colT = 0;            int temp = p;            while ((temp &gt;&gt;= 1) &gt; 0) ++colT;\t\t// 对应列            board[row][colT] = &#x27;Q&#x27;;            int next_col = col | p;\t\t// 新的二进制            int next_digR = (digR | p) &gt;&gt; 1;            int next_digL = (digL | p) &lt;&lt; 1;            recursion(row + 1, next_col, next_digR, next_digL, board);            board[row][colT] = &#x27;.&#x27;;            avail &amp;= (~p);\t\t// 取消可用位置        &#125;    &#125;&#125;;\n\n三：二叉树中的最大路径和\n\n1. 递归\n这里主要需要使用一个常数来记录最大值，因为不能回溯，而返回值不能叠加\nclass Solution &#123;public:    int result = INT_MIN;    int maxPathSum(TreeNode* root) &#123;        recursion(root);        return result;    &#125;    int recursion(TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftVal = max(recursion(node-&gt;left), 0);        int rightVal = max(recursion(node-&gt;right), 0);        result = max(result, node-&gt;val + leftVal + rightVal);        return node-&gt;val + max(leftVal, rightVal);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.21)","url":"/posts/82141fca/","content":"一：合并 K 个升序链表\n\n1. 顺序合并\n按照链表合并的逻辑将数组中的链表逐个合并\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        int len = lists.size();        ListNode* retuslt = nullptr;        for (int i = 0; i &lt; len; ++i) retuslt = Merge(retuslt, lists[i]);        return retuslt;    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n2. 分治合并\n将数组中的链表两两配对，依次递归\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        return recursion(lists, 0, lists.size() - 1);    &#125;    ListNode* recursion(vector&lt;ListNode*&gt;&amp; lists, int left, int right)    &#123;        if (left == right) return lists[left];        if (left &gt; right) return nullptr;        int mid = (left + right) &gt;&gt; 1;        return Merge(recursion(lists, left, mid), recursion(lists, mid + 1, right));    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n3. 使用优先队列合并\n根据节点的值将其放入优先队列中，依次取出队列顶端的值，可得到最小的节点\nclass Solution &#123;public:    struct Node    &#123;        int val;        ListNode* p;        bool operator &lt; (const Node &amp;com) const        &#123;            return val &gt; com.val;        &#125;    &#125;;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode head, *cur = &amp;head;        priority_queue&lt;Node&gt; pq;        for (auto &amp;list : lists)             if (list) pq.push(&#123;list-&gt;val, list&#125;);        while (!pq.empty())        &#123;            auto temp = pq.top();            pq.pop();            cur-&gt;next = temp.p;            cur = cur-&gt;next;            if (temp.p-&gt;next) pq.push(&#123;temp.p-&gt;next-&gt;val, temp.p-&gt;next&#125;);        &#125;        return head.next;    &#125;&#125;;\n\n二：K 个一组翻转链表\n\n1. 模拟\n翻转链表的实现很容易，但反转之后需要它的前置和后置节点，以便更新在链表中的结构，所以需要提前保留需要交换的头和尾节点\nclass Solution &#123;public:    ListNode* reverseKGroup(ListNode* head, int k) &#123;        ListNode* result = new ListNode(0);        result-&gt;next = head;        ListNode* pre = result;        while (head)        &#123;            ListNode* tail = pre;            for (int i = 0; i &lt; k; ++i)            &#123;                tail = tail-&gt;next;                if (tail == nullptr) return result-&gt;next;            &#125;            ListNode* next = tail-&gt;next;            tie(head, tail) = Reverse(head, tail);            pre-&gt;next = head;            tail-&gt;next = next;            head = tail-&gt;next;            pre = tail;        &#125;        return result-&gt;next;    &#125;    pair&lt;ListNode*, ListNode*&gt; Reverse(ListNode* head, ListNode* tail)    &#123;        ListNode* pre = nullptr;        ListNode* cur = head;        while (pre != tail)        &#123;            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return &#123;tail, head&#125;;    &#125;&#125;;\n\n三：缺失的第一个正数\n\n1. 哈希表\n想要记录没有出现的数据，通常使用哈希表，这里无法使用额外空间，我们可以对数组进行原地操作\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (auto&amp; num: nums)            if (num &lt;= 0) num = INT_MAX;        for (auto&amp; num: nums)        &#123;            int temp = abs(num);            if (temp &lt;= len) nums[temp - 1] = -abs(nums[temp - 1]);     // 这里可能修改后面的数据，所以取负值        &#125;        for (int i = 0; i &lt; len; ++i)            if (nums[i] &gt; 0) return i + 1;        return len + 1;    &#125;&#125;;\n\n2. 置换\n我们可以尝试把元素的值与数组索引对应\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - 1])                 swap(nums[i], nums[nums[i] - 1]);        for (int i = 0; i &lt; len; ++i)            if (nums[i] != i + 1) return i + 1;        return len + 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.22)","url":"/posts/a9394c09/","content":"一：接雨水\n\n1. 动态规划\n使用两个数组维护其左右最大高度，其当前位置的雨水即为左右高度的最小值减去当前值\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        vector&lt;int&gt; LeftH(len);        vector&lt;int&gt; rightH(len);        LeftH[0] = height[0];        rightH[len - 1] = height[len - 1];        for (int i = 1; i &lt; len; ++i)            LeftH[i] = max(LeftH[i - 1], height[i]);        for (int i = len - 2; i &gt;= 0; --i)            rightH[i] = max(rightH[i + 1], height[i]);        for (int i = 0; i &lt; len; ++i)            result += min(LeftH[i], rightH[i]) - height[i];        return result;    &#125;&#125;;\n\n2. 单调栈\n按照递减的顺序将数据放入栈中，如果有数据大于栈顶，则计算其包含的雨水量\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        stack&lt;int&gt; stk;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()])            &#123;                int cur = stk.top();                stk.pop();                if (stk.empty()) break;                int left = stk.top();                int width = i - left - 1;                int hei = min(height[left], height[i]) - height[cur];                result += width * hei;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n3. 双指针\n使用两个指针维护左右的最大值，哪个指针的值小便进行移动\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        int left = 0, right = len - 1;        int leftM = 0, rightM = 0;        while (left &lt; right)        &#123;            leftM = max(leftM, height[left]);            rightM = max(rightM, height[right]);            if (leftM &lt; rightM)            &#123;                result += leftM - height[left];                ++left;            &#125; else            &#123;                result += rightM - height[right];                --right;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：滑动窗口最大值\n\n1. 优先队列\n维护一个当前窗口的优先队列，每次从里面选中一个最大值作为当前窗口的最大值，然后移动窗口并剔除超出边界的队顶元素\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;        for (int i = 0; i &lt; k; ++i) pq.push(&#123;nums[i], i&#125;);        result.emplace_back(pq.top().first);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            pq.push(&#123;nums[i], i&#125;);            while (pq.top().second &lt;= i - k) pq.pop();            result.emplace_back(pq.top().first);        &#125;        return result;    &#125;&#125;;\n\n2. 单调队列\n将优先队列改为双端队列，同时维护有序状态，可将原来操作插入的log⁡(n)\\log(n)log(n)复杂度降低为(n)(n)(n)\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        deque&lt;int&gt; dq;        for (int i = 0; i &lt; k; ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);        &#125;        result.emplace_back(nums[dq.front()]);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);            while (dq.front() &lt;= i - k) dq.pop_front();            result.emplace_back(nums[dq.front()]);        &#125;        return result;    &#125;&#125;;\n\n3. 分块+预处理\n首先将元素分块，并计算出当前元素在该块的前缀最大值和后缀最大值，随后遍历元素取其中的最大值即可\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        vector&lt;int&gt; result;        vector&lt;int&gt; pre(len);        vector&lt;int&gt; suf(len);        for (int i = 0; i &lt; len; ++i)            if (i % k == 0)                pre[i] = nums[i];            else                pre[i] = max(pre[i - 1], nums[i]);        for (int i = len - 1; i &gt;= 0; --i)            if (i == len - 1 || (i + 1) % k == 0)                suf[i] = nums[i];            else                suf[i] = max(suf[i + 1], nums[i]);        for (int i = 0; i &lt;= len - k; ++i)            result.emplace_back(max(pre[i + k - 1], suf[i]));        return result;    &#125;&#125;;\n\n三：最小覆盖子串\n\n1. 滑动窗口\n使用一个窗口来表示当前子串的范围，并在包含所有元素之后尝试缩短长度\nclass Solution &#123;public:    unordered_map &lt;char, int&gt; ori, cnt;    string minWindow(string s, string t) &#123;        for (const auto &amp;c: t)            ++ori[c];        int l = 0, r = -1;        int len = INT_MAX, ansL = -1;        while (r &lt; int(s.size())) &#123;            if (ori.find(s[++r]) != ori.end())                 ++cnt[s[r]];            while (check() &amp;&amp; l &lt;= r) &#123;                if (r - l + 1 &lt; len) &#123;                    len = r - l + 1;                    ansL = l; // 记录最短子串的起始位置                &#125;                if (ori.find(s[l]) != ori.end())                     --cnt[s[l]];                ++l;            &#125;        &#125;        return ansL == -1 ? string() : s.substr(ansL, len);    &#125;    bool check()     &#123;        for (const auto &amp;p: ori)             if (cnt[p.first] &lt; p.second)                 return false;        return true;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.3)","url":"/posts/19f6d24e/","content":"一：字母异位词分组\n\n1. 排序\n字母异位词排序之后相同，可使用哈希表\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str : strs)        &#123;            string key = str;            sort(key.begin(), key.end());            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)        &#123;            result.emplace_back(row.second);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            char[] arrayStr = str.toCharArray();            Arrays.sort(arrayStr);            String key = new String(arrayStr);            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            // getOrDefault 它的作用是：如果 map 中存在 key，则返回 key 对应的值；            // 如果不存在，则返回 new ArrayList&lt;String&gt;() 并添加到 map 中            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            # sorted(st) 返回一个按字母排序的列表 [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;t&#x27;]            # &quot;&quot;.join(...) 将列表中的字符连接成字符串 &quot;aet&quot;            key = &quot;&quot;.join(sorted(str))            hashMap[key].append(str)        return list(hashMap.values())\n\n2. 计数\n跟排序道理相同，只不过增加了字符的次数\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str: strs) &#123;            array&lt;int, 26&gt; counts&#123;&#125;;            for (char ch : str)                 counts[ch - &#x27;a&#x27;] ++;            string key;            for (auto count : counts)                 key += to_string(count) + &quot;#&quot;;            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)            result.emplace_back(row.second);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            int[] counts = new int[26];            for (int i = 0; i &lt; str.length(); i++)                counts[str.charAt(i) - &#x27;a&#x27;]++;            StringBuffer sb = new StringBuffer();            for (int i = 0; i &lt; 26; i++)                if (counts[i] != 0)\t\t\t// 这里也可以使用python的方式，但是必须在字符之间添加分界符，原因是出现次数超过10的字母会导致键不唯一                &#123;                    sb.append((char)(&#x27;a&#x27; + i));                    sb.append(counts[i]);                &#125;            String key = sb.toString();            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            counts = [0] * 26            for ch in str:                counts[ord(ch) - ord(&quot;a&quot;)] += 1            hashMap[tuple(counts)].append(str)\t\t# 直接使用计数数组，注意这里保留了顺序，因为生成的是元组        return list(hashMap.values())\n\n二：最长连续序列\n\n1. 哈希表\n将数据放入哈希表，然后不断寻找它的下一位，时间大概为线性，但有些数据没必要再次寻找，如已经找过的数据\nclass Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; hashSet;        int maxCount = 0;        for (auto num : nums) hashSet.insert(num);        for (auto num : hashSet)        &#123;            if (!hashSet.count(num - 1))            &#123;                int count = 1;                  while (hashSet.count(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = max(maxCount, count);            &#125;        &#125;         return maxCount;                                       &#125;&#125;;\nclass Solution &#123;    public int longestConsecutive(int[] nums) &#123;        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        int maxCount = 0;        for (int num : nums) hashSet.add(num);        for (int num : hashSet)        &#123;            if (!hashSet.contains(num - 1))            &#123;                int count = 1;                  while (hashSet.contains(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = Math.max(maxCount, count);            &#125;        &#125;         return maxCount;        &#125;&#125;\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        hashSet = set(nums)        maxCount = 0        for num in hashSet:            if num - 1 not in hashSet:                count = 1                  while (num + 1) in hashSet:                    count += 1                    num += 1                maxCount = max(maxCount, count)        return maxCount   \n\n三：盛水最多的容器\n\n1. 双指针\n从两端开始，移动小的向中间靠近\nclass Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int left = 0, right = height.size() - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;;\nclass Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0, right = height.length - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = Math.min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = Math.max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, maxA = 0, 0        right = len(height) - 1        while left &lt; right:            curArea = min(height[left], height[right]) * (right - left)            if (height[left] &lt; height[right]): left += 1            else: right -= 1            maxA = max(maxA, curArea)        return maxA\n\n四：三数之和\n\n1. 排序 + 双指针\n首先对数组进行排序，外层循环从左往右，内层从右往左，题目要求三元组不重复意味着相同的值无需处理跳过即可\n当我们想要枚举数组中的两个元素时，如果发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N2)O(N^2)O(N2) 减少至 O(N)O(N)O(N)。为什么是 O(N)O(N)O(N) 呢？这是因为在枚举的过程中，每一步中，“左指针”会向右移动一个位置，而“右指针”会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)O(N)。均摊下来，每次也只向右移动一个位置，因此时间复杂度为 O(N)O(N)O(N)。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0) result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        int length = nums.length;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0)                &#123;                    List&lt;Integer&gt; row = new ArrayList&lt;&gt;();                    row.add(nums[i]);                    row.add(nums[j]);                    row.add(nums[k]);                    result.add(row);                &#125;            &#125;        &#125;        return result;    &#125;&#125;\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        length = len(nums)        result = list()        nums.sort()        for i in range(length):            if i &gt; 0 and nums[i] == nums[i - 1]: continue            k = length - 1            for j in range(i + 1, length):                if j &gt; i + 1 and nums[j] == nums[j - 1]: continue                while nums[i] + nums[j] + nums[k] &gt; 0 and j &lt; k: k -= 1                if j == k: break                if nums[i] + nums[j] + nums[k] == 0:                    result.append([nums[i], nums[j], nums[k]])        return result\n\n五：无重复字符的最长子串\n\n1. 滑动窗口\n通过哈希表维护窗口，两个指针指向字符串，若右指针元素不在哈希表则添加并右移，若包含则左指针右移并剔除当前指向元素\nclass Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        unordered_set&lt;char&gt; hashSet;        int right = 0;        int length = s.size();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.count(s[right]))            &#123;                hashSet.insert(s[right]);                ++right;            &#125;            hashSet.erase(s[i]);            result = max(result, right - i);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();        int right = 0;        int length = s.length();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.contains(s.charAt(right)))            &#123;                hashSet.add(s.charAt(right));                ++right;            &#125;            hashSet.remove(s.charAt(i));            result = Math.max(result, right - i);        &#125;        return result;    &#125;&#125;\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        hashSet = set()        right = 0        length = len(s)        result = 0        for i in range(length):            while (right &lt; length and s[right] not in hashSet):                hashSet.add(s[right])                right += 1            hashSet.remove(s[i])            result = max(result, right - i)        return result\n\n六：找到字符串中所有字母异位词\n\n1. 滑动窗口\np的长度固定，在s中寻找p可使用p的长度的作为窗口宽度，利用当前宽度两个字符串出现的次数即可作为判定\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; pCharCount(26);        vector&lt;int&gt; sCharCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p[i] - &#x27;a&#x27;];            ++sCharCount[s[i] - &#x27;a&#x27;];        &#125;        if (sCharCount == pCharCount) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s[i] - &#x27;a&#x27;];            ++sCharCount[s[i + pL] - &#x27;a&#x27;];            if (sCharCount == pCharCount) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] pCharCount = new int[26];        int[] sCharCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        if (Arrays.equals(pCharCount, sCharCount)) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (Arrays.equals(pCharCount, sCharCount)) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        pCharCount = [0] * 26        sCharCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            pCharCount[ord(p[i]) - 97] += 1            sCharCount[ord(s[i]) - 97] += 1        if (sCharCount == pCharCount): result.append(0)        for i in range(sL - pL):               sCharCount[ord(s[i]) - 97] -= 1            sCharCount[ord(s[i + pL]) - 97] += 1            if (sCharCount == pCharCount): result.append(i + 1)        return result\n\n2. 优化\n不比较两个字符串在窗口的位置，直接比较差值\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; charCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p[i] - &#x27;a&#x27;];            ++charCount[s[i] - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s[i] - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s[i] - &#x27;a&#x27;] == 0) ++dif;            --charCount[s[i] - &#x27;a&#x27;];            if (charCount[s[i + pL] - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s[i + pL] - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s[i + pL] - &#x27;a&#x27;];            if (dif == 0) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] charCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p.charAt(i) - &#x27;a&#x27;];            ++charCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s.charAt(i) - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s.charAt(i) - &#x27;a&#x27;] == 0) ++dif;            --charCount[s.charAt(i) - &#x27;a&#x27;];            if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (dif == 0) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        charCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            charCount[ord(p[i]) - 97] -= 1            charCount[ord(s[i]) - 97] += 1        differ = [c != 0 for c in charCount].count(True)        if (differ == 0): result.append(0)        for i in range(sL - pL):               if charCount[ord(s[i]) - 97] == 1: differ -= 1            elif charCount[ord(s[i]) - 97] == 0: differ += 1            charCount[ord(s[i]) - 97] -= 1            if charCount[ord(s[i + pL]) - 97] == -1: differ -= 1            elif charCount[ord(s[i + pL]) - 97] == 0: differ += 1            charCount[ord(s[i + pL]) - 97] += 1            if (differ == 0): result.append(i + 1)        return result\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.4)","url":"/posts/56b74489/","content":"一：和为K的子数组\n\n1. 枚举\n其实就是暴力，两层循环，python可能会超时\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        int length = nums.length;        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        length = len(nums)        count = 0        for i in range(length):            sum = 0            for j in range(i, length):                sum += nums[j]                if (sum == k): count += 1        return count\n\n2. 哈希表\n遍历时记录所有和并放入哈希表，寻找子串时只寻找当前值与目标值的差，相同值通过哈希表的值来记录\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; hashMap;        hashMap[0] = 1;         // 相同值需要        int sum = 0;        int count = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            if (hashMap.count(sum - k)) count += hashMap[sum - k];            ++hashMap[sum];        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(0, 1);        int sum = 0;        int count = 0;        for (int num : nums)        &#123;            sum += num;            if (hashMap.containsKey(sum - k)) count += hashMap.get(sum - k);            hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        hashMap = &#123;0 : 1&#125;        sum = 0        count = 0        for num in nums:            sum += num            if (sum - k in hashMap): count += hashMap[sum - k]            hashMap[sum] = hashMap.get(sum, 0) + 1        return count\n\n二：最大子数组和\n\n1. 动态规划\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int next = 0;        int result = nums[0];        for (auto&amp; num : nums)        &#123;            next = max(next + num, num);            // 局部最优            result = max(result, next);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int next = 0;        int result = nums[0];        for (int num : nums)        &#123;            next = Math.max(next + num, num);            // 局部最优            result = Math.max(result, next);        &#125;        return result;    &#125;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        next = 0        result = nums[0]        for num in nums:            next = max(next + num, num)                      result = max(result, next)        return result\n\n2. 分治\nclass Solution &#123;public:    struct Status &#123;        int left, right, media, sum;    &#125;;    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1).media;    &#125;    Status recursion(vector&lt;int&gt; &amp;a, int l, int r) &#123;        if (l == r) &#123;            return (Status) &#123;a[l], a[l], a[l], a[l]&#125;;        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;        Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = max(l.left, l.sum + r.left);        int rSum = max(r.right, r.sum + l.right);        int mSum = max(max(l.media, r.media), l.right + r.left);        return (Status) &#123;lSum, rSum, mSum, iSum&#125;;    &#125;;&#125;;\nclass Solution &#123;    public class Status &#123;        public int left, right, media, sum;        public Status(int lSum, int rSum, int mSum, int iSum) &#123;            this.left = lSum;            this.right = rSum;            this.media = mSum;            this.sum = iSum;        &#125;    &#125;    public int maxSubArray(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1).media;    &#125;    public Status recursion(int[] a, int l, int r) &#123;        if (l == r) &#123;            return new Status (a[l], a[l], a[l], a[l]);        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;    public Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = Math.max(l.left, l.sum + r.left);        int rSum = Math.max(r.right, r.sum + l.right);        int mSum = Math.max(Math.max(l.media, r.media), l.right + r.left);        return new Status (lSum, rSum, mSum, iSum);    &#125;;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1).media    def recursion(self, a, l, r):        if l == r:            val = a[l]            return (val, val, val, val)                m = (r + l) // 2        l_sub = self.recursion(a, l, m)        r_sub = self.recursion(a, m + 1, r)          return self.pushUp(l_sub, r_sub)    def pushUp(self, l, r):        l_left, l_right, l_media, l_sum = l        r_left, r_right, r_media, r_sum = r                i_sum = l_sum + r_sum        l_sum_new = max(l_left, l_sum + r_left)        r_sum_new = max(r_right, r_sum + l_right)        m_sum_new = max(max(l_media, r_media), l_right + r_left)                return (l_sum_new, r_sum_new, m_sum_new, i_sum)\n\n3. 前缀法\n参考第一题的第二中解法，时间和空间同动态规划方法\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int minV = 0, maxV = -1e9;        int sum = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            maxV = max(maxV, sum - minV);            minV = min(minV , sum);        &#125;        return maxV;    &#125;&#125;;\n三：合并区间\n\n1. 排序\n对首元素排序，然后判断每个区间的首尾大小即可\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(), intervals.end());        vector&lt;vector&lt;int&gt;&gt; reruslt;        for (int i = 0; i &lt; intervals.size(); ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.back()[1] &lt; left) reruslt.emplace_back(intervals[i]);            else reruslt.back()[1] = max(reruslt.back()[1], right);        &#125;         return reruslt;    &#125;&#125;;\nclass Solution &#123;    public int[][] merge(int[][] intervals) &#123;        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] interval1, int[] interval2) &#123;                return interval1[0] - interval2[0];            &#125;        &#125;);        List&lt;int[]&gt; reruslt = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; intervals.length; ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.get(reruslt.size() - 1)[1] &lt; left) reruslt.add(new int[]&#123;left, right&#125;);            else reruslt.get(reruslt.size() - 1)[1] = Math.max(reruslt.get(reruslt.size() - 1)[1], right);        &#125;         return reruslt.toArray(new int[reruslt.size()][]);    &#125;&#125;\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        result = []        for interval in intervals:            if not result or result[-1][1] &lt; interval[0]: result.append(interval)            else: result[-1][1] = max(result[-1][1], interval[1])        return result\n\n四：轮转数组\n\n1. 额外数组\n使用一个额外数组来存储移动后的元素\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; newNums(nums.size());        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            newNums[(i + k) % nums.size()] = nums[i];        &#125;        return nums.assign(newNums.begin(), newNums.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[] nums, int k) &#123;        int[] newNums = new int[nums.length];        for (int i = 0; i &lt; nums.length; ++i)        &#123;            newNums[(i + k) % nums.length] = nums[i];        &#125;        System.arraycopy(newNums, 0, nums, 0, nums.length);    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        newNums = [0] * len(nums)        for i in range(len(nums)):            newNums[(i + k) % len(nums)] = nums[i]        nums[:] = newNums\n\n2. 环状替换\n以环为单位在数组元素中跳动反转，跳转几次后会回到原点，使用临时值来作为其中一个交换对象，如果遍历交换，则需要多个值来存储交换对象，效率变低\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                swap(nums[cur], curV);            &#125; while(i != cur);        &#125;    &#125;&#125;;\nclass Solution &#123;    public int gcd(int x, int y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;    public void rotate(int[] nums, int k) &#123;        int length = nums.length;        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                int temp = nums[cur];                nums[cur] = curV;                curV = temp;            &#125; while(i != cur);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        length = len(nums)        k = k % length        step = math.gcd(k, length)               for i in range(step):            cur = i            curV = nums[i]            while True:                cur = (cur + k) % length                nums[cur], curV = curV, nums[cur]                if i == cur: break\n\n3. 数组反转\n先将数组反转，然后反转前k个值，最后反转剩余值就得到换位后的数组\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        k = k % nums.size();        reverse(nums, 0, nums.size() - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.size() - 1);    &#125;    void reverse(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j) swap(nums[i], nums[j]);    &#125;&#125;;\nclass Solution &#123;   public void rotate(int[] nums, int k) &#123;        k = k % nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    &#125;    public void reverse(int[] nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j)        &#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        k = k % len(nums)        self.reverse(nums, 0, len(nums) - 1)        self.reverse(nums, 0, k - 1)        self.reverse(nums, k, len(nums) - 1)    def reverse(self, nums, left, right):        while left &lt; right:            nums[left], nums[right] = nums[right], nums[left]            left += 1            right -= 1\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.5)","url":"/posts/4fac75c8/","content":"一：除自身以外数组的乘积\n\n1. 左右乘积列表\n用两个数组分别记录左右两端的乘积\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; left(length);        vector&lt;int&gt; right(length);        vector&lt;int&gt; result(length);        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] left = new int[length] ;        int[] right = new int[length] ;        int[] result = new int[length] ;        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        left = [0] * length        right = [0] * length        result = [0] * length        left[0] = 1        right[length -  1] = 1        for i in range(1, length):            left[i] = nums[i - 1] * left[i - 1]        for j in reversed(range(length - 1)):            right[j] = nums[j + 1] * right[j + 1]        for i in range(length):            result[i] = left[i] * right[i]        return result\n\n2. 空间复杂度O(1)O(1)O(1)的方法\n用结果数组先作为左乘积列表，然后使用临时变量记录每个右乘积并更新数组\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; result(length);        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] result = new int[length] ;        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        result = [0] * length        result[0] = 1        for i in range(1, length):            result[i] = nums[i - 1] * result[i - 1]        rightMul = 1        for j in reversed(range(length)):            result[j] = result[j] * rightMul            rightMul *= nums[j]        return result\n\n二：矩阵置零\n\n1. 使用标记数组\n通过两个数组来记录二维数组中某行或这某列是否包含零\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        vector&lt;int&gt; vRow(nRow);        vector&lt;int&gt; vCol(nCol);        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        int[] vRow = new int[nRow];        int[] vCol = new int[nCol];        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        vRow = [0] * nRow        vCol = [0] * nCol        for i in range(nRow):            for j in range(nCol):                if (matrix[i][j] == 0): vRow[i] = vCol[j] = 1        for i in range(nRow):            for j in range(nCol):                if (vRow[i] == 1 or vCol[j] == 1): matrix[i][j] = 0\n\n2. 使用两个标记变量\n使用第一行和第一列来记录其余位置的零，再使用两个标记变量来记录第一行和第一列的情况\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstRow = false;        bool firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstRow = false;        boolean firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        firstRow = False        firstCol = False        for i in range(nRow):            if (matrix[i][0] == 0): firstCol = True        for i in range(nCol):            if (matrix[0][i] == 0): firstRow = True        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0        if (firstCol == True):            for i in range(nRow):                matrix[i][0] = 0        if (firstRow == True):            for i in range(nCol):                matrix[0][i] = 0\n\n3. 使用一个标记变量\n用左上角的元素作为标记变量\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        flag = False        for i in range(nRow):            if (matrix[i][0] == 0): flag = True            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in reversed(range(nRow)):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0            if flag == True:                matrix[i][0] = 0\n\n三：螺旋矩阵\n\n1. 模拟\n定义一个旋转方向，当遇到边界和访问过的节点进行旋转（属于暴力）\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowCnt = matrix.size();        int colCnt = matrix[0].size();        enum Rule &#123;leftToright, upTodow, rightToleft, downToup&#125;;        Rule myRule = Rule::leftToright;        vector&lt;int&gt; results;        vector&lt;vector&lt;int&gt;&gt; visited(rowCnt, vector&lt;int&gt;(colCnt));        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            int nextRow = row, nextCol = col;            results.emplace_back(matrix[row][col]);            visited[row][col] = 1;            if (myRule == 0) nextCol = col + 1;            if (myRule == 1) nextRow = row + 1;            if (myRule == 2) nextCol = col - 1;            if (myRule == 3) nextRow = row - 1;            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                myRule = static_cast&lt;Rule&gt;((myRule + 1) % 4);            if (myRule == 0) ++col;            if (myRule == 1) ++row;            if (myRule == 2) --col;            if (myRule == 3) --row;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int rowCnt = matrix.length;        int colCnt = matrix[0].length;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int[][] visited = new int[rowCnt][colCnt];        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;        int directionIndex = 0;        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            results.add(matrix[row][col]);            visited[row][col] = 1;            int nextRow = row + directions[directionIndex][0];            int nextCol = col + directions[directionIndex][1];            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                directionIndex = (directionIndex + 1) % 4;            row += directions[directionIndex][0];            col += directions[directionIndex][1];        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        rowCnt, colCnt = len(matrix), len(matrix[0])        results = []        visited = [[0] * colCnt for _ in range(rowCnt)]        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]        direction_index = 0          row, col = 0, 0        for _ in range(rowCnt * colCnt):            results.append(matrix[row][col])            visited[row][col] = True            next_row = row + directions[direction_index][0]            next_col = col + directions[direction_index][1]            if not (0 &lt;= next_row &lt; rowCnt and 0 &lt;= next_col &lt; colCnt and not visited[next_row][next_col]):                direction_index = (direction_index + 1) % 4            row += directions[direction_index][0]            col += directions[direction_index][1]        return results\n\n2. 按层模拟\n每一圈相当于将最外围的数据输出，需要四个循环将四个边界输出，然后通过大的循环来遍历每一圈，注意圈的截止条件\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;;        int bottom = matrix.size() - 1;        int right = matrix[0].size() - 1;        vector&lt;int&gt; results;        int left = 0, top = 0;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.emplace_back(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.emplace_back(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom) \t\t\t// 到这里可能剩余不足围成圈，如1*n或n*1，此时前两个循环已经足够处理，如果不加以限制，那么在n大于1的情况下，下述的循环将会有一个进入导致最后结尾出现多余的数据            &#123;                for (int i = right - 1; i &gt; left; --i) results.emplace_back(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.emplace_back(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int bottom = matrix.length - 1;        int right = matrix[0].length - 1;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int left = 0, top = 0;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return results;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.add(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.add(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom)             &#123;                for (int i = right - 1; i &gt; left; --i) results.add(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.add(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        bottom, right = len(matrix) - 1, len(matrix[0]) - 1        results = list()         left, top = 0, 0        while left &lt;= right and top &lt;= bottom:            for i in range(left, right + 1): results.append(matrix[top][i])            for i in range(top + 1, bottom + 1): results.append(matrix[i][right])            if left &lt; right and top &lt; bottom:                for i in range(right - 1, left, -1): results.append(matrix[bottom][i])                for i in range(bottom, top, -1): results.append(matrix[i][left])            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1        return results\n\n四：旋转图像\n\n1. 辅助数组\n将旋转后的元素放入新的数组\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        auto result = matrix;        int m = matrix.size();        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        matrix.assign(result.begin(), result.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        int[][] result = new int[m][m];        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        for (int i = 0; i &lt; m; i++) &#123;            System.arraycopy(result[i], 0, matrix[i], 0, m);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        n = len(matrix)        result = [[0] * n for _ in range(n)]        for i in range(n):            for j in range(n):                result[j][n - 1 - i] = matrix[i][j]        matrix[:] = result\n\n2. 原地旋转\n参考移动数组的解决方案，这里旋转四次会回到原地，一圈会移动四个数据，那么也就是只需要旋转约四分之一的元素，n的奇的情况下，中间不需要管\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range((m + 1) // 2):                temp = matrix[i][j]                matrix[i][j] = matrix[m - 1 - j][i]                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1]                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1]                matrix[j][m - 1 - i] = temp\n\n3. 翻转\n先水平后主对角线，也可以先竖直\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)                swap(matrix[i][j], matrix[m - i - 1][j]);        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)                swap(matrix[i][j], matrix[j][i]);    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - i - 1][j];                matrix[m - i - 1][j] = temp;            &#125;        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range(m):                matrix[i][j], matrix[m - i - 1][j] = matrix[m - i - 1][j], matrix[i][j]        for i in range(m):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n五：搜索二维矩阵\n\n1. 暴力\n不写\n\n2. 二分\n由于数组左右有序，对每一行使用二分从中间查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        for (auto&amp; row : matrix)        &#123;            auto it = lower_bound(row.begin(), row.end(), target);\t\t\t// 返回不小于目标值的第一个元素的迭代器            if (it != row.end() &amp;&amp; *it == target) return true;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        for (int[] row : matrix)        &#123;            int index = searchInsert(row, target);            if (index != -1) return true;        &#125;        return false;    &#125;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target == nums[mid]) return mid;            else if (target &lt; nums[mid])                     right = mid - 1;            else                left = mid + 1;        &#125;        return -1;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        for row in matrix:            it = bisect.bisect_left(row, target)\t\t\t            if it &lt; len(row) and row[it] == target: return True        return False\n\n3. Z 字形查找\n充分运用题目要求，第二种方法只有了一个条件，但数据从上往下也是递增，从右上角开始，横竖作为边界，也就是说如果某个位置的值小于目标值，行数可以加一，如果大于目标值，则列数应该减一\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m = matrix.size();        int n = matrix[0].size();        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length;        int n = matrix[0].length;        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        m = len(matrix)        n = len(matrix[0])        i = 0        j = n - 1        while i &lt; m and j &gt;= 0:            if (matrix[i][j] == target): return True            elif (matrix[i][j] &gt; target): j -= 1            elif(matrix[i][j] &lt; target): i += 1        return False\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.6)","url":"/posts/6481260b/","content":"一：环形链表2️⃣\n\n1. 哈希表\n这道题的思路和环形链表的方法一相同\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return head;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return head;\t\t\t            hashTable.add(head);            head = head.next;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        hashTable = set()        while head:            if head in hashTable:                return head            hashTable.add(head)            head = head.next        return None\n\n2. 快慢指针\n这道题的思路和环形链表的方法二相同，如果有环相遇点一定在环中，且快指针比慢指针多n圈，进入环之后快指针比慢指针多一圈\n\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return nullptr;        ListNode* fastNode = head;               ListNode* slowNode = head;        while (fastNode != nullptr)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return nullptr;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;            if (fastNode == slowNode)            &#123;                ListNode* cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur-&gt;next;                    slowNode = slowNode-&gt;next;                &#125;                return cur;            &#125;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        if (head == null || head.next == null) return null;        ListNode fastNode = head;               ListNode slowNode = head;        while (fastNode != null)        &#123;            if (fastNode == null || fastNode.next == null) return null;            slowNode = slowNode.next;            fastNode = fastNode.next.next;            if (fastNode == slowNode)            &#123;                ListNode cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur.next;                    slowNode = slowNode.next;                &#125;                return cur;            &#125;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return None        fastNode = head               slowNode = head        while (fastNode != None):            if (fastNode == None or fastNode.next == None): return None            slowNode = slowNode.next            fastNode = fastNode.next.next            if (fastNode == slowNode):                cur = head                while ( cur != slowNode):                     cur = cur.next                    slowNode = slowNode.next                return cur        return None\n\n二：两数相加\n\n1. 模拟\n直接对对应节点的数字进行相加，难点在于处理进位和非对齐的场景\nclass Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        int carry = 0;        ListNode* head = nullptr;        ListNode* cur = nullptr;        while (l1 != nullptr || l2 != nullptr)        &#123;            int num1= l1 ? l1-&gt;val : 0;            int num2= l2 ? l2-&gt;val : 0;            int sum= num1 + num2 + carry;            if (head == nullptr)                cur = head = new ListNode(sum % 10);            else                cur = cur-&gt;next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != nullptr) l1 = l1-&gt;next;            if (l2 != nullptr) l2 = l2-&gt;next;        &#125;        if (carry != 0) cur-&gt;next = new ListNode(carry);        return head;    &#125;&#125;;\nclass Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int carry = 0;        ListNode head = null;        ListNode cur = null;        while (l1 != null || l2 != null)        &#123;            int num1= l1 != null ? l1.val : 0;            int num2= l2 != null ? l2.val : 0;            int sum= num1 + num2 + carry;            if (head == null)                cur = head = new ListNode(sum % 10);            else                cur = cur.next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        if (carry != 0) cur.next = new ListNode(carry);        return head;    &#125;&#125;\nclass Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        carry = 0        head = None        cur = None        while (l1 != None or l2 != None):            num1 = l1.val if l1 else 0            num2 = l2.val if l2 else 0            sum= num1 + num2 + carry            if (head == None):                head = ListNode(sum % 10)                cur = head            else:                cur.next = ListNode(sum % 10)                cur = cur.next            carry = sum // 10            if (l1 != None): l1 = l1.next            if (l2 != None): l2 = l2.next        if (carry != 0): cur.next = ListNode(carry)        return head\n\n三：删除链表的倒数第 N 个结点\n\n1. 计算链表长度\n需要一个虚拟头结点，这样可以删除任意的节点，否则如果只有一个节点并删除自己，则需要单独处理\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        int length = GetLength(head);        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur-&gt;next;        &#125;        cur-&gt;next = cur-&gt;next-&gt;next;        ListNode* ans = dummy-&gt;next;        return ans;    &#125;    int GetLength(ListNode* head)    &#123;        int length = 0;        while (head)        &#123;            head = head-&gt;next;            ++length;        &#125;         return length;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        int length = GetLength(head);        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur.next;        &#125;        cur.next = cur.next.next;        ListNode ans = dummy.next;        return ans;    &#125;    public int GetLength(ListNode head)    &#123;        int length = 0;        while (head != null)        &#123;            head = head.next;            ++length;        &#125;         return length;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        def GetLength(head : Optional[ListNode]) -&gt; Optional[int]:            length = 0            while (head != None):                head = head.next                length += 1            return length        length = GetLength(head)        cur = ListNode(0, head)        dummy = cur        for i in range(1, length + 1 -n):            cur = cur.next        cur.next = cur.next.next        ans = dummy.next        return ans\n\n2. 栈\n用一个栈去存储节点，之后弹出的第n个节点就是需要删除的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        stack&lt;ListNode*&gt; stk;        while (cur != nullptr)         &#123;            stk.push(cur);            cur = cur-&gt;next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.top();        head-&gt;next = head-&gt;next-&gt;next;        return dummy-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        Deque&lt;ListNode&gt; stk = new LinkedList&lt;&gt;();        while (cur != null)         &#123;            stk.push(cur);            cur = cur.next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.peek();        head.next = head.next.next;        return dummy.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        cur = ListNode(0, head)        dummy = cur        stk = list()        while (cur != None):             stk.append(cur)            cur = cur.next        for i in range(n): stk.pop()        head = stk[-1]        head.next = head.next.next        return dummy.next\n\n3. 双指针\n使用两个指针，快指针比慢指针多n个节点，快指针到达末尾则慢指针位置就是需要处理的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* slow = pre;           // 不从head开始的原因在于，可以刚好到达倒数第n节点的前继结点        ListNode* fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast-&gt;next;        while (fast != nullptr)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        slow-&gt;next = slow-&gt;next-&gt;next;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode pre = new ListNode(0, head);        ListNode slow = pre;                 ListNode fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast.next;        while (fast != null)        &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return pre.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        slow = pre                 fast = head        for i in range(n): fast = fast.next        while (fast != None):            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return pre.next\n\n四：两两交换链表中的节点\n\n1. 递归\n终止条件为末尾只有单个节点或没有节点，一个递归需要处理两个节点\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return head;        ListNode* n1 = head-&gt;next;        head-&gt;next = swapPairs(n1-&gt;next);        n1-&gt;next = head;        return n1;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) return head;        ListNode n1 = head.next;        head.next = swapPairs(n1.next);        n1.next = head;        return n1;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return head        n1 = head.next        head.next = self.swapPairs(n1.next)        n1.next = head        return n1\n\n2. 迭代\n我们定义一个前继结点，依次交换后面的两个节点，然后前继结点向前移动两个位置\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* cur = pre;        while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)        &#123;            ListNode* n1 = cur-&gt;next;            ListNode* n2 = cur-&gt;next-&gt;next;            cur-&gt;next = n2;            n1-&gt;next = n2-&gt;next;            n2-&gt;next = n1;            cur = n1;        &#125;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0, head);        ListNode cur = pre;        while (cur.next != null &amp;&amp; cur.next.next != null)        &#123;            ListNode n1 = cur.next;            ListNode n2 = cur.next.next;            cur.next = n2;            n1.next = n2.next;            n2.next = n1;            cur = n1;        &#125;        return pre.next;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        cur = pre        while (cur.next != None and cur.next.next != None):            n1 = cur.next            n2 = cur.next.next            cur.next = n2            n1.next = n2.next            n2.next = n1            cur = n1        return pre.next\n\n五：随机链表的复制\n\n1. 回溯+哈希表\n该题的难度在于随机指针的处理，因为拷贝节点时，随机指针指向的节点可能还未创建，一种方法是先不拷贝随机指针，在第二次循环中再拷贝，或者利用递归的思想反向处理\nclass Solution &#123;public:    unordered_map&lt;Node*, Node*&gt; hashMap;    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return head;        if (!hashMap.count(head))        &#123;            Node* newNode = new Node(head-&gt;val);            hashMap[head] = newNode;            newNode-&gt;next = copyRandomList(head-&gt;next);     // 到这里完成了除随机指针的拷贝            newNode-&gt;random = copyRandomList(head-&gt;random);\t\t// 等效于第二次遍历，此时节点已完成创建        &#125;        return hashMap[head];    &#125;&#125;;\nclass Solution &#123;    public Map&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();    public Node copyRandomList(Node head) &#123;        if (head == null) return head;        if (hashMap.containsKey(head) == false)        &#123;            Node newNode = new Node(head.val);            hashMap.put(head, newNode);            newNode.next = copyRandomList(head.next);                 newNode.random = copyRandomList(head.random);             &#125;        return hashMap.get(head);    &#125;&#125;\nclass Solution:    def __init__(self):        self.hashMap = &#123;&#125;\t\t# 这里初始化    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return head        if (head not in self.hashMap):            newNode= Node(head.val)            self.hashMap[head] = newNode            newNode.next = self.copyRandomList(head.next)                 newNode.random = self.copyRandomList(head.random)             return self.hashMap[head]\n\n2. 迭代+拆分\n将每一个拷贝后的节点作为原节点的后继结点，随机指针则为原指针的随机指针节点的后继位置，空除外\nclass Solution &#123;public:    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return nullptr;        Node* newHead = nullptr;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 建立复制链表        &#123;            Node* newNode = new Node(start-&gt;val);            newNode-&gt;next = start-&gt;next;            start-&gt;next = newNode;        &#125;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 对随机指针赋值        &#123;            if (start-&gt;random != nullptr) start-&gt;next-&gt;random = start-&gt;random-&gt;next;            else start-&gt;next-&gt;random =nullptr;        &#125;        newHead = head-&gt;next;        for (Node* start = head; start != nullptr; start = start-&gt;next)\t\t\t// 恢复原链表，连接新链表        &#123;            Node* newNode = start-&gt;next;            start-&gt;next = start-&gt;next-&gt;next;            newNode-&gt;next = (newNode-&gt;next != nullptr) ? newNode-&gt;next-&gt;next : nullptr;        &#125;        return newHead;    &#125;&#125;;\nclass Solution &#123;    public Node copyRandomList(Node head) &#123;        if (head == null) return null;        Node newHead = null;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            Node newNode = new Node(start.val);            newNode.next = start.next;            start.next = newNode;        &#125;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            if (start.random != null) start.next.random = start.random.next;            else start.next.random =null;        &#125;        newHead = head.next;        for (Node start = head; start != null; start = start.next)\t\t\t        &#123;            Node newNode = start.next;            start.next = start.next.next;            newNode.next = (newNode.next != null) ? newNode.next.next : null;        &#125;        return newHead;    &#125;&#125;\nclass Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return None        start = head        while start:\t            newNode = Node(start.val)            newNode.next = start.next            start.next = newNode            start = newNode.next        start = head        while start:\t            if (start.random != None): start.next.random = start.random.next            else: start.next.random = None            start = start.next.next        newHead = head.next        start = head        while start:\t\t            newNode = start.next            start.next = start.next.next            if newNode.next:                newNode.next = newNode.next.next            start = start.next        return newHead\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.7)","url":"/posts/7d9a174a/","content":"一：排序链表\n\n1. 自顶向下归并排序\n对链表不断切分，然后使用合并两个有序链表的方式合并\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        return recursion(head, nullptr);    &#125;    ListNode* recursion(ListNode* left, ListNode* right)    &#123;        if (left == nullptr || left-&gt;next == nullptr) return left;        if (left-&gt;next == right)        &#123;            left-&gt;next = nullptr;            return left;        &#125;        ListNode* slow = left, *fast = left;        while (fast != right)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;            if (fast != right) fast = fast-&gt;next;        &#125;        ListNode* mid = slow;        ListNode* leftNew = recursion(left, mid);        ListNode* rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        return recursion(head, null);    &#125;    public ListNode recursion(ListNode left, ListNode right)    &#123;        if (left == null || left.next == null) return left;        if (left.next == right)        &#123;            left.next = null;            return left;        &#125;        ListNode slow = left, fast = left;        while (fast != right)        &#123;            slow = slow.next;            fast = fast.next;            if (fast != right) fast = fast.next;        &#125;        ListNode mid = slow;        ListNode leftNew = recursion(left, mid);        ListNode rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.recursion(head, None)    def recursion(self, left, right):        if (left == None or left.next == None): return left        if (left.next == right):            left.next = None            return left        slow, fast = left, left        while (fast != right):            slow = slow.next            fast = fast.next            if (fast != right): fast = fast.next        mid = slow        leftNew = self.recursion(left, mid)        rightNew = self.recursion(mid, right)        return self.MergeTwoLists(leftNew, rightNew)     def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 自底向上归并排序\n第一层处理两个节点，将它们断开并排序，第二层结束处理四个节点，其中的两两已经处理好，是有序链表，因此可直接排序，依次迭代\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (head == nullptr) return head;        int length = 0;        ListNode* temp = head;        ListNode* pre = new ListNode(0, head);        while (temp != nullptr)        &#123;            ++length;            temp = temp-&gt;next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode* preCur = pre;            ListNode* cur = pre-&gt;next;            while (cur != nullptr)            &#123;                ListNode* node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur-&gt;next != nullptr; ++i) cur = cur-&gt;next;                ListNode* node2 = cur-&gt;next;                cur-&gt;next = nullptr;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != nullptr &amp;&amp; cur-&gt;next !=nullptr; ++i) cur = cur-&gt;next;                ListNode* next = nullptr;                if (cur != nullptr)                &#123;                    next = cur-&gt;next;                    cur-&gt;next = nullptr;                    cur = next;                &#125;                preCur-&gt;next = MergeTwoLists(node1, node2);                while (preCur-&gt;next != nullptr) preCur = preCur-&gt;next;            &#125;        &#125;        return pre-&gt;next;    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        if (head == null) return head;        int length = 0;        ListNode temp = head;        ListNode pre = new ListNode(0, head);        while (temp != null)        &#123;            ++length;            temp = temp.next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode preCur = pre;            ListNode cur = pre.next;            while (cur != null)            &#123;                ListNode node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur.next != null; ++i) cur = cur.next;                ListNode node2 = cur.next;                cur.next = null;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != null &amp;&amp; cur.next !=null; ++i) cur = cur.next;                ListNode next = null;                if (cur != null)                &#123;                    next = cur.next;                    cur.next = null;                    cur = next;                &#125;                preCur.next = MergeTwoLists(node1, node2);                while (preCur.next != null) preCur = preCur.next;            &#125;        &#125;        return pre.next;    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None): return head        length = 0        temp = head        pre = ListNode(0, head)        while (temp != None):            length += 1            temp = temp.next        sub = 1        while (sub &lt; length):            preCur = pre            cur = pre.next            while (cur != None):                node1 = cur                for i in range(1, sub):                    if cur.next:                        cur = cur.next                    else:                        break                node2 = cur.next                cur.next = None                cur = node2                for i in range(1, sub):                    if cur and cur.next:                        cur = cur.next                    else:                        break                next = None                if (cur != None):                    next = cur.next                    cur.next = None                    cur = next                preCur.next = self.MergeTwoLists(node1, node2)                while (preCur.next != None): preCur = preCur.next            sub *= 2        return pre.next    def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n二：LRU缓存\n\n1. 哈希表+双向链表\n使用哈希表保存键和双向链表的节点，节点保存键值和前后指针，这样每个操作都为常数\nclass LRUCache &#123;private:struct DoubleList&#123;    int key;    int value;    DoubleList* pre;    DoubleList* next;    DoubleList() : key(0), value(0), pre(nullptr), next(nullptr) &#123;&#125;    DoubleList(int _key, int _value) : key(_key), value(_value), pre(nullptr), next(nullptr) &#123;&#125;&#125;;public:    unordered_map&lt;int, DoubleList*&gt; hashMap;    DoubleList* head;    DoubleList* tail;    int capacity = 0;    int size = 0;    LRUCache(int capacity) &#123;        this-&gt;capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head-&gt;next = tail;        tail-&gt;pre = head;    &#125;        int get(int key) &#123;        if (hashMap.count(key) == false) return -1;        else        &#123;            DoubleList* cur = hashMap[key];            AddToHead(DeleteNode(cur));            return cur-&gt;value;        &#125;    &#125;        void put(int key, int value) &#123;        if (hashMap.count(key) == false)        &#123;            DoubleList* newNode = new DoubleList(key, value);            hashMap[key] = newNode;            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList* deleteNode = DeleteNode(tail-&gt;pre);                hashMap.erase(deleteNode-&gt;key);                delete deleteNode;                --size;            &#125;        &#125; else        &#123;            DoubleList* cur = hashMap[key];            cur-&gt;value = value;            AddToHead(DeleteNode(cur));        &#125;    &#125;    DoubleList* DeleteNode(DoubleList* node)    &#123;        node-&gt;next-&gt;pre = node-&gt;pre;        node-&gt;pre-&gt;next = node-&gt;next;        return node;    &#125;    void AddToHead(DoubleList* node)    &#123;        node-&gt;pre = head;        node-&gt;next = head-&gt;next;        head-&gt;next = node;        node-&gt;next-&gt;pre = node;    &#125;&#125;;\nclass LRUCache &#123;    class DoubleList    &#123;        int key;        int value;        DoubleList pre;        DoubleList next;        public DoubleList() &#123;&#125;        public DoubleList(int _key, int _value) &#123;key = _key; value = _value;&#125;    &#125;    Map&lt;Integer, DoubleList&gt; hashMap = new HashMap&lt;&gt;();    DoubleList head;    DoubleList tail;    int capacity = 0;    int size = 0;    public LRUCache(int capacity) &#123;        this.capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head.next = tail;        tail.pre = head;    &#125;        public int get(int key) &#123;        if (hashMap.containsKey(key) == false) return -1;        else        &#123;            DoubleList cur = hashMap.get(key);            AddToHead(DeleteNode(cur));            return cur.value;        &#125;    &#125;        public void put(int key, int value) &#123;        if (hashMap.containsKey(key) == false)        &#123;            DoubleList newNode = new DoubleList(key, value);            hashMap.put(key, newNode);            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList deleteNode = DeleteNode(tail.pre);                hashMap.remove(deleteNode.key);                --size;            &#125;        &#125; else        &#123;            DoubleList cur = hashMap.get(key);            cur.value = value;            AddToHead(DeleteNode(cur));        &#125;     &#125;    public DoubleList DeleteNode(DoubleList node)    &#123;        node.next.pre = node.pre;        node.pre.next = node.next;        return node;    &#125;    public void AddToHead(DoubleList node)    &#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;&#125;\nclass LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.size = 0        self.hashMap = dict()        self.head = DoubleList()        self.tail = DoubleList()        self.head.next = self.tail        self.tail.prev = self.head    def get(self, key: int) -&gt; int:        if (key not in self.hashMap): return -1        else:            cur = self.hashMap[key]            self.AddToHead(self.DeleteNode(cur))            return cur.value    def put(self, key: int, value: int) -&gt; None:        if (key not in self.hashMap):            newNode = DoubleList(key, value)            self.hashMap[key] = newNode            self.AddToHead(newNode)            self.size += 1            if (self.size &gt; self.capacity):                   deleteNode = self.DeleteNode(self.tail.pre)                self.hashMap.pop(deleteNode.key)                self.size -= 1        else:            cur = self.hashMap[key]            cur.value = value            self.AddToHead(self.DeleteNode(cur))    def DeleteNode(self, node):        node.next.pre = node.pre        node.pre.next = node.next        return node    def AddToHead(self, node):        node.pre = self.head        node.next = self.head.next        self.head.next = node        node.next.pre = nodeclass DoubleList:    def __init__(self, key = 0, value = 0):        self.key = key        self.value = value        self.prev = None        self.next = None\n\n三：二叉树的层序遍历\n\n1. 广度优先搜索\n用队列表示每一层，逐层遍历\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if (root == nullptr) return result;        queue&lt;TreeNode*&gt; queueTree;        queueTree.push(root);        while (queueTree.empty() == false)        &#123;            int size = queueTree.size();            result.emplace_back(vector&lt;int&gt;());            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode* newNode = queueTree.front();                queueTree.pop();                result.back().emplace_back(newNode-&gt;val);                if (newNode-&gt;left) queueTree.push(newNode-&gt;left);                if (newNode-&gt;right) queueTree.push(newNode-&gt;right);              &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if (root == null) return result;        Queue&lt;TreeNode&gt; queueTree = new LinkedList&lt;&gt;();        queueTree.offer(root);        while (queueTree.isEmpty() == false)        &#123;            int size = queueTree.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode newNode = queueTree.poll();                level.add(newNode.val);                if (newNode.left != null) queueTree.offer(newNode.left);                if (newNode.right != null) queueTree.offer(newNode.right);              &#125;            result.add(level);        &#125;        return result;    &#125;&#125;\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        result = []        if (root == None): return result        queueTree = deque([root])        while (queueTree):            size = len(queueTree)            level = []            for _ in range(size):                newNode = queueTree.popleft()                level.append(newNode.val)                if (newNode.left != None): queueTree.append(newNode.left)                if (newNode.right != None): queueTree.append(newNode.right)              result.append(level)        return result\n\n四：验证二叉搜索树\n\n1. 递归\n参考二叉树的中序遍历的递归写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        return recursion(root, LONG_MIN, LONG_MAX);    &#125;    bool recursion(TreeNode* node, long long min, long long max)    &#123;        if (node == nullptr) return true;        if (node-&gt;val &lt;= min || node-&gt;val &gt;= max) return false;        bool flagLeft = recursion(node-&gt;left, min, node-&gt;val);        bool flagRight = recursion(node-&gt;right, node-&gt;val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public boolean recursion(TreeNode node, long min, long max)    &#123;        if (node == null) return true;        if (node.val &lt;= min || node.val &gt;= max) return false;        boolean flagLeft = recursion(node.left, min, node.val);        boolean flagRight = recursion(node.right, node.val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def recursion(node, min, max):            if (node == None): return True            if (node.val &lt;= min or node.val &gt;= max): return False            flagLeft = recursion(node.left, min, node.val)            flagRight = recursion(node.right, node.val, max)            return flagLeft and flagRight        return recursion(root, float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;))\n\n2. 中序遍历\n参考二叉树的中序遍历的迭代写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        long long min = (long long)INT_MIN - 1;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            treeStack.pop();                    // 拿到数据出栈            if (root -&gt; val &lt;= min) return false;            min = root -&gt; val;            root = root-&gt;right;       &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            if (root.val &lt;= min) return false;            min = root.val;            root = root.right;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        treeStack = []        min = float(&#x27;-inf&#x27;)        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            if (root.val &lt;= min): return False            min = root.val            root = root.right        return True\n\n五：二叉搜索树中第 K 小的元素\n\n1. 中序遍历\n利用中序遍历得到有序数组，找到数组中的第K个元素即可。迭代用栈管理，栈弹出的顺序就是有序列表，因此第K个就是需要的值\nclass Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())              &#123;            while (root != nullptr)            &#123;                treeStack.push(root);                       root = root-&gt;left;            &#125;            root = treeStack.top();                   treeStack.pop();                    // 第一个出栈的为最小元素，出栈k次即可得到结果            --k;            if (k == 0) break;             root = root-&gt;right;       &#125;        return root-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            --k;            if (k == 0) break;            root = root.right;        &#125;        return root.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            k -= 1            if (k == 0): break            root = root.right        return root.val\n\n2. 记录子树的节点\n把每个节点的左右子树的节点数量记录，此时只需要判断k与子树节点数量的大小，因为左子树一定小于当前节点，右子树大于当前节点。适用于频繁寻找k值\nclass Solution &#123;public:    unordered_map&lt;TreeNode*, int&gt; hashMap;    TreeNode* root;    int kthSmallest(TreeNode* root, int k) &#123;        this-&gt;root = root;        CountNum(root);        return SearchTarget(k);    &#125;    int CountNum(TreeNode* node)    &#123;        if (node == nullptr) return 0;        hashMap[node] = 1 + CountNum(node-&gt;left) + CountNum(node-&gt;right);        return hashMap[node];    &#125;    int GetNum(TreeNode* node)    &#123;        if (node != nullptr &amp;&amp; hashMap.count(node)) return hashMap[node];        else return 0;    &#125;    int SearchTarget(int k)    &#123;        TreeNode* node = root;        while (node != nullptr)        &#123;            int leftNum = GetNum(node-&gt;left);            if (leftNum &lt; k - 1)            &#123;                node = node-&gt;right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node-&gt;left;            else break;        &#125;        return node-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public Map&lt;TreeNode, Integer&gt; hashMap = new HashMap&lt;&gt;();    public TreeNode root;    public int kthSmallest(TreeNode root, int k) &#123;        this.root = root;        CountNum(root);        return SearchTarget(k);    &#125;    public int CountNum(TreeNode node)    &#123;        if (node == null) return 0;        hashMap.put(node, 1 + CountNum(node.left) + CountNum(node.right));        return hashMap.get(node);    &#125;    public int GetNum(TreeNode node)    &#123;        if (node != null &amp;&amp; hashMap.containsKey(node)) return hashMap.get(node);        else return 0;    &#125;    public int SearchTarget(int k)    &#123;        TreeNode node = root;        while (node != null)        &#123;            int leftNum = GetNum(node.left);            if (leftNum &lt; k - 1)            &#123;                node = node.right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node.left;            else break;        &#125;        return node.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        self.hashMap = &#123;&#125;        self.root = root        self.CountNum(self.root)        return self.SearchTarget(k)    def CountNum(self, node):        if (node == None): return 0        self.hashMap[node] = 1 + self.CountNum(node.left) + self.CountNum(node.right)        return self.hashMap[node]    def GetNum(self, node):        if (node != None and node in self.hashMap): return self.hashMap[node]        else: return 0    def SearchTarget(self, k):        node = self.root        while (node != None):            leftNum = self.GetNum(node.left)            if (leftNum &lt; k - 1):                node = node.right                k -= leftNum + 1            elif (leftNum &gt; k - 1): node = node.left            else: break        return node.val\n\n3. 平衡二叉搜索树\n官方给的题解太长了，使用了经典的AVL树数据结构，并添加了一些常用的操作，没必要，简化一下吧\nstruct Node &#123;    int val;    Node * parent;    Node * left;    Node * right;    int size;    int height;    Node(int val, Node * parent) &#123;        this-&gt;val = val;        this-&gt;parent = parent;        this-&gt;left = nullptr;        this-&gt;right = nullptr;        this-&gt;height = 0;         this-&gt;size = 1;     &#125;&#125;;class AVL &#123;public:    Node * root;    AVL(vector&lt;int&gt; &amp; vals) &#123;        if (!vals.empty()) &#123;            root = build(vals, 0, vals.size() - 1, nullptr);        &#125;    &#125;    Node * build(vector&lt;int&gt; &amp; vals, int l, int r, Node * parent) &#123;        int m = (l + r) &gt;&gt; 1;        Node * node = new Node(vals[m], parent);        if (l &lt;= m - 1) &#123;            node-&gt;left = build(vals, l, m - 1, node);        &#125;        if (m + 1 &lt;= r) &#123;            node-&gt;right = build(vals, m + 1, r, node);        &#125;        recompute(node);        return node;    &#125;    void recompute(Node * node) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));        node-&gt;size = 1 + getSize(node-&gt;left) + getSize(node-&gt;right);    &#125;    static int getHeight(Node * node) &#123;        return node != nullptr ? node-&gt;height : 0;    &#125;    static int getSize(Node * node) &#123;        return node != nullptr ? node-&gt;size : 0;    &#125;    int kthSmallest(int k) &#123;        Node * node = root;        while (node != nullptr) &#123;            int left = getSize(node-&gt;left);            if (left &lt; k - 1) &#123;                node = node-&gt;right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node-&gt;left;            &#125;        &#125;        return node-&gt;val;    &#125;&#125;;class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        vector&lt;int&gt; inorderList;        inorder(root, inorderList);        AVL avl(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode * node, vector&lt;int&gt; &amp; inorderList) &#123;        if (node-&gt;left != nullptr) &#123;            inorder(node-&gt;left, inorderList);        &#125;        inorderList.push_back(node-&gt;val);        if (node-&gt;right != nullptr) &#123;            inorder(node-&gt;right, inorderList);        &#125;    &#125;&#125;;\nclass Node &#123;    int val;    Node parent;    Node left;    Node right;    int size;    int height;    Node(int val, Node parent) &#123;        this.val = val;        this.parent = parent;        this.left = null;        this.right = null;        this.height = 0;         this.size = 1;     &#125;&#125;class AVL &#123;    Node root;    AVL(List&lt;Integer&gt; vals) &#123;        if (!vals.isEmpty()) &#123;            root = build(vals, 0, vals.size() - 1, null);        &#125;    &#125;    Node build(List&lt;Integer&gt; vals, int l, int r, Node parent) &#123;        if (l &gt; r) &#123;            return null;        &#125;        int m = l + (r - l) / 2;        Node node = new Node(vals.get(m), parent);        node.left = build(vals, l, m - 1, node);        node.right = build(vals, m + 1, r, node);                recompute(node);        return node;    &#125;    void recompute(Node node) &#123;        if (node == null) return;        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));        node.size = 1 + getSize(node.left) + getSize(node.right);    &#125;    static int getHeight(Node node) &#123;        return node != null ? node.height : 0;    &#125;    static int getSize(Node node) &#123;        return node != null ? node.size : 0;    &#125;    int kthSmallest(int k) &#123;        Node node = root;        while (node != null) &#123;            int left = getSize(node.left);            if (left &lt; k - 1) &#123;                node = node.right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node.left;            &#125;        &#125;        return node.val;    &#125;&#125;class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        List&lt;Integer&gt; inorderList = new ArrayList&lt;&gt;();        inorder(root, inorderList);                if (inorderList.isEmpty() || k &lt;= 0 || k &gt; inorderList.size()) &#123;            return -1;        &#125;        AVL avl = new AVL(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode node, List&lt;Integer&gt; inorderList) &#123;        if (node == null) &#123;            return;        &#125;        inorder(node.left, inorderList);        inorderList.add(node.val);        inorder(node.right, inorderList);    &#125;&#125;\nclass Node:    def __init__(self, val: int, parent: Optional[&#x27;Node&#x27;] = None):        self.val = val        self.parent = parent        self.left = None        self.right = None        self.height = 0        self.size = 1class AVL:    def __init__(self, vals: List[int]):        self.root: Optional[Node] = None        if vals:            self.root = self.build(vals, 0, len(vals) - 1, None)    def build(self, vals: List[int], l: int, r: int, parent: Optional[Node]) -&gt; Optional[Node]:        if l &gt; r:            return None                m = (l + r) // 2        node = Node(vals[m], parent)                node.left = self.build(vals, l, m - 1, node)        node.right = self.build(vals, m + 1, r, node)                self.recompute(node)        return node    def recompute(self, node: Node):        if node is None:            return                    left_height = AVL.get_height(node.left)        right_height = AVL.get_height(node.right)                node.height = 1 + max(left_height, right_height)        node.size = 1 + AVL.get_size(node.left) + AVL.get_size(node.right)    @staticmethod    def get_height(node: Optional[Node]) -&gt; int:        return node.height if node else 0    @staticmethod    def get_size(node: Optional[Node]) -&gt; int:        return node.size if node else 0    def kthSmallest(self, k: int) -&gt; int:        node = self.root        while node:            left_size = AVL.get_size(node.left)                        if left_size &lt; k - 1:                k -= left_size + 1                node = node.right            elif left_size == k - 1:                return node.val            else:                node = node.left                return -1class Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        inorder_list: List[int] = []        self._inorder(root, inorder_list)                if not inorder_list or k &lt;= 0 or k &gt; len(inorder_list):            return -1                    avl = AVL(inorder_list)        return avl.kthSmallest(k)    def _inorder(self, node: Optional[TreeNode], inorder_list: List[int]):        if node is None:            return                    self._inorder(node.left, inorder_list)        inorder_list.append(node.val)        self._inorder(node.right, inorder_list)\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.8)","url":"/posts/fa020b85/","content":"一：二叉树的右视图\n\n1. 深度优先搜索\n通过另一个深度栈来维护每一层唯一的可见值，这个值为后添加的右节点\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        stack&lt;TreeNode*&gt; stk;        stack&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.top();            stk.pop();            int depth = stkDepth.top(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                if (hashMap.count(depth) == false) hashMap[depth] = node-&gt;val;                stk.push(node-&gt;left);                stk.push(node-&gt;right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Deque&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.pop();            int depth = stkDepth.pop();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                if (hashMap.containsKey(depth) == false) hashMap.put(depth, node.val);                stk.push(node.left);                stk.push(node.right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        stack = [(root, 1)]        while stack:            node, depth = stack.pop()            if (node != None):                maxDepth = max(maxDepth, depth)                if (depth not in hashMap): hashMap[depth] = node.val                    stack.append((node.left, depth + 1))                stack.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n2. 广度优先搜索\n类似于深度，这里使用队列执行先进先出，因此从左节点开始向右遍历\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        queue&lt;TreeNode*&gt; stk;        queue&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.front();            stk.pop();            int depth = stkDepth.front(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                hashMap[depth] = node-&gt;val;\t\t\t// 最后一个节点为可见节点                stk.push(node-&gt;left);                stk.push(node-&gt;right);      \t\t// 先弹出左节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Queue&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.add(root);        stkDepth.add(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.remove();            int depth = stkDepth.remove();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                hashMap.put(depth, node.val);                stk.add(node.left);                stk.add(node.right);      // 优先弹出右节点                stkDepth.add(depth + 1);                stkDepth.add(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        queue = deque([(root, 1)])        while queue:            node, depth = queue.popleft()            if (node != None):                maxDepth = max(maxDepth, depth)                hashMap[depth] = node.val                    queue.append((node.left, depth + 1))                queue.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n二：二叉树展开为链表\n\n1. 前序遍历\n前序遍历得到所有节点的数组，然后逐一构建\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        vector&lt;TreeNode*&gt; listTree;        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode* pre = listTree[i - 1];            TreeNode* cur = listTree[i];            pre-&gt;right = cur;            pre-&gt;left = nullptr;        &#125;    &#125;    void PreOrder(TreeNode* node, vector&lt;TreeNode*&gt;&amp; listTree)    &#123;        if (node != nullptr)         &#123;            listTree.emplace_back(node);            PreOrder(node-&gt;left, listTree);            PreOrder(node-&gt;right, listTree);        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        List&lt;TreeNode&gt; listTree = new ArrayList&lt;&gt;();        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode pre = listTree.get(i - 1);            TreeNode cur = listTree.get(i);            pre.right = cur;            pre.left = null;        &#125;    &#125;    public void PreOrder(TreeNode node, List&lt;TreeNode&gt; listTree)    &#123;        if (node != null)         &#123;            listTree.add(node);            PreOrder(node.left, listTree);            PreOrder(node.right, listTree);        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        listTree = list()        self.PreOrder(root, listTree)        for i in range(1, len(listTree)):            pre = listTree[i - 1]            cur = listTree[i]            pre.right = cur            pre.left = None    def PreOrder(self, node, listTree):        if (node != None):            listTree.append(node)            self.PreOrder(node.left, listTree)            self.PreOrder(node.right, listTree)\n\n2. 前序遍历和展开同步进行\n不使用额外数组，使用栈来使遍历和创建新链表同时进行\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        stack&lt;TreeNode*&gt; stk;        stk.push(root);        TreeNode* pre = nullptr;        while (stk.empty() == false)        &#123;            TreeNode* cur = stk.top();            stk.pop();            if (pre != nullptr)            &#123;                pre-&gt;left = nullptr;                pre-&gt;right = cur;            &#125;            if (cur-&gt;right != nullptr) stk.push(cur-&gt;right);     // 先进右节点出栈可以先处理左节点            if (cur-&gt;left != nullptr) stk.push(cur-&gt;left);            pre = cur;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        stk.push(root);        TreeNode pre = null;        while (stk.isEmpty() == false)        &#123;            TreeNode cur = stk.pop();            if (pre != null)            &#123;                pre.left = null;                pre.right = cur;            &#125;            if (cur.right != null) stk.push(cur.right);     // 先进右节点出栈可以先处理左节点            if (cur.left != null) stk.push(cur.left);            pre = cur;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        stk = [root]        pre = None        while (stk):            cur = stk.pop()            if (pre != None):                pre.left = None                pre.right = cur            if (cur.right != None): stk.append(cur.right)                 if (cur.left != None): stk.append(cur.left)            pre = cur\n\n3. 寻找前驱节点\n这个方法有点类似于二叉树的中序遍历中的Morris方法，通过将左子树最后的右节点指向当前节点的右节点，从而建立连接关系，相当于更改了当前链表的结构\n */class Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        auto cur = root;        while (cur != nullptr)        &#123;            if (cur-&gt;left != nullptr)            &#123;                auto node = cur-&gt;left;                auto next = node;                while (node-&gt;right != nullptr) node = node-&gt;right;      // 一直右移找到当前节点的前继结点                node-&gt;right = cur-&gt;right;                cur-&gt;left = nullptr;                cur-&gt;right = next;            &#125;            cur = cur-&gt;right;        &#125;    &#125;&#125;;\t\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        TreeNode cur = root;        while (cur != null)        &#123;            if (cur.left != null)            &#123;                TreeNode node = cur.left;                TreeNode next = node;                while (node.right != null) node = node.right;      // 一直右移找到当前节点的前继结点                node.right = cur.right;                cur.left = null;                cur.right = next;            &#125;            cur = cur.right;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        cur = root        while (cur != None):            if (cur.left != None):                node = cur.left                next = node                while (node.right != None): node = node.right                     node.right = cur.right                cur.left = None                cur.right = next            cur = cur.right\n\n三：从前序与中序遍历序列构造二叉树\n\n1. 递归\n通过前序遍历找到中序遍历的根节点，然后左右划分依次递归，需要先处理左边，因为先序遍历根节点之后是左子树\nclass Solution &#123;private:    unordered_map&lt;int, int&gt; index;public:    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return nullptr;        &#125;        int preorder_root = preorder_left;        int inorder_root = index[preorder[preorder_root]];        TreeNode* root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int n = preorder.size();        for (int i = 0; i &lt; n; ++i) &#123;            index[inorder[i]] = i;        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;\nclass Solution &#123;    private Map&lt;Integer, Integer&gt; indexMap;    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return null;        &#125;        int preorder_root = preorder_left;        int inorder_root = indexMap.get(preorder[preorder_root]);        TreeNode root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n = preorder.length;        indexMap = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; n; i++) &#123;            indexMap.put(inorder[i], i);        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):            if preorder_left &gt; preorder_right:                return None            preorder_root = preorder_left            inorder_root = index[preorder[preorder_root]]            root = TreeNode(preorder[preorder_root])            size_left_subtree = inorder_root - inorder_left            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)            return root        n = len(preorder)        index = &#123;element: i for i, element in enumerate(inorder)&#125;        return myBuildTree(0, n - 1, 0, n - 1)\n\n2. 迭代\n这个解法巧妙的利用了先序和中序的特点，先序从根节点先到达最后一个左节点，中序则从最后一个左节点开始，当先序的某个节点和中序的第一个相等意味着当前节点的左子树结束，此时用栈来维护没有处理右子树的节点即可\nclass Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if (!preorder.size()) &#123;            return nullptr;        &#125;        TreeNode* root = new TreeNode(preorder[0]);        stack&lt;TreeNode*&gt; stk;        stk.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.size(); ++i) &#123;            int preorderVal = preorder[i];            TreeNode* node = stk.top();            if (node-&gt;val != inorder[inorderIndex]) &#123;                node-&gt;left = new TreeNode(preorderVal);                stk.push(node-&gt;left);            &#125;            else &#123;                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;                    node = stk.top();                    stk.pop();                    ++inorderIndex;                &#125;                node-&gt;right = new TreeNode(preorderVal);                stk.push(node-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if (preorder == null || preorder.length == 0) &#123;            return null;        &#125;        TreeNode root = new TreeNode(preorder[0]);        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();        stack.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.length; i++) &#123;            int preorderVal = preorder[i];            TreeNode node = stack.peek();            if (node.val != inorder[inorderIndex]) &#123;                node.left = new TreeNode(preorderVal);                stack.push(node.left);            &#125; else &#123;                while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;                    node = stack.pop();                    inorderIndex++;                &#125;                node.right = new TreeNode(preorderVal);                stack.push(node.right);            &#125;        &#125;        return root;    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None        root = TreeNode(preorder[0])        stack = [root]        inorderIndex = 0        for i in range(1, len(preorder)):            preorderVal = preorder[i]            node = stack[-1]            if node.val != inorder[inorderIndex]:                node.left = TreeNode(preorderVal)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[inorderIndex]:                    node = stack.pop()                    inorderIndex += 1                node.right = TreeNode(preorderVal)                stack.append(node.right)        return root\n\n四：路径总和 III\n\n1. 深度优先搜索\nclass Solution &#123;public:    int rootSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, long targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = rootSum(root, targetSum);        ret += pathSum(root.left, targetSum);        ret += pathSum(root.right, targetSum);        return ret;    &#125;    public int rootSum(TreeNode root, long targetSum) &#123;        int ret = 0;        if (root == null) &#123;            return 0;        &#125;        int val = root.val;        if (val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root.left, targetSum - val);        ret += rootSum(root.right, targetSum - val);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        def rootSum(root, targetSum):            if root is None:                return 0            ret = 0            if root.val == targetSum:                ret += 1            ret += rootSum(root.left, targetSum - root.val)            ret += rootSum(root.right, targetSum - root.val)            return ret                if root is None:            return 0                    ret = rootSum(root, targetSum)        ret += self.pathSum(root.left, targetSum)        ret += self.pathSum(root.right, targetSum)        return ret\n\n2. 前缀和\nclass Solution &#123;public:    unordered_map&lt;long long, int&gt; prefix;    int dfs(TreeNode *root, long long curr, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        curr += root-&gt;val;        if (prefix.count(curr - targetSum)) &#123;            ret = prefix[curr - targetSum];        &#125;        prefix[curr]++;        ret += dfs(root-&gt;left, curr, targetSum);        ret += dfs(root-&gt;right, curr, targetSum);        prefix[curr]--;        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        prefix[0] = 1;        return dfs(root, 0, targetSum);    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, int targetSum) &#123;        Map&lt;Long, Integer&gt; prefix = new HashMap&lt;Long, Integer&gt;();        prefix.put(0L, 1);        return dfs(root, prefix, 0, targetSum);    &#125;    public int dfs(TreeNode root, Map&lt;Long, Integer&gt; prefix, long curr, int targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = 0;        curr += root.val;        ret = prefix.getOrDefault(curr - targetSum, 0);        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);        ret += dfs(root.left, prefix, curr, targetSum);        ret += dfs(root.right, prefix, curr, targetSum);        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        prefix = collections.defaultdict(int)        prefix[0] = 1        def dfs(root, curr):            if not root:                return 0            ret = 0            curr += root.val            ret += prefix[curr - targetSum]            prefix[curr] += 1            ret += dfs(root.left, curr)            ret += dfs(root.right, curr)            prefix[curr] -= 1            return ret        return dfs(root, 0)\n\n五：二叉树的最近公共祖先\n\n1. 递归\nclass Solution &#123;public:    TreeNode* ans;    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root == nullptr) return false;        bool lson = dfs(root-&gt;left, p, q);        bool rson = dfs(root-&gt;right, p, q);        if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        dfs(root, p, q);        return ans;    &#125;&#125;;\nclass Solution &#123;    private TreeNode ans;    public Solution() &#123;        this.ans = null;    &#125;    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) &#123;        if (root == null) return false;        boolean lson = dfs(root.left, p, q);        boolean rson = dfs(root.right, p, q);        if ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root.val == p.val || root.val == q.val);    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        this.dfs(root, p, q);        return this.ans;    &#125;&#125;\nclass Solution:    def __init__(self):        self.ans = None    def dfs(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; bool:        if not root:            return False        lson = self.dfs(root.left, p, q)        rson = self.dfs(root.right, p, q)        if (lson and rson) or ((root.val == p.val or root.val == q.val) and (lson or rson)):            self.ans = root        return lson or rson or (root.val == p.val or root.val == q.val)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.dfs(root, p, q)        return self.ans\n\n2. 存储父节点\nclass Solution &#123;public:    unordered_map&lt;int, TreeNode*&gt; fa;    unordered_map&lt;int, bool&gt; vis;    void dfs(TreeNode* root)&#123;        if (root-&gt;left != nullptr) &#123;            fa[root-&gt;left-&gt;val] = root;            dfs(root-&gt;left);        &#125;        if (root-&gt;right != nullptr) &#123;            fa[root-&gt;right-&gt;val] = root;            dfs(root-&gt;right);        &#125;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        fa[root-&gt;val] = nullptr;        dfs(root);        while (p != nullptr) &#123;            vis[p-&gt;val] = true;            p = fa[p-&gt;val];        &#125;        while (q != nullptr) &#123;            if (vis[q-&gt;val]) return q;            q = fa[q-&gt;val];        &#125;        return nullptr;    &#125;&#125;;\nclass Solution &#123;    Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();    Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();    public void dfs(TreeNode root) &#123;        if (root.left != null) &#123;            parent.put(root.left.val, root);            dfs(root.left);        &#125;        if (root.right != null) &#123;            parent.put(root.right.val, root);            dfs(root.right);        &#125;    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        dfs(root);        while (p != null) &#123;            visited.add(p.val);            p = parent.get(p.val);        &#125;        while (q != null) &#123;            if (visited.contains(q.val)) &#123;                return q;            &#125;            q = parent.get(q.val);        &#125;        return null;    &#125;&#125;\nclass Solution:    def __init__(self):        self.fa = &#123;&#125;        self.visited = set()    def dfs(self, root: &#x27;TreeNode&#x27;):        if root.left:            self.fa[root.left.val] = root            self.dfs(root.left)        if root.right:            self.fa[root.right.val] = root            self.dfs(root.right)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.fa[root.val] = None  # 根节点没有父节点        self.dfs(root)        while p:            self.visited.add(p.val)            p = self.fa.get(p.val) # 使用.get()避免键不存在时出错        while q:            if q.val in self.visited:                return q            q = self.fa.get(q.val)        return None\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.9)","url":"/posts/e3193ac4/","content":"一：岛屿数量\n假期结束了，没有足够时间刷题了，因此往后只采用一种语言解题，方法还是向官方看齐\n\n1. 深度优先搜索\n遍历所有元素，然后将该元素的周围为1的元素设为0，依次递归，直到下一次循环\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    recursion(grid, i, j);      // 当前位置                &#125;            &#125;        return num;    &#125;    void recursion(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)    &#123;        grid[i][j] = 0;     // 访问过的点设为0        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;) recursion(grid, i - 1, j);     // 遍历上下左右四个点        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;) recursion(grid, i, j - 1);        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;) recursion(grid, i + 1, j);        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;) recursion(grid, i, j + 1);    &#125;&#125;;\n\n2. 广度优先搜索\n广度使用队列来维护节点，优先处理队列顶端的前后左右四个元素\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        queue&lt;pair&lt;int, int&gt;&gt; queueNum;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    grid[i][j] = &#x27;0&#x27;;                    queueNum.push(pair(i, j));                    while (!queueNum.empty())                    &#123;                        auto cur = queueNum.front();                        queueNum.pop();                        int i = cur.first;                        int j = cur.second;                        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i - 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i - 1, j));                        &#125;                        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j - 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j - 1));                        &#125;                        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i + 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i + 1, j));                        &#125;                        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j + 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j + 1));                        &#125;                    &#125;                &#125;        return num;    &#125;&#125;;\n\n3. 并查集\n这个数据结构就是为了处理这种“查询两个元素是否属于同一集合”和“合并两个元素所在的集合”的操作而生的。parent.push_back(i * n + j)将每个元素的父节点保存\nclass UnionFind&#123;public:    vector&lt;int&gt; parent;     // 记录父节点    vector&lt;int&gt; depth;      // 记录节点深度    int count = 0;          // 记录独立森林数    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid)       // 初始化森林和父节点列表    &#123;        int row = grid.size();        int col = grid[0].size();        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    parent.emplace_back(i * col + j);       // 父节点为自己                    ++count;            // 森林数量+1                &#125;                else parent.emplace_back(-1);        // 无父节点                depth.emplace_back(0);           // 深度为1            &#125;    &#125;    int Find(int i)          // 查找父节点    &#123;        if (parent[i] != i) parent[i] = Find(parent[i]);        // 父节点不是本身，向上查找        return parent[i];    &#125;    void Unite(int x, int y)            // 联合    &#123;        x = Find(x);                y = Find(y);        if (x != y)     // 两者父节点不相同，相同节点不必处理        &#123;            if (depth[x] &lt; depth[y]) parent[x] = y;           // 深度浅接到深度深的节点，方便查找            else if (depth[x] &gt; depth[y]) parent[y] = x;            else parent[x] = y;            --count;            x &gt; y ? ++depth[y] : ++depth[x];        &#125;    &#125;&#125;;class Solution &#123;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int nr = grid.size();        if (!nr) return 0;        int nc = grid[0].size();        UnionFind uf(grid);        for (int r = 0; r &lt; nr; ++r)             for (int c = 0; c &lt; nc; ++c)                 if (grid[r][c] == &#x27;1&#x27;) &#123;                    grid[r][c] = &#x27;0&#x27;;           // 不需要，只是为了减少重复访问的次数                    if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r-1) * nc + c);                    if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r+1) * nc + c);                    if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c - 1);                    if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c + 1);                &#125;        return uf.count;    &#125;&#125;;\n\n二：腐烂的橘子\n\n1. 多源广度优先搜索\n使用栈来维护每一层，然后依次判断该层每个节点的上下左右是否被感染，因为每分钟只能感染周围\nclass Solution &#123;public:    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int time = 0;        int numFre = 0;        int row = grid.size();         int col = grid[0].size();        queue&lt;pair&lt;int, int&gt;&gt; Q;        if (row == 0 || col == 0 ) return 0;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == 2)                    Q.push(pair&#123;i ,j&#125;);                if (grid[i][j] == 1)                    ++numFre;            &#125;        if (numFre == 0) return 0;        while (!Q.empty())        &#123;            int size = Q.size();            ++time;            for (int i = 0; i &lt; size; ++i)            &#123;                int x = Q.front().first;                int y = Q.front().second;                Q.pop();                if (x - 1 &gt;= 0 &amp;&amp; grid[x - 1][y] == 1)                &#123;                    grid[x - 1][y] = 2;                    Q.push(pair&#123;x - 1, y&#125;);                    --numFre;                &#125;                if (x + 1 &lt; row &amp;&amp; grid[x + 1][y] == 1)                &#123;                    grid[x + 1][y] = 2;                    Q.push(pair&#123;x + 1, y&#125;);                    --numFre;                &#125;                if (y - 1 &gt;= 0 &amp;&amp; grid[x][y - 1] == 1)                &#123;                    grid[x][y - 1] = 2;                    Q.push(pair&#123;x, y - 1&#125;);                    --numFre;                &#125;                if (y + 1 &lt; col &amp;&amp; grid[x][y + 1] == 1)                &#123;                    grid[x][y + 1] = 2;                    Q.push(pair&#123;x, y + 1&#125;);                    --numFre;                &#125;            &#125;        &#125;        if (numFre != 0) return -1;        return time - 1;    &#125;&#125;;\n\n三：课程表\n\n1. 深度优先搜索\n实际上是判断该结构是否为有向无环图，使用0、1、2来表示节点的状态，再次遇到1表示存在环\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; edge;    vector&lt;int&gt; visit;    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        edge.resize(numCourses);        visit.resize(numCourses);         for (auto&amp; it : prerequisites)            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边        for (int i = 0; i &lt; numCourses; ++i)            if (visit[i] == 0)              // 未访问的节点，每一个都判断防止森林的情况                &#123;                    if (!recursion(i)) return false;                &#125;        return true;            &#125;    bool recursion(int i)    &#123;        visit[i] = 1;               // 表示正在访问，还未完成        for (auto sub : edge[i])        // 寻找子节点        &#123;            if (visit[sub] == 0)                &#123;                    if (!recursion(sub)) return false;                &#125;         // 表明子节点存在环，直接返回无需设为已完成            else if(visit[sub] == 1)      // 访问到正在访问的节点，表明出现环                return false;        &#125;        visit[i] = 2;               // 完成访问        return true;    &#125;&#125;;\n\n2. 广度优先搜索\n用队列维护没有入度的节点，然后对每个子节点的入度减一，然后添加子节点到队列，记录的子节点数量和题目要求的值相同表明可以完成课程\nclass Solution &#123;public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;vector&lt;int&gt;&gt; edge;        vector&lt;int&gt; inEdge;        edge.resize(numCourses);        inEdge.resize(numCourses);         for (auto&amp; it : prerequisites)        &#123;            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边            ++inEdge[it[0]];                    // 入边的数量        &#125;        queue&lt;int&gt; q;        int allNum = 0;        for (int i = 0; i &lt; numCourses; ++i)        // 没有入度的节点            if (inEdge[i] == 0) q.push(i);        while (!q.empty())        &#123;            ++allNum;            int cur = q.front();            q.pop();            for (auto&amp; sub : edge[cur])            &#123;                --inEdge[sub];                if (inEdge[sub] == 0) q.push(sub);            &#125;        &#125;        return allNum == numCourses;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"Modelica之带迁移的掠食者猎物方程","url":"/posts/a129a992/","content":"一、经典 LV：单区域两物种\n目标：在经典的掠食-猎物（Lotka–Volterra, LV）两物种模型上，加入区域间迁移。\n做法：把每个区域都当作一个“本地 LV 子系统”，然后用“扩散式”迁移把同类物种在相邻区域之间耦合（从高密度流向低密度），并保证总量守恒。\n最小两区域（A、B）方程：\nx˙A=αxA−βxAyA+Dx(xB−xA),y˙A=δxAyA−γyA+Dy(yB−yA),x˙B=αxB−βxByB+Dx(xA−xB),y˙B=δxByB−γyB+Dy(yA−yB).\\begin{aligned}\n\\dot x_A &amp;= \\alpha x_A - \\beta x_A y_A + D_x (x_B - x_A),\\\\\n\\dot y_A &amp;= \\delta x_A y_A - \\gamma y_A + D_y (y_B - y_A),\\\\\n\\dot x_B &amp;= \\alpha x_B - \\beta x_B y_B + D_x (x_A - x_B),\\\\\n\\dot y_B &amp;= \\delta x_B y_B - \\gamma y_B + D_y (y_A - y_B).\n\\end{aligned}\nx˙A​y˙​A​x˙B​y˙​B​​=αxA​−βxA​yA​+Dx​(xB​−xA​),=δxA​yA​−γyA​+Dy​(yB​−yA​),=αxB​−βxB​yB​+Dx​(xA​−xB​),=δxB​yB​−γyB​+Dy​(yA​−yB​).​\n\n二、代码讲解\n\n⚠️：下述代码仅代表部分功能实现的示例，并不是完整代码，完整代码后续会考虑上传至GitHub\n\n1) 接口层：Interfaces.Species\n作用：一根线同时承载两个量：种群数量（population）和对它的“作用流”（rate，flow 变量）。\nconnector Species &quot;物种连接器：传递种群数量与通量&quot;  Real population &quot;种群数量&quot;;  flow Real rate &quot;作用于种群的通量（正为流入，负为流出）&quot;;  annotation(Icon(graphics=&#123;      Rectangle(extent=&#123;&#123;-80,60&#125;,&#123;80,-60&#125;&#125;, lineColor=&#123;0,0,0&#125;, fillColor=&#123;220,220,255&#125;),      Text(extent=&#123;&#123;-80,65&#125;,&#123;80,85&#125;&#125;, string=&quot;物种&quot;, fontSize=12)&#125;),            Documentation(info=&quot;&lt;html&gt;&lt;p&gt;用于在组件之间传递“种群数量（population）”与其变化通量（rate）。&lt;/p&gt;&lt;/html&gt;&quot;));end Species;\n\n2) 基础组件：繁殖/饥饿/捕食\n\n\nReproduction（繁殖）：对单一物种，增长与数量成正比\nmodel Reproduction &quot;繁殖：增长与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real alpha &quot;出生率比例系数 α&quot;;equation  growth = alpha * species.population &quot;增长 ~ α·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;繁殖&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;繁殖项：&lt;code&gt;growth = α·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Reproduction;\n\n\nStarvation（饥饿/自然死亡）：对单一物种，衰退与数量成正比\nmodel Starvation &quot;饥饿：衰退与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real gamma &quot;饥饿（死亡）系数 γ&quot;;equation  decline = gamma * species.population &quot;衰退 ~ γ·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,220,220&#125;, lineColor=&#123;150,0,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;饥饿&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;饥饿/自然死亡项：&lt;code&gt;decline = γ·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Starvation;\n\n\nPredation（捕食）：两物种相互作用（A=猎物，B=掠食者）\nmodel Predation &quot;捕食：A为猎物，B为捕食者&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Interaction;  parameter Real beta  &quot;猎物被捕食系数 β&quot;;  parameter Real delta &quot;捕食者摄食增殖系数 δ&quot;;equation  b_growth = delta * a.population * b.population &quot;B增长 ~ δ·A·B&quot;;  a_decline = beta  * a.population * b.population &quot;A衰退 ~ β·A·B&quot;;  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,240,200&#125;, lineColor=&#123;120,60,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;捕食&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;经典 Lotka–Volterra 捕食项。&lt;/p&gt;&lt;/html&gt;&quot;));end Predation;\n\n\n\n3) 区域内状态持有者：RegionalPopulation\n作用：把连接器里的 rate 积分成状态 population；这是唯一持有微分方程的地方。\nmodel RegionalPopulation &quot;区域内的单物种种群（带初始化选项）&quot;  encapsulated type InitializationOptions = enumeration(    Free &quot;自由：不施加额外初值条件&quot;,    FixedPopulation &quot;固定初值：指定初始种群&quot;,    SteadyState &quot;稳态：初始导数为0&quot;);  parameter InitializationOptions init = InitializationOptions.Free     annotation(Dialog(group=&quot;初始化&quot;));  parameter Real initial_population = 10     annotation(Dialog(group=&quot;初始化&quot;, enable=init==InitializationOptions.FixedPopulation));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species species     annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  Real population(start=initial_population) &quot;内部状态 = 外部连接器的 population&quot;;initial equation  if init == InitializationOptions.FixedPopulation then    population = initial_population;  elseif init == InitializationOptions.SteadyState then    der(population) = 0;  end if;equation  der(population) = species.rate;  species.population = population;  assert(population &gt;= 0, &quot;种群数量必须非负&quot;);  annotation(Icon(graphics=&#123;    Circle(extent=&#123;&#123;-40,40&#125;,&#123;40,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-50,45&#125;,&#123;50,65&#125;&#125;, string=&quot;区域种群&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;区域内的单物种状态持有者，&lt;code&gt;der(population) = rate&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end RegionalPopulation;\n\n4) 区域两物种子系统：TwoSpecies\n作用：组装“兔-狐”这对物种在单一区域内的 LV 过程。\nmodel TwoSpecies &quot;区域两物种（兔-狐）Lotka–Volterra 子系统&quot;  import RegionalPopulation = ModelicaByExample_CN.Components.LotkaVolterra.Components.RegionalPopulation;  import Reproduction      = ModelicaByExample_CN.Components.LotkaVolterra.Components.Reproduction;  import Starvation        = ModelicaByExample_CN.Components.LotkaVolterra.Components.Starvation;  import Predation         = ModelicaByExample_CN.Components.LotkaVolterra.Components.Predation;  parameter Real alpha = 0.1 &quot;兔出生率 α&quot;;  parameter Real gamma = 0.4 &quot;狐饥饿系数 γ&quot;;  parameter Real initial_rabbit_population = 10 &quot;兔初始数量&quot;;  parameter Real initial_fox_population    = 10 &quot;狐初始数量&quot;;  parameter Real beta  = 0.02 &quot;兔被捕食系数 β&quot;;  parameter Real delta = 0.02 &quot;狐摄食增殖系数 δ&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbits    &quot;本区域的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-10&#125;,&#123;-90,10&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species foxes    &quot;本区域的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  RegionalPopulation rabbit_population(    initial_population=initial_rabbit_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;-60,-10&#125;,&#123;-40,10&#125;&#125;)));  Reproduction reproduction(alpha=alpha)     annotation(Placement(transformation(extent=&#123;&#123;-80,30&#125;,&#123;-60,50&#125;&#125;)));  RegionalPopulation fox_population(    initial_population=initial_fox_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;40,-10&#125;,&#123;60,10&#125;&#125;)));  Starvation fox_starvation(gamma=gamma)     annotation(Placement(transformation(extent=&#123;&#123;60,30&#125;,&#123;80,50&#125;&#125;)));  Predation fox_predation(beta=beta, delta=delta)     annotation(Placement(transformation(extent=&#123;&#123;-10,-10&#125;,&#123;10,10&#125;&#125;)));equation  connect(reproduction.species,      rabbit_population.species);  connect(fox_predation.a,           rabbit_population.species);  connect(fox_starvation.species,    fox_population.species);  connect(fox_population.species,    fox_predation.b);  connect(rabbit_population.species, rabbits);  connect(fox_population.species,    foxes);  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,60&#125;,&#123;60,-60&#125;&#125;, fillColor=&#123;255,255,200&#125;, lineColor=&#123;0,0,0&#125;),    Text(extent=&#123;&#123;-60,65&#125;,&#123;60,85&#125;&#125;, string=&quot;两物种区域&quot;, fontSize=12)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;该子系统组合了：兔（繁殖）+ 狐（饥饿）+ 捕食（A=兔,B=狐）。&lt;/p&gt;&lt;/html&gt;&quot;));end TwoSpecies;\n\n5) 迁移组件：Migration\n作用：把两个区域的同类物种通过“差驱动扩散 + 守恒约束”耦合。\nA端： rateA=k (XA−XB),守恒： rateA+rateB=0.\\text{A端：}\\ \\text{rate}_A = k\\,(X_A - X_B),\\qquad\n\\text{守恒：}\\ \\text{rate}_A + \\text{rate}_B = 0.\nA端： rateA​=k(XA​−XB​),守恒： rateA​+rateB​=0.\nmodel Migration &quot;迁移（扩散）模型：A↔B 两区域&quot;  parameter Real rabbit_migration = 0.001 &quot;兔迁移率&quot;;  parameter Real fox_migration    = 0.005 &quot;狐迁移率&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_a    &quot;区域A的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-40&#125;,&#123;-90,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_b    &quot;区域B的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-40&#125;,&#123;110,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_a    &quot;区域A的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,20&#125;,&#123;-90,40&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_b    &quot;区域B的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,20&#125;,&#123;110,40&#125;&#125;)));equation  // 兔扩散：按两区数量差迁移 + 总量守恒  rabbit_a.rate = (rabbit_a.population - rabbit_b.population) * rabbit_migration;  rabbit_a.rate + rabbit_b.rate = 0 &quot;兔总量守恒&quot;;  // 狐扩散：按两区数量差迁移 + 总量守恒  fox_a.rate    = (fox_a.population    - fox_b.population)    * fox_migration;  fox_a.rate + fox_b.rate = 0 &quot;狐总量守恒&quot;;  annotation(Icon(graphics=&#123;    Line(points=&#123;&#123;-50,0&#125;,&#123;50,0&#125;&#125;, color=&#123;0,0,150&#125;),    Polygon(points=&#123;&#123;45,5&#125;,&#123;55,0&#125;,&#123;45,-5&#125;&#125;, fillPattern=FillPattern.Solid),    Text(extent=&#123;&#123;-60,10&#125;,&#123;60,30&#125;&#125;, string=&quot;迁移&quot;, fontSize=11)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;扩散式迁移：通量与两区域人口差成正比，并通过方程 &lt;code&gt;a.rate + b.rate = 0&lt;/code&gt; 保证总量守恒。&lt;/p&gt;&lt;/html&gt;&quot;));end Migration;\n\n6) 顶层系统：WithMigration\n四个区域（A,B,C,D 都是 TwoSpecies），用三段 Migration 串联成 A↔B↔C↔D。\nmodel WithMigration &quot;四区域：相邻迁移耦合（A↔B↔C↔D）&quot;  extends InitiallyDifferent;  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_AB    &quot;A↔B 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-60,10&#125;,&#123;-20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_BC    &quot;B↔C 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-20,10&#125;,&#123;20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_CD    &quot;C↔D 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;20,10&#125;,&#123;60,30&#125;&#125;)));equation  connect(migrate_AB.rabbit_a, A.rabbits);  connect(migrate_AB.rabbit_b, B.rabbits);  connect(migrate_AB.fox_a,    A.foxes);  connect(migrate_AB.fox_b,    B.foxes);  connect(migrate_BC.rabbit_a, B.rabbits);  connect(migrate_BC.rabbit_b, C.rabbits);  connect(migrate_BC.fox_a,    B.foxes);  connect(migrate_BC.fox_b,    C.foxes);  connect(migrate_CD.rabbit_a, C.rabbits);  connect(migrate_CD.rabbit_b, D.rabbits);  connect(migrate_CD.fox_a,    C.foxes);  connect(migrate_CD.fox_b,    D.foxes);end WithMigration;\n\n三、仿真运行\n在 OpenModelica / MWorks 中使用\nOpenModelica / OMEdit：\n\nFile → Open Model/Library… 选择 ModelicaByExample_CN/package.mo\n打开：ModelicaByExample_CN.Subsystems.LotkaVolterra.Examples.WithMigration\nStopTime = 200，点击 Simulate\nPlot：A.rabbits.population、A.foxes.population、…、D.*\n\nMWorks：\n若对 MSL 版本敏感，把顶层 package.mo 中的\nannotation(uses(Modelica(version=&quot;4.0.0&quot;)))\n改成 MWorks 支持的版本（如 4.1.3），然后直接打开package.mo即可。\n\n结果展示\n各个不同的颜色分别代表了不同区域兔子和狐狸的数量\n\n","categories":["Modelica"],"tags":["Modelica","仿真","综合仿真平台开发"]},{"title":"Python实战之Web开发-续","url":"/posts/71a5f1f6/","content":"用户账户\n用户添加主题\n在learning_log目录中创建forms.py文件，添加\nfrom django import formsfrom .models import Topicclass TopicForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating topics.&quot;&quot;&quot;    class Meta:        model = Topic        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field\n添加URL：path('new_topic/', views.new_topic, name='new_topic')\n创建视图函数new_topic\ndef new_topic(request):    &quot;&quot;&quot;Add a new topic.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = TopicForm()    else:        # POST data submitted; process data.        form = TopicForm(data=request.POST)        if form.is_valid():            new_topic = form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=new_topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_topic.html&#x27;, context)\n创建模板new_topic.html\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Add a new topic:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;\n链接到页面：&lt;a href = &quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt;\n代码解释：当用户在网页中点击 &lt;a href=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt; 这个链接时，浏览器会跳转到 /new_topic/。这个路径在 urls.py 中由 path('new_topic/', views.new_topic, name='new_topic') 映射到 views.new_topic 函数。\n当请求被送到这个视图函数时，Django 会调用 new_topic(request) 来处理。这个视图首先判断请求的方法是不是 POST。如果用户只是点击链接，还没提交表单，那么请求方法是 GET，程序会创建一个空的表单对象 form = TopicForm()，此时这个表单中没有预填数据，只是用于初次显示在网页上。\n如果用户已经在表单中输入了内容并点击了提交按钮，那么浏览器发送的是 POST 请求，此时视图就会执行 form = TopicForm(data=request.POST) 来从用户提交的数据构造一个表单实例。接着通过 form.is_valid() 检查数据是否合法（比如字段有没有漏填，格式是否正确）。如果验证通过，就执行 form.save()，这会自动创建一条新的 Topic 记录并保存到数据库中。接着用 redirect('learning_log:topic', topic_id=new_topic.id) 跳转到刚创建的主题详情页。\n不论是初次打开页面，还是提交失败（例如空表单或非法输入），视图最后都会调用 render(request, 'learning_log/new_topic.html', context) 来渲染模板，把表单对象传入 context 变量中。\n这个模板 new_topic.html 继承自 base.html，并在 &#123;% block content %&#125; 中放入了一段 HTML 表单。&lt;form action=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot; method=&quot;post&quot;&gt; 声明了该表单提交回自己；&#123;% csrf_token %&#125; 是 Django 要求添加的防跨站攻击标记；&#123;&#123; form.as_div &#125;&#125; 是将表单对象渲染为 HTML 元素。最后 &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt; 是提交按钮。\n添加条目\n代码如下\n# 新建formclass EntryForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating entries.&quot;&quot;&quot;    class Meta:        model = Entry        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field        widgets = &#123;&#x27;text&#x27;: forms.Textarea(attrs=&#123;&#x27;cols&#x27;: 80&#125;)&#125;  # Wider text area        # 添加URLpath(&#x27;new_entry/&lt;int:topic_id&gt;/&#x27;, views.new_entry, name=&#x27;new_entry&#x27;)# 添加视图def new_entry(request, topic_id):    &quot;&quot;&quot;Add a new entry for a particular topic.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = EntryForm()    else:        # POST data submitted; process data.        form = EntryForm(data=request.POST)        if form.is_valid():            new_entry = form.save(commit=False)            new_entry.topic = topic            new_entry.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic_id)    # Display a blank or invalid form.    context = &#123;&#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_entry.html&#x27;, context)\n&#123;# 新建模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Add a new entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Entry&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add a new entry&lt;/a&gt;    &lt;/p&gt;\n代码解释：这一套代码实现了在某个具体主题（Topic）下添加新学习内容（Entry）的功能。它包括一个基于模型的表单 EntryForm，用于生成输入框，主要针对 Entry 模型中的 text 字段，并通过 widgets 设置了一个宽一些的多行文本区域。URL 配置中使用了路径参数 &lt;int:topic_id&gt; 来标识具体主题，这样不同主题就能通过不同链接添加各自的学习记录。视图函数 new_entry 首先获取对应的 Topic 实例，然后根据请求方法判断是初次访问还是表单提交。如果是提交请求，就根据提交内容构造表单并校验，若通过验证，就先创建一个未保存的 Entry 实例，手动指定其 topic 属性，然后保存到数据库，并跳转回该主题的详情页。\n模板部分继承自基础模板 base.html，显示了当前主题的名称，并提供一个表单用于输入新条目。提交按钮下方还包含一个返回原主题页面的链接。最后那段 HTML 链接代码负责在主题详情页中显示“Add a new entry”按钮，点击即可跳转到添加页面。\n\n编辑条目\n代码如下\n# 添加URLpath(&#x27;edit_entry/&lt;int:entry_id&gt;/&#x27;, views.edit_entry, name=&#x27;edit_entry&#x27;)# 添加edit_entry函数def edit_entry(request, entry_id):    &quot;&quot;&quot;Edit an existing entry.&quot;&quot;&quot;    entry = Entry.objects.get(id=entry_id)    topic = entry.topic    if request.method != &#x27;POST&#x27;:        # Initial request; pre-fill form with the current entry.        form = EntryForm(instance=entry)    else:        # POST data submitted; process data.        form = EntryForm(instance=entry, data=request.POST)        if form.is_valid():            form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;entry&#x27;: entry, &#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/edit_entry.html&#x27;, context)\n&#123;# 添加html #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Edit entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Save Changes&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;&lt;li&gt;    &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;Edit entry&lt;/a&gt;    &lt;/p&gt;&lt;/li&gt;\n创建用户\n首先创建一个新的应用程序来管理账户相关的内容\npython .\\manage.py startapp accounts\n在INSTALLED_APPS中添加accounts，并包含accounts的URL：path('accounts/', include('accounts.urls'))\n在accounts中新建urls.py，添加以下内容\nfrom django.urls import path, includeapp_name = &#x27;accounts&#x27;urlpatterns = [    # Include the default auth URLs    path(&#x27;&#x27;, include(&#x27;django.contrib.auth.urls&#x27;)),]\n在templates中新建registration文件夹，添加login.html文件\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;  &#123;% if form.errors %&#125;    &lt;p&gt;Your username and password didn&#x27;t match. Please try again.&lt;/p&gt;  &#123;% endif %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Log in&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;\n随后在settings中添加成功登录后的重定向地址：LOGIN_REDIRECT_URL = 'learning_log:index'\n修改base.html如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt; -    &lt;a href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;Topics&lt;/a&gt; -     &#123;% if user.is_authenticated %&#125;        Hello, &#123;&#123; user.username &#125;&#125;! -        &#123;% else %&#125;        &lt;a href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;Log in&lt;/a&gt; -        &#123;% endif %&#125;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n此时就可以通过http://localhost:8000/accounts/login/来登录了，可以使用我们的管理员账号来测试（提前在管理界面退出）\n\n注销和注册用户\n注销账户\n在base.html中添加注销表单\n&#123;% if user.is_authenticated %&#125;  &lt;hr /&gt;  &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &lt;button name=&#x27;submit&#x27;&gt;Log out&lt;/button&gt;  &lt;/form&gt;&#123;% endif %&#125;\n如果账户登录，那么则在最下方显示一个注销按钮用于注销账户，注销后将页面链接到主页：LOGOUT_REDIRECT_URL = 'learning_log:index'\n注册账户\n# 添加URLpath(&#x27;register/&#x27;, views.register, name=&#x27;register&#x27;)# 创建视图函数def register(request):    &quot;&quot;&quot;Register a new user.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # Display blank registration form.        form = UserCreationForm()    else:        # Process completed form.        form = UserCreationForm(data=request.POST)        if form.is_valid():            new_user = form.save()            # Log the user in and then redirect to home page.            login(request, new_user)            return redirect(&#x27;learning_log:index&#x27;)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;registration/register.html&#x27;, context)\n&#123;# 创建模板 #&#125;&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Register&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接注册界面 #&#125;&lt;a href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register&lt;/a&gt; -\n当用户登录后，base.html 会显示一个“注销”按钮，它触发的是 accounts:logout 路由（即 Django 默认的登出视图），并通过 LOGOUT_REDIRECT_URL = 'learning_log:index' 设置注销后跳转回主页。\n对于注册功能，定义了一个新的 URL 路由 /accounts/register/，并在对应视图函数 register() 中使用 Django 提供的 UserCreationForm 构建注册表单。如果请求为 POST，则处理表单提交并保存用户数据，注册成功后自动登录该用户，并重定向到主页。否则显示一个空白或验证失败的注册表单。\n前端模板继承自 base.html，通过 &#123;% csrf_token %&#125; 加入安全标记，表单本体使用 &#123;&#123; form.as_div &#125;&#125; 渲染输入字段，点击“Register”按钮即可提交注册。\n创建用户数据\n在未登录的状态下，learning_log中的内容除了主页外，其余内容应该均不可访问，对此我们通过装饰器@login_required来限制未登录用户的访问，如果用户未登录，我们将其重定向到登录界面，在settings中添加LOGIN_URL = 'accounts:login'即可\n对于不同的用户，除了主页外，其他的内容应该只能访问自己的部分，我们将数据关联到用户，在Topic中添加owner = models.ForeignKey(User, on_delete=models.CASCADE)，将主题与用户关联。然后把数据库中的内容进行迁移，由于我们新增了owner字段，迁移时会提示我们选择哪一种方式，我们选择“1”让系统自动给我们添加一个默认值，然后将所有的内容迁移到管理账户中，即ID“1”\n\n虽然把主题全部与管理账户进行了关联，但是目前任何用户登录均可访问所有主题，在topics中添加topics = Topic.objects.filter(owner=request.user).order_by('date_added')，将不属于当前用户的所有Topic过滤掉，然后在topic和edit_entry中添加以下代码\nif topic.owner != request.user:    raise Http404\n从而防止用户通过网址直接访问他人的数据\n最后将新的topic关联到当前用户中，添加代码如下\nnew_topic = form.save(commit=False)new_topic.owner = request.usernew_topic.save()\n此时任何用户都可创建自己的账号并拥有自己独立的数据了\n样式更改\n我们的web已经具备基本的功能了，如创建主题、创建与之关联的条目，并且每个用户都有自己的数据而不必担心被其他人访问，但我们的界面还过于简陋，无法吸引用户，因此接下来我们将更改它的布局，使其更加美观\n首先安装django-bootstrap5，我们将使用其中的模板\npip install django-bootstrap5\n然后在INSTALLED_APPS中我们的应用和默认应用之间添加django_bootstrap5，接下来修改base.html\n&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Learning Log&lt;/title&gt;  &#123;% load django_bootstrap5 %&#125;  &#123;% bootstrap_css %&#125;  &#123;% bootstrap_javascript %&#125;&lt;/head&gt;&lt;body&gt;  &lt;nav class=&quot;navbar navbar-expand-md navbar-light bg-light mb-4 border&quot;&gt;    &lt;div class=&quot;container-fluid&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;          Learning Log&lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot;        data-bs-target=&quot;#navbarCollapse&quot; aria-controls=&quot;navbarCollapse&quot;        aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarCollapse&quot;&gt;        &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-md-0&quot;&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;              Topics&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt; &lt;!-- End of links on left side of navbar --&gt;        &lt;!-- Account-related links --&gt;        &lt;ul class=&quot;navbar-nav ms-auto mb-2 mb-md-0&quot;&gt;          &#123;% if user.is_authenticated %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;span class=&quot;navbar-text me-2&quot;&gt;Hello, &#123;&#123; user.username &#125;&#125;.                &lt;/span&gt;&lt;/li&gt;          &#123;% else %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;                  Register&lt;/a&gt;&lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;                  Log in&lt;/a&gt;&lt;/li&gt;          &#123;% endif %&#125;        &lt;/ul&gt; &lt;!-- End of account-related links --&gt;        &#123;% if user.is_authenticated %&#125;          &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;            &#123;% csrf_token %&#125;            &lt;button name=&#x27;submit&#x27; class=&#x27;btn btn-outline-secondary btn-sm&#x27;&gt;              Log out&lt;/button&gt;          &lt;/form&gt;        &#123;% endif %&#125;      &lt;/div&gt; &lt;!-- Closes collapsible parts of navbar --&gt;    &lt;/div&gt; &lt;!-- Closes navbar&#x27;s container --&gt;  &lt;/nav&gt; &lt;!-- End of navbar --&gt;  &lt;main class=&quot;container&quot;&gt;    &lt;div class=&quot;pb-2 mb-2 border-bottom&quot;&gt;      &#123;% block page_header %&#125;&#123;% endblock page_header %&#125;    &lt;/div&gt;    &lt;div&gt;      &#123;% block content %&#125;&#123;% endblock content %&#125;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;&lt;/html&gt;\n修改主页index.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;div class=&quot;p-3 mb-4 bg-light border rounded-3&quot;&gt;    &lt;div class=&quot;container-fluid py-4&quot;&gt;      &lt;h1 class=&quot;display-3&quot;&gt;Track your learning.&lt;/h1&gt;            &lt;p class=&quot;lead&quot;&gt;Make your own Learning Log, and keep a list of the      topics you&#x27;re learning about. Whenever you learn something new      about a topic, make an entry summarizing what you&#x27;ve learned.&lt;/p&gt;      &lt;a class=&quot;btn btn-primary btn-lg mt-1&quot;          href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register &amp;raquo;&lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;&#123;% endblock page_header %&#125;\n修改登录界面login.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% load django_bootstrap5 %&#125;&#123;% block page_header %&#125;  &lt;h2&gt;Log in to your account.&lt;/h2&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;% bootstrap_form form %&#125;    &#123;% bootstrap_button button_type=&quot;submit&quot; content=&quot;Log in&quot; %&#125;  &lt;/form&gt;&#123;% endblock content %&#125;\n修改页面topics的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;Topics&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;ul class=&quot;list-group border-bottom pb-2 mb-4&quot;&gt;    &#123;% for topic in topics %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;          &#123;&#123; topic.text &#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &#123;% empty %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;No topics have been added yet.&lt;/li&gt;    &#123;% endfor %&#125;  &lt;/ul&gt;  &lt;a href=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;&gt;Add a new topic&lt;/a&gt;&#123;% endblock content %&#125;\n修改页面topic条目的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;&#123;&#123; topic.text &#125;&#125;&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add new entry&lt;/a&gt;  &lt;/p&gt;  &#123;% for entry in entries %&#125;    &lt;div class=&quot;card mb-3&quot;&gt;      &lt;!-- Card header with timestamp and edit link --&gt;      &lt;h4 class=&quot;card-header&quot;&gt;        &#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;        &lt;small&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;          edit entry&lt;/a&gt;&lt;/small&gt;      &lt;/h4&gt;      &lt;!-- Card body with entry text --&gt;      &lt;div class=&quot;card-body&quot;&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &#123;% empty %&#125;    &lt;p&gt;There are no entries for this topic yet.&lt;/p&gt;  &#123;% endfor %&#125;&#123;% endblock content %&#125;\n修改后的界面如下\n\n项目部署\n这部分内容主要就是把项目部署到远程服务器上，让其他人访问，全是配置，没啥意思，不搞了\n","categories":["Django开发"],"tags":["Python"]},{"title":"Python实战之Web开发","url":"/posts/1a56256/","content":"创建Django项目\n我使用Pycharm来创建Django项目，也可以自己手动创建虚拟环境等，配置如下，所有代码可点击这里查看\n\n运行，在浏览器输入http://localhost:8000/，显示如下表明项目创建正确\n\n创建应用程序\n终端输入python manage.py migrate创建数据库，用于将项目相关的信息存储，然后输入python manage.py startapp learning_log来创建应用程序，项目结构如下\n\n.venv/\n\nPython 虚拟环境目录。\n包含你项目安装的所有依赖（如 Django）。\n通常会在 .gitignore 中忽略它。\n\nmanage.py\n\n\n管理工具脚本，用于执行各种 Django 命令，如：\npython manage.py runserver      # 启动开发服务器python manage.py makemigrations # 创建迁移python manage.py migrate        # 应用迁移到数据库python manage.py createsuperuser # 创建管理员账户\n\n\n__init__.py\n\n让该目录成为 Python 包可为空\n\nsettings.py\n\nDjango 项目的配置文件\n包含数据库设置、应用注册、模板路径、静态文件配置、安全设置等\n\nurls.py\n\n\n项目级URL 路由入口\n\n\n将不同的 URL 请求分发给对应的 app 处理\n\n\n通常写法：\nfrom django.urls import path, includeurlpatterns = [    path(&#x27;admin/&#x27;, admin.site.urls),    path(&#x27;&#x27;, include(&#x27;learning_log.urls&#x27;)),  # 指向 app 的 url]\n\n\nwsgi.py\n\n用于部署到 WSGI 服务器\n生产环境使用\n\nasgi.py\n\n用于部署到 ASGI 服务器\n用于支持 WebSocket、异步视图\n\n__init__.py\n\n表示这是一个 Python 包\n\nadmin.py\n\n\n用于注册模型到 Django 管理后台（admin site）\n\n\n示例：\nfrom django.contrib import adminfrom .models import Entryadmin.site.register(Entry)\n\n\napps.py\n\n定义 app 的元信息，通常不需修改\n当你在 INSTALLED_APPS 中注册 app 时，这里也会用到\n\nmodels.py\n\n定义数据模型（Model）类\n每个模型对应数据库中的一张表\n\nviews.py\n\n视图函数，用来处理用户请求并返回响应\n例如返回 HTML 页面、JSON 数据等\n\ntests.py\n\n单元测试文件，可编写自动化测试\nDjango 内建测试框架基于 Python 的 unittest\n\nmigrations/\n\n\n自动生成的数据库迁移文件\n\n\n每当你修改模型（models.py）并运行：\npython manage.py makemigrations\n就会在此生成一个迁移脚本，用于记录数据库变更\n\n\ntemplates/\n\n存放 HTML 模板文件的目录\n用于 Django 的模板引擎渲染页面\n\n例如：\n你可以在 templates/ 中创建 index.html，然后在视图中渲染：\nfrom django.shortcuts import renderdef index(request):    return render(request, &#x27;index.html&#x27;)\ndb.sqlite3\n\n默认使用的 SQLite 数据库文件\n存储了你项目所有模型的数据内容\n\n\n\n\n文件/文件夹\n作用说明\n\n\n\n\n.venv/\n虚拟环境，包含依赖\n\n\nmanage.py\n管理命令脚本\n\n\nDjangoProject/settings.py\n项目配置\n\n\nDjangoProject/urls.py\nURL 路由入口\n\n\nDjangoProject/wsgi.py\n部署用 WSGI 接口\n\n\nlearning_log/\n自定义 app\n\n\nmodels.py\n定义数据库模型\n\n\nviews.py\n编写视图函数\n\n\nadmin.py\n注册后台模型\n\n\nmigrations/\n数据库变更记录\n\n\ntemplates/\nHTML 模板目录\n\n\ndb.sqlite3\nSQLite 数据库文件\n\n\n\n应用设置\n修改models.py文件如下\nfrom django.db import models# Create your models here.class Topic(models.Model):    &quot;&quot;&quot;A topic the user is learning about.&quot;&quot;&quot;    text = models.CharField(max_length=200)    date_added = models.DateTimeField(auto_now_add=True)    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        return self.text\n在settings.py的INSTALLED_APPS中添加learning_log，然后执行数据库迁移，如下\npython manage.py makemigrationspython manage.py migrate \n\n创建超级用户\n输入python manage.py createsuperuser来创建管理者，账户名、密码、邮箱自行设置，其中密码会被隐藏\n\n随后在admin.py文件中修改代码如下\nfrom django.contrib import adminfrom learning_log.models import Topic# Register your models here.admin.site.register(Topic)\n这段代码用于向管理网站注册Topic\n由于我在创建项目时没有勾选“启用Django admin”，因此这里需要对项目进行简单的更改\n\n\n将urls.py中注释的部分取消\n# from django.contrib import adminfrom django.urls import pathurlpatterns = [    #    path(&#x27;admin/&#x27;, admin.site.urls),]\n\n\n在settings.py的INSTALLED_APPS中添加django.contrib.admin\n\n\n访问http://localhost:8000/admin/，显示如下\n\n输入账户和密码，登录进去界面显示如下\n\nUser和Group是Django自动在管理网站添加的模型，而Topic是我们刚刚自己添加的。此时可以点击Topic，添加任意的主题\n定义Entry\n在models.py中添加如下代码\nclass Entry(models.Model):    &quot;&quot;&quot;Something specific learned about a topic.&quot;&quot;&quot;    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)    text = models.TextField()    date_added = models.DateTimeField(auto_now_add=True)    class Meta:        verbose_name_plural = &#x27;entries&#x27;    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        if len(self.text) &gt; 50:            return f&quot;&#123;self.text[:50]&#125;...&quot;        else:            return self.text\n这里主要说一下两个地方\n\n\ntopic = models.ForeignKey(Topic, on_delete=models.CASCADE)是将每一条 Entry 都关联一个 Topic，形成多对一的关系\n\n\n元信息配置（Meta）：默认 Django 会把模型名称小写加 “s” 做复数，这句是为了告诉 Django这个模型的复数名称设置为 entries，而不是默认的 Entrys\n\n\n由于修改了模型文件，因此我们需要再次迁移数据库，执行\npython manage.py makemigrations learning_logpython manage.py migrate \n然后在管理网站注册Entry：admin.site.register(Entry)（有关模型导入的问题这里不做叙述）\n进入管理网站后会发现多出了一个Entries条目，进入该条目，点击下拉框就可以选择对应的主题，如下图\n\n这时候我们就可以创建条目并将其与对应的主题相关联。不过，目前除了后台管理界面，我们还没任何可供用户访问的界面，下一步我们将尝试创建一个网页来让其他人访问\n创建网页\n使用Django创建网页主要分为三个步骤，定义URL、编写视图、编写模板，完成这三个部分的顺序通常无关紧要，每个人都可以按照个人喜好来实现\n映射URL\n当前http://localhost:8000返回默认的Django网站，下面进行修改，打开urls.py文件，在urlpatterns中添加path('', include('learning_log.urls')),表示我们导入应用learning_log中的url。然后在应用learning_log中添加urls.py文件，内容如下\nfrom django.urls import pathfrom . import viewsapp_name = &#x27;learning_log&#x27;urlpatterns = [    # Home page    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),]\n这段代码主要为当前 app 即（learning_log）配置 URL 路由，其中app_name = 'learning_log'，给这个 app 的 URL 配置一个命名空间，防止与其他 app 中的 URL 名称冲突，在模板中使用 &#123;% url 'learning_log:index' %&#125; 就能明确地调用这个 URL。urlpatterns 是 Django 查找 URL 的核心列表，每一个 path() 定义了一个 URL 与视图的映射。path('', views.index, name='index'),第一个参数是一个字符串用于正确的路由请求，这里表示匹配根路径，第二个参数表示当匹配到 / 时，调用 views.py 中的 index() 函数，第三个参数给这个 URL 取了一个名字叫 'index'，在模板中可以用 &#123;% url 'learning_log:index' %&#125; 来反向生成地址\n编写视图\n视图函数接受请求中的信息，准备好生成网页所需的数据，然后将其发送给浏览器。在前面我们调用了 views.py 中的 index() 函数，但该函数还未编写，打开views.py文件，添加代码如下\nfrom django.shortcuts import render# Create your views here.def index(request):    return render(request, &#x27;learning_log/index.html&#x27;)\n它接受一个 request 对象作为参数，这是 Django 在用户访问网页时自动传入的请求信息对象。函数的返回值是 render(request, 'learning_log/index.html')，表示让 Django 去找一个路径为 learning_log/index.html 的模板文件，并渲染它，默认的模板查找路径为app/templates/app_name/文件名.html\n编写模板\n模板定义网页的外观，每当访问网页时，Django都将填入相关的数据用于显示，我们的template文件夹位于根目录，所以无需在app目录中重新创建，但需要在settings.py的TEMPLATES中检查是否存在'DIRS': [BASE_DIR / 'templates']，以便正确检索html文件\n在template文件夹中创建learning_log文件夹并在其中创建index.html，添加代码如下\n&lt;p&gt;Learning Log&lt;/p&gt;&lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.&lt;/p&gt;\n这里添加了两个段落，运行访问界面如下\n\n创建其他网页\n创建父模板\n在index.html所在的目录中，创建一个base.html文件，这个模板将包含所有页面的通用元素，并将所有子模板都继承它，添加内容如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;\n这段表示页面顶部的一个链接，点击后会跳转到名为 'learning_log:index' 的 URL 对应的页面。\n\n&#123;% url 'learning_log:index' %&#125; 是 Django 模板语言提供的 URL 反向解析标签。\n'learning_log' 是在 learning_log/urls.py 中定义的 app_name。\n'index' 是在 urlpatterns 中为首页设置的 name。\n\n所以最终这个标签会被渲染为：\n&lt;a href=&quot;/&quot;&gt;Learning Log&lt;/a&gt;\n如果将 index 页面映射到 /，那么这个链接就是返回首页的作用。\n&#123;% block content %&#125;&#123;% endblock content %&#125;\n这是 Django 模板语言中非常关键的部分，称为 模板块（template block），它用于定义“可扩展区域”。\n解释如下：\n\n&#123;% block content %&#125;` 是定义一个名为 `content` 的内容区块。\n- `&#123;% endblock content %&#125; 表示这个区块的结束。\n\n换句话说，子模板可以继承这个模板，并用自己的内容替换掉这个 block 区域，例如：\n&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;h2&gt;This is the home page!&lt;/h2&gt;&#123;% endblock content %&#125;\n创建子模板\n重写index.html文件，使其继承base.html，如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.    &lt;/p&gt;&#123;% endblock content %&#125;\n这里将index从base继承下来，使用&#123;% block content %&#125;`定义一个`content`并插入内容，使用`&#123;% endblock content %&#125;结束content块，里面内容将显示在界面上，此时通过修改父模板将修改所有继承它的界面，方便统一管理\n显示所有主题的页面\n首先定义URL，添加path('topics/',  views.topics, name='topics')，在视图中定义topics函数如下\ndef topics(request):    &quot;&quot;&quot;Show all topics.&quot;&quot;&quot;    topics = Topic.objects.order_by(&#x27;date_added&#x27;)    context = &#123;&#x27;topics&#x27;: topics&#125;    return render(request, &#x27;learning_log/topics.html&#x27;, context)\n将所有主题按照时间顺序排序并返回，然后创建topics.html，内容如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topics&lt;/p&gt;    &lt;ul&gt;        &#123;% for topic in topics %&#125;            &lt;li&gt;&#123;&#123; topic.text &#125;&#125;&lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No topics have been created yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;&#123;% endblock content %&#125;\n这里主要将topics中的内容通过无序列表的方式呈现出来。随后在base.html中添加连字符以及代码&lt;a href=&quot;&#123;% url 'learning_log:topics' %&#125;&quot;&gt;Topics&lt;/a&gt;，这将产生一个与Topics匹配的URL链接，访问http://localhost:8000/topics/，如下![image-20250712114413813](https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/Python实战之Web开发%2F2025-07-12-23-47-46-91b35a.png)\n显示特定主题\n我们已经创建了两次页面，对其基本流程应该有所了解了，后续关于URL、视图、模板相关的内容将进行简略，我们再次创建一个页面用于显示特定的主题及其所有的条目\n# URLpath(&#x27;topics/&lt;int:topic_id&gt;/&#x27;, views.topic, name=&#x27;topic&#x27;)# topic函数def topic(request, topic_id):    &quot;&quot;&quot;Show a single topic and all its entries.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    entries = topic.entry_set.order_by(&#x27;-date_added&#x27;)    context = &#123;&#x27;topic&#x27;: topic, &#x27;entries&#x27;: entries&#125;    return render(request, &#x27;learning_log/topic.html&#x27;, context)\n&#123;# 模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topic:&#123;&#123; topic.text &#125;&#125;&lt;/p&gt;        &lt;p&gt;Entries:&lt;/p&gt;    &lt;ul&gt;            &#123;% for entry in entries %&#125;            &lt;li&gt;                &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;                &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;            &lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No entries have been created for this topic yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% endblock content %&#125;\n在topic函数中先通过id获取到特定的主题，然后将主题中的条目降序排列，最后将Topic和Entries返回。模板主要把entries按照特定的格式显示，“|”表示过滤符，也就是将时间按照：January 1, 2025 23:00格式。linebreaks是将文本中的换行符转变为浏览器理解的内容。\n然后修改topics.html，将每个主题都映射为对应的链接\n&#123;% for topic in topics %&#125;    &lt;li&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic.text &#125;&#125;&lt;/a&gt;    &lt;/li&gt;\n运行之后在Topic页面点击主题，显示如下\n\n","categories":["Django开发"],"tags":["Python"]},{"title":"Python实战之外星人入侵《一》","url":"/posts/25297ba4/","content":"武装飞船\n由于不经常用Python写程序，最近在用Python写一个可视化工具时，惊觉发现自己的Python水平严重下滑，因此又重新拿起了《Python编程-从入门到实践》这本书。\n经过简单的复习，觉得还是有必要把书中的项目给练习一遍，同时也通过Blog记录一下我的实现过程，该篇文章以及后续系列将会讲解这本书中的“外星人入侵”项目，经过第十二、十三、十四章的阅读，我觉得在开始编程之前有必要先分析一下要实现的功能以及项目的整体架构，姑且就按照书上的顺序来吧。\n这里我们需要四个类，分别是主程序类AlienInvasion、子弹类Bullet、设置类Settings、飞船类Ship，主程序类主要用于初始化游戏界面，然后通过循环来更新游戏，子弹类和飞船类主要用于自身属性的初始化、显示和更新位置，设置类主要包含游戏的界面大小、飞船和子弹的移动速度等。整体结构大致如下\n\n游戏入口\n我的IDE是Pycharm，首先创建一个名为 Alien-Invasion-Project 并初始化了git仓库的项目，后续的所有开发代码都将放到我的Gitghub Alien-Invasion-Project 同名仓库中，有兴趣可以访问查看。这里我们首先安装开发需要用到的模块pygame，使用命令pip instal pygame即可，如下\n\n提示“Successfully ……”表明安装成功，也可使用书中的命令python -m pip install --user pygame来安装\n初步实现界面\n先创建一个alien_invasion.py文件，用来实现界面的初始化，然后创建AlienInvasion类，添加如下代码\nimport  pygameclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.screen = pygame.display.set_mode((800, 600))        pygame.display.set_caption(&quot;外星人来喽&quot;)    def run_game(self):        # 游戏主循环        while True:            passif __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\n这里我们通过pygame.init()来实现游戏环境的初始化，然后设置了一个800*600的游戏界面，再通过pygame.display.set_caption(&quot;外星人来喽&quot;)来设置游戏界面的Title，同时我们定义一个run_game函数用来进入游戏，这里添加了一个while的死循环，通过pass占位符来保持界面的显示，并在main里面完成游戏类的实例化和进入游戏中的循环，运行程序，如下图\n\n大致就是一个黑框框，里面什么都没有，由于我们只初始化了游戏界面的大小和标题，因此不会有其他的内容，同时各位应该也能注意到运行之后电脑很卡，这是因为我们在程序中添加了一个死循环，下面我们来对程序进行优化\n优化界面\n我们在其中添加事件处理程序来监听事件，首先导入系统模块sys，然后删除pass，在循环中添加如下代码\nfor event in pygame.event.get():    if event.type == pygame.QUIT:        pygame.quit()        sys.exit()\n这段程序表明我们一直在监听事件，如果有退出的事件发生，我们将调用pygame和系统的退出函数来结束游戏的运行，这时候运行代码，就不会卡了，同时点击X号也能正常退出\n下一步我们对游戏界面填充背景色，同时控制游戏的刷新的帧率\n添加成员变量bg_color，并在while循环中通过screen.fill()来绘制屏幕，然后使用pygame.display.flip()来使屏幕显示出来，运行结果如下\n\n帧率的控制主要通过限制循环中屏幕刷新的时间来实现，添加成员变量clock来定义时钟，然后在循环的末尾启动计时，我们这里设个90帧，代码如下\nclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.clock = pygame.time.Clock()        ……    def run_game(self):        # 游戏主循环        while True:            ……            # 控制游戏帧率            self.clock.tick(90)\n封装Settings类\n为了方便，我们可以把游戏设置相关的内容统一组织起来，放入单独的类中，比如屏幕大小，背景颜色等\n创建settings.py文件，并在其中添加Settings类，将屏幕大小，背景颜色甚至帧率等添加到类中，如下\nclass Settings:    def __init__(self):        self.screen_width = 800        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;\n在主程序创建Settings的实例，并用其中的属性替换掉原来的硬编码行为，这样便于我们理解和组织代码以及后续拓展开发\n创建Ship类\n这里我们要在游戏界面创建一个飞船，首先需要准备一张照片，创建文件夹imgs，将书中源码位置的图片复制到imgs下，并添加新文件ship.py，Ship类要加载图片显示，初始位置应当位于屏幕中心底部，并且支持左右移动，代码如下\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(&#x27;imgs/ship.bmp&#x27;)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += 3        if self.moving_left and self.rect.left &gt; 0:            self.x -= 3        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n突然发现写博客还是比较费时间的，这里就不过多解释了，完成Ship类之后就需要对主程序进行更改了，我们对原来的代码进行重构，因为要添加左右移动的消息，所以将while循环中的内容简化，尽可能的封装为函数模块，大致分为事件检测、事件执行、飞船更新、屏幕更新等\n事件检测：\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP:            self._check_keyup_events(event)\n判断消息类型，如果是退出，就结束游戏，如果是键盘按键按下或者是键盘按键松开，则执行对应的函数\n事件执行：\ndef _check_keydown_events(self, event):    &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = True    elif event.key == pygame.K_LEFT:        self.ship.moving_left = True    elif event.key == pygame.K_q:        pygame.quit()        sys.exit()\n如果键盘按下，则判断按下的是哪一个键，右键激活飞船的右移动标识，左键则激活左移动标识，如果是q键，同样执行退出，这是为了方便用户结束游戏而不用每次都点击右上角X号\ndef _check_keyup_events(self, event):    &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = False    elif event.key == pygame.K_LEFT:        self.ship.moving_left = False\n如果键盘松开，则根据松开的按键来结束对应的移动标识\n屏幕更新：\ndef _update_screen(self):    &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;    self.screen.fill(self.settings.bg_color)    self.ship.draw()    pygame.display.flip()\n综上，while循环目前应该包含的内容如下\nwhile True:    # 监听事件    self._check_events()    # 更新飞船位置    self.ship.update()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n运行\n\n这个时候我们的飞船就可以正常移动了\n创建Bullet类\n首先创建bullet.py文件，在其中创建Bullet类，为了便于管理子弹，我们采用群组的方式将其继承Sprite，Bullet类应当包含颜色、大小、速度等，同时绘制自身并更新位置，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        self.color = (60, 60, 60)        self.rect = pygame.Rect(0, 0, 3, 15)               self.speed = 4        self.rect.midtop = self.game.ship.rect.midtop()        self.y = float(self.rect.y)    def update(self):        self.y -= self.speed        self.rect.y = self.y    def draw(self):        pygame.draw.rect(self.game.screen, self.color, self.rect)\n更改主程序代码，以pygame.sprite.Group()的方式创建子弹群组，在按下键盘事件中添加空格的侦听，并添加发射子弹的函数，然后在主循环中添加更新子弹的函数，用于更新子弹的位置并删除超出屏幕的子弹，最后在刷新屏幕的函数中添加显示子弹的代码，主要添加内容如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)            def _fire_bullet(self):    &quot;&quot;&quot;发射子弹&quot;&quot;&quot;    if len(self.bullets) &lt; 6:        new_bullet = Bullet(self)        self.bullets.add(new_bullet)\n运行如下\n\n这样就可以正常发射子弹了。下面我们还需要对代码进行简单的修改，将子弹的相关配置放入Settings中\n代码优化\n跟设置相关的内容我们应该放在Settings类当中，同时尽可能的减少硬编码的行为，优化后的完整代码如下\nalien_invasion.py\nimport  pygameimport sysfrom settings import Settingsfrom ship import Shipfrom bullet import Bulletclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.settings = Settings()        self.clock = pygame.time.Clock()        self.screen = pygame.display.set_mode((self.settings.screen_width, self.settings.screen_height))        pygame.display.set_caption(self.settings.TITLE)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()    def run_game(self):        # 游戏主循环        while True:            # 监听事件            self._check_events()            # 更新飞船位置            self.ship.update()            # 更新子弹位置            self._update_bullets()            # 更新屏幕            self._update_screen()            # 控制游戏帧率            self.clock.tick(self.settings.FPS)    def _check_events(self):        &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)    def _check_keydown_events(self, event):        &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            pygame.quit()            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()    def _check_keyup_events(self, event):        &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    def _update_screen(self):        &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        for bullet in self.bullets.sprites():            bullet.draw()        self.ship.draw()        pygame.display.flip()    def _update_bullets(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.bullets.update()        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                self.bullets.remove(bullet)    def _fire_bullet(self):        &quot;&quot;&quot;发射子弹&quot;&quot;&quot;        if len(self.bullets) &lt; self.settings.bullet_limit:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)if __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\nbullet.py\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 设置子弹的属性        self.color = self.game.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.game.settings.bullet_width, self.game.settings.bullet_height)        # 将子弹放在飞船的顶部        self.rect.midtop = self.game.ship.rect.midtop\t\t        # 子弹的y轴位置        self.y = float(self.rect.y)    def update(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.y -= self.game.settings.bullet_speed        self.rect.y = self.y    def draw(self):        &quot;&quot;&quot;绘制子弹&quot;&quot;&quot;        pygame.draw.rect(self.game.screen, self.color, self.rect)\nsettings.py\nclass Settings:    def __init__(self):        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;        self.screen_width = 1600        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;        # 飞船设置        self.ship_image_path = &#x27;imgs/ship.bmp&#x27;        self.ship_speed = 3        # 子弹设置        self.bullet_color = (60, 60, 60)        self.bullet_speed = 4        self.bullet_width = 3        self.bullet_height = 15        self.bullet_limit = 10\nship.py\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(self.game.settings.ship_image_path)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += self.game.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:            self.x -= self.game.settings.ship_speed        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《三》","url":"/posts/5821342e/","content":"添加Play按钮\n首先在Setting中添加如下代码\n# 按钮设置self.button_color = (0, 255, 0)self.button_width = 200self.button_height = 50self.button_text_color = (255, 255, 255)self.button_font = 48self.play_button_text = &quot;Play&quot;\n将按钮的相关属性加入到设置相关的类中，然后创建button.py文件，添加如下代码\nimport pygame.fontclass Button:    def __init__(self, game, msg):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.button_font)        self.rect = pygame.Rect(0, 0, self.game.settings.button_width, self.game.settings.button_height)        self.rect.center = self.game.screen.get_rect().center        self._pre_msg(msg)    def _pre_msg(self, msg):        &quot;&quot;&quot;将msg渲染为图像&quot;&quot;&quot;        self.msg_image = self.font.render(msg, True, self.game.settings.button_text_color, self.game.settings.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw(self):        &quot;&quot;&quot;绘制按钮&quot;&quot;&quot;        self.game.screen.fill(self.game.settings.button_color, self.rect)        self.game.screen.blit(self.msg_image, self.msg_image_rect)\n__init__()函数用于按钮的初始化，如按钮的大小、字体、位置等，_pre_msg()函数用于将字符串消息转换为图像并填充到矩形中，draw()函数用于绘制按钮\n接下来我们在主程序中将game_active设为False，从而为了显示按钮，然后添加按钮属性self.play_button = Button(self, self.settings.play_button_text)，接着在更新屏幕的地方判断如果游戏处于非活跃状态就显示按钮\nif not self.game_active:    self.play_button.draw()\n现在运行游戏\n\n开始游戏\n此时点击按钮并没有做出反应，因为我们还没有添加鼠标点击响应的事件，首先在_check_events中添加如下代码\nelif event.type == pygame.MOUSEBUTTONDOWN:    mouse_pos = pygame.mouse.get_pos()    self._check_play_button(mouse_pos)\n上述代码用于检测是否有鼠标按下，如果有则获取鼠标点击的位置，然后将变量传递给_check_play_button，现在我们添加该函数\ndef _check_play_button(self, mouse_pos):    &quot;&quot;&quot;响应Play按钮的点击事件&quot;&quot;&quot;    if self.play_button.rect.collidepoint(mouse_pos):        # 重置游戏状态        self.status.reset_status()        self.game_active = True        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 创建新的外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()\n一旦有点击事件的发生，我们就判断点击位置是否位于按钮中，如果是，则重置游戏状态并清空所有子弹和外星人，创建新的外星人和飞船，从而表明我们开启了新游戏，运行如下\n\n游戏优化\n当前游戏中还存在Bug，如果我们点击按钮所在区域，即便是按钮已经消失但仍会做出响应并重置游戏，因为我们的鼠标点击事件还会判断其点击位置与按钮位置重合，因此我们需要对判断做出优化\nif self.play_button.rect.collidepoint(mouse_pos) and not self.game_active:\n将_check_play_button函数中的if判断语句改为上述代码，从而防止其在游戏运行时仍会执行重置代码\n另外，玩游戏时我们应该将光标隐藏，在游戏结束时显示光标\n在_check_play_button的末尾添加pygame.mouse.set_visible(False)，游戏开始将光标隐藏，在_ship_hit的else块的末尾添加pygame.mouse.set_visible(True) ，游戏结束时将光标显示\n提升趣味性\n在Settings中添加如下代码\n    # 游戏速度设置    self.speed_scale = 1.1    self.init_settings()def init_settings(self):    &quot;&quot;&quot;初始化游戏的动态设置&quot;&quot;&quot;    self.ship_speed = 30    self.bullet_speed = 10    self.alien_speed = 10    self.alien_drop_speed = 10    self.alien_direction = 1def increase_speed(self):    &quot;&quot;&quot;提高游戏速度设置&quot;&quot;&quot;    self.ship_speed *= self.speed_scale    self.bullet_speed *= self.speed_scale    self.alien_speed *= self.speed_scale    self.alien_drop_speed *= self.speed_scale\nspeed_scale用于控制游戏增长的速度，init_settings用于初始化设置，increase_speed用于将相关参数增长从而提高游戏难度\n在_check_bullet_alien_collisions中，如果外星人全部被击落，我们就调用self.settings.increase_speed()增加游戏速度。当然每次开启新游戏时，应当将所有设置还原，在_check_play_button的if语块的第一行添加self.settings.init_settings()，这将使得新游戏的属性为初始化值\n记录分数\n在GameStatus中添加属性self.score = 0用于重置分数，在Settings中添加分数相关设置\n# 游戏分数设置self.score_text_color = (30, 30, 30)self.score_font = 48\n然后创建gamescore.py文件添加如下代码\nimport pygame.fontclass GameScore:    def __init__(self, game):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.score_font)        self.prep_score()    def prep_score(self):        &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;        score_str = str(self.game.status.score)        self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)        self.score_rect = self.score_image.get_rect()        self.score_rect.right = self.game.screen.get_rect().right - 20        self.score_rect.top = 20    def show_score(self):        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;        self.game.screen.blit(self.score_image, self.score_rect)\n在主程序中添加成员self.score = GameScore(self)，随后在更新屏幕函数中显示分数面板self.score.show_score()，此时运行游戏就能显示分数面板了\n更新得分\n在Settings的init_settings中添加self.alien_points = 50，用于表示每个外星人击落的初始得分，然后在主程序的_check_bullet_alien_collisions中添加\nif collisions:    for aliens in collisions.values():        self.status.score += self.settings.alien_points * len(aliens)    self.score.prep_score()\n表示每次击中一个外星人则对其进行加分，同时击落多个外星人也能同时记分，当然每次开始游戏我们也要重置分数，在_check_play_button中添加self.score.prep_score()，用新的分数来初始化记分面板\n对于不同速度的外星人，我们也应该增加其击落分数，在Settings中添加self.score_scale = 1.5表示外星人的分数增长速度，然后在increase_speed中添加self.alien_points = int(self.alien_points * self.score_scale)，更新新的外星人分数，最后再对分数进行取舍，在GameScore的prep_score中修改代码如下\ndef prep_score(self):    &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;    rounded_score = round(self.game.status.score, -1)    score_str = f&quot;&#123;rounded_score:,&#125;&quot;  # 使用逗号分隔千位    self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.score_rect = self.score_image.get_rect()    self.score_rect.right = self.game.screen.get_rect().right - 20    self.score_rect.top = 20\n表示我们通过round函数将分数取为10的整数倍，这样每个外星人的分数都是10的倍数了\n获取最高分\n在GameStatus添加新属性self.max_score = 0用来记录最高分，随后在GameScore中添加新函数\ndef prep_high_score(self):    &quot;&quot;&quot;将最高得分渲染为图像&quot;&quot;&quot;    high_score = round(self.game.status.max_score, -1)    high_score_str = f&quot;&#123;high_score:,&#125;&quot;    self.high_score_image = self.font.render(high_score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.high_score_rect = self.high_score_image.get_rect()    self.high_score_rect.centerx = self.game.screen.get_rect().centerx    self.high_score_rect.top = self.score_rect.top    def check_high_score(self):    &quot;&quot;&quot;检查是否达到了新的最高得分&quot;&quot;&quot;    if self.game.status.score &gt; self.game.status.max_score:        self.game.status.max_score = self.game.status.score        self.prep_high_score()\n这里将最高分渲染为图像并放置在屏幕正中央的上方，在__init__中调用prep_high_score，然后在show_score中将high_score_image显示出来，并在主程序中每当碰撞发生时就调用check_high_score判断当前分数是否超过了最高分，运行如下\n\n显示等级和飞船数\n在GameStatus的reset_status中添加self.level = 1，在GameScore的__init__添加函数self.prep_level()，代码如下\ndef prep_level(self):    &quot;&quot;&quot;将当前关卡渲染为图像&quot;&quot;&quot;    level_str = str(self.game.status.level)    self.level_image = self.font.render(level_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.level_rect = self.level_image.get_rect()    self.level_rect.right = self.score_rect.right    self.level_rect.top = self.score_rect.bottom + 10\n将等级渲染为图片并显示在得分的正下方，然后在show_score中添加self.game.screen.blit(self.level_image, self.level_rect)来显示图像，在主程序中清除所有外星人之后提升等级，代码如下\nif not self.aliens:    # 如果没有外星人了，重新创建外星人舰队    self._create_fleet()    self.bullets.empty()    self.settings.increase_speed()    # 提升关卡    self.status.level += 1    self.score.prep_level()\n最后在_check_play_button中重置等级，调用self.score.prep_level()即可，运行如下\n\n接下来我们要显示剩余飞船数，这里我们对飞船也要使用Sprite，更改Ship类如下\nclass Ship(Sprite):    def __init__(self, game):        super().__init__()\n将Ship继承自Sprite，在GameScore中添加函数prep_ships如下\ndef prep_ships(self):    &quot;&quot;&quot;显示剩余飞船数量&quot;&quot;&quot;    self.ships = Group()    for ship_number in range(self.game.status.ships_left):        ship = Ship(self.game)        ship.rect.x = 10 + ship_number * ship.rect.width        ship.rect.y = 10        self.ships.add(ship)\n这个函数用于根据剩余的飞船数量来创建飞船对象并调整位置，然后在初始化的函数中添加self.prep_ships()。下一步我们就要绘制飞船了，在show_score中添加self.ships.draw(self.game.screen)即可，然后在主程序的游戏开始和飞船被撞击的地方调用self.score.prep_ships()就能够正常加载和显示剩余飞船了，如下\n\n游戏Bug更改\n到上述部分我们就完成了书中的所有内容，但经过我的测试，这款游戏存在一定的Bug，看图\n\n是不是很奇怪？游戏还没有开始怎么就出现了一条横线？其实这是因为我们通过循环来侦听不同事件的发生，如果在游戏开始之前点击空格按钮，那么就会执行发射子弹的函数。但此时游戏状态并没有被激活，因此这条横线会停在这里，而且由于我们的子弹比较大，我们的飞船图像并不能完全遮盖子弹，所以就出现了这种现象，但从逻辑上来讲，如果我们不停按空格，程序应该每次都会执行空格所对应的响应，所以这里我们对其进行修改\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN and self.game_active:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP and self.game_active:            self._check_keyup_events(event)        elif event.type == pygame.MOUSEBUTTONDOWN:            mouse_pos = pygame.mouse.get_pos()            self._check_play_button(mouse_pos)\n上述代码主要增加了当键盘响应时游戏是否处于激活状态，如果游戏未激活则不响应任何按键，此时我们无论按键盘上的哪里，都不会再次出现上述的情况了，至此，该项目就完全结束了。源码访问点击这里\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《二》","url":"/posts/153f977c/","content":"创建Alien类\n创建一个alien.py文件，并把书中源码的alien.bmp图片拷贝到我们的imgs文件夹中，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Alien(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 加载外星人图片        self.image = pygame.image.load(&#x27;imgs/alien.bmp&#x27;)        self.rect = self.image.get_rect()        # 设置外星人初始位置        self.rect.x = self.rect.width        self.rect.y = self.rect.height        # 外星人当前的x轴位置        self.x = float(self.rect.x)\n创建Alien实例\n由于外星人通常是成批次出现，因此我们也要通过Sprite管理，如self.aliens = pygame.sprite.Group()，这里我们单独创建一个函数用于外星人的生成\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    self.aliens.add(alinen)\n然后在更新屏幕的函数中添加如下代码用于外星人在屏幕上的显示\nself.aliens.draw(self.screen)\n运行\n\n此时在屏幕的左上角已经出现了一个外星人\n创建Alien舰队\n上述我们在_create_fleet中只生成了一个外星人，下面进行修改来生成多行外星人，代码如下\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    alien_width = alinen.rect.width    alien_height = alinen.rect.height    current_x, current_y = alien_width, alien_height    # 计算屏幕可以容纳多少个外星人    while current_y &lt; (self.settings.screen_height - 3 * alien_height):        while current_x &lt; (self.settings.screen_width - 2 * alien_width):            self._create_alien(current_x, current_y)            current_x += 2 * alien_width        # 重置当前x位置，移动到下一行        current_y += 2 * alien_height        current_x = alien_widthdef _create_alien(self, current_x, current_y):    &quot;&quot;&quot;创建一个外星人&quot;&quot;&quot;    alien = Alien(self)    alien.x = current_x    alien.rect.x = current_x    alien.rect.y = current_y    self.aliens.add(alien)\n这里我们先生成一个实例，然后获取到它的宽度和高度并赋值为当前的x轴位置和y轴位置，内层循环用来生成一行外星人，从距离屏幕一个外星人的宽度开始，每隔一个外星人宽度创建一个实例，直到屏幕宽度不满足两个外星人的宽度为止，外层循环首先更新y轴位置，将其下移两个外星人的高度，然后初始化当前的x轴位置，再次创建一行，直到屏幕高度不满足三个外星人的高度位置为止，运行如下\n\n此时我们已经创建了一个外星人的舰队\n移动舰队\n在Setting中添加如下代码\n# 外星人设置self.alien_speed = 1self.alien_drop_speed = 10self.alien_direction = 1  # 1表示向右移动，-1表示向左移动\n分别表示外星人的水平速度、下降速度、水平方向\n然后在Alien中添加更新位置的函数\ndef update(self):    &quot;&quot;&quot;更新外星人位置&quot;&quot;&quot;    self.x += self.game.settings.alien_speed * self.game.settings.alien_direction    self.rect.x = self.x\n通过alien_direction来决定水平方向的移动，但这样只会让舰队朝着一个方向不停移动直到超出屏幕范围，在舰队即将到达屏幕边缘时，我们应该改变它的方向，让它朝着相反的方向移动，并下降一段距离。先添加边缘检测函数，如下\ndef check_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    screen_rect = self.game.screen.get_rect()    if self.rect.right &gt;= screen_rect.right or self.rect.left &lt;= 0:        return True    return False\n先获取屏幕大小，然后根据外星人所在的位置判断是否超出了屏幕边界，超了就返回True，否则返回就False\n随后我们在主程序添加检测函数，并在到达边缘时使其下降一段距离\ndef _check_fleet_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.check_edges():            self._change_fleet_direction()            breakdef _change_fleet_direction(self):    &quot;&quot;&quot;改变外星人舰队的方向&quot;&quot;&quot;    for alien in self.aliens.sprites():        alien.rect.y += self.settings.alien_drop_speed    self.settings.alien_direction *= -1\n对于每一个外星人我们都检测其是否超出了屏幕范围，然后改变所有外星人其移动方向，并下降一段距离，此时我们在更新外星人位置的函数中调用检测边界函数，运行结果如下\n\n射击外星人\n此时我们发射子弹，子弹并不能击落外星人，而是会直接穿过外星人，因为我们还没有做子弹和外星人的碰撞检测，下面我们来逐步实现这一过程\n检测子弹和外星人的碰撞\n要实现这个功能非常简单，我们只需要利用pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)这个函数即可，前两个参数分别表示子弹群组和外星人群组，后面两个参数表示碰撞后是否消失，True表明碰撞后子弹和外星人均消失。但这样还有个缺陷，就是我们把外星人全部击落之后，屏幕将没有外星人了，我们应该在打完所有外星人之后重新生成新的外星人舰队，代码如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)                self._check_bullet_alien_collisions()def _check_bullet_alien_collisions(self):    &quot;&quot;&quot;检查子弹与外星人碰撞&quot;&quot;&quot;    collisions = pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)    if not self.aliens:        # 如果没有外星人了，重新创建外星人舰队        self._create_fleet()        self.bullets.empty()\n我们在更新子弹的后面加入了调用检测碰撞的函数，并在所有外星人消失后重新生成新的外星人舰队，同时清除所有子弹，从而使我们继续游戏\n检测飞船和外星人的碰撞\n如果按照上述的逻辑，那么这个游戏将没有终止的时候，为此应该加入游戏结束的一些条件，比如我们的飞船和外星人发生了碰撞，在更新外星人的函数中添加代码如下\n# 检测外星人和飞船的碰撞if pygame.sprite.spritecollideany(self.ship, self.aliens):    print(&quot;飞船被外星人撞了！&quot;)\nspritecollideany(self.ship, self.aliens)函数接收一个精灵和一个编组，用于检测飞船是否有和外星人碰撞，如果发生碰撞，将打印&quot;飞船被外星人撞了！&quot;。通常来讲，我们不应当在飞船撞毁之后直接结束游戏，而是应该给予玩家多次机会，下面我们创建一个game_status.py文件，用于记录游戏信息，内容如下\nclass GameStatus:    def __init__(self, game):        &quot;&quot;&quot;初始化游戏状态&quot;&quot;&quot;        self.ships_left = None        self.game = game        self.reset_status()            def reset_status(self):        &quot;&quot;&quot;重置游戏状态&quot;&quot;&quot;        self.ships_left = self.game.settings.ship_limit\n同时在Settings中添加self.ship_limit = 3，表明飞船最多只有三次，ships_left则用来记录剩余的飞船数量\n下面我们对主程序进行修改，添加一个用于游戏状态表示的实例：self.status = GameStatus(self)，然后创建撞击后的响应函数，如下\ndef _ship_hit(self):    &quot;&quot;&quot;响应飞船被外星人撞击的事件&quot;&quot;&quot;    if self.status.ships_left &gt; 0:        # 减少剩余飞船数量        self.status.ships_left -= 1        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 重新创建外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()        # 暂停一段时间        sleep(1)    else:        print(&quot;游戏结束！&quot;)\n如果被撞击并且飞船数量大于0，则减少一个飞船数量并清空子弹和外星人，从而生成新的外星人和飞船。删除碰撞函数里print()函数，替换为_ship_hit()，并在Ship中添加如下函数\ndef center_ship(self):    &quot;&quot;&quot;将飞船放在屏幕底部中央&quot;&quot;&quot;    self.rect.midbottom = self.game.screen.get_rect().midbottom    self.x = float(self.rect.x)\n使新生成的飞船位于屏幕底部中心\n到达屏幕底部边缘\n如果外星人到达屏幕底部，我们同样应该跟碰撞一样响应，添加屏幕下边缘检测函数\ndef _check_alien_bottom(self):    &quot;&quot;&quot;检查外星人是否到达屏幕底部&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.rect.bottom &gt;= self.settings.screen_height:            self._ship_hit()            break\n检查每个外星人的底部是否超过了屏幕的高度，如果超过则调用_ship_hit()函数。在更新外星人的最后添加self._check_alien_bottom()，此时当外星人到达屏幕底部游戏也将重置\nGameOver\n细心一点可能会注意到，当我们死亡超过三次时，游戏仍然没有结束，事实上它永远也不会结束，因为我们在_ship_hit()函数中，当ships_left小于0时，只是调用了print(&quot;游戏结束！&quot;)，其他什么也没有做，因此ships_left只会越来越小，我们应该为其添加一个游戏标识，如果标识为False则终止某些部分的运行，从而实现游戏的结束。在主程序添加self.game_active = True，并将print(&quot;游戏结束！&quot;)替换为self.game_active = False，同时修改主循环如下\n# 游戏主循环while True:    # 监听事件    self._check_events()    if self.game_active:        # 更新飞船位置        self.ship.update()        # 更新子弹位置        self._update_bullets()        # 更新外星人位置        self._update_aliens()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Simulink调用外部Dll交互《三》","url":"/posts/ee275623/","content":"介绍\n本文主要实现了Simulink下模块化GUI与外部Dll数据交互的功能。首先将需要用到的交互接口封装，导出为C风格的函数，然后在模块中创建可视化界面并导入外部Dll，用于显示和操作数据，并在修改数据后通过接口保存到文件，如果成功，则与后续接口通信，调用求解器并显示结果\n导出交互接口\n// 参数交互EXPORT_API void LoadParametersFromIni(void* p, const char* filename);EXPORT_API int GetGlobalParameterCount(void* p);EXPORT_API const char* GetParameterName(void* p, int index);EXPORT_API double GetParameterValue(void* p, int index);EXPORT_API double GetParameterMin(void* p, int index);EXPORT_API double GetParameterMax(void* p, int index);EXPORT_API const char* GetParameterDescription(void* p, int index);EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath);\n//-------------参数交互用-------------------   EXPORT_API void LoadParametersFromIni(void* p, const char* filename) &#123;       if (!p || !filename) return;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       proc-&gt;LoadIniParametersToGlobalParameter(filename);  // 调用现有方法   &#125;   EXPORT_API int GetGlobalParameterCount(void* p) &#123;       if (!p) return 0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       return static_cast&lt;int&gt;(proc-&gt;m_vglobalParams.size());   &#125;   EXPORT_API const char* GetParameterName(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetName().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API double GetParameterValue(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetValue();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMin(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMin();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMax(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMax();       &#125;       return 0.0;   &#125;   EXPORT_API const char* GetParameterDescription(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetDescription().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath) &#123;       if (!p || !paramName || !projectPath) &#123;           return false;       &#125;       try &#123;           auto proc = static_cast&lt;CXXXProcessor*&gt;(p);           // 调用 C++ 类成员函数进行参数修改           return proc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);                   &#125;       catch (const std::exception&amp; e) &#123;           std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;           return false;       &#125;   &#125;\n这段代码主要是通过 C++ 的 EXPORT_API 宏将 CXXXProcessor 类的相关函数暴露为 API 接口，允许外部调用进行参数的读取、修改以及加载配置。\n1. EXPORT_API 宏\n每个函数前面都使用了 EXPORT_API 宏，这通常是为了将这些函数导出为 DLL 接口，让外部应用可以调用这些函数。这种做法常见于需要将 C++ 类和方法暴露给其他编程语言（如 Python 或 C#）的情况。EXPORT_API 一般在头文件中定义，并用来标记需要导出的函数。\n2. 参数校验\n在所有函数内部，第一步都是检查指针或参数是否为空或无效。例如：\nif (!p || !filename) return;\n这种做法可以确保在程序运行时避免因为传入无效参数而导致的崩溃，增强了代码的鲁棒性。\n3. static_cast 类型转换\n很多地方使用了 static_cast 来进行类型转换。比如：\nauto proc = static_cast&lt;CXXXProcessor*&gt;(p);\n这里 p 是一个 void* 类型的指针，指向 CXXXProcessor 类型的对象。static_cast 将 void* 转换成 CXXXProcessor* 类型，以便调用该类的成员函数。通过这种方式，可以在不暴露类内部实现的情况下，提供面向外部的 API 接口。\n4. 函数功能设计\n加载参数 (LoadParametersFromIni)\nproc-&gt;LoadIniParametersToGlobalParameter(filename);\n该函数的设计目的是加载指定的 .ini 配置文件，并将参数值导入到类内部的全局参数列表中。它的设计思想是将文件读取与内存中数据的存储解耦，便于后续的参数操作。\n参数获取函数\n包括：\n\nGetGlobalParameterCount：返回全局参数的数量。\nGetParameterName、GetParameterValue、GetParameterMin、GetParameterMax：返回指定参数的不同属性（名称、值、最小值、最大值）。\nGetParameterDescription：返回参数的描述信息。\n\n这些函数的设计方式非常直观，主要是通过访问类内部 m_vglobalParams 成员（一个存储参数的容器，如 std::vector）来返回相应的信息。每个函数都首先检查传入的索引是否有效，确保在访问数组或容器时不会越界。\n修改参数 (RewriteBWIIni_Param)\nproc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);\n此函数负责修改指定参数的值并将其更新回 .ini 配置文件中。它利用 CXXXProcessor 类中的现有方法 RewriteBWIIni_Param 来执行实际的修改操作。在设计上，这个函数有一个异常处理机制（try-catch 语句），用于捕获运行时可能出现的异常，防止程序崩溃。错误信息会通过 std::cerr 输出，便于调试。\n5. 数据封装与分离\n函数内部使用了 CXXXProcessor 类封装了所有参数相关的操作，外部调用者仅通过接口来操作这些数据。这样的封装设计符合面向对象编程（OOP）的原则，数据与操作方法分离，外部只关心接口而无需了解内部实现细节。\n\nm_vglobalParams 是存储所有全局参数的容器，封装了参数的读取、修改等操作。\nCXXXProcessor 类中提供了对参数的处理函数，如 LoadIniParametersToGlobalParameter 和 RewriteBWIIni_Param，而 API 函数仅暴露必要的接口给外部调用。\n\n6. 错误处理与返回值\n大多数函数都进行了参数校验和错误处理。比如 GetParameterName 和其他类似的获取参数信息的函数都返回 nullptr 或默认值（如 0.0），当输入无效时避免出现错误：\nif (!p || index &lt; 0) return nullptr;\nRewriteBWIIni_Param 函数则使用 try-catch 机制来捕获异常，确保在发生异常时能返回 false，并输出错误信息。\n7. 代码设计的一致性与可扩展性\n\n所有获取参数的函数（如 GetParameterName、GetParameterValue 等）具有一致的接口设计，参数索引作为输入，返回相关数据。这使得 API 易于扩展和维护，后期可以轻松增加更多的参数获取功能。\nRewriteBWIIni_Param 与加载参数的功能解耦，遵循了单一职责原则，使得每个函数都专注于自己的一部分工作，易于理解和测试。\n\nMatlab GUI实现\n将上个步骤的代码编译为Dll，并把其头文件、dll文件以及所有用到的其他dll拷贝到Matlab的运行环境下\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0        start_import_gui(block.BlockHandle);  % 传递块句柄给 GUI        block.Dwork(1).Data = 1;  % 设置 GUI 已启动标志    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        % 自动开始仿真，无需手动输入        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;  % 设置已启动标志    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            % 检查仿真是否正在运行，若正在运行则停止            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                % 如果仿真正在运行，取消仿真                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            % 如果没有仿真，或其他错误，则跳过            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(blockHandle)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.blockHandle = blockHandle;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end\n这段代码是一个用于在 Simulink 模型中调用自定义 S-Function 的实现，目的是在仿真过程中与图形用户界面 (GUI) 交互，导入和修改参数。\nS-Function 主体\n首先，sfun_callInterface 函数是 S-Function 的入口，调用了 setup 函数来进行初始化配置。setup 函数为 S-Function 设置了输入输出端口、采样时间、以及仿真相关的回调方法。\nsetup 函数\n在 setup 函数中，设置了 S-Function 的输入和输出端口配置。它没有输入端口，只有一个输出端口，并且输出的维度和数据类型进行了设定。该端口的采样模式为 Sample，表示输出数据为常规的样本数据。\n此外，SampleTimes 被设置为 [0 0]，这意味着该 S-Function 会立即执行并且不会进行周期性的采样。通过注册 PostPropagationSetup, InitializeConditions, Outputs, 和 Terminate 四个方法，定义了仿真生命周期内不同阶段的行为。\n最后，set_param 设置了 OpenFcn 触发，指向了 start_import_gui 函数，用于启动 GUI 界面。\nPostPropagationSetup 函数\n该函数用于声明 S-Function 中的 DWork（数据工作区）。DWork 是用来存储状态信息的地方。这里定义了三个 DWork 变量：\n\nguiLaunched 用于标识 GUI 是否已启动。\nconfirmationFlag 用于存储从 GUI 获取的确认状态。\nsimStarted 用于标记仿真是否已经启动。\n\n这些 DWork 变量的作用是确保 GUI 在需要时只启动一次，并且管理仿真状态，防止重复操作。\nInitCond 函数\nInitCond 函数在每次仿真开始时被调用，用来初始化 DWork 变量。在这里，所有的标志变量（guiLaunched, confirmationFlag, simStarted）都被初始化为 0，表示 GUI 尚未启动，确认标志为未设置，仿真尚未开始。\nOutputs 函数\nOutputs 函数是在仿真过程中持续被调用的，用来控制和更新仿真输出。首先，它获取了 GUI 启动状态、确认标志和仿真启动状态。如果 GUI 尚未启动，则调用 start_import_gui 函数启动 GUI 界面，并将 guiLaunched 标志设为 1。\n如果 GUI 已经启动，尝试从基础工作空间获取 confirmationFlag 变量的值。如果获取到有效值，则更新 DWork 中的 confirmationFlag。\n然后，函数检查确认标志的值：\n\n如果 confirmationFlag 为 1 且仿真尚未启动，则自动启动仿真，并将 simStarted 设为 1。\n如果 confirmationFlag 为 -1，表示取消，尝试停止正在运行的仿真。\n\nTerminate 函数\nTerminate 函数在仿真结束时调用，主要作用是清理基础工作空间中的标志变量 confirmationFlag，以防止在下次仿真中出现残留的状态信息。\nstart_import_gui 函数\nstart_import_gui 函数用于创建并显示 GUI 窗口。首先，它计算并设置窗口居中显示的坐标。然后，创建了一个图形界面，并在其中添加了以下元素：\n\n一个按钮用来触发数据导入。\n一个表格用来显示导入的数据。\n一个文本框用来显示当前选择的文件夹路径。\n“确认”和“取消”按钮，用来控制数据导入和取消操作。\n\n此外，在 GUI 初始化时加载了一个动态链接库（DLL），用于后续的参数导入和修改操作。\n调用Dll\n% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\nimport_data 函数\nimport_data 函数是在用户点击导入按钮时调用的。它弹出一个文件夹选择对话框，允许用户选择包含数据文件的文件夹。如果用户选择了文件夹并且其中包含 bwiparamtemp.ini 文件，程序会调用 DLL 函数读取该文件中的参数并将其显示在表格中。\nconfirm_action 函数\nconfirm_action 函数在用户点击“确认”按钮时被调用。它从表格中读取每个参数的名称和值，并将更新的参数通过 DLL 保存到指定路径的 .ini 文件中。如果参数值有变化，则执行更新操作。\n更新成功后，将 confirmationFlag 设置为 1，表示操作已完成，仿真可以开始。\ncancel_action 函数\ncancel_action 函数在用户点击“取消”按钮时调用。它将 confirmationFlag 设置为 -1，表示取消操作，然后关闭 GUI 窗口。\nclose_gui 函数\nclose_gui 函数用于关闭 GUI 窗口时调用。它会卸载已经加载的 DLL，并释放其他资源。\n总结\n这段代码实现了一个与 Simulink 模型交互的 GUI 系统，允许用户在仿真过程中导入和修改参数，启动或停止仿真。代码通过 S-Function 接口与 Simulink 仿真框架进行集成，并使用 MATLAB 图形界面元素提供用户交互界面。设计上使用了 DWork 数据工作区来存储和管理仿真状态，并通过回调函数实现不同阶段的功能。\n关于文件在不同运行环境下编码不同的问题\n\n其主要原因在于，Matlab的运行环境和Visual Studio不同，而封装的读写代码中用到了windows的API，该API会根据运行编译环境来选择不同的写入方式，而Matlab默认使用UTF-8，从而导致写入数据时中文出现乱码的情况，如下图\n\n如果不需要在多个环境下运行（如Unicode），我们可以固定写入方式，如读写均采用ANSI方式\nchar *CIniFile::ReadString(string &amp;m_Sec, string &amp;m_Ident, char *m_Def)&#123;\tGetPrivateProfileStringA(m_Sec.c_str(), m_Ident.c_str(), m_Def, Buffer, sizeof(Buffer), m_Name);\treturn Buffer;&#125;bool CIniFile::WriteString(const char *m_Sec, const char *m_Ident, const char *m_Val)&#123;\treturn (bool)WritePrivateProfileStringA(m_Sec, m_Ident, m_Val, m_Name);&#125;\n也可以使用开源替代库来替代原有的ini操作类，如SimpleIni，或者自己手动检测编码，手动写入，如下\nvoid CIniFile::detectEncoding() &#123;\tm_isUtf8 = false;\tm_hasUtf8BOM = false;\tunsigned char bom[3] = &#123; 0,0,0 &#125;;\tif (FILE* f = std::fopen(m_Name, &quot;rb&quot;)) &#123;\t\tstd::fread(bom, 1, 3, f);\t\tstd::fclose(f);\t\tif (bom[0] == 0xEF &amp;&amp; bom[1] == 0xBB &amp;&amp; bom[2] == 0xBF) &#123;\t\t\tm_isUtf8 = true;\t\t\tm_hasUtf8BOM = true;\t\t&#125;\t&#125;\t// 如果无 BOM：保守视为 MBCS/ANSI（如 GBK）；这样不会把老文件强转 UTF-8。&#125;bool CIniFile::saveInternal() &#123;\tif (!m_loaded) return false;\t// UTF-8 文件：是否写 BOM：保持与原文件一致\tconst bool addSig = (m_isUtf8 &amp;&amp; m_hasUtf8BOM);\t// 如果是 GB2312/GBK 编码，保存时不写 BOM\tif (!m_isUtf8) &#123;\t\tSI_Error rc = m_ini.SaveFile(m_Name, false); // No BOM for MBCS/ANSI\t\tif (rc &lt; 0) return false;\t&#125;\telse &#123;\t\t// 保存为 UTF-8 编码，并且根据原文件是否有 BOM 来决定是否加 BOM\t\tSI_Error rc = m_ini.SaveFile(m_Name, addSig);\t\tif (rc &lt; 0) return false;\t&#125;\tm_dirty = false;\treturn true;&#125;\n\n注意：如果非同一个项目，需要把所有用到的项目进行编译，并把运行需要的dll文件拷贝到Matlab环境下\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"Simulink调用外部Dll可视化《二》","url":"/posts/4e6df0d5/","content":"介绍\n这篇文章主要实现在Simulink中可视化的工作，由于自身求解工具的可视化代码采用C++编程，同时与项目耦合过多，难以独立摘出或通过Matlab重现，因此这里采用新建桥接工程将所有需要用到的可视化代码封装并导出\n封装Dll并导出C函数\n首先在VS中新建空项目工程并进行配置，主要是关于项目依赖、导出Dll相关，然后将所有可能用到的代码进行简化和封装，我这里采用的类进行管理，由于跟项目相关不进行展示，新建XXXBridgeDLL.h和XXXBridgeDLL.cpp用于导出C接口供Matlab调用，内容如下\n#pragma once#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    EXPORT_API void* CreateProcessor();    EXPORT_API void DeleteProcessor(void* p);    EXPORT_API int  ReadXXXDat(void* p, const char* folder, int* pNumPts);        EXPORT_API int   GetPointCount(void* p);                      /* 返回总点数         */    EXPORT_API int   CopyX_mm(void* p, double* out, int max);  /* 轴向坐标 (mm)     */    EXPORT_API int   CopyPower(void* p, double* out, int max);  /* 输出功率 (W)      */    EXPORT_API int   CopyGain(void* p, double* out, int max);  /* 增益 (dB)         */    EXPORT_API int   CopyEff(void* p, double* out, int max);  /* 效率 (%)          */#ifdef __cplusplus&#125;#endif\n这段代码是一个 C/C++ 动态链接库（DLL）的头文件（.h），用于定义向外部导出的一组函数接口。\n\nDLL 导出宏定义部分\n#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif\n\n作用：用于在不同编译阶段切换导出/导入。\n\n如果编译的是 DLL 本身（定义了 XXXBRIDGEDLL_EXPORTS），则 EXPORT_API 展开为 __declspec(dllexport)，导出符号；\n如果是使用 DLL 的客户端程序，则展开为 __declspec(dllimport)，用于导入符号。\n\n\n\n\nextern &quot;C&quot; 块\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif...#ifdef __cplusplus&#125;#endif\n\n使得这些函数按照 C语言方式 进行链接（不进行 C++ 名字改编 / name mangling），以便在 C/C++/Python/MATLAB 等跨语言调用时保持接口兼容。\n\n\n导出的函数接口\nEXPORT_API void* CreateProcessor();\n\n创建一个处理器对象，返回一个 void* 指针（通常是一个类的实例地址）。\n\nEXPORT_API void DeleteProcessor(void* p);\n\n删除处理器对象，释放资源。\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pNumPts);\n\n从指定文件夹读取数据，p 是处理器对象指针，folder 是数据路径，pNumPts 用于返回读取到的点数。\n\n\n数据访问函数（数据从内存复制出来）\nEXPORT_API int GetPointCount(void* p);\n\n获取数据点总数。\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max);\n\n复制轴向坐标数据（单位：mm）到 out 指针所指向的数组，max 是允许写入的最大点数。\n\nEXPORT_API int CopyPower(void* p, double* out, int max);\n\n复制输出功率数据（单位：瓦特）。\n\nEXPORT_API int CopyGain(void* p, double* out, int max);\n\n复制增益数据（单位：dB）。\n\nEXPORT_API int CopyEff(void* p, double* out, int max);\n\n复制电子效率数据（单位：百分比）。\n\n这个 DLL 接口提供了一个基于文件夹读取仿真结果（XXX仿真输出），并通过一系列函数获取：\n\n坐标（X）\n功率（Power）\n增益（Gain）\n效率（Eff）\n\n#define XXXBRIDGEDLL_EXPORTS#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125; extern &quot;C&quot; &#123;    EXPORT_API void* CreateProcessor() &#123; return new CXXXProcessor(); &#125;    EXPORT_API void  DeleteProcessor(void* p) &#123; delete static_cast&lt;CXXXProcessor*&gt;(p); &#125;    EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;        if (!p || !folder || !pts) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        bool ok = proc-&gt;ReadXXXDat(folder);        *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;        return ok;    &#125;    EXPORT_API int GetPointCount(void* p) &#123;        return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;    &#125;    EXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;        if (!p || !out || max &lt;= 0) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);        for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;        return n;    &#125;    EXPORT_API int CopyPower(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);    &#125;    EXPORT_API int CopyGain(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);    &#125;    EXPORT_API int CopyEff(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);    &#125;&#125;\n这段代码是 XXXBridgeDLL.dll 的 实现部分（C++源文件），与之前的头文件 XXXBridgeDLL.h 搭配使用，向外部程序提供接口来访问 XXX 仿真数据\n\n文件头部设置\n#define XXXBRIDGEDLL_EXPORTS\n\n定义此宏意味着当前正在编译 DLL，因此头文件中的 EXPORT_API 会变成 __declspec(dllexport)，导出接口。\n\n\n#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;\n\n引入头文件和 STL 库。CXXXProcessor 是处理器类，核心功能由它实现，接口只是封装。\n\n\n匿名命名空间 copyVector\nnamespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125;\n\n作用：通用的向 double* out 中复制数据的函数模板。\nSRC_GETTER 是一个 Lambda，返回某个 vector&lt;double&gt; 的引用。\n使用匿名命名空间是为了限定作用域（防止链接冲突）。\n\n\n导出接口（extern &quot;C&quot;）\n\nCreateProcessor\n\nEXPORT_API void* CreateProcessor() &#123;    return new CXXXProcessor();&#125;\n\n返回新建的处理器对象（指针以 void* 形式传出，保持 C 接口风格）。\n\n\nDeleteProcessor\n\nEXPORT_API void DeleteProcessor(void* p) &#123;    delete static_cast&lt;CXXXProcessor*&gt;(p);&#125;\n\n释放 CreateProcessor() 创建的对象。\n\n\nReadXXXDat\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;    if (!p || !folder || !pts) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    bool ok = proc-&gt;ReadXXXDat(folder);    *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;    return ok;&#125;\n\n调用 CXXXProcessor::ReadXXXDat(folder) 加载文件夹中的数据。\n加载成功后将数据点数写入 pts。\nm_vdpX 是轴向坐标数组。\n\n\nGetPointCount\n\nEXPORT_API int GetPointCount(void* p) &#123;    return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;&#125;\n\n返回总的数据点数（坐标数量）。\n\n\nCopyX_mm\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;    if (!p || !out || max &lt;= 0) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);    for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;    return n;&#125;\n\n将轴向坐标 m_vdpX（单位：米）转换为毫米（乘以 1000）并复制到 out 缓冲区。\n\n\nCopyPower, CopyGain, CopyEff\n\nEXPORT_API int CopyPower(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);&#125;\n\n通过 copyVector 模板复制 PowerOut 数据。\n\nEXPORT_API int CopyGain(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);&#125;\n\n复制增益（Gain）数据。\n\nEXPORT_API int CopyEff(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);&#125;\n\n复制效率（Eff）数据。\n\n\n模块用途概览\n\n\n\n函数名\n功能描述\n\n\n\n\nCreateProcessor\n创建处理器对象\n\n\nDeleteProcessor\n释放处理器对象\n\n\nReadXXXDat\n从指定目录读取 XXX 数据文件\n\n\nGetPointCount\n获取总数据点数\n\n\nCopyX_mm\n获取轴向坐标（单位 mm）\n\n\nCopyPower\n获取输出功率（单位 W）\n\n\nCopyGain\n获取增益（单位 dB）\n\n\nCopyEff\n获取电子效率（单位 %）\n\n\n\n编译成功后会在指定目录生成dll文件，把dll文件和导出函数头文件放到Matlab的工作目录下供其使用\nMatlab及Simulink调用Dll\n在Matlab中新建m文件，内容如下\n% 0. 环境与路径dll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);endp   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;% --- 指针缓冲区 ---xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);x    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;% --- 绘图 ---figure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);% --- 清理 ---calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n这段 MATLAB 代码演示了如何通过调用 C++ 动态链接库 XXXBridgeDLL.dll 来读取 XXX 仿真数据，并绘制输出功率、增益和效率随轴向位置变化的曲线\n\n1. 加载 DLL 与设置路径\ndll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);end\n\n设置 DLL 文件路径、头文件路径和数据文件夹路径。\n如果 DLL 尚未加载，则调用 loadlibrary 加载 DLL 并注册其接口函数。\n\n\n2. 创建处理器并读取数据\np   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;\n\n创建处理器实例 p（C++ 对象的指针）。\n申请一个 int32 类型的指针 nPt 用于返回数据点数量。\n调用 ReadXXXDat 从 dir 文件夹读取仿真数据。\n将数据点个数保存在 N 中。\n\n\n3. 分配输出缓冲区并复制数据\nxPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);\n\n为四类数据创建指针缓冲区，长度为 N。\n通过调用 DLL 中的接口函数将数据从 C++ 内部复制到 MATLAB 缓冲区中。\n\n\n4. 将指针值转换为 MATLAB 向量\nx    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;\n\n将指针对象中的数据取出，转换为 MATLAB 可用的数组。\n\n\n5. 绘制仿真结果曲线\nfigure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);\n\n打开一个新图像窗口，将三种数据绘制在三个子图中：\n\n输出功率 vs. 坐标\n增益 vs. 坐标\n效率 vs. 坐标\n\n\n\n\n6. 清理资源\ncalllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n\n释放处理器对象 p。\n卸载 DLL，释放系统资源。\n\n这段代码实现了：\n\n加载 DLL 并创建处理器。\n调用 C++ 函数读取 XXX 仿真数据。\n将结果复制到 MATLAB 并绘图。\n使用完后清理资源，避免内存泄漏。\n\n运行效果如下\n\n与求解工具链接\n现在的可视化模块只是通过硬编码的方式读取指定文件，下面需要把求解工具和可视化链接，通过求解工具输出的参数来进行泛型可视化\n修改现有的调用求解工具S Function代码\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\n这段代码是一个 Level-2 MATLAB S-Function，用于在 Simulink 中检测输入信号的 上升沿（从0变为1），然后异步启动一个外部 EXE 程序（XXX.exe），并轮询进程状态，完成后自动停止仿真。\n\n\n\n步骤\n说明\n\n\n\n\n①\n输入信号从 0 → 1，触发启动 XXX.exe\n\n\n②\n启动进程，记录 PID 和运行状态\n\n\n③\n每 0.5 秒轮询一次，判断进程是否结束\n\n\n④\n若 EXE 正常退出，则输出状态为 2，仿真停止；否则输出 -1 并停止\n\n\n⑤\n清理进程资源，防止残留\n\n\n\n\n调用工具代码解释\n\n顶部函数入口\n\nfunction sfun_callXXX(block)    setup(block);end\n\nS-Function 的主函数入口，调用 setup() 注册接口。\n\n\nsetup(block)：配置端口、采样、方法等\n\nblock.NumInputPorts  = 1;  % 输入1个信号（控制启动）block.NumOutputPorts = 1;  % 输出当前状态（0, 1, 2, -1）block.SampleTimes = [0.5 0];  % 每 0.5 秒执行一次block.RegBlockMethod(...)    % 注册各阶段的回调函数set_param(..., &#x27;StopTime&#x27;, &#x27;inf&#x27;);  % 设置仿真不主动终止\n\nPostProp：声明离散状态（DWork）\n\nblock.NumDworks = 3;names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;\n\nprevU：上一时刻输入值（检测上升沿用）\nexeState：执行状态（0=未启动，1=运行中，2=正常退出，-1=错误）\npid：外部进程 PID\n\n\nInitCond：初始化 DWork 数据\n\nblock.Dwork(1).Data = 0;  % 上一时刻输入值block.Dwork(2).Data = 0;  % exeStateblock.Dwork(3).Data = 0;  % pid\n\nOutputs(block)：主逻辑处理区\n\nu = block.InputPort(1).Data;\n上升沿触发：启动外部 EXE\nif u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0    [ok, procObj, pid, exeState] = launchExe(...);end\n运行中：轮询状态（每次采样调用）\nif exeState == 1    [exeState, pid] = pollProcessExitStatus(...);    if exeState == 2 || exeState == -1        stopSimulation(block);  % 进程完成 → 停止仿真    endend\n输出当前状态并保存状态数据\nblock.OutputPort(1).Data = exeState;\n\nTerminate：终止残留进程（防挂后台）\n\nif ~isempty(procObj)    terminateProcess(procObj);end\n内部 helper 函数说明\nlaunchExe(exePath, paramPath)\n\n启动 XXX.exe\n参数格式是 '1|1|参数路径'\n返回是否成功、进程对象、PID、状态\n\npollProcessExitStatus(procObj, pid)\n\n检查进程是否已退出\n如果异常，也尝试通过 PID 判断\n根据 ExitCode 判断：\n\n0 → 正常结束（返回状态 2）\n非 0 → 异常（状态 -1）\n\n\n\nisProcAlive(pid)\n\n尝试通过 PID 检查进程是否还活着\n\nterminateProcess(procObj)\n\n如果进程还在运行，则强制结束并释放资源\n\nstopSimulation(block)\n\n调用 Simulink 命令强制停止整个仿真\n\n状态码含义总结\n\n\n\n状态码\n含义\n\n\n\n\n0\n初始未启动\n\n\n1\n正在运行 EXE\n\n\n2\nEXE 正常退出\n\n\n-1\n启动或执行异常\n\n\n\n修改M文件\n将调用dll的Matlab代码改为S Function的方式，并通过1→2来进行触发，代码如下\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)end\n这段代码实现了一个 MATLAB Level-2 S-Function，主要功能是当输入信号为 2 时触发外部 DLL（XXXBridgeDLL.dll）的数据读取和处理，之后进行数据的可视化。\n总体功能流程\n\n输入信号：该 S-Function 监听一个输入信号 u。\n脉冲触发：当信号 u == 2 且前一时刻 prevU != 2 时，触发读取数据。\n调用 DLL：加载外部 DLL (XXXBridgeDLL.dll)，读取 XXX 仿真数据。\n数据处理与绘图：读取坐标、功率、增益和效率数据，并绘制图形。\n清理资源：在操作完成后，清理 DLL 资源。\n\n代码分解\n\nsfun_callXXXProcess(block)\n\nfunction sfun_callXXXProcess(block)    setup(block);end\n\n这是 S-Function 的入口函数，调用 setup(block) 设置仿真模块的基本配置。\n\n\nsetup(block): 配置端口、采样时间与方法\n\nfunction setup(block)    block.NumInputPorts  = 1;  % 一个输入端口    block.NumOutputPorts = 0;  % 无输出端口    block.SampleTimes        = [0.5 0];  % 每 0.5 秒触发一次    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;  % 默认的仿真状态兼容性    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);end\n\n配置输入端口和采样时间（每 0.5 秒触发一次）。\n注册方法：PostPropagationSetup、InitializeConditions、Outputs 和 Terminate。\n\n\nPostProp(block): 声明 DWork 状态变量\n\nfunction PostProp(block)    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevU&#x27;;  % 存储上一时刻的输入信号    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;  % double 类型    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end\n\n声明一个名为 prevU 的 DWork 变量，用于保存前一时刻的输入信号值。\n\n\nInitCond(block): 初始化 DWork 数据\n\nfunction InitCond(block)    block.Dwork(1).Data = 0;  % 初始化 `prevU` 为 0end\n\n初始化时，prevU 设置为 0，表示初始状态。\n\n\nOutputs(block): 主逻辑处理区\n\nfunction Outputs(block)    u = block.InputPort(1).Data;  % 获取当前输入信号    prevU = block.Dwork(1).Data;  % 获取前一时刻的输入信号    if u == 2 &amp;&amp; prevU ~= 2        % 读取 XXX 数据        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);  % 加载 DLL        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);  % 创建处理器对象        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);  % 读取数据        N = nPt.Value;  % 获取数据点数量        % 初始化指针缓冲区        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        % 从 DLL 中复制数据到指针        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;, p, effPtr, N);        % 获取数据        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % 绘图        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % 清理资源        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end\n\n当 u == 2 时，调用 XXXBridgeDLL.dll 进行数据读取，获取 x（坐标）、pow（功率）、gain（增益）和 eff（效率）数据。\n使用 figure 绘制三张子图，显示输出功率、增益和效率随坐标的变化。\n在操作完成后，清理 DLL 资源。\n\n\nTerminate(~): 清理\n\nfunction Terminate(~)end\n\n在仿真结束时，Terminate 函数被调用，但在这个实现中没有进行额外操作。\n\n工作流程\n\n输入信号：当输入信号为 2 时，触发外部 EXE 进程。\n调用 DLL：通过 XXXBridgeDLL.dll 读取 XXX 仿真数据。\n数据处理与绘图：读取数据并绘制输出功率、增益和效率曲线。\n清理：仿真结束后清理 DLL 资源。\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"Simulink调用外部工具仿真《一》","url":"/posts/51a3b25e/","content":"该项目旨在使用Simulink来完成某些计算和仿真，计算工具采用自己的求解器，因此Simulink在这里的作用主要为模拟输入输出接口和触发信号，后续可能会引入优化器来对参数进行优化，本篇作为开头，主要介绍如何使用Simulink调用外部工具。\n创建m文件\n首先打开Matlab，指定工作路径，在命令行窗口输入edit sfun_callXXX从而在当前路径下创建sfun_callXXX.m文件，输入下述代码\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);endfunction setup(block)    % 一个输入端口：触发信号（1 表示触发执行）    block.NumInputPorts = 1;    block.SetPreCompInpPortInfoToDynamic;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    % 一个输出端口：执行状态    block.NumOutputPorts = 1;    block.SetPreCompOutPortInfoToDynamic;    block.OutputPort(1).Dimensions   = 1;    block.OutputPort(1).DatatypeID   = 0;    block.OutputPort(1).Complexity   = &#x27;Real&#x27;;    % 一个 Dwork 变量：用于保存上一个输入（用于边沿检测）    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevInput&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;    % 每 1 秒调用一次    block.SampleTimes = [1.0 0.0];    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.InitializeConditions = @InitConditions;    block.Outputs              = @Output;endfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值：输入未触发endfunction Output(block)    u = block.InputPort(1).Data;    prev = block.Dwork(1).Data;    % 只在输入从 0 → 1 的跳变时执行    if u == 1 &amp;&amp; prev == 0        % 配置路径        exePath = &#x27;I:\\XXX.exe&#x27;;        paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        % 检查 EXE 是否存在        if ~isfile(exePath)            warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);            block.OutputPort(1).Data = -2;            block.Dwork(1).Data = u;            return;        end        % 检查参数路径是否存在        if ~isfolder(paramPath)            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);            block.OutputPort(1).Data = -3;            block.Dwork(1).Data = u;            return;        end        % 构造命令        exePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];        paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];        args = [&#x27;1|1|&#x27; paramPathQuoted];        cmd = [exePathQuoted &#x27; &#x27; args];        disp([&#x27;[XXX] 正在执行: &#x27; cmd]);        % 执行命令        status = system(cmd);        if status == 0            block.OutputPort(1).Data = 1;  % 成功        else            block.OutputPort(1).Data = -1; % 执行失败        end    else        block.OutputPort(1).Data = 0;  % 无触发    end    % 更新 Dwork 状态    block.Dwork(1).Data = u;end\n该函数的主要作用是在 Simulink 中通过输入触发器调用外部程序 XXX.exe，实现如下特性：\n\n支持多次触发执行，但只在输入信号从 0 到 1 的上升沿执行\n执行结果通过输出端口返回状态码：\n\n1 → 执行成功；\n-1 → 执行失败；\n-2 → EXE 路径不存在；\n-3 → 参数路径不存在；\n0 → 没有触发。\n\n\n\n主函数部分\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);end\n这是主入口函数，Simulink 在加载该 S-Function 时会调用这个函数。block 是代表这个 S-Function 块的对象，包含输入输出、状态等所有接口\nfunction setup(block)\nblock.NumInputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;  % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;\n设置只有 1 个输入端口，类型为 double 实数，输入数据是一个触发信号，为 1 表示要执行 XXX.exe\nblock.NumOutputPorts = 1;block.SetPreCompOutPortInfoToDynamic;block.OutputPort(1).Dimensions   = 1;block.OutputPort(1).DatatypeID   = 0;block.OutputPort(1).Complexity   = &#x27;Real&#x27;;\n也只有 1 个输出端口，用于输出执行状态\nblock.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;block.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;\nDwork 是 S-Function 中的离散状态变量，在仿真期间保留，这里用来保存上一时刻的输入值，从而判断是否出现了 0→1 的跳变（上升沿）\nblock.SampleTimes = [1.0 0.0];block.SimStateCompliance = &#x27;DefaultSimState&#x27;;block.InitializeConditions = @InitConditions;block.Outputs              = @Output;\nSampleTimes = [1.0 0.0] → 每 1 秒调用一次 Output 函数，注册初始化函数和主输出函数\n初始化函数 InitConditions\nfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值设为0，表示“未触发”end\n初始化 Dwork 状态变量，表示开始时没有任何触发信号\n主执行函数 Output\nfunction Output(block)\nu = block.InputPort(1).Data;prev = block.Dwork(1).Data;\nu 是当前输入值，prev 是上一个采样时刻的输入值，用于检测跳变\nif u == 1 &amp;&amp; prev == 0\n\n只有从 0 → 1 的跳变，才执行外部命令\n如果持续为 1，不会重复执行\n\nexePath = &#x27;...XXX.exe&#x27;;paramPath = &#x27;...指定输入&#x27;;\nexePath 是要调用的外部可执行文件路径，paramPath 是输入数据或配置文件的路径\nif ~isfile(exePath)    warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);    block.OutputPort(1).Data = -2;    block.Dwork(1).Data = u;    return;endif ~isfolder(paramPath)    warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);    block.OutputPort(1).Data = -3;    block.Dwork(1).Data = u;    return;end\n\n如果 EXE 不存在 → 返回 -2\n如果参数目录不存在 → 返回 -3\n\nexePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];args = [&#x27;1|1|&#x27; paramPathQuoted];cmd = [exePathQuoted &#x27; &#x27; args];disp([&#x27;[XXX] 正在执行: &#x27; cmd]);\n\n\n把路径加引号是为了防止路径中有空格报错\n\n\n执行命令类似于（根据自己的可执行文件进行修改，这里的1|1|是参数需要）\n&quot;I:\\...\\XXX.exe&quot; 1|1|&quot;C:\\Users\\...\\指定输入&quot;\n\n\nstatus = system(cmd);if status == 0    block.OutputPort(1).Data = 1;  % 成功else    block.OutputPort(1).Data = -1; % 失败end\n\nsystem(cmd) 用于调用系统命令\n如果返回值为 0，表示执行成功 → 输出 1\n否则 → 输出 -1\n\nelse    block.OutputPort(1).Data = 0;  % 无触发，不执行end\n\n输入无变化或不是上升沿时，输出 0\n\nblock.Dwork(1).Data = u;\n\n用当前输入值覆盖 Dwork，供下一次仿真调用使用\n\n\n\n\n输出值\n含义\n\n\n\n\n1\n成功执行 XXX.exe\n\n\n-1\n执行失败\n\n\n-2\n找不到 EXE\n\n\n-3\n参数目录不存在\n\n\n0\n无触发（未上升沿）\n\n\n\n代码流程概览\n\n\n\n阶段\nSimulink 触发\n函数\n功能描述\n\n\n\n\n模块加载时\nSimulink 加载模型\nsfun_callXXX() → setup()\n初始化输入输出端口、采样时间、Dwork 状态变量等\n\n\n仿真开始时\n点击仿真按钮 Run\nInitializeConditions()\n将 prevInput 初始化为 0\n\n\n每个仿真步\n每秒调用一次\nOutput()\n检测输入信号是否跳变为 1，如果是就执行 XXX.exe\n\n\n\n在Simulink中使用S Function\n在命令行窗口输入simulink或直接点击菜单面板“Simulink”来打开Simulink仿真工具，新建空白模型\n\n将该模型保存到当前目录下（与上述.m文件相同），在库浏览器中依次将Constant、Level-2 MATLAB S-Function（不能直接选S-Function，因为我们的代码是针对Level 2的）、Display模块拖入，并连接如下\n\n双击S-Function模块，将 S-function name 设为 sfun_callXXX，确认之后提示出错。\n这里的主要原因为MATLAB Level-2 S-Function 的 Dwork 区只能在 PostPropagationSetup() 阶段设置，而目前把 NumDworks 和 Dwork 配置写在了 setup() 里，这是不允许的，修改如下\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function：检测 0→1 边沿并调用 XXX.exe    setup(block);end%-----------------------------------------------------------%function setup(block)%% 1. 端口block.NumInputPorts  = 1;block.NumOutputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.SetPreCompOutPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;   % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;block.OutputPort(1).Dimensions = 1;block.OutputPort(1).DatatypeID = 0;block.OutputPort(1).Complexity = &#x27;Real&#x27;;%% 2. 采样时间（每 1 s 执行一次）block.SampleTimes = [1 0];%% 3. S-Function 状态机合规block.SimStateCompliance = &#x27;DefaultSimState&#x27;;%% 4. 注册回调 —— 用 RegBlockMethod（关键）block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostPropSetup);block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitConditions);block.RegBlockMethod(&#x27;Outputs&#x27;,              @Output);end%-----------------------------------------------------------%function PostPropSetup(block)%% Dwork 在此阶段声明block.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;  % doubleblock.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;end%-----------------------------------------------------------%function InitConditions(block)%% 仿真开始时：prevInput 置零block.Dwork(1).Data = 0;end%-----------------------------------------------------------%function Output(block)%% 边沿检测 + 执行外部 EXEu    = block.InputPort(1).Data;prev = block.Dwork(1).Data;if u == 1 &amp;&amp; prev == 0    % 路径设定    exePath   = &#x27;I:\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    % -------- 路径检查（兼容旧版 MATLAB：用 exist） --------    if exist(exePath,&#x27;file&#x27;) ~= 2        warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath);        block.OutputPort(1).Data = -2;    elseif exist(paramPath,&#x27;dir&#x27;) ~= 7        warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);        block.OutputPort(1).Data = -3;    else        % 构造命令        cmd = [&#x27;&quot;&#x27; exePath &#x27;&quot; 1|1|&quot;&#x27; paramPath &#x27;&quot;&#x27;];        disp([&#x27;[XXX] 执行: &#x27; cmd]);        status = system(cmd);        block.OutputPort(1).Data = double(status == 0) * 2 - 1;  % 1 成功 /-1 失败    endelse    block.OutputPort(1).Data = 0;                                % 未触发end% 更新上周期输入block.Dwork(1).Data = u;end\n运行仿真，观察到Display显示为1表明正确调用执行，为了方便截图，我把Display换为Scope，观察如下\n\n第一秒，输入从0→1 调用exe成功并输出1，第二秒没有跳变发生，输出为0\nSimulink 对该 S-Function 模块的调用时序如下\n\n\n\n时间\n执行\n来自 S-Function 的函数调用\n说明\n\n\n\n\n0s\n初始化\nsetup() → InitializeConditions()\n初始化端口、状态变量（prevInput=0）\n\n\n每秒\n仿真步\nOutput() 被调用一次\n判断输入信号是否从 0→1 变化，若是就调用 EXE\n\n\n\n假设输入信号如下\n\n\n\n步数\n输入 u\nprevInput\n是否执行 EXE？\n输出值\n\n\n\n\n1\n0\n0\n否\n0\n\n\n2\n1\n0\n是（跳变）\n1 / -1\n\n\n3\n1\n1\n否\n0\n\n\n4\n0\n1\n否\n0\n\n\n5\n1\n0\n是（跳变）\n1 / -1\n\n\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"VSCode插件开发-文件统计功能","url":"/posts/57a69459/","content":"修改package.json\n在开发 VS Code 插件时，package.json 是整个插件的“说明书”。这里以一个简单的功能为例进行测试\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;],&quot;main&quot;: &quot;./out/extension.js&quot;,&quot;contributes&quot;: &#123;  &quot;commands&quot;: [    &#123;      &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,      &quot;title&quot;: &quot;File State&quot;,      &quot;category&quot;: &quot;Code Auto Test&quot;    &#125;  ],  &quot;menus&quot;: &#123;    &quot;editor/context&quot;: [      &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ],    &quot;explorer/context&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ]  &#125;&#125;\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;]\n\n意义：插件不会在 VS Code 启动时就加载，而是在用户执行命令 code-auto-test.getFileState 时激活。\n优势：提升启动性能，遵循 VS Code 插件的延迟加载机制。\n\n指定插件的主入口\n&quot;main&quot;: &quot;./out/extension.js&quot;\n\n指向插件的主模块，通常是 TypeScript 编译后的文件。\nextension.js 中通常包含 activate(context) 和 deactivate() 函数，用于插件的生命周期管理。\n\n注册自定义命令\n&quot;commands&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;title&quot;: &quot;File State&quot;,    &quot;category&quot;: &quot;Code Auto Test&quot;  &#125;]\n\ncommand：命令的唯一标识符，供代码调用。\ntitle：在命令面板（Ctrl+Shift+P）中的显示名称。\ncategory：命令分类，显示为 &quot;Code Auto Test: File State&quot;。\n\n执行位置包括：\n\n命令面板\n上下文菜单（通过 menus 配置）\n\n集成到右键菜单中\n编辑器右键菜单\n&quot;editor/context&quot;: [  &#123;    &quot;when&quot;: &quot;editorFocus&quot;,    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：当编辑器中有焦点时，在右键菜单的“导航”区域显示。\nwhen: 上下文条件，这里为 editorFocus 表示编辑器有焦点时才显示。\n\n资源管理器右键菜单\n&quot;explorer/context&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：资源管理器（文件树）右键菜单中。\n可用于对选中的文件/文件夹执行操作。\n\n通过这段简单的配置，我们实现了一个功能完整的 VS Code 插件功能点：\n\n\n\n功能\n实现方式\n\n\n\n\n延迟激活\nactivationEvents 指定命令触发激活\n\n\n注册命令\ncontributes.commands\n\n\n集成编辑器右键菜单\nmenus.editor/context\n\n\n集成资源管理器右键菜单\nmenus.explorer/context\n\n\n\n这套模式是编写 VS Code 插件的基础，适用于各种需要通过右键或命令面板触发逻辑的场景，比如自动测试、代码分析、格式化工具等。\n修改extension.ts\n查看文件状态的命令实现（extension.ts）\n我们前面在 package.json 中注册了命令 code-auto-test.getFileState，接下来在插件主入口文件中进行具体实现。\n文件路径：src/extension.ts\n// 引入 VS Code 扩展 APIimport * as vscode from &#x27;vscode&#x27;;import * as fs from &#x27;fs&#x27;;// 插件激活时触发export function activate(context: vscode.ExtensionContext) &#123;\tconsole.log(&#x27;插件已激活：code-auto-test&#x27;);\t// 注册 getFileState 命令\tconst disposable = vscode.commands.registerCommand(&#x27;code-auto-test.getFileState&#x27;, (uri: vscode.Uri) =&gt; &#123;\t\t// 获取文件路径\t\tconst filePath = uri.fsPath;\t\t// 异步获取文件信息\t\tfs.stat(filePath, (err, stats) =&gt; &#123;\t\t\tif (err) &#123;\t\t\t\tvscode.window.showErrorMessage(`获取文件信息失败: $&#123;err.message&#125;`);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 判断是否为文件夹\t\t\tif (stats.isDirectory()) &#123;\t\t\t\tvscode.window.showWarningMessage(&#x27;检测的是文件夹，不是文件，请重新选择！&#x27;);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 若是普通文件，显示基本信息\t\t\tif (stats.isFile()) &#123;\t\t\t\tconst size = stats.size;\t\t\t\tconst createTime = stats.birthtime.toLocaleString();\t\t\t\tconst modifyTime = stats.mtime.toLocaleString();\t\t\t\tvscode.window.showInformationMessage(\t\t\t\t\t` 文件大小: $&#123;size&#125; 字节\\n 创建时间: $&#123;createTime&#125;\\n 修改时间: $&#123;modifyTime&#125;`,\t\t\t\t\t&#123; modal: true &#125;\t\t\t\t);\t\t\t&#125;\t\t&#125;);\t\t// 调试用：同步读取 stat 信息输出日志\t\ttry &#123;\t\t\tconst statsSync = fs.statSync(filePath);\t\t\tconsole.log(&#x27;statSync:&#x27;, statsSync);\t\t\tconsole.log(&#x27;isFile:&#x27;, statsSync.isFile());\t\t&#125; catch (err) &#123;\t\t\tconsole.error(&#x27;statSync 读取失败:&#x27;, err);\t\t&#125;\t&#125;);\t// 将命令加入插件上下文中\tcontext.subscriptions.push(disposable);&#125;// 插件被卸载时触发export function deactivate() &#123;&#125;\n\n\n\n功能点\n说明\n\n\n\n\nvscode.Uri\n命令参数自动传入，支持从资源管理器中点击文件触发命令。\n\n\nfs.stat()\n异步获取文件状态，包含文件大小、创建时间、修改时间等。\n\n\nfs.statSync()\n同步版本，用于调试或日志输出。\n\n\nvscode.window.showInformationMessage(..., &#123; modal: true &#125;)\n使用模态窗口展示信息，确保用户注意查看。\n\n\n\n在编辑器中右键文件：\n\n显示：File State\n点击后弹出文件大小、创建时间、修改时间\n\n在资源管理器中右键文件：\n\n同样支持显示该命令\n若选中文件夹则给出提示\n\n\n通过 package.json + extension.ts，我们构建了一个结构完整、功能清晰的 VS Code 插件，具备以下特征：\n\n延迟激活（按需加载）\n支持右键菜单调用\n使用原生 Node.js 文件系统 API 获取信息\n弹出信息提示（用户交互友好）\n\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"关于Clash开启TUN无法联网的问题","url":"/posts/78c6fb80/","content":"之前我一直在用 Clash for Windows 科学上网。后来为了使用 Google 的反重力（Antigravity）软件，需要开启 TUN 模式，但我这边出现了一个非常折磨人的问题：只要一打开 TUN，就直接断网。\n这期间我在网上翻了无数帖子、试了无数“玄学设置”，都没能根治。中间还换过同门的一款 CFW（确实能开 TUN 正常用），但它有一个新毛病：会随机掉网——有时一瞬间，有时持续十几秒，尤其在和 AI 对话时，断一下就可能导致长回答直接中断，反复重试也很浪费时间。\n于是我决定换到口碑更好、且仍在维护的 Clash Verge Rev。结果安装后发现：开启 TUN 依然无法联网。这让我意识到：问题不在某一款软件，而在我的网络环境/路由策略上。\n直到某次我无意间翻日志，看到了“不太一样”的提示（大意是内核选择的出口接口/路由不对），我才突然反应过来——\n\n\n我的以太网（Ethernet）连的是内网。\n如果系统默认把“以太网”当成更优先的出口，Clash 开启 TUN 后把流量按默认路由丢给以太网，那怎么可能访问公网？\n\n所以真正要解决的不是“怎么调 Clash”，而是：\n让系统默认出口走 WLAN（Wi-Fi），而不是以太网。\n下面记录两种我亲测有效的方案。\n\n症状表现\n\n\nClash Verge Rev（或其他支持 TUN 的客户端）开启 TUN 后：\n\n浏览器打不开网页 / 全局断网\n或日志里出现 IP/路由相关报错（比如出口接口选择异常、路由不可达等）\n\n\n关闭 TUN 一切恢复正常\n\n\n根因：默认路由/接口优先级选错了\nWindows 在多网卡并存时，会根据 接口跃点数（Interface Metric）、路由表等规则决定默认出口。\n如果你的 以太网优先级高于 Wi-Fi，系统就可能优先走以太网默认路由——而你这条以太网只通内网，不通公网，于是“看起来像是 TUN 把网搞没了”。\n\n方案一：禁用以太网（有副作用）\n适用场景：你暂时不需要访问内网服务，只想立刻恢复公网。\n操作步骤\n\nWin + R 输入 ncpa.cpl 回车（打开“网络连接”）\n找到 以太网（Ethernet） → 右键 → 禁用\n再打开 Clash 的 TUN，通常就能直接联网\n\n缺点\n\n禁用后 无法访问内网资源（例如内网服务器、NAS、实验室网段等）\n需要内网时还得手动启用回来\n\n\n方案二：提升 WLAN 优先级（推荐）\n核心思路：把 Wi-Fi 的 Metric 调小（优先级更高），把 以太网的 Metric 调大（优先级更低）。\n这样默认出口走 Wi-Fi，但你访问内网网段时，依然可以走以太网（只要路由存在）。\n方法 A：图形界面修改（稳定、直观）\n\n建议 IPv4 和 IPv6 都改一下，避免某些环境下“IPv6 先走错”。\n\n\n\nWin + R → 输入 ncpa.cpl\n\n\n\n右键 Wi-Fi → 属性\n\n\n\n双击 Internet 协议版本 4 (TCP/IPv4) → “高级…”\n\n\n\n\n取消勾选 自动跃点数（Automatic metric）\n\n\n在“接口跃点数”填一个较小值，例如：5 或 10\n\n\n\nIPv6（TCP/IPv6）同样操作一遍（可选但推荐）\n\n\n\n\n右键 以太网 → 属性\n\n操作同上\n\n\n同样进入 IPv4/IPv6 高级设置\n取消自动跃点数\n设置一个较大的值，例如：50 / 100\n\n\n\n修改后一般无需重启，断开重连 Wi-Fi/以太网或重启 Clash 即可。\n\n方法 B：命令行修改（适合记录/脚本化）\n以管理员身份打开 PowerShell，然后：\n# 查看当前接口与跃点数Get-NetIPInterface | Sort-Object InterfaceMetric | Format-Table ifIndex,InterfaceAlias,AddressFamily,InterfaceMetric# 把 Wi-Fi 提高优先级（metric 更小）Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv4 -InterfaceMetric 5Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv6 -InterfaceMetric 5# 把 Ethernet 降低优先级（metric 更大）Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv4 -InterfaceMetric 50Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv6 -InterfaceMetric 50\n\n这是我修改后的配置\n\n注意：不同机器网卡名称可能不是 WLAN / 以太网，以你 Get-NetIPInterface 里看到的 InterfaceAlias 为准。\n\n进阶：用 Proxifier 给 AI 工具做应用级代理，减少对话断连\n即便把 TUN 问题解决了，我还遇到过 AI 工具网络不稳定、对话偶发中断 的情况。很多 AI 客户端/IDE 插件并不总是“乖乖走系统代理”，或者在网络切换时连接更容易抖动。\n我的做法是：不用全局折腾，把 AI 相关进程强制走 Clash 的本地 SOCKS5 代理（应用级代理），让它们的网络路径更一致，从而减少断连。\n下面以我当前配置为例：\n1）在 Proxifier 添加 Clash 的 SOCKS5 代理\n打开 Proxifier：\n\n\nProfile → Proxy Servers... → Add...\n或点击图中位置\n\n\n\n\n按如下填写：\n\n\nAddress：127.0.0.1\n\n\nPort：7897\n\n\nProtocol：SOCKS Version 5\n\n\nAuthentication 不用勾（一般 Clash 本地不需要）\n\n\n\n\n\n点 Check 测试连通性，确认 OK\n\n\n\n\n提醒：7897 是我这边 Clash 的 SOCKS 端口，你的端口以 Clash/Verge 的端口设置为准。\n\n2）新增一条“AI”规则，只代理指定程序\n\n\nProfile → Proxification Rules... → Add...\n或点击图中位置\n\n\n\n\nName：AI（勾选 Enabled）\n\n\nApplications：填入需要强制走代理的程序：\n\nantigravity.exe; language_server_windows_x64.exe; cursor.exe\n\n\n\nTarget hosts：留空（表示不限制域名）\n\n\nTarget ports：Any\n\n\nAction：选择刚才创建的代理\n\nProxy SOCKS5 127.0.0.1\n\n\n\n最后把 AI 规则放到 Default 规则之上（规则是从上往下匹配的），避免被默认规则抢先匹配。\n\n\n3）效果\n\n只有 AI 相关进程走代理\n内网/其他软件照常走直连或按你自己的规则走\n对话连接更稳定：不会因为某些程序绕过系统代理而“时通时不通”，也更不容易在长对话时突然断掉\n\n","categories":["Clash"],"tags":["Clash","Proxifier","Tun"]},{"title":"关于Simulink中参数传递的解决方案","url":"/posts/fcf42186/","content":"介绍\n本文主要对之前的Simulink工作进行优化，前面通过S Function一共实现了三个模块，分别为参数交互模块、调用求解模块和数据展示模块。但后续两个模块的代码中都采用了硬编码的方式来指定文件夹的路径，事实上后续两个模块的文件夹路径与第一个模块选中的文件夹是同一个路径，因此为了减少因为硬编码而导致的路径错误，我们将修改代码，把第一个模块选中的文件夹传递给后续的模块，这里将会使用Simulink的封装功能\n如何传递模块参数\n核心问题：传递文件夹路径\n目前，sfun_callXXX.m 和 sfun_callXXXProcess.m 中的文件路径是硬编码的，这降低了灵活性。\n% sfun_callXXX.mparamPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;% sfun_callXXXProcess.mdir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;\n最佳的解决方案是利用 Simulink 的 Mask Parameters (模块参数) 来接收路径，然后由第一个 S-Function (sfun_callInterface) 在用户确认路径后，通过编程方式设置这些参数。\n\n在 Simulink 模型中，右键点击 sfun_callXXX 模块，选择 Mask &gt; Create Mask。\n在 Mask Editor 窗口中，进入 Parameters &amp; Dialog 选项卡。\n在左侧面板添加一个 Edit 参数。\n在右侧的 Parameter Properties 中，设置:\n\nPrompt: 求解器参数路径\nName: paramPath\nEvaluate：取消勾选\n\n\n点击 OK 或 Apply 保存 Mask。\n对 sfun_callXXXProcess 模块重复以上步骤，但将参数 Name 设置为 dataDir。\n再次右键点击该模块，选择 Block Parameters (S-function)。\n在打开的对话框中，找到一个名为 S-function parameters 的输入框。\n在这个输入框里，填入你的 变量名 (paramPath 或 dataDir)。\n点击 OK 或 Apply。\n为另一个 S-Function 模块重复上述步骤。\n\n\n这个操作的目的是建立 Mask 和 S-Function 代码之间的连接。当你在 Mask 界面输入路径时，该路径字符串会存入名为 paramPath 的变量中。然后，通过将 paramPath填入 “S-function parameters” 字段，这个变量的值就被传递给了 S-Function 内部，代码 block.DialogPrm(1).Data 才能成功地接收到这个路径。\n现在，修改这两个 S-Function，让它们从刚刚创建的 Mask Parameter 中读取路径，而不是使用硬编码的字符串。\n修改 sfun_callXXX.m:\n\n\n在 setup 函数中，声明该模块有一个 Mask Parameter。\nfunction setup(block)    % ... (I/O 配置)    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    % ... (SampleTime 等其他配置)end\n\n\n在 Outputs 函数中，用 block.DialogPrm(1).Data 替换硬编码的路径。\nfunction Outputs(block)    % ...    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行    paramPath = block.DialogPrm(1).Data;    % &lt;--- 添加这一行    % ...end\n\n\n修改 sfun_callXXXProcess.m:\n\n\n同样，在 setup 函数中声明 Mask Parameter。\nfunction setup(block)    % ...    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    block.SampleTimes        = [0.5 0];    % ...end\n\n\n在 Outputs 函数中，替换硬编码的路径。\nfunction Outputs(block)    % ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行        dir = block.DialogPrm(1).Data;    % &lt;--- 添加这一行        % ...    end    % ...end\n\n\n最后，修改第一个 S-Function 的 GUI 确认回调函数 (confirm_action)，让它在用户点击“确认”时，自动将选定的文件夹路径写入另外两个模块的 Mask Parameter。\n为此，需要在 Simulink 模型中为 sfun_callXXX 和 sfun_callXXXProcess 模块指定一个清晰的、可编程访问的名称。例如，将它们分别命名为 XXX_Launcher 和 XXX_Processor。如图所示\n\n修改 sfun_callInterface.m 中的 confirm_action 函数:\n% sfun_callInterface.mfunction confirm_action(fig)    % ... (前面的代码保持不变)    % --- 新增代码：获取模型名称和设置其他模块的参数 ---    try        blockHandle = fig.UserData.blockHandle;        modelName = bdroot(blockHandle); % 获取顶层模型的名称                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);    catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % 释放处理器并返回，防止在出错时继续执行        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        return;    end    % --- 新增代码结束 ---    % ... (释放处理器、设置 confirmationFlag 和关闭 GUI 的代码保持不变)        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end\n小结: 通过以上三步，完成了下述工作：\n\nsfun_callInterface 的 GUI 捕获用户选择的路径。\n当用户点击“确认”时，该模块通过 set_param 函数，将路径动态地写入 XXX_Launcher 和 XXX_Processor 模块的 Mask 中。\n这两个模块在运行时，从自己的 Mask Parameter 中读取路径，从而实现了动态配置，完全避免了硬编码。\n\n\n注意：上述代码仍会出现问题，具体来说是modelName无法被识别，后续我将附上全部修改代码，这里不做展示\n\n\n加载/卸载Dll的优化\n此时多个模块正在加载和卸载同一个DLL (BWIBridgeDLL.dll)。这种做法效率低下，并且可以被简化。最佳实践是在整个仿真生命周期内将DLL作为共享资源进行管理：在仿真开始时加载一次，在仿真终止时卸载一次。\n1. 修改 sfun_callInterface.m\n该模块应负责加载DLL，并确保它在仿真期间保持加载状态。\n在 close_gui 函数中，删除卸载DLL的那一行代码。GUI不再需要管理DLL的卸载，这个任务将交给仿真的终止阶段来处理。\n原始代码 (sfun_callInterface.m):\nfunction close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\n建议修改:\nfunction close_gui(fig)    % DLL 不再在这里卸载。它将由仿真流程中最后一个S-Function模块的    % Terminate 函数来处理。    delete(fig);end\n2. 修改 sfun_callXXXProcess.m\n该模块应负责在仿真结束时卸载DLL。其 Outputs 函数也应简化，直接使用已加载的库。\na. 在 Outputs 函数中:\n移除 loadlibrary 和 unloadlibrary 调用。现在代码应该假设DLL已经被第一个模块加载了。为保险起见，可以添加一个 libisloaded 检查。\n原始代码 (sfun_callXXXProcess.m):\nfunction Outputs(block)    % ... (前面的代码) ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        dir = block.DialogPrm(1).Data;        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        % ... (调用库的逻辑) ...                % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % ... (剩余的代码) ...end\n建议修改:\nfunction Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        % ... (其余逻辑保持不变) ...        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary 调用已从此函数中移除。    end    block.Dwork(1).Data = u;end\nb. 在 Terminate 函数中:\n此函数在仿真停止时会执行一次。这是卸载DLL的理想位置。\n原始代码 (sfun_callXXXProcess.m):\nfunction Terminate(~)end\n建议修改:\nfunction Terminate(~)    fprintf(&#x27;[XXX] Simulation terminated. Unloading BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n经过修改之后，我们的代码理论上只会在仿真开始时加载Dll，在仿真结束后卸载Dll，避免中间过程对Dll的反复调用\n隐含问题\n在sfun_callXXX.m的代码中，还存在着一个潜在的重要问题，我们使用了如下代码\n%— 持久变量：进程句柄 —————————————persistent procObj\n这是一个持久变量，用来检测进程的状态，当我们使用了不止于一个sfun_callXXX模块时，所有模块将共享这个变量，如果我们在第一个模块中启动一个.exe进程，并将其句柄存入 procObj。紧接着，第二个模块启动另一个.exe进程，并将其句柄覆盖到同一个 procObj 变量中。此时，第一个进程的句柄就丢失了。系统将无法再轮询或终止第一个进程，从而导致逻辑错误和进程失控。简单来说，当前的设计只适用于模型中只有一个XXX_Launcher模块的情况。一旦需要多个，就会立即出错。\n目前这个问题还没有解决，后续如果遇到了，会在该系列文章中提供解决方案\n最后附上全部代码\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);         % 这里的双击回调函数并不能正常使用，如要使用，可能要把start_import_gui及相关代码作为独立的文件和函数end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0                % --- 确保 modelName 永远是字符串 ---        rootSystem = bdroot(block.BlockHandle); % 获取顶层模型，结果可能是句柄或名称                modelName = &#x27;&#x27;; % 初始化        if isnumeric(rootSystem) &amp;&amp; ishandle(rootSystem)            % 如果返回的是数字句柄，则通过句柄获取名称            modelName = get_param(rootSystem, &#x27;Name&#x27;);        elseif ischar(rootSystem)            % 如果返回的是字符串名称，则直接使用            modelName = rootSystem;        end        % 添加一个安全检查，如果获取名称失败则报错并停止        if isempty(modelName)            errordlg(&#x27;无法获取 Simulink 模型名称，GUI 无法启动。&#x27;, &#x27;严重错误&#x27;);            % 在这种严重错误下，停止仿真可能更安全            set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);            return; % 提前退出函数        end        % --- 修复结束 ---                start_import_gui(modelName);        block.Dwork(1).Data = 1;    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(modelName)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.modelName  = modelName;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;    try        % 从 UserData 获取模型名称字符串        modelName = fig.UserData.modelName; % &lt;--- 修改点                % 检查 modelName 是否有效 (例如，不是空的)        if isempty(modelName) || ~ischar(modelName)            error(&#x27;未能获取有效的模型名称。&#x27;); % 抛出一个错误        end                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);            catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % ... (释放处理器并返回)        return;    end        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    % if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)    %     unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    % end    % 清理其他资源如果需要    delete(fig);end\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    block.NumDialogPrms  = 1;     %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;    paramPath = block.DialogPrm(1).Data;     %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            fprintf(&#x27;[XXX] PID=%d 已退出\\n&#x27;, block.Dwork(3).Data)            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.NumDialogPrms  = 1;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        % --- 读取数据并绘图 ---        % dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        % hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt);        if ~result            fprintf(&#x27;读取失败&#x27;)            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);            unloadlibrary(&#x27;BWIBridgeDLL&#x27;)        end;        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)    fprintf(&#x27;[XXX] Simulation 终止. 卸载 BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"创建VS Code插件","url":"/posts/7d850c90/","content":"本人打算创建一个VS Code插件用于调试代码，拟结合AI用于生成测试用例，分析代码等\n环境准备\n安装Node.is\nVS Code 插件开发使用 JavaScript / TypeScript 编写，需要 Node.js 来运行开发脚本和构建流程\n官网：https://nodejs.org\n安装后验证是否成功\nnode -v\n\n安装脚手架\n这里会用到yo和generator-code\nyo 是 Yeoman 的命令行工具，是一个用于快速生成项目脚手架的工具，类似于项目生成器\ngenerator-code 是一个 Yeoman 生成器插件，专门用于生成 VS Code 插件项目 的脚手架。\n全局安装yo和generator-code\nnpm i -g yo generator-code\n我这里已经安装过了，输出如下\n\n创建VS Code插件项目\n新建工程\n在你需要创建插件的目录下输入\nyo code\n执行如下\n\n\n[!NOTE]\n这里将会依次问你如下几个问题\n\n选择你的插件类型\n插件的名字\n插件的唯一标识\n插件的描述\n是否需要git仓库\n打包工具选择\n选择包管理工具\n\n\n我的配置如图\n\n选择完成之后出现如下内容\n\n然后可以选择打开新建的工程或者直接跳过，这里选择第一个，打开之后项目结构如图所示，其中最重要的文件是package.json和extension.js，到这里一个VS Code的框架算是基本完成了。\n\n目录介绍\n\n[!NOTE]\n.vscode: 里面的文件是用来测试插件或者测试代码的一些文件。\nnode_modules: 第三方依赖。\nsrc/test：测试文件。\nsrc/extension.ts：插件的主文件\n\npackage.json文件\n该文件是vscode扩展的清单文件，具体可以看文档：发布内容配置\n&#123;  &quot;name&quot;: &quot;code-auto-test&quot;,\t// 插件名  &quot;displayName&quot;: &quot;code-auto-test&quot;,\t// 应用市场显示的名字  &quot;description&quot;: &quot;自动执行代码测试&quot;,\t// 插件描述  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;engines&quot;: &#123;    &quot;vscode&quot;: &quot;^1.101.0&quot;  &#125;,  &quot;categories&quot;: [    &quot;Other&quot;\t// 扩展类别  ],   // 激活事件组，在那些事件情况下被激活  &quot;activationEvents&quot;: [],   // 插件的主入口文件  &quot;main&quot;: &quot;./out/extension.js&quot;,  &quot;contributes&quot;: &#123;     // 命令    &quot;commands&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.helloWorld&quot;,        &quot;title&quot;: &quot;Hello World&quot;      &#125;    ]  &#125;,  &quot;scripts&quot;: &#123;    &quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,    &quot;compile&quot;: &quot;tsc -p ./&quot;,    &quot;watch&quot;: &quot;tsc -watch -p ./&quot;,    &quot;pretest&quot;: &quot;npm run compile &amp;&amp; npm run lint&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;test&quot;: &quot;vscode-test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@types/vscode&quot;: &quot;^1.101.0&quot;,    &quot;@types/mocha&quot;: &quot;^10.0.10&quot;,    &quot;@types/node&quot;: &quot;20.x&quot;,    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.31.1&quot;,    &quot;@typescript-eslint/parser&quot;: &quot;^8.31.1&quot;,    &quot;eslint&quot;: &quot;^9.25.1&quot;,    &quot;typescript&quot;: &quot;^5.8.3&quot;,    &quot;@vscode/test-cli&quot;: &quot;^0.0.10&quot;,    &quot;@vscode/test-electron&quot;: &quot;^2.5.2&quot;  &#125;&#125;\nextension.js文件\n入口文件，即package.json中main字段对应的文件，文件中有导出两个方法：activate和deactivate\n测试\n在package.json文件中添加激活事件\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.helloWorld&quot;],\n终端进入项目\ncd code-auto-testnpm installnpm run compile\n这会将 src/extension.ts 编译到 out/extension.js，为插件运行做好准备\nF5运行插件，会启动扩展宿主环境，打开任意文件夹，按下ctrl+shift+p 并输入helloworld\n\n确认选择Hello World，右下角出现如图内容表明运行成功\n\n先到这吧，累了😮‍💨\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"Ascend C算子开发能力认证（中级）","url":"/posts/9e1eacb0/","content":"认证要求\n实现Ascend C算子Sigmoid,算子命名为SigmoidCustom,编写其kernel侧代码、host侧代码,并完成aclnn算子调用测试。\n相关算法:\nsigmoid(x)=1/(1+exp(−x))sigmoid(x) = 1/(1 + exp(-x))\nsigmoid(x)=1/(1+exp(−x))\n\n实现流程\n环境初始配置\n由于华为的ModelAtrs平台每次重启会把环境中除work目录之外的内容全部清除，因此每次需要重新设置环境，执行\nbash init_env.shsource ~/.bashrcsource /home/ma-user/Ascend/ascend-toolkit/set_env.shchmod +x -R *\n上述命令依次用于下载包、配置环境变量以及脚本权限等\n代码编写\n从认证平台下载压缩包，解压之后包含SigmoidCustom和AclNNInvocation两个文件夹，SigmoidCustom中的内容主要完成代码编写、编译运行等，AclNNInvocation用于实现调用、测试等\n文件主要内容如下\n\nHost测实现\n首先在sigmoid_custom_tiling.h完成tiling结构体设计，在代码的注释后添加如下内容\nTILING_DATA_FIELD_DEF(uint32_t, totalLength);TILING_DATA_FIELD_DEF(uint32_t, tileNum);\n然后在sigmoid_custom.cpp中的注释后添加\nuint32_t totalLength = context-&gt;GetInputShape(0)-&gt;GetOriginShape().GetShapeSize();context-&gt;SetBlockDim(BLOCK_DIM);tiling.set_totalLength(totalLength);tiling.set_tileNum(TILE_NUM);tiling.SaveToBuffer(context-&gt;GetRawTilingData()-&gt;GetData(), context-&gt;GetRawTilingData()-&gt;GetCapacity());context-&gt;GetRawTilingData()-&gt;SetDataSize(tiling.GetDataSize());size_t *currentWorkspace = context-&gt;GetWorkspaceSizes(1);currentWorkspace[0] = 0;return ge::GRAPH_SUCCESS;\nDevice测实现\n这里的代码稍微复杂，需要用户自行实现核函数的初始化、内存迁移、算法实现等，完整代码如下\n#include &quot;kernel_operator.h&quot;using namespace AscendC;constexpr int32_t BUFFER_NUM = 2;class KernelSigmoid &#123;public:    __aicore__ inline KernelSigmoid() &#123;&#125;    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, uint32_t totalLength, uint32_t tileNum)    &#123;        //考生补充初始化代码        this-&gt;blockLength = totalLength / AscendC::GetBlockNum();        this-&gt;tileNum = tileNum;        this-&gt;tileLength = this-&gt;blockLength / tileNum / BUFFER_NUM;        xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        yGm.SetGlobalBuffer((__gm__ DTYPE_Y *)y + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        pipe.InitBuffer(inQueueX, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(outQueueY, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer1, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer2, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer3, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer4, this-&gt;tileLength * sizeof(half));    &#125;    __aicore__ inline void Process()    &#123;        //考生补充对“loopCount”的定义，注意对Tiling的处理        int32_t loopCount = this-&gt;tileNum * BUFFER_NUM;        for (int32_t i = 0; i &lt; loopCount; i++) &#123;            CopyIn(i);            Compute(i);            CopyOut(i);        &#125;    &#125;private:    __aicore__ inline void HighPrecisionReciprocal(LocalTensor&lt;half&gt;&amp; dst,                                               const LocalTensor&lt;half&gt;&amp; src,                                               int32_t length,                                               int iterations = 2)    &#123;        LocalTensor&lt;half&gt; tmp = tmpBuffer4.Get&lt;half&gt;();        half two = 2.0h,negone=-1.0h;        // 初始近似值 (可以使用硬件Reciprocal的初始值)        AscendC::Reciprocal(dst, src, length);        // 牛顿迭代: x_&#123;n+1&#125; = x_n * (2 - a * x_n)        for (int i = 0; i &lt; iterations; ++i) &#123;            AscendC::Mul(tmp, src, dst, length);    // tmp = a * x_n            AscendC::Muls(tmp, tmp, negone, length);   // tmp = 2 - a * x_n            AscendC::Adds(tmp, tmp, two, length);            AscendC::Mul(dst, dst, tmp, length);     // x_&#123;n+1&#125; = x_n * tmp        &#125;    &#125;    __aicore__ inline void CopyIn(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();        AscendC::DataCopy(xLocal, xGm[progress * this-&gt;tileLength], this-&gt;tileLength);        inQueueX.EnQue(xLocal);    &#125;    __aicore__ inline void Compute(int32_t progress)    &#123;        //考生补充算子计算代码        LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;();        LocalTensor&lt;half&gt; yLocal = outQueueY.AllocTensor&lt;half&gt;();                LocalTensor&lt;half&gt; tmp1 = tmpBuffer1.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp2 = tmpBuffer2.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp3 = tmpBuffer3.Get&lt;half&gt;();                half one=1.0,negone=-1.0;        AscendC::Muls(tmp1, xLocal, negone, this-&gt;tileLength);        AscendC::Exp(tmp2, tmp1, this-&gt;tileLength);        AscendC::Adds(tmp3, tmp2, one, this-&gt;tileLength);                HighPrecisionReciprocal(yLocal,tmp3,this-&gt;tileLength,2);        outQueueY.EnQue&lt;half&gt;(yLocal);        inQueueX.FreeTensor(xLocal);    &#125;    __aicore__ inline void CopyOut(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; yLocal = outQueueY.DeQue&lt;half&gt;();        AscendC::DataCopy(yGm[progress * this-&gt;tileLength], yLocal, this-&gt;tileLength);        outQueueY.FreeTensor(yLocal);    &#125;private:    TPipe pipe;    //create queue for input, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;    //create queue for output, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueY;    GlobalTensor&lt;half&gt; xGm;    GlobalTensor&lt;half&gt; yGm;    //考生补充自定义成员变量    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;    uint32_t blockLength;    uint32_t tileNum;    uint32_t tileLength;&#125;;extern &quot;C&quot; __global__ __aicore__ void sigmoid_custom(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling) &#123;    GET_TILING_DATA(tiling_data, tiling);    KernelSigmoid op;    //补充init和process函数调用内容    op.Init(x, y, tiling_data.totalLength, tiling_data.tileNum);    op.Process();&#125;\n代码解释\n一个自定义算子的生命周期\n在深入代码之前，我们先理解一下从编写到执行，这个 SigmoidCustom 算子经历了什么：\n\n\n开发阶段: 您编写了算子定义、Tiling 逻辑和 Kernel 实现这几个文件。\n\n\n编译阶段: 使用 CANN 提供的工具链进行编译。编译器会分别处理 Host 端代码（编译成标准的 CPU 可执行指令）和 Device 端代码（编译成 AI Core 能理解的 CUBE 指令）。同时，OP_ADD(SigmoidCustom) 宏会将算子的元信息（如输入输出、Tiling 函数地址等）注册到昇腾的算子库中。\n\n\n图构建与下发阶段: 当用户在一个神经网络模型（例如用 MindSpore 或 PyTorch）中调用 SigmoidCustom 时，前端框架会将模型转换为昇腾的计算图（Graph）。图编译器（Graph Engine, GE）会解析这个图，当遇到 SigmoidCustom 节点时，它会：\na.  调用 InferShape 和 InferDataType 函数，在不运行实际计算的情况下，静态推断出这个节点输出的形状和数据类型，以便为整个网络预先分配好内存。\nb.  调用 TilingFunc 函数，根据当前节点的输入张量大小，生成具体的任务切分方案（即 TilingData）。\nc.  将编译好的 Kernel CUBE 指令和 TilingData 打包成一个任务，下发给 NPU 的任务调度器（Task Scheduler）。\n\n\n执行阶段: NPU 的任务调度器根据 TilingData 中的 blockDim 信息，唤醒指定数量的 AI Core。每个被唤醒的 AI Core 都会接收到 Kernel CUBE 指令和 TilingData 的一份拷贝，然后从 sigmoid_custom 这个 __global__ 入口函数开始，独立地执行计算任务。\n\n\nHost 端代码深度解析 (CPU 侧)\nHost 端代码的核心目标是**“定义规则”和“制定计划”**，它不参与实际的数值计算。\n1.1 算子接口定义\n这部分代码是 SigmoidCustom 算子与 CANN 框架交互的“接口”或“驱动”。框架本身不知道你这个算子具体怎么算，但通过这个定义，它知道了如何使用你。\n\nthis-&gt;Input(&quot;x&quot;)... 和 this-&gt;Output(&quot;y&quot;)...: 这不仅仅是定义了输入输出的名称，更重要的是定义了数据依赖关系。图编译器根据这个关系来构建计算图的拓扑结构，决定算子执行的先后顺序。\n.DataType(&#123;ge::DT_FLOAT16&#125;).Format(&#123;ge::FORMAT_ND&#125;): 这是算子的能力声明。它告诉框架：“我能处理 FP16 类型的数据，并且不关心输入的具体维度（ND 格式）。” 如果上游算子的输出格式不匹配，图编译器会自动插入一个转置（Transpose）或类型转换（Cast）算子来适配。\nthis-&gt;SetInferShape(ge::InferShape): 这是一个至关重要的静态分析钩子。在模型编译时，真实的输入数据还不存在，但其形状（Shape）是已知的。框架会调用 InferShape 函数，让算子根据输入的 Shape &quot;预言&quot;自己输出的 Shape。对于 Sigmoid 这种 Element-wise（逐元素）操作，输出形状与输入形状完全相同，所以实现很简单：*y_shape = *x1_shape;。这使得框架可以在运行前就规划好整个模型的内存布局。\nthis-&gt;AICore().SetTiling(optiling::TilingFunc): 这是将**“计划制定者”**（Tiling 函数）与算子本身绑定的关键。框架知道，每当需要执行这个算子时，都应该去调用 TilingFunc 来获取详细的执行计划。\n\n1.2 Tiling 函数\nTiling 函数是 Host 端的智慧所在，它在 CPU 上运行，为即将开始的 Device 端计算制定精密的作战计划。\n\ngert::TilingContext\\* context: context 对象是框架传递给 Tiling 函数的**“情报手册”**。它包含了关于当前任务的所有上下文信息，最主要的就是 context-&gt;GetInputShape(0)，它让 Tiling 函数知道了待处理的数据有多大。\n核心决策:\n\n总览全局: uint32_t totalLength = ...GetShapeSize() 获取了总工作量。\n分配兵力: context-&gt;SetBlockDim(BLOCK_DIM) 决定了要动用多少个 AI Core（这里硬编码为8）。这是一个关键的并行策略决策。如果 totalLength 很小，可能只用一个 AI Core 更高效（避免多核通信开销）；如果 totalLength 巨大，则可以用满所有可用的 Core。\n制定指令:\n\ntiling.set_totalLength(totalLength): 把全局信息写入“指令书” (TilingData)。\ntiling.set_tileNum(TILE_NUM): 决定每个 AI Core 内部的流水线深度或切分粒度。这个值会影响性能，需要根据计算量和数据搬运量的比例（计算访存比）来权衡。TILE_NUM 越大，tileLength 就越小，数据搬运更频繁，但每个计算任务的延迟也更低，有利于流水线隐藏延迟。\n\n\n\n\n信息传递: tiling.SaveToBuffer(...) 将填满信息的 TilingData 结构体序列化为一段连续的内存块。这段内存块将和编译好的 Kernel 代码一起被发送到 Device 端，成为每个 AI Core 执行任务的依据。\n\nDevice 端代码深度解析 (AI Core 侧)\nDevice 端代码是**“一线士兵”**，它们根据 Host 发来的计划，在自己的阵地（AI Core）上高效地执行计算。\n2.1 内存模型与数据并行 (SPMD)\n\nGM_ADDR x, GM_ADDR y: GM_ADDR 是 Global Memory Address 的缩写，代表全局内存中的一个地址。x 和 y 是输入和输出张量在全局内存中的起始地址。\nSPMD (Single Program, Multiple Data): 这是 AI Core 的核心工作模式。所有被唤醒的 AI Core 都执行同一份程序代码（Single Program），但处理的数据各不相同（Multiple Data）。\nAscendC::GetBlockIdx(): 这是实现 SPMD 的关键。该函数返回当前 AI Core 的唯一ID（从0到 blockDim-1）。\nxGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), ...): 这行代码是数据划分的精髓。\n\n(__gm__ DTYPE_X *)x: 将全局内存地址 x 转换为一个指向 FP16 类型的指针。\n... + this-&gt;blockLength * AscendC::GetBlockIdx(): 计算偏移量。\n\n对于 ID=0 的 Core，偏移量是 blockLength * 0 = 0，它处理从 x 开始的数据。\n对于 ID=1 的 Core，偏移量是 blockLength * 1，它处理紧接着第一块的数据。\n…\n\n\n通过这种方式，totalLength 的数据被完美地分割成了 blockDim 份，每个 AI Core 都只关心自己负责的那一段，实现了无冲突的数据并行。\n\n\n\n2.2 本地内存与流水线 (TPipe, TQue)\nAI Core 的性能源泉在于其内部极速的本地内存（LM）和向量计算单元。流水线的目标就是让计算单元永远不要因为等待数据而停工。\n\nTPipe, TQue: 这不是硬件，而是 Ascend C 提供的软件抽象，用于简化对硬件 DMA（数据搬运单元）和本地内存的管理。\nInitBuffer: 在 Init 方法中，pipe.InitBuffer(inQueueX, BUFFER_NUM, ...) 相当于在本地内存中划分出 BUFFER_NUM (即2) 块独立的区域，并由 inQueueX 这个队列对象来管理。\n双缓冲 (Double Buffering) 详解: BUFFER_NUM=2 构成了双缓冲。想象有两块缓冲区 A 和 B：\n\nCopyIn: 调用 inQueueX.AllocTensor&lt;half&gt;() 会从空闲的缓冲区队列中取出一个（比如A），然后 DataCopy 指令启动 DMA 将 GM 数据拷贝到 A。完成后 inQueueX.EnQue(A) 将 A 标记为“已填充，可供计算”。\nCompute: 调用 inQueueX.DeQue&lt;half&gt;() 会从“已填充”队列中取出一个（比如A），然后计算单元对 A 中的数据进行计算。\n重叠执行: 当计算单元正在处理 A 的数据时，CopyIn 阶段可以同时向另一个空闲的缓冲区 B 中拷贝下一批数据。当 A 计算完成，B 也正好拷贝完成，计算单元可以马不停蹄地开始处理 B，而 DMA 则开始将 A 的计算结果写回 GM。\n\n\nfor 循环的流水线建立过程:\n\n迭代 i=0: CopyIn(0) 开始（数据块0从GM-&gt;LM），Compute(0) 和 CopyOut(0) 等待。\n迭代 i=1: CopyIn(1) 开始（数据块1从GM-&gt;LM），同时 Compute(0) 开始（处理数据块0）。CopyOut(1) 等待。\n迭代 i=2: CopyIn(2) 开始，Compute(1) 开始，CopyOut(0) 开始（将数据块0的结果从LM-&gt;GM）。至此，三级流水线完全建立，DMA的读、计算单元、DMA的写三个硬件部件都在满负荷工作。\n\n\n\n2.3 向量计算与硬件指令\n\nAscendC::Muls, AscendC::Exp, AscendC::Adds: 这些函数被称为内置函数（Intrinsics）。它们在编译时会被直接映射为 AI Core 的一条或多条向量指令。\n例如，AscendC::Exp(tmp2, tmp1, this-&gt;tileLength) 不是一个循环，而是一条指令。它告诉向量计算单元：“对 tmp1 指向的 tileLength 个半精度浮点数，逐个执行指数运算，并将结果存放到 tmp2 中”。这种 SIMD（单指令多数据） 的处理方式是 AI Core 性能的根本来源。\n\n2.4 数值计算优化\n\n问题: 硬件通常提供速度快但精度有限的近似计算指令，比如求倒数。对于某些需要高精度的算法，这可能导致误差累积。\n解决方案: 牛顿-拉弗森迭代法是一种经典的数值分析方法，可以用来求方程的根。对于求 1/a，相当于求方程 f(x) = 1/x - a 的根。\n代码映射:\n\nAscendC::Reciprocal(dst, src, length);: 使用硬件指令得到一个初始近似值 x_0 (即 dst)。src 是 a。\nAscendC::Mul(tmp, src, dst, length);: 计算 a * x_n，结果存入 tmp。\nAscendC::Muls(tmp, tmp, negone, length);: 变为 - (a * x_n)。\nAscendC::Adds(tmp, tmp, two, length);: 变为 2 - a * x_n。\nAscendC::Mul(dst, dst, tmp, length);: 计算 x_n * (2 - a * x_n)，得到 x_&#123;n+1&#125;，并覆盖回 dst。\n\n\n这个 for 循环每迭代一次，结果的精度就会翻倍。迭代2次就能获得非常高的精度，这体现了算法与硬件结合的优化思想。\n\n运行测试\n在运行之前，首先检查CMakePresets.json文件中的ASCEND_COMPUTE_UNIT和ASCEND_CANN_PACKAGE_PATH是否正确，如下\n&quot;ASCEND_COMPUTE_UNIT&quot;: &#123;    &quot;type&quot;: &quot;STRING&quot;,    &quot;value&quot;: &quot;ascend310b;ascend910b&quot;&#125;,&quot;ASCEND_CANN_PACKAGE_PATH&quot;: &#123;    &quot;type&quot;: &quot;PATH&quot;,    &quot;value&quot;: &quot;/home/ma-user/Ascend/ascend-toolkit/latest&quot;&#125;,\n然后检查SigmoidCustom中的AICore是否设置正确，如下\nthis-&gt;AICore().AddConfig(&quot;ascend910b&quot;)              .AddConfig(&quot;ascend310b&quot;);\n如果上述设置没有问题，就可以进行编译测试了\n运行编译\nbash build.sh\n编译之后会得到build_out目录，运行其中的安装包\ncd build_out./custom_opp_ubuntu_aarch64.run\n最后到AclNNInvocation中运行测试\nbash run.sh\n检验脚本会调用py脚本，分别用numpy和我们写的算子计算答案，然后对比误差，如果代码没有问题会给出测试成功的提示。由于华为云提供的这个环境属实有点贵，因此我就不再开机测试并截图了，大家自行操作\n随后按照认证要求将SigmoidCustom打包提交即可，测试通过后会获得认证证书，如下\n\n","categories":["华为算子挑战赛"],"tags":["Ascend C","算子开发"]},{"title":"常见数据结构-优先队列","url":"/posts/5beb8088/","content":"优先队列详解：数据结构中的「VIP通道」\n\n掌握优先队列，轻松解决 Top K 和动态数据流问题\n\n\n什么是优先队列\n优先队列（Priority Queue）是一种特殊的队列，其中每个元素都有一个「优先级」，出队时总是优先级最高的元素先出队。\n\n核心特点：不是先进先出（FIFO），而是按优先级出队\n\n形象理解\n想象你在机场登机：\n普通队列：先到先登机优先队列：VIP/头等舱先登机，然后才是经济舱\n底层实现：堆（Heap）\n优先队列通常用堆来实现：\ngraph TD\n    subgraph 最大堆\n        A[9] --&gt; B[7]\n        A --&gt; C[8]\n        B --&gt; D[3]\n        B --&gt; E[5]\n        C --&gt; F[6]\n        C --&gt; G[2]\n    end\n    \n    style A fill:#FF6B6B\n\n\n\n操作\n时间复杂度\n说明\n\n\n\n\n插入\nO(log n)\n上浮调整\n\n\n取出堆顶\nO(log n)\n下沉调整\n\n\n查看堆顶\nO(1)\n不需要调整\n\n\n建堆\nO(n)\n从下往上调整\n\n\n\n\nC++ 中的优先队列\n基本语法\n#include &lt;queue&gt;// 最大堆（默认）priority_queue&lt;int&gt; maxHeap;// 最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n常用操作\npriority_queue&lt;int&gt; pq;pq.push(5);     // 插入元素pq.top();       // 查看堆顶（不删除）pq.pop();       // 删除堆顶pq.empty();     // 是否为空pq.size();      // 元素个数\n自定义比较器\n// 方法1：使用 lambdaauto cmp = [](int a, int b) &#123; return a &gt; b; &#125;;  // 最小堆priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; pq(cmp);// 方法2：存储 pairauto cmp = [](pair&lt;int,int&gt;&amp; a, pair&lt;int,int&gt;&amp; b) &#123;    return a.second &gt; b.second;  // 按 second 的最小堆&#125;;priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; pq(cmp);// 方法3：自定义结构体struct Compare &#123;    bool operator()(int a, int b) &#123;        return a &gt; b;  // 最小堆    &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq;\n\n注意：C++ 优先队列的比较器与 sort 相反！return a &gt; b 表示最小堆\n\n\n典型应用场景\ngraph LR\n    A[优先队列] --&gt; B[Top K 问题]\n    A --&gt; C[合并 K 个有序结构]\n    A --&gt; D[数据流统计]\n    A --&gt; E[贪心算法]\n    A --&gt; F[堆排序]\n    \n    B --&gt; B1[第K大元素]\n    B --&gt; B2[前K个高频元素]\n    \n    C --&gt; C1[合并K个链表]\n    C --&gt; C2[合并K个数组]\n    \n    D --&gt; D1[数据流中位数]\n    D --&gt; D2[滑动窗口最大值]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n    style D fill:#DDA0DD\n\n经典问题详解\n1. 数组中的第K个最大元素\n\nLeetCode 215: 在未排序的数组中找到第 k 个最大的元素\n\n问题分析\n输入：[3, 2, 1, 5, 6, 4], k = 2输出：5排序后：[1, 2, 3, 4, 5, 6]第2大：5\n解法选择\n\n\n\n方法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n\n排序\nO(n log n)\nO(1)\n简单直接\n\n\n最小堆\nO(n log k)\nO(k)\nk 远小于 n\n\n\n快速选择\nO(n) 平均\nO(1)\n一次性查询\n\n\n\n代码实现\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    // 最小堆    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;        for (int num : nums) &#123;        minHeap.push(num);        // 保持堆大小为 k        if (minHeap.size() &gt; k) &#123;            minHeap.pop();  // 移除最小的        &#125;    &#125;        return minHeap.top();  // 堆顶就是第 k 大&#125;\n原理图解\nk = 2数组：[3, 2, 1, 5, 6, 4]step 1: push 3 → [3]step 2: push 2 → [2, 3]step 3: push 1 → [1, 2, 3] → pop → [2, 3]step 4: push 5 → [2, 3, 5] → pop → [3, 5]step 5: push 6 → [3, 5, 6] → pop → [5, 6]step 6: push 4 → [4, 5, 6] → pop → [5, 6]堆顶 = 5 = 第2大\n\n2. 前K个高频元素\n\nLeetCode 347: 给定一个非空的整数数组，返回其中出现频率前 k 高的元素\n\n问题分析\n输入：nums = [1,1,1,2,2,3], k = 2输出：[1, 2]\n两步走策略\ngraph LR\n    A[统计频率] --&gt; B[维护 Top K]\n    \n    A --&gt; A1[&quot;哈希表 O(n)&quot;]\n    B --&gt; B1[&quot;最小堆 O(n log k)&quot;]\n代码实现\nvector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;    // Step 1: 统计频率    unordered_map&lt;int, int&gt; freq;    for (int num : nums) &#123;        freq[num]++;    &#125;        // Step 2: 最小堆维护 Top K    auto cmp = [](pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123;        return a.second &gt; b.second;  // 按频率，小的在堆顶    &#125;;    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);        for (auto&amp; [num, count] : freq) &#123;        minHeap.push(&#123;num, count&#125;);        if (minHeap.size() &gt; k) &#123;            minHeap.pop();  // 移除频率最低的        &#125;    &#125;        // Step 3: 收集结果    vector&lt;int&gt; result;    while (!minHeap.empty()) &#123;        result.push_back(minHeap.top().first);        minHeap.pop();    &#125;        return result;&#125;\n\n3. 合并K个升序链表\n\nLeetCode 23: 给你一个链表数组，每个链表都已经按升序排列，请将所有链表合并到一个升序链表中\n\n问题分析\n输入：[[1,4,5], [1,3,4], [2,6]]输出：[1,1,2,3,4,4,5,6]\n解法对比\n\n\n\n方法\n时间复杂度\n说明\n\n\n\n\n逐一合并\nO(kn)\n简单但慢\n\n\n分治合并\nO(n log k)\n类似归并排序\n\n\n优先队列\nO(n log k)\n每次取最小\n\n\n\n代码实现（数组模拟）\nvector&lt;int&gt; mergeKSortedArrays(vector&lt;vector&lt;int&gt;&gt;&amp; arrays) &#123;    vector&lt;int&gt; result;        // 最小堆：&#123;值, 数组索引, 元素索引&#125;    auto cmp = [](auto&amp; a, auto&amp; b) &#123;        return get&lt;0&gt;(a) &gt; get&lt;0&gt;(b);    &#125;;    priority_queue&lt;tuple&lt;int,int,int&gt;, vector&lt;tuple&lt;int,int,int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);        // 初始化：加入每个数组的第一个元素    for (int i = 0; i &lt; arrays.size(); ++i) &#123;        if (!arrays[i].empty()) &#123;            minHeap.push(&#123;arrays[i][0], i, 0&#125;);        &#125;    &#125;        while (!minHeap.empty()) &#123;        auto [val, arrIdx, elemIdx] = minHeap.top();        minHeap.pop();        result.push_back(val);                // 加入该数组的下一个元素        if (elemIdx + 1 &lt; arrays[arrIdx].size()) &#123;            minHeap.push(&#123;arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1&#125;);        &#125;    &#125;        return result;&#125;\n过程图解\narrays: [[1,4,5], [1,3,4], [2,6]]初始堆：[(1,0,0), (1,1,0), (2,2,0)]        堆顶 = 1Step 1: pop (1,0,0) → result=[1] → push (4,0,1)Step 2: pop (1,1,0) → result=[1,1] → push (3,1,1)Step 3: pop (2,2,0) → result=[1,1,2] → push (6,2,1)...最终：[1,1,2,3,4,4,5,6]\n\n4. 数据流的中位数\n\nLeetCode 295: 设计一个支持以下两种操作的数据结构：添加数字、返回中位数\n\n核心思路：对顶堆\n使用两个堆：\n\n最大堆：存储较小的一半\n最小堆：存储较大的一半\n\ngraph LR\n    subgraph 较小的一半\n        A[最大堆]\n    end\n    \n    subgraph 较大的一半\n        B[最小堆]\n    end\n    \n    A --&gt;|堆顶| C[中位数]\n    B --&gt;|堆顶| C\n    \n    style A fill:#87CEEB\n    style B fill:#90EE90\n    style C fill:#FFE4B5\n核心约束\n\n最大堆的所有元素 ≤ 最小堆的所有元素\n两堆大小差不超过 1\n\n代码实现\nclass MedianFinder &#123;private:    priority_queue&lt;int&gt; maxHeap;  // 较小的一半    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 较大的一半    public:    void addNum(int num) &#123;        // Step 1: 先加入最大堆        maxHeap.push(num);                // Step 2: 最大堆的最大值移到最小堆        minHeap.push(maxHeap.top());        maxHeap.pop();                // Step 3: 平衡大小        if (minHeap.size() &gt; maxHeap.size()) &#123;            maxHeap.push(minHeap.top());            minHeap.pop();        &#125;    &#125;        double findMedian() &#123;        if (maxHeap.size() &gt; minHeap.size()) &#123;            return maxHeap.top();        &#125;        return (maxHeap.top() + minHeap.top()) / 2.0;    &#125;&#125;;\n插入过程演示\n添加 [1, 2, 3]add(1):  maxHeap.push(1) → maxHeap: [1]  move to minHeap → minHeap: [1]  balance → maxHeap: [1], minHeap: []  add(2):  maxHeap.push(2) → maxHeap: [2,1]  move to minHeap → maxHeap: [1], minHeap: [2]  (已平衡)add(3):  maxHeap.push(3) → maxHeap: [3,1]  move to minHeap → maxHeap: [1], minHeap: [2,3]  balance → maxHeap: [2,1], minHeap: [3]  中位数 = maxHeap.top() = 2\n\n5. 最后一块石头的重量\n\nLeetCode 1046: 每次选出最重的两块石头碰撞，返回最后剩下的石头重量\n\n代码实现\nint lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());        while (maxHeap.size() &gt; 1) &#123;        int stone1 = maxHeap.top(); maxHeap.pop();        int stone2 = maxHeap.top(); maxHeap.pop();                if (stone1 != stone2) &#123;            maxHeap.push(stone1 - stone2);        &#125;    &#125;        return maxHeap.empty() ? 0 : maxHeap.top();&#125;\n\n6. K个最接近原点的点\n\nLeetCode 973: 找出 K 个距离原点最近的点\n\n代码实现\nvector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;    // 最大堆：距离大的在堆顶    auto cmp = [](pair&lt;int,int&gt;&amp; a, pair&lt;int,int&gt;&amp; b) &#123;        return a.first &lt; b.first;    &#125;;    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; maxHeap(cmp);        for (int i = 0; i &lt; points.size(); ++i) &#123;        int dist = points[i][0]*points[i][0] + points[i][1]*points[i][1];        maxHeap.push(&#123;dist, i&#125;);        if (maxHeap.size() &gt; k) &#123;            maxHeap.pop();  // 移除距离最大的        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; result;    while (!maxHeap.empty()) &#123;        result.push_back(points[maxHeap.top().second]);        maxHeap.pop();    &#125;    return result;&#125;\n\n7. 堆排序\n\n利用堆的性质进行排序\n\n算法步骤\n\n建堆：将数组构建成最大堆\n排序：依次将堆顶（最大值）与末尾交换，然后调整堆\n\ngraph TD\n    subgraph 建堆\n        A[无序数组] --&gt; B[最大堆]\n    end\n    \n    subgraph 排序\n        B --&gt; C[堆顶与末尾交换]\n        C --&gt; D[缩小堆范围]\n        D --&gt; E[调整堆]\n        E --&gt;|重复| C\n    end\n    \n    E --&gt; F[有序数组]\n代码实现\nvoid heapSort(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();        // 建堆：从最后一个非叶子节点开始    for (int i = n/2 - 1; i &gt;= 0; --i) &#123;        heapify(nums, n, i);    &#125;        // 排序    for (int i = n - 1; i &gt; 0; --i) &#123;        swap(nums[0], nums[i]);  // 堆顶与末尾交换        heapify(nums, i, 0);      // 调整堆    &#125;&#125;void heapify(vector&lt;int&gt;&amp; nums, int n, int i) &#123;    int largest = i;    int left = 2 * i + 1;    int right = 2 * i + 2;        if (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;        largest = left;    &#125;    if (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;        largest = right;    &#125;        if (largest != i) &#123;        swap(nums[i], nums[largest]);        heapify(nums, n, largest);    &#125;&#125;\n复杂度分析\n\n时间：O(n log n)\n空间：O(1) 原地排序\n稳定性：不稳定\n\n\nTop K 问题总结\n选择合适的堆\n\n\n\n问题\n堆类型\n原因\n\n\n\n\n第 K 大元素\n最小堆\n堆顶是第 K 大\n\n\n第 K 小元素\n最大堆\n堆顶是第 K 小\n\n\n前 K 大元素\n最小堆\n淘汰堆顶（最小的）\n\n\n前 K 小元素\n最大堆\n淘汰堆顶（最大的）\n\n\n\n口诀\n\n求大用小，求小用大\n\n\n求最大的 K 个 → 用最小堆\n求最小的 K 个 → 用最大堆\n\n\n优先队列 vs 其他数据结构\n\n\n\n数据结构\n插入\n删除堆顶\n查找最值\n任意查找\n\n\n\n\n无序数组\nO(1)\nO(n)\nO(n)\nO(n)\n\n\n有序数组\nO(n)\nO(1)\nO(1)\nO(log n)\n\n\n优先队列\nO(log n)\nO(log n)\nO(1)\n❌\n\n\n平衡树\nO(log n)\nO(log n)\nO(log n)\nO(log n)\n\n\n\n\n思维导图\ngraph TD\n    A[优先队列] --&gt; B[基础操作]\n    A --&gt; C[经典问题]\n    A --&gt; D[高级应用]\n    \n    B --&gt; B1[push/pop/top]\n    B --&gt; B2[自定义比较器]\n    B --&gt; B3[最大堆/最小堆]\n    \n    C --&gt; C1[Top K 问题]\n    C --&gt; C2[合并 K 个链表]\n    C --&gt; C3[数据流中位数]\n    \n    D --&gt; D1[任务调度]\n    D --&gt; D2[Dijkstra 最短路]\n    D --&gt; D3[Huffman 编码]\n    \n    style A fill:#FFE4B5\n    style C1 fill:#87CEEB\n    style C2 fill:#90EE90\n    style C3 fill:#DDA0DD\n\n总结\n核心要点\n\n优先队列 = 堆：底层用堆实现，O(log n) 插入删除\n求大用小：需要最大的 K 个，用最小堆\n对顶堆：维护动态中位数的经典技巧\n堆排序：O(n log n)，原地排序\n\n常见模式\n\n\n\n模式\n典型问题\n关键点\n\n\n\n\n固定大小堆\n第 K 大\n堆大小保持 K\n\n\n对顶堆\n数据流中位数\n两个堆，一大一小\n\n\n多路归并\n合并 K 个链表\n每次取最小的那条\n\n\n贪心 + 堆\n任务调度\n优先处理某种特性的任务\n\n\n\n代码模板\n// Top K 问题模板priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 最小堆for (int num : nums) &#123;    minHeap.push(num);    if (minHeap.size() &gt; k) &#123;        minHeap.pop();    &#125;&#125;// minHeap.top() 就是第 K 大\n推荐阅读：\n\nLeetCode 优先队列专题\n《算法导论》第6章：堆排序\n\n","categories":["数据结构"],"tags":["C++","LeetCode","优先队列","堆","数据结构","算法设计"]},{"title":"常见算法-KMP","url":"/posts/d26e9827/","content":"KMP 字符串匹配算法详解：从原理到实现\n\n深入理解 KMP 算法的核心思想，掌握高效字符串匹配的关键技术\n\n\n引言\nKMP（Knuth-Morris-Pratt）算法是计算机科学中最经典的字符串匹配算法之一，由 Donald Knuth、Vaughan Pratt 和 James H. Morris 在 1977 年共同发明。该算法通过预处理模式串，避免了暴力匹配中的重复比较，将时间复杂度从 O(m×n) 优化到 O(m+n)。\n适用场景：\n\n文本编辑器的查找功能\nDNA 序列匹配\n网络数据包检测\n编译器词法分析\n\n\n问题背景\n字符串匹配问题定义\n给定两个字符串：\n\n主串（文本串）：需要被搜索的字符串，长度为 n\n模式串（模板串）：要查找的子串，长度为 m\n\n目标：在主串中找到第一次出现模式串的位置。\n主串：  ABABDABACDABABCABAB模式串：      ABABCABAB\n\n暴力匹配的局限性\n暴力算法流程\nint bruteForce(const string&amp; text, const string&amp; pattern) &#123;    int n = text.size();    int m = pattern.size();        for (int i = 0; i &lt;= n - m; i++) &#123;        int j = 0;        while (j &lt; m &amp;&amp; text[i + j] == pattern[j]) &#123;            j++;        &#125;        if (j == m) return i;  // 找到匹配    &#125;    return -1;  // 未找到&#125;\n暴力匹配的问题\n主串：  A B A B A B C模式串：A B A B C步骤1：  A B A B A B C        A B A B C        ✓ ✓ ✓ ✓ ✗ (第5位失配)步骤2：  A B A B A B C          A B A B C          ✗ (第1位就失配，浪费！)步骤3：  A B A B A B C            A B A B C            ✓ ✓ ✓ ✓ ✓ (成功)\n问题：失配后，模式串从头开始，主串回退，导致重复比较。\ngraph TD\n    A[主串位置 i] --&gt; B&#123;text i == pattern j?&#125;\n    B --&gt;|是| C[i++, j++]\n    B --&gt;|否| D[i 回退到 i-j+1]\n    D --&gt; E[j 重置为 0]\n    E --&gt; F[重新匹配]\n时间复杂度：O(m×n)，最坏情况下每个位置都要尝试完整匹配。\n\nKMP 核心思想\n关键洞察\n当失配发生时，我们已经知道了前面已经匹配的部分，可以利用这些信息避免回退。\n主串：  A B A B A B C模式串：A B A B C        ✓ ✓ ✓ ✓ ✗已知：前4个字符 &quot;ABAB&quot; 已匹配观察：模式串的前缀 &quot;AB&quot; 等于已匹配部分的后缀 &quot;AB&quot;结论：可以直接将模式串滑动到对齐位置，无需回退主串指针\nKMP 的两大创新\n\n主串指针不回退：i 只向前移动，永不后退\n模式串智能跳转：通过 next 数组确定失配后模式串应该跳到哪里\n\ngraph LR\n    A[失配发生] --&gt; B[查询 next 数组]\n    B --&gt; C[模式串跳转]\n    C --&gt; D[继续匹配]\n    D --&gt; E&#123;匹配成功?&#125;\n    E --&gt;|是| F[完成]\n    E --&gt;|否| B\n\nNext 数组详解\nNext 数组的定义\nnext[i] 表示：模式串中以位置 i 结尾的子串的最长相等前后缀的长度。\n模式串：A B A B C A B A B索引：  0 1 2 3 4 5 6 7 8next：  0 0 1 2 0 1 2 3 4\n解释：\n\nnext[0] = 0：单个字符没有前后缀\nnext[1] = 0：AB 没有相等的前后缀\nnext[2] = 1：ABA 的最长相等前后缀是 A（长度1）\nnext[3] = 2：ABAB 的最长相等前后缀是 AB（长度2）\nnext[4] = 0：ABABC 没有相等的前后缀\nnext[7] = 3：ABABCAB 的最长相等前后缀是 AB（长度2）… 等等\n\n前缀和后缀的概念\n字符串：A B C D前缀：A, AB, ABC     (不包含最后一个字符)后缀：D, CD, BCD     (不包含第一个字符)\nNext 数组的构建\n核心思想：利用已经计算出的 next 值来计算新的值（动态规划思想）。\nvector&lt;int&gt; buildNext(const string&amp; pattern) &#123;    int n = pattern.size();    vector&lt;int&gt; next(n);    next[0] = 0;  // 第一个字符的 next 值为 0        int j = 0;  // j 表示当前最长相等前后缀的长度        for (int i = 1; i &lt; n; i++) &#123;        // 如果不匹配，回退 j        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) &#123;            j = next[j - 1];        &#125;                // 如果匹配，增加前后缀长度        if (pattern[i] == pattern[j]) &#123;            j++;        &#125;                next[i] = j;    &#125;        return next;&#125;\n构建过程示例\n模式串：ABABCABAB\ni=0: pattern[0]=&#x27;A&#x27;     next[0] = 0i=1: pattern[1]=&#x27;B&#x27;, pattern[0]=&#x27;A&#x27;     不匹配，j=0     next[1] = 0i=2: pattern[2]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;     匹配！j=1     next[2] = 1i=3: pattern[3]=&#x27;B&#x27;, pattern[1]=&#x27;B&#x27;     匹配！j=2     next[3] = 2i=4: pattern[4]=&#x27;C&#x27;, pattern[2]=&#x27;A&#x27;     不匹配，j回退到next[1]=0     pattern[4]=&#x27;C&#x27;, pattern[0]=&#x27;A&#x27;     不匹配，j=0     next[4] = 0i=5: pattern[5]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;     匹配！j=1     next[5] = 1... (以此类推)\n最终结果：\n\n\n\n索引\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n字符\nA\nB\nA\nB\nC\nA\nB\nA\nB\n\n\nnext\n0\n0\n1\n2\n0\n1\n2\n3\n4\n\n\n\ngraph TD\n    A[开始: i=1, j=0] --&gt; B&#123;pattern i == pattern j?&#125;\n    B --&gt;|是| C[j++]\n    C --&gt; D[next i = j]\n    D --&gt; E[i++]\n    \n    B --&gt;|否| F&#123;j &gt; 0?&#125;\n    F --&gt;|是| G[j = next j-1]\n    G --&gt; B\n    F --&gt;|否| H[next i = 0]\n    H --&gt; E\n    \n    E --&gt; I&#123;i &lt; n?&#125;\n    I --&gt;|是| B\n    I --&gt;|否| J[完成]\n\n算法实现\n完整实现\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class KMP &#123;public:    // 构建 next 数组    vector&lt;int&gt; buildNext(const string&amp; pattern) &#123;        int n = pattern.size();        vector&lt;int&gt; next(n);        if (n == 0) return next;                next[0] = 0;        int j = 0;                for (int i = 1; i &lt; n; i++) &#123;            // 失配时回退            while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) &#123;                j = next[j - 1];            &#125;                        // 匹配时前进            if (pattern[i] == pattern[j]) &#123;                j++;            &#125;                        next[i] = j;        &#125;                return next;    &#125;        // KMP 搜索    int search(const string&amp; text, const string&amp; pattern) &#123;        int n = text.size();        int m = pattern.size();                if (m == 0) return 0;        if (n &lt; m) return -1;                vector&lt;int&gt; next = buildNext(pattern);        int j = 0;  // 模式串指针                for (int i = 0; i &lt; n; i++) &#123;  // 主串指针            // 失配时，模式串回退            while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) &#123;                j = next[j - 1];            &#125;                        // 匹配时，模式串前进            if (text[i] == pattern[j]) &#123;                j++;            &#125;                        // 完全匹配            if (j == m) &#123;                return i - m + 1;  // 返回起始位置            &#125;        &#125;                return -1;  // 未找到    &#125;&#125;;int main() &#123;    KMP kmp;        string text = &quot;ABABDABACDABABCABAB&quot;;    string pattern = &quot;ABABCABAB&quot;;        int pos = kmp.search(text, pattern);        if (pos != -1) &#123;        cout &lt;&lt; &quot;在位置 &quot; &lt;&lt; pos &lt;&lt; &quot; 找到模式串&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;主串：&quot; &lt;&lt; text &lt;&lt; endl;        cout &lt;&lt; &quot;匹配：&quot; &lt;&lt; string(pos, &#x27; &#x27;) &lt;&lt; pattern &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;未找到模式串&quot; &lt;&lt; endl;    &#125;        return 0;&#125;\n输出：\n在位置 10 找到模式串主串：ABABDABACDABABCABAB匹配：          ABABCABAB\n\n复杂度分析\n时间复杂度\n\n\n构建 next 数组：O(m)\n\n外层循环：遍历模式串 m 个字符\n内层 while 循环：j 最多回退 m 次（均摊分析）\n\n\n\n匹配过程：O(n)\n\n外层循环：遍历主串 n 个字符\n内层 while 循环：j 最多回退 n 次（均摊分析）\n\n\n\n总时间复杂度：O(m + n)\n空间复杂度\nO(m)：需要存储 next 数组。\n与暴力算法对比\n\n\n\n算法\n时间复杂度\n空间复杂度\n主串指针\n\n\n\n\n暴力匹配\nO(m×n)\nO(1)\n会回退\n\n\nKMP\nO(m+n)\nO(m)\n不回退\n\n\n\n性能提升：\n对于长度为 1000 的主串和长度为 100 的模式串：\n\n暴力：最坏 100,000 次比较\nKMP：最多 1,100 次比较\n\n\n总结\n核心要点\n\nKMP 的本质：利用已匹配信息，避免无效回退\nNext 数组：记录最长相等前后缀，是算法的核心\n时间复杂度：O(m+n)，主串指针不回退\n适用场景：单模式串匹配，需要高效查找\n\n优缺点对比\n优点：\n\n✓ 时间复杂度优秀：O(m+n)\n✓ 主串指针不回退，适合流式处理\n✓ 易于理解和实现\n\n缺点：\n\n✗ 需要额外空间：O(m)\n✗ 多模式匹配需要多次调用\n✗ 对于短模式串，可能不如暴力快（常数因子）\n\n与其他算法对比\n\n\n\n算法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n\n暴力\nO(m×n)\nO(1)\n短串、简单场景\n\n\nKMP\nO(m+n)\nO(m)\n单模式、长串\n\n\nBM\nO(n/m)\nO(m)\n长模式串\n\n\nAC自动机\nO(n+m+k)\nO(m×字符集)\n多模式匹配\n\n\n\n扩展阅读\n\nKMP 算法原始论文\nBoyer-Moore 算法\nAho-Corasick 自动机（多模式匹配）\nSunday 算法\n\n","categories":["算法"],"tags":["C++","LeetCode","数据结构","KMP","字符串匹配","动态规划"]},{"title":"常见算法-Kadane","url":"/posts/251a1af2/","content":"引言\nKadane算法是解决最大子数组和问题的经典动态规划算法，由计算机科学家Jay Kadane于1984年提出。该算法以极其简洁的代码实现了O(n)的最优时间复杂度，是动态规划空间优化的典范。\n\n问题背景\n最大子数组和问题\n\nLeetCode 53: 给定一个整数数组，找到具有最大和的连续子数组，返回其最大和。\n\n示例：\n输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6\n应用场景\n\n股票交易：找到最佳买卖时机的最大利润\n信号处理：在噪声中找到最强信号段\n生物信息学：DNA序列分析\n数据分析：找到业务指标的最佳表现时段\n\n\n算法演变\n方法1: 暴力枚举\n枚举所有可能的子数组：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxSum = INT_MIN;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        for (int j = i; j &lt; nums.size(); ++j) &#123;            int sum = 0;            for (int k = i; k &lt;= j; ++k) &#123;                sum += nums[k];            &#125;            maxSum = max(maxSum, sum);        &#125;    &#125;    return maxSum;&#125;\n时间复杂度：O(n³)\n问题：三层循环，效率极低\n方法2: 优化暴力\n利用前缀和优化：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxSum = INT_MIN;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        int sum = 0;        for (int j = i; j &lt; nums.size(); ++j) &#123;            sum += nums[j];  // 累加，避免重复计算            maxSum = max(maxSum, sum);        &#125;    &#125;    return maxSum;&#125;\n时间复杂度：O(n²)\n问题：仍然较慢\n方法3: 分治算法\n如之前在DivideAndConqer.cpp中实现：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    // 分成左右两半，递归求解    // 考虑跨越中点的情况&#125;\n时间复杂度：O(n log n)\n优势：比O(n²)快，适合理解分治思想\n方法4: Kadane算法\n最优解法：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n时间复杂度：O(n)\n空间复杂度：O(1)\n完美！\n\nKadane算法原理\n核心思想\n对于数组中的每个位置，我们只需要做一个决定：\n\n当前元素应该加入之前的子数组，还是从当前元素重新开始？\n\n对于位置 i：maxEndingHere[i] = max(nums[i], maxEndingHere[i-1] + nums[i])                   ↑           ↑                重新开始    加入之前的子数组\n状态定义\n\nmaxEndingHere：以当前位置结尾的最大子数组和\nmaxSoFar：全局最大子数组和\n\n决策过程可视化\n数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]位置0: maxEndingHere = -2, maxSoFar = -2       [-2]位置1: maxEndingHere = max(1, -2+1) = 1 (重新开始)       maxSoFar = 1       [1]位置2: maxEndingHere = max(-3, 1-3) = -2 (继续)       maxSoFar = 1       [1, -3]位置3: maxEndingHere = max(4, -2+4) = 4 (重新开始)       maxSoFar = 4       [4]位置4: maxEndingHere = max(-1, 4-1) = 3 (继续)       maxSoFar = 4       [4, -1]位置5: maxEndingHere = max(2, 3+2) = 5 (继续)       maxSoFar = 5       [4, -1, 2]位置6: maxEndingHere = max(1, 5+1) = 6 (继续)       maxSoFar = 6       [4, -1, 2, 1] ← 答案！位置7: maxEndingHere = max(-5, 6-5) = 1 (继续)       maxSoFar = 6位置8: maxEndingHere = max(4, 1+4) = 5 (继续)       maxSoFar = 6\ngraph LR\n    A[-2] --&gt;|重新开始| B[1]\n    B --&gt;|继续| C[-3]\n    C --&gt;|重新开始| D[4]\n    D --&gt;|继续| E[-1]\n    E --&gt;|继续| F[2]\n    F --&gt;|继续| G[1]\n    G --&gt;|继续| H[-5]\n    H --&gt;|继续| I[4]\n    \n    style D fill:#FFE4B5\n    style E fill:#FFE4B5\n    style F fill:#FFE4B5\n    style G fill:#90EE90\n为什么这样做是对的？\n关键洞察：\n如果 maxEndingHere[i-1] &lt; 0，那么加上它只会让结果变小，不如重新开始！\n如果前面的和是负数：  -5 + 3 = -2  (不如直接从3开始)  如果前面的和是正数：  5 + 3 = 8   (应该继续)\n\n代码实现\n基础版本\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    if (nums.empty()) return 0;        int maxEndingHere = nums[0];  // 以当前位置结尾的最大和    int maxSoFar = nums[0];       // 全局最大和        for (int i = 1; i &lt; nums.size(); ++i) &#123;        // 核心决策        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n动态规划视角\n// 等价的DP写法（更占空间）int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; dp(n);  // dp[i] = 以i结尾的最大子数组和        dp[0] = nums[0];    int maxSum = dp[0];        for (int i = 1; i &lt; n; ++i) &#123;        dp[i] = max(nums[i], dp[i-1] + nums[i]);        maxSum = max(maxSum, dp[i]);    &#125;        return maxSum;&#125;\n观察：dp[i]只依赖于dp[i-1]，所以可以用一个变量代替数组！\n返回子数组位置\nstruct SubarrayInfo &#123;    int sum;    int start;    int end;&#125;;SubarrayInfo maxSubArrayWithIndices(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];    int start = 0, end = 0;    int tempStart = 0;        for (int i = 1; i &lt; nums.size(); ++i) &#123;        if (nums[i] &gt; maxEndingHere + nums[i]) &#123;            maxEndingHere = nums[i];            tempStart = i;  // 重新开始，更新起始位置        &#125; else &#123;            maxEndingHere = maxEndingHere + nums[i];        &#125;                if (maxEndingHere &gt; maxSoFar) &#123;            maxSoFar = maxEndingHere;            start = tempStart;            end = i;        &#125;    &#125;        return &#123;maxSoFar, start, end&#125;;&#125;\n\n正确性证明\n归纳法证明\n基础情况：一个元素时，算法显然正确。\n归纳假设：假设对于前i-1个元素，算法正确。\n归纳步骤：对于第i个元素：\n\n\n如果maxEndingHere[i-1] + nums[i] &gt; nums[i]\n\n说明前面的子数组对当前有贡献\n应该继续\n\n\n\n如果maxEndingHere[i-1] + nums[i] &lt;= nums[i]\n\n说明前面的子数组拖后腿\n应该重新开始\n\n\n\n因此，算法在每一步都做出了最优决策。\n反例分析\n错误想法：遇到负数就重新开始？\n数组：[5, -2, 3]错误：遇到-2就重新开始 → 最大和 = 5正确：5 + (-2) + 3 = 6\nKadane的优势：它考虑的是&quot;累积贡献&quot;，而不是单个元素的正负。\n\n变种问题\n1. 环形数组的最大子数组和\n\nLeetCode 918: 环形子数组的最大和\n\n思路：环形数组的最大子数组只有两种情况：\n\n不跨越边界：正常Kadane算法\n跨越边界：总和 - 最小子数组和\n\nint maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;    int totalSum = 0;    int maxSum = INT_MIN, minSum = INT_MAX;    int maxEndingHere = 0, minEndingHere = 0;        for (int num : nums) &#123;        totalSum += num;                // 最大子数组        maxEndingHere = max(num, maxEndingHere + num);        maxSum = max(maxSum, maxEndingHere);                // 最小子数组        minEndingHere = min(num, minEndingHere + num);        minSum = min(minSum, minEndingHere);    &#125;        // 特殊情况：所有元素都是负数    if (maxSum &lt; 0) return maxSum;        return max(maxSum, totalSum - minSum);&#125;\n可视化：\n数组：[5, -3, 5]情况1 (不跨越)：[5, -3, 5] → 和 = 7情况2 (跨越)：[5] + [5] → 和 = 10 ✓计算：总和 - 最小子数组和 = 7 - (-3) = 10\n2. 乘积最大子数组\n\nLeetCode 152: 乘积最大子数组\n\n关键：负数 × 负数 = 正数，需要同时维护最大值和最小值！\nint maxProduct(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int minEndingHere = nums[0];    int result = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        int num = nums[i];        int tempMax = maxEndingHere;                // 可能：当前元素、最大值×当前、最小值×当前        maxEndingHere = max(&#123;num, maxEndingHere * num, minEndingHere * num&#125;);        minEndingHere = min(&#123;num, tempMax * num, minEndingHere * num&#125;);                result = max(result, maxEndingHere);    &#125;        return result;&#125;\n示例：\n数组：[2, 3, -2, 4]i=0: max=2,  min=2,  result=2i=1: max=6,  min=3,  result=6   (2×3)i=2: max=-2, min=-12, result=6  (6×-2 vs 3×-2)i=3: max=4,  min=-48, result=6  (-12×-2 才是最大的中间结果，但4最后才来)答案[2,3]的乘积=6\n3. 股票买卖最佳时机\n\nLeetCode 121: 买卖股票的最佳时机\n\n转换：最大利润 = 最大子数组和（差分数组）\nint maxProfit(vector&lt;int&gt;&amp; prices) &#123;    if (prices.size() &lt; 2) return 0;        int minPrice = prices[0];    int maxProfit = 0;        for (int i = 1; i &lt; prices.size(); ++i) &#123;        maxProfit = max(maxProfit, prices[i] - minPrice);        minPrice = min(minPrice, prices[i]);    &#125;        return maxProfit;&#125;\nKadane视角：\n// 将价格数组转换为差分数组vector&lt;int&gt; diff;for (int i = 1; i &lt; prices.size(); ++i) &#123;    diff.push_back(prices[i] - prices[i-1]);&#125;// 然后在diff上运行Kadane算法\n\n性能对比\n时间复杂度对比\n\n\n\n方法\n时间复杂度\n空间复杂度\n\n\n\n\n暴力枚举\nO(n³)\nO(1)\n\n\n优化暴力\nO(n²)\nO(1)\n\n\n分治算法\nO(n log n)\nO(log n)\n\n\nKadane算法\nO(n)\nO(1)\n\n\n\n为什么Kadane最优？\n\n单次遍历：只需要扫描数组一次\n常数空间：只用两个变量\n无递归：没有函数调用开销\n缓存友好：顺序访问，利用CPU缓存\n\n\n总结\n核心要点\n\nKadane算法是最大子数组和的最优解\n时间O(n)，空间O(1)\n动态规划的空间优化经典例子\n关键在于理解&quot;何时重新开始&quot;\n\n算法模板\nint kadane(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n记忆口诀\n\n加入或重启，两者取大；\n全局最优，随时更新。\n\n扩展学习\n相关算法：\n\n最大子矩阵和：二维Kadane\n最长递增子序列：类似的DP思想\n股票买卖系列：状态机DP\n\n\n推荐练习：\n\nLeetCode 53 - 最大子数组和\nLeetCode 152 - 乘积最大子数组\nLeetCode 918 - 环形子数组的最大和\n\n","categories":["算法"],"tags":["C++","LeetCode","动态规划","Kadane","最大子数组和","贪心"]},{"title":"常见算法-二分查找","url":"/posts/e84ddac/","content":"写在前面\n二分查找应该是我刷LeetCode时最早接触的算法之一，当时觉得挺简单的——不就是折半查找嘛。结果真正写起来才发现，left、right、mid这些边界条件一不小心就写错，要么死循环，要么漏掉元素。后来才意识到，二分查找看似简单，其实细节很多。\n这篇文章我会按照自己的理解，把二分查找从基础到变种都梳理一遍。\n\n二分查找是什么\n最基础的二分查找就是在有序数组中找一个目标值，每次通过比较中间元素，排除一半的搜索空间。\n举个例子，在 [1, 3, 5, 7, 9, 11, 13] 中找 7：\n第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，找到了！\n如果找 8 呢：\n第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，8 &gt; 7，去右边找第2次: 范围 [9,11,13]，中间是 11，8 &lt; 11，去左边找第3次: 范围 [9]，9 != 8，找不到\n简单来说就是：每次排除一半，直到找到或者范围为空。\n时间复杂度 O(log n)，这也是二分查找的魅力所在——数据量越大，优势越明显。100万条数据，最多查20次。\n\n基础模板\n我自己用的最多的是左闭右闭区间的写法，也就是 [left, right]。\nint binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;  // 注意是 n-1        while (left &lt;= right) &#123;  // 注意是 &lt;=        int mid = left + (right - left) / 2;  // 防溢出                if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;  // 去右半边        &#125; else &#123;            right = mid - 1;  // 去左半边        &#125;    &#125;        return -1;  // 没找到&#125;\n几个细节\n\n\n为什么是 right = nums.size() - 1？\n因为我们用的是闭区间 [left, right]，右边界要包含最后一个元素。\n\n\n为什么循环条件是 left &lt;= right？\n当 left == right 时，区间 [left, right] 还有一个元素没检查，所以要用 &lt;=。\n\n\n为什么是 mid = left + (right - left) / 2？\n如果写成 (left + right) / 2，当 left 和 right 都很大时可能溢出。虽然LeetCode数据范围一般不会溢出，但这是个好习惯。\n\n\n为什么是 left = mid + 1 而不是 mid？\n因为 nums[mid] 已经检查过了，不是目标值，所以可以排除。\n\n\n\n左闭右开写法\n有些人喜欢用左闭右开区间 [left, right)，也就是右边界不包含。\nint binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();  // 注意是 n（不包含）        while (left &lt; right) &#123;  // 注意是 &lt;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;  // 注意是 mid，不是 mid - 1        &#125;    &#125;        return -1;&#125;\n说实话，我一开始也纠结用哪种写法。后来发现，选一个用熟就行，关键是理解区间的含义，不要混用。\n\n变种1：查找左边界\n有时候数组中有重复元素，我们要找第一个等于 target 的位置。\n比如 [1, 2, 2, 2, 3] 中找 2 的左边界，应该返回索引 1。\nint searchLeft(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    int result = -1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            result = mid;     // 记录位置            right = mid - 1;  // 继续向左找        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n核心思路：找到 target 后不立即返回，而是继续向左缩小范围。\n\n变种2：查找右边界\n同理，找最后一个等于 target 的位置。\n[1, 2, 2, 2, 3] 中找 2 的右边界，应该返回索引 3。\nint searchRight(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    int result = -1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            result = mid;    // 记录位置            left = mid + 1;  // 继续向右找        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n\n变种3：找第一个大于等于target的位置\n这个在实际应用中很常见，比如查找插入位置。\nint lowerBound(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;  // nums[mid] &gt;= target，可能是答案        &#125;    &#125;        return left;&#125;\n注意：这里我用的是左闭右开写法 [left, right)，因为这样写起来比较简洁。\n如果数组是 [1, 3, 5, 7]，target = 4，返回索引 2（也就是 5 的位置）。\n\n变种4：找第一个大于target的位置\nint upperBound(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] &lt;= target) &#123;  // 注意是 &lt;=            left = mid + 1;        &#125; else &#123;            right = mid;        &#125;    &#125;        return left;&#125;\n\n实战题目\nLeetCode 704 - 二分查找\n最基础的题，直接套模板就行。\nint search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) return mid;        else if (nums[mid] &lt; target) left = mid + 1;        else right = mid - 1;    &#125;        return -1;&#125;\n\nLeetCode 35 - 搜索插入位置\n给定一个排序数组和目标值，如果找到返回索引，否则返回它应该被插入的位置。\nint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;        &#125;    &#125;        return left;&#125;\n其实就是找第一个 &gt;= target 的位置（lower_bound）。\n\nLeetCode 34 - 在排序数组中查找元素的第一个和最后一个位置\n这题就是找左右边界的综合应用。\nvector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;    if (nums.empty()) return &#123;-1, -1&#125;;        int left = searchLeft(nums, target);    if (left == -1) return &#123;-1, -1&#125;;  // 没找到        int right = searchRight(nums, target);    return &#123;left, right&#125;;&#125;\n\nLeetCode 69 - x 的平方根\n计算并返回 x 的平方根（只保留整数部分）。\n这题其实是在 [0, x] 中找最后一个满足 i * i &lt;= x 的数。\nint mySqrt(int x) &#123;    if (x == 0) return 0;        int left = 1, right = x;    int result = 0;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (mid &lt;= x / mid) &#123;  // 避免溢出            result = mid;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n小技巧：用 mid &lt;= x / mid 代替 mid * mid &lt;= x，避免整数溢出。\n\nLeetCode 33 - 搜索旋转排序数组\n这题有点意思，数组被旋转了，比如 [4,5,6,7,0,1,2]。\n核心思路：虽然整体无序，但肯定有一半是有序的。先判断哪半边有序，再判断 target 在不在有序的那半边。\nint search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) return mid;                // 左半边有序        if (nums[left] &lt;= nums[mid]) &#123;            // target 在左半边            if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        // 右半边有序        else &#123;            // target 在右半边            if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;    &#125;        return -1;&#125;\n\nLeetCode 153 - 寻找旋转排序数组中的最小值\n还是旋转数组，这次是找最小值。\nint findMin(vector&lt;int&gt;&amp; nums) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                // 右半边无序，最小值在右边        if (nums[mid] &gt; nums[right]) &#123;            left = mid + 1;        &#125;        // 左半边无序或全部有序，最小值在左边（包括mid）        else &#123;            right = mid;        &#125;    &#125;        return nums[left];&#125;\n\n二分答案\n除了在数组中二分查找，还有一类题是二分答案。也就是答案有一定范围，通过二分猜答案，然后验证是否可行。\n经典例题：LeetCode 875 - 爱吃香蕉的珂珂\n珂珂有 N 堆香蕉，第 i 堆有 piles[i] 根香蕉。她可以决定每小时吃香蕉的速度 K（根/小时）。每小时她会选择一堆香蕉，吃 K 根（如果这堆不够 K 根，她会吃完这堆就停下来）。\n问：在 H 小时内吃完所有香蕉，最小的 K 是多少？\n思路：K 的范围是 [1, max(piles)]，我们可以二分 K 的值。对于每个 K，检查能否在 H 小时内吃完。\nint minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;    int left = 1;    int right = *max_element(piles.begin(), piles.end());        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                // 检查能否在 h 小时内吃完        long long hours = 0;        for (int pile : piles) &#123;            hours += (pile + mid - 1) / mid;  // 向上取整        &#125;                if (hours &lt;= h) &#123;            right = mid;  // 可以吃完，尝试更小的速度        &#125; else &#123;            left = mid + 1;  // 吃不完，需要更快的速度        &#125;    &#125;        return left;&#125;\n小技巧：(pile + mid - 1) / mid 是向上取整的技巧，等价于 ceil(pile / mid)。\n\n容易踩的坑\n\n\n循环条件写错\nleft &lt;= right 还是 left &lt; right？取决于区间定义。记住：闭区间用 &lt;=，半开区间用 &lt;。\n\n\n边界更新写错\nleft = mid 还是 left = mid + 1？记住：已经检查过 mid 了，要排除就用 +1 或 -1。\n\n\n死循环\n如果边界更新不当，可能导致 left 和 right 永远无法相遇。比如用 left &lt; right 但更新时用 right = mid，当 left = mid - 1 时就会死循环。\n\n\n溢出问题\n写成 (left + right) / 2 在理论上可能溢出，虽然LeetCode一般不会卡这个。\n\n\n边界条件遗漏\n数组为空、target 不在范围内等特殊情况要单独处理。\n\n\n\n总结\n二分查找虽然看起来简单，但要写对还是需要细心。我的建议是：\n\n选定一种写法（闭区间或半开区间），熟练掌握它\n理解区间不变量：每次循环后，答案一定在 [left, right] 区间内\n多刷题：变种题做多了，自然就有感觉了\n\n常见的二分查找题型：\n\n基础二分：LeetCode 704\n查找边界：LeetCode 34\n旋转数组：LeetCode 33, 153\n二分答案：LeetCode 875, 1011, 410\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","分治","二分查找","搜索"]},{"title":"常见算法-分治","url":"/posts/f7223eb4/","content":"分治算法详解：化繁为简的行为艺术\n\n掌握分治思想，轻松解决复杂问题\n\n\n什么是分治算法\n分治（Divide and Conquer）是一种重要的算法设计思想，其核心是：\n\n将一个复杂的问题分解成若干个规模较小但结构相似的子问题，递归地解决这些子问题，然后将子问题的解合并得到原问题的解。\n\n形象理解\n想象你需要统计一本厚书的总字数：\n方法1：一页一页数（暴力）方法2：分治  ├── 把书分成两半  ├── 分别数每一半的字数（递归）  └── 两半字数相加（合并）\n适用条件\n分治算法适用于具有以下特征的问题：\n\n可分解性：问题可以分解成若干个规模较小的相同问题\n子问题独立：子问题之间相互独立，不包含公共子问题\n可合并性：子问题的解可以合并为原问题的解\n存在基准情况：当问题规模足够小时，可以直接求解\n\ngraph TD\n    A[原问题] --&gt; B[子问题1]\n    A --&gt; C[子问题2]\n    A --&gt; D[子问题...]\n    \n    B --&gt; E[解1]\n    C --&gt; F[解2]\n    D --&gt; G[解...]\n    \n    E --&gt; H[合并]\n    F --&gt; H\n    G --&gt; H\n    H --&gt; I[最终解]\n    \n    style A fill:#FFE4B5\n    style I fill:#90EE90\n\n分治三步曲\n核心框架\nResult divideAndConquer(Problem problem) &#123;    // 1. 基准情况：问题足够小，直接求解    if (problem.size &lt;= threshold) &#123;        return directSolve(problem);    &#125;        // 2. 分解：将问题分成子问题    subProblems = divide(problem);        // 3. 递归：解决每个子问题    for (subProblem : subProblems) &#123;        subResults.push_back(divideAndConquer(subProblem));    &#125;        // 4. 合并：将子问题的解合并    return combine(subResults);&#125;\n三步详解\n\n\n\n步骤\n名称\n作用\n关键点\n\n\n\n\n1\nDivide（分）\n将问题分解为子问题\n如何划分？划分几份？\n\n\n2\nConquer（治）\n递归解决子问题\n基准情况是什么？\n\n\n3\nCombine（合）\n合并子问题的解\n如何高效合并？\n\n\n\n时间复杂度通用公式\nT(n)=aT(n/b)+f(n)T(n) = aT(n/b) + f(n)\nT(n)=aT(n/b)+f(n)\n\naaa：子问题数量\nbbb：子问题规模缩小的倍数\nf(n)f(n)f(n)：分解和合并的代价\n\n\n经典问题详解\n1. 归并排序\n\nLeetCode 912: 排序数组\n\n问题分析\n将一个无序数组排序成有序数组。\n分治思路\n原数组：[38, 27, 43, 3, 9, 82, 10]               分解（Divide）         ↓[38, 27, 43, 3]    [9, 82, 10]      ↓                 ↓[38, 27] [43, 3]   [9, 82] [10]   ↓       ↓         ↓      ↓[38][27] [43][3]  [9][82]  [10]   ↓       ↓         ↓      ↓   解决（Conquer）- 单元素已有序         ↓      合并（Combine）         ↓[27, 38] [3, 43]  [9, 82]  [10]      ↓                ↓[3, 27, 38, 43]   [9, 10, 82]            ↓   [3, 9, 10, 27, 38, 43, 82]\n代码实现\nvoid mergeSort(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; temp(nums.size());    mergeSortHelper(nums, temp, 0, nums.size() - 1);&#125;void mergeSortHelper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right) &#123;    if (left &gt;= right) return;  // 基准情况        int mid = left + (right - left) / 2;        // 分解 + 递归    mergeSortHelper(nums, temp, left, mid);    mergeSortHelper(nums, temp, mid + 1, right);        // 合并    merge(nums, temp, left, mid, right);&#125;void merge(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int mid, int right) &#123;    for (int i = left; i &lt;= right; ++i) &#123;        temp[i] = nums[i];    &#125;        int i = left, j = mid + 1, k = left;    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        if (temp[i] &lt;= temp[j]) &#123;            nums[k++] = temp[i++];        &#125; else &#123;            nums[k++] = temp[j++];        &#125;    &#125;        while (i &lt;= mid) nums[k++] = temp[i++];    while (j &lt;= right) nums[k++] = temp[j++];&#125;\n复杂度分析\n\n时间：T(n)=2T(n/2)+O(n)=O(nlog⁡n)T(n) = 2T(n/2) + O(n) = O(n \\log n)T(n)=2T(n/2)+O(n)=O(nlogn)\n空间：O(n)O(n)O(n) 临时数组\n\n为什么用归并排序？\n✅ 稳定排序：相等元素的相对顺序不变\n✅ 时间稳定：最好、最坏、平均都是 O(nlog⁡n)O(n \\log n)O(nlogn)\n✅ 适合链表：不需要随机访问\n✅ 适合外排序：大文件排序\n\n2. 快速排序\n\nLeetCode 912: 排序数组（另一种解法）\n\n分治思路\n原数组：[64, 34, 25, 12, 22, 11, 90]选择 pivot = 22（随机选择）      分区（Partition）             ↓[12, 11] [22] [64, 34, 25, 90]  &lt; 22    =      &gt; 22    ↓             ↓  递归排序      递归排序    ↓             ↓[11, 12]     [25, 34, 64, 90]         ↓    合并（无需操作，已有序）         ↓[11, 12, 22, 25, 34, 64, 90]\n代码实现\nvoid quickSort(vector&lt;int&gt;&amp; nums) &#123;    quickSortHelper(nums, 0, nums.size() - 1);&#125;void quickSortHelper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left &gt;= right) return;        int pivotIndex = partition(nums, left, right);        quickSortHelper(nums, left, pivotIndex - 1);    quickSortHelper(nums, pivotIndex + 1, right);&#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    // 随机选择pivot，避免最坏情况    int randomIndex = left + rand() % (right - left + 1);    swap(nums[randomIndex], nums[right]);        int pivot = nums[right];    int i = left - 1;        for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            swap(nums[++i], nums[j]);        &#125;    &#125;        swap(nums[i + 1], nums[right]);    return i + 1;&#125;\n复杂度分析\n\n时间：平均 O(nlog⁡n)O(n \\log n)O(nlogn)，最坏 O(n2)O(n^2)O(n2)\n空间：O(log⁡n)O(\\log n)O(logn) 递归栈\n\n快排 vs 归并\n\n\n\n特性\n快速排序\n归并排序\n\n\n\n\n平均时间\nO(nlog⁡n)O(n \\log n)O(nlogn)\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\n最坏时间\nO(n2)O(n^2)O(n2)\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\n空间复杂度\nO(log⁡n)O(\\log n)O(logn)\nO(n)O(n)O(n)\n\n\n稳定性\n❌ 不稳定\n✅ 稳定\n\n\n原地排序\n✅ 是\n❌ 否\n\n\n实际性能\n更快（缓存友好）\n略慢\n\n\n\n\n3. 最大子数组和\n\nLeetCode 53: 最大子数组和\n\n问题描述\n给定一个整数数组，找到具有最大和的连续子数组。\n输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6\n分治思路\n最大子数组只可能在三个位置：\n\n完全在左半部分\n完全在右半部分\n跨越中点\n\n数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]              ↓ mid      左半部分  |  右半部分                左边最大：1    右边最大：4 跨越中点最大：4 + (-1) + 2 + 1 = 6  最终答案：max(1, 4, 6) = 6\ngraph TD\n    A[整个数组] --&gt; B[左半部分]\n    A --&gt; C[右半部分]\n    A --&gt; D[跨越中点]\n    \n    B --&gt; E[递归求解]\n    C --&gt; F[递归求解]\n    D --&gt; G[线性扫描]\n    \n    E --&gt; H[取最大值]\n    F --&gt; H\n    G --&gt; H\n    \n    H --&gt; I[返回结果]\n    \n    style D fill:#FFE4B5\n    style H fill:#90EE90\n代码实现\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    return maxSubArrayHelper(nums, 0, nums.size() - 1);&#125;int maxSubArrayHelper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left == right) return nums[left];  // 基准情况        int mid = left + (right - left) / 2;        int leftMax = maxSubArrayHelper(nums, left, mid);    int rightMax = maxSubArrayHelper(nums, mid + 1, right);    int crossMax = maxCrossing(nums, left, mid, right);        return max(&#123;leftMax, rightMax, crossMax&#125;);&#125;int maxCrossing(vector&lt;int&gt;&amp; nums, int left, int mid, int right) &#123;    // 从中点向左扩展    int leftSum = INT_MIN, sum = 0;    for (int i = mid; i &gt;= left; --i) &#123;        sum += nums[i];        leftSum = max(leftSum, sum);    &#125;        // 从中点向右扩展    int rightSum = INT_MIN;    sum = 0;    for (int i = mid + 1; i &lt;= right; ++i) &#123;        sum += nums[i];        rightSum = max(rightSum, sum);    &#125;        return leftSum + rightSum;&#125;\n复杂度分析\n\n时间：T(n)=2T(n/2)+O(n)=O(nlog⁡n)T(n) = 2T(n/2) + O(n) = O(n \\log n)T(n)=2T(n/2)+O(n)=O(nlogn)\n空间：O(log⁡n)O(\\log n)O(logn) 递归栈\n\n\n注意：这道题有更优的 O(n)O(n)O(n) 动态规划解法，但分治解法是理解分治思想的好例子。\n\n\n4. 快速幂\n\nLeetCode 50: Pow(x, n)\n\n问题描述\n实现 pow(x, n)，即计算 x 的 n 次幂。\n暴力 vs 分治\n计算 2^10：暴力：2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2  (10次乘法)分治：  2^10 = 2^5 × 2^5  2^5 = 2^2 × 2^2 × 2  2^2 = 2 × 2只需要 4 次乘法！\n分治思路\nxn={xn/2×xn/2n 是偶数xn/2×xn/2×xn 是奇数x^n = \\begin{cases} x^{n/2} \\times x^{n/2} &amp; n \\text{ 是偶数} \\\\ x^{n/2} \\times x^{n/2} \\times x &amp; n \\text{ 是奇数} \\end{cases}\nxn={xn/2×xn/2xn/2×xn/2×x​n 是偶数n 是奇数​\n代码实现\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;    return fastPow(x, n);&#125;double fastPow(double x, long long n) &#123;    if (n == 0) return 1.0;  // 基准情况        double half = fastPow(x, n / 2);  // 分治        if (n % 2 == 0) &#123;        return half * half;           // 偶数    &#125; else &#123;        return half * half * x;       // 奇数    &#125;&#125;\n迭代版本（更优）\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;        double result = 1.0;    while (n &gt; 0) &#123;        if (n &amp; 1) &#123;        // n是奇数            result *= x;        &#125;        x *= x;             // x = x^2        n &gt;&gt;= 1;            // n = n / 2    &#125;    return result;&#125;\n复杂度分析\n\n时间：O(log⁡n)O(\\log n)O(logn)\n空间：递归 O(log⁡n)O(\\log n)O(logn)，迭代 O(1)O(1)O(1)\n\n\n5. 第K大元素\n\nLeetCode 215: 数组中的第K个最大元素\n\n问题描述\n找出数组中第 k 大的元素。\n输入：[3, 2, 1, 5, 6, 4], k = 2输出：5\n分治思路：快速选择\n利用快排的 partition 思想，每次可以确定一个元素的最终位置：\n数组：[3, 2, 1, 5, 6, 4]，找第2大（即第5小）Partition后（假设pivot=4）：[3, 2, 1] [4] [5, 6]  0,1,2    3   4,5pivot在位置3，第5小应该在位置4所以在右半部分继续找\n代码实现\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    int targetIndex = nums.size() - k;    return quickSelect(nums, 0, nums.size() - 1, targetIndex);&#125;int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    if (left == right) return nums[left];        int pivotIndex = partition(nums, left, right);        if (pivotIndex == k) &#123;        return nums[k];    &#125; else if (pivotIndex &lt; k) &#123;        return quickSelect(nums, pivotIndex + 1, right, k);    &#125; else &#123;        return quickSelect(nums, left, pivotIndex - 1, k);    &#125;&#125;\n复杂度分析\n\n时间：平均 O(n)O(n)O(n)，最坏 O(n2)O(n^2)O(n2)\n空间：O(1)O(1)O(1)\n\n为什么平均是 O(n)？\nT(n)=T(n/2)+O(n)=O(n)+O(n/2)+O(n/4)+...=O(2n)=O(n)T(n) = T(n/2) + O(n) = O(n) + O(n/2) + O(n/4) + ... = O(2n) = O(n)\nT(n)=T(n/2)+O(n)=O(n)+O(n/2)+O(n/4)+...=O(2n)=O(n)\n与快排不同，快速选择只需要递归一侧！\n\n6. 逆序对计数\n\n剑指Offer 51: 数组中的逆序对\n\n问题描述\n在数组中，如果前面的数大于后面的数，则这两个数构成一个逆序对。\n输入：[7, 5, 6, 4]输出：5解释：(7,5), (7,6), (7,4), (5,4), (6,4)\n分治思路\n利用归并排序的过程统计逆序对：\n[7, 5, 6, 4]     ↓ 分解[7, 5] [6, 4]  ↓       ↓[7][5] [6][4]  ↓       ↓ 合并时统计[5,7]   [4,6]  ← 统计了 (7,5), (6,4)     ↓ 合并时统计[4, 5, 6, 7]   ← 统计了 (7,4), (7,6), (5,4)关键：当右边元素先被放入时，左边剩余的都是逆序对\n代码实现\nint countInversions(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; temp(nums.size());    return countHelper(nums, temp, 0, nums.size() - 1);&#125;int countHelper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right) &#123;    if (left &gt;= right) return 0;        int mid = left + (right - left) / 2;    int count = 0;        count += countHelper(nums, temp, left, mid);    count += countHelper(nums, temp, mid + 1, right);    count += mergeAndCount(nums, temp, left, mid, right);        return count;&#125;int mergeAndCount(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp,                   int left, int mid, int right) &#123;    for (int i = left; i &lt;= right; ++i) &#123;        temp[i] = nums[i];    &#125;        int i = left, j = mid + 1, k = left, count = 0;        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        if (temp[i] &lt;= temp[j]) &#123;            nums[k++] = temp[i++];        &#125; else &#123;            nums[k++] = temp[j++];            count += (mid - i + 1);  // 关键：左边剩余都是逆序对        &#125;    &#125;        while (i &lt;= mid) nums[k++] = temp[i++];    while (j &lt;= right) nums[k++] = temp[j++];        return count;&#125;\n复杂度分析\n\n时间：O(nlog⁡n)O(n \\log n)O(nlogn)\n空间：O(n)O(n)O(n)\n\n\n分治 vs 递归 vs 动态规划\n三者关系\ngraph TD\n    A[递归] --&gt; B[分治]\n    A --&gt; C[动态规划]\n    \n    B --&gt; D[子问题独立]\n    C --&gt; E[子问题重叠]\n    \n    D --&gt; F[直接递归求解]\n    E --&gt; G[记忆化/自底向上]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n对比表\n\n\n\n特性\n递归\n分治\n动态规划\n\n\n\n\n本质\n实现技术\n算法思想\n算法思想\n\n\n子问题\n-\n独立\n重叠\n\n\n求解方式\n自顶向下\n自顶向下\n自底向上/记忆化\n\n\n典型问题\n阶乘\n归并排序\n斐波那契\n\n\n\n如何选择？\n\n分治：子问题独立，无重复计算\n动态规划：子问题重叠，需要记忆化\n\n\n复杂度分析：主定理\n主定理公式\n对于递归式 T(n)=aT(n/b)+f(n)T(n) = aT(n/b) + f(n)T(n)=aT(n/b)+f(n)，设 c=log⁡bac = \\log_b ac=logb​a：\n\n若 f(n)=O(nc−ϵ)f(n) = O(n^{c-\\epsilon})f(n)=O(nc−ϵ)，则 T(n)=Θ(nc)T(n) = \\Theta(n^c)T(n)=Θ(nc)\n若 f(n)=Θ(nc)f(n) = \\Theta(n^c)f(n)=Θ(nc)，则 T(n)=Θ(nclog⁡n)T(n) = \\Theta(n^c \\log n)T(n)=Θ(nclogn)\n若 f(n)=Ω(nc+ϵ)f(n) = \\Omega(n^{c+\\epsilon})f(n)=Ω(nc+ϵ)，则 T(n)=Θ(f(n))T(n) = \\Theta(f(n))T(n)=Θ(f(n))\n\n常见情况\n\n\n\n递归式\n算法\n时间复杂度\n\n\n\n\nT(n)=2T(n/2)+O(n)T(n) = 2T(n/2) + O(n)T(n)=2T(n/2)+O(n)\n归并排序\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\nT(n)=2T(n/2)+O(1)T(n) = 2T(n/2) + O(1)T(n)=2T(n/2)+O(1)\n二分查找\nO(log⁡n)O(\\log n)O(logn)\n\n\nT(n)=T(n/2)+O(n)T(n) = T(n/2) + O(n)T(n)=T(n/2)+O(n)\n快速选择\nO(n)O(n)O(n)\n\n\nT(n)=T(n/2)+O(1)T(n) = T(n/2) + O(1)T(n)=T(n/2)+O(1)\n二分幂\nO(log⁡n)O(\\log n)O(logn)\n\n\n\n\n思维导图\ngraph TD\n    A[分治算法] --&gt; B[排序问题]\n    A --&gt; C[搜索问题]\n    A --&gt; D[数学问题]\n    A --&gt; E[统计问题]\n    \n    B --&gt; B1[归并排序]\n    B --&gt; B2[快速排序]\n    \n    C --&gt; C1[二分查找]\n    C --&gt; C2[第K大元素]\n    \n    D --&gt; D1[快速幂]\n    D --&gt; D2[大整数乘法]\n    \n    E --&gt; E1[逆序对]\n    E --&gt; E2[最大子数组]\n    \n    style A fill:#FFE4B5\n    style B1 fill:#87CEEB\n    style B2 fill:#87CEEB\n    style C1 fill:#90EE90\n    style D1 fill:#DDA0DD\n\n总结\n核心要点\n\n分治三步曲：分解 → 递归 → 合并\n适用条件：子问题独立、可合并、存在基准情况\n时间分析：使用主定理\n优化方向：合并操作是关键\n\n分治模板\nResult divideAndConquer(Problem problem) &#123;    // 1. 基准情况    if (isBaseCase(problem)) &#123;        return solve(problem);    &#125;        // 2. 分解    subProblems = divide(problem);        // 3. 递归解决    for (sub : subProblems) &#123;        subResults.push_back(divideAndConquer(sub));    &#125;        // 4. 合并    return combine(subResults);&#125;\n常见问题分类\n\n\n\n类型\n问题\n合并方式\n\n\n\n\n排序\n归并、快排\n双指针合并\n\n\n搜索\n二分查找\n直接返回\n\n\n数学\n快速幂\n乘法\n\n\n统计\n逆序对\n计数累加\n\n\n优化\n最大子数组\n取最大值\n\n\n\n推荐阅读：\n\n《算法导论》第4章：分治策略\nLeetCode 分治专题\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","分治","归并排序","快速排序"]},{"title":"常见算法-回溯","url":"/posts/97ccf2e3/","content":"引言\n回溯算法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。当探索到某一步时，发现原先的选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为&quot;回溯点&quot;。\n回溯算法的本质：穷举所有可能，然后选出我们想要的答案。\n适用场景：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n排列问题：N个数按一定规则全排列，有几种排列方式\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n棋盘问题：N皇后，数独等等\n\n\n什么是回溯算法\n形象化理解\n想象你在一个迷宫中寻找出口：\n入口 → 岔路1 → 岔路2 → 死路 ✗     ↓     回退到岔路2     ↓     岔路2 → 岔路3 → 出口 ✓\n这就是回溯：尝试 → 失败 → 回退 → 再尝试\n决策树可视化\n回溯算法可以抽象为决策树的遍历过程：\ngraph TD\n    A[开始] --&gt; B[选择1]\n    A --&gt; C[选择2]\n    A --&gt; D[选择3]\n    B --&gt; E[选择1.1]\n    B --&gt; F[选择1.2]\n    C --&gt; G[选择2.1]\n    C --&gt; H[选择2.2]\n    \n    style E fill:#90EE90\n    style H fill:#90EE90\n    style F fill:#FFB6C1\n    style G fill:#FFB6C1\n\n绿色节点：满足条件的解\n粉色节点：不满足条件，需要回溯\n\n\n回溯框架模板\n通用模板\nvoid backtrack(路径, 选择列表) &#123;    if (满足结束条件) &#123;        result.push_back(路径);        return;    &#125;        for (选择 : 选择列表) &#123;        if (不满足条件) continue;  // 剪枝                做选择;        backtrack(路径, 选择列表);  // 递归        撤销选择;  // 回溯    &#125;&#125;\n三要素\n\n路径（Path）：已经做出的选择\n选择列表（Choices）：当前可以做的选择\n结束条件（End Condition）：到达决策树底层，无法再做选择的条件\n\ngraph LR\n    A[开始] --&gt; B&#123;满足结束条件?&#125;\n    B --&gt;|是| C[保存结果]\n    B --&gt;|否| D[遍历选择列表]\n    D --&gt; E&#123;是否有效?&#125;\n    E --&gt;|否| F[剪枝跳过]\n    E --&gt;|是| G[做选择]\n    G --&gt; H[递归调用]\n    H --&gt; I[撤销选择]\n    I --&gt; D\n    F --&gt; D\n    C --&gt; J[返回]\n    I --&gt; K&#123;还有选择?&#125;\n    K --&gt;|是| D\n    K --&gt;|否| J\n\n核心思想\n回溯三步曲\n\n做选择：将当前元素加入路径\n递归：基于当前选择继续探索\n撤销选择：将当前元素从路径中移除，尝试其他选择\n\n// 伪代码示例path.push_back(choice);      // 1. 做选择backtrack(path, choices);    // 2. 递归path.pop_back();             // 3. 撤销选择\n关键特性\n\n时间换空间：通过回溯避免存储所有中间状态\n深度优先搜索（DFS）：本质上是DFS的一种实现\n剪枝优化：提前排除不可能的分支，提高效率\n\n\n经典问题详解\n1. 全排列问题\n\nLeetCode 46: 给定一个不含重复数字的数组 nums，返回其所有可能的全排列。\n\n示例：\n输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n决策树\n                 []       /          |          \\     [1]         [2]         [3]    /   \\       /   \\       /   \\ [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]   |     |     |     |     |     |[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]\n实现\nvoid permuteBacktrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path,                       vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 终止条件：路径长度等于数组长度    if (path.size() == nums.size()) &#123;        result.push_back(path);        return;    &#125;        for (int i = 0; i &lt; nums.size(); ++i) &#123;        if (used[i]) continue;  // 剪枝：已使用的元素跳过                // 做选择        path.push_back(nums[i]);        used[i] = true;                // 递归        permuteBacktrack(nums, path, used, result);                // 撤销选择        path.pop_back();        used[i] = false;    &#125;&#125;\n执行过程示例\n输入: [1, 2, 3]步骤1: path=[], 选择1       path=[1], used=[T,F,F]步骤2: path=[1], 选择2       path=[1,2], used=[T,T,F]步骤3: path=[1,2], 选择3       path=[1,2,3], used=[T,T,T]       ✓ 找到一个解！步骤4: 回溯，撤销3       path=[1,2], used=[T,T,F]步骤5: 回溯，撤销2       path=[1], used=[T,F,F]步骤6: path=[1], 选择3       path=[1,3], used=[T,F,T]       ... (继续)\n时间复杂度：O(n × n!)\n空间复杂度：O(n)\n\n2. N皇后问题\n\nLeetCode 51: 在 n×n 的棋盘上放置 n 个皇后，使得它们不能相互攻击。\n\n规则：皇后可以攻击同一行、同一列、同一对角线上的棋子。\n可视化\n4皇后的一个解：. Q . .     行0. . . Q     行1Q . . .     行2. . Q .     行3\n决策树\ngraph TD\n    A[行0: 选择列] --&gt; B[列0]\n    A --&gt; C[列1]\n    A --&gt; D[列2]\n    A --&gt; E[列3]\n    \n    C --&gt; F[行1: 列3]\n    F --&gt; G[行2: 列1]\n    G --&gt; H[行3: 列2 ✓]\n    \n    B --&gt; I[行1: 检查...✗]\n    D --&gt; J[行1: 检查...✗]\n实现\nvoid nQueensBacktrack(vector&lt;string&gt;&amp; board, int row,                       vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    // 终止条件：所有行都放置了皇后    if (row == board.size()) &#123;        result.push_back(board);        return;    &#125;        int n = board[row].size();    for (int col = 0; col &lt; n; ++col) &#123;        if (!isValidQueen(board, row, col)) &#123;            continue;  // 剪枝：不合法位置        &#125;                // 做选择        board[row][col] = &#x27;Q&#x27;;                // 递归        nQueensBacktrack(board, row + 1, result);                // 撤销选择        board[row][col] = &#x27;.&#x27;;    &#125;&#125;bool isValidQueen(vector&lt;string&gt;&amp; board, int row, int col) &#123;    int n = board.size();        // 检查列    for (int i = 0; i &lt; row; ++i) &#123;        if (board[i][col] == &#x27;Q&#x27;) return false;    &#125;        // 检查左上对角线    for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;        if (board[i][j] == &#x27;Q&#x27;) return false;    &#125;        // 检查右上对角线    for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123;        if (board[i][j] == &#x27;Q&#x27;) return false;    &#125;        return true;&#125;\n时间复杂度：O(n!)\n空间复杂度：O(n²)\n\n3. 组合总和\n\nLeetCode 39: 给定一个无重复元素的数组 candidates 和一个目标数 target，找出所有可以使数字和为 target 的组合。\n\n示例：\n输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]\n决策树\n                        []         /       |        |        \\       [2]      [3]      [6]      [7]✓      / | \\     / \\       |  [2,2] ...  [3,3] ...  [6,?]   / \\[2,2,2] [2,2,3]✓\n实现\nvoid combinationBacktrack(vector&lt;int&gt;&amp; candidates, int target, int start,                          vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 终止条件    if (target == 0) &#123;        result.push_back(path);        return;    &#125;        for (int i = start; i &lt; candidates.size(); ++i) &#123;        if (candidates[i] &gt; target) break;  // 剪枝：超过目标                // 做选择        path.push_back(candidates[i]);                // 递归（可重复使用，所以传入 i）        combinationBacktrack(candidates, target - candidates[i], i, path, result);                // 撤销选择        path.pop_back();    &#125;&#125;\n关键点：\n\n可以重复使用同一元素，所以递归时传入 i 而不是 i+1\n排序后可以提前剪枝\n\n\n4. 子集问题\n\nLeetCode 78: 给定一个整数数组 nums，返回该数组所有可能的子集。\n\n示例：\n输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n决策树\n                 []✓       /          |          \\     [1]✓        [2]✓        [3]✓    /   \\          \\ [1,2]✓ [1,3]✓   [2,3]✓   |[1,2,3]✓\n关键：每个节点都是一个有效子集！\n实现\nvoid subsetsBacktrack(vector&lt;int&gt;&amp; nums, int start,                      vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 每个节点都是一个子集    result.push_back(path);        for (int i = start; i &lt; nums.size(); ++i) &#123;        // 做选择        path.push_back(nums[i]);                // 递归        subsetsBacktrack(nums, i + 1, path, result);                // 撤销选择        path.pop_back();    &#125;&#125;\n时间复杂度：O(n × 2ⁿ)\n空间复杂度：O(n)\n\n5. 括号生成\n\nLeetCode 22: 生成所有由 n 对括号组成的有效组合。\n\n示例：\n输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]\n约束条件\n\n左括号数量 ≤ n\n右括号数量 ≤ 左括号数量\n\n决策树\n                        &quot;&quot;              /                    \\            &quot;(&quot;                    ❌ &quot;)&quot; (违反规则2)       /         \\    &quot;((&quot;        &quot;()&quot;   /   \\       /   \\&quot;(((&quot;  &quot;(()&quot; &quot;()&quot;  &quot;())&quot;❌\n实现\nvoid parenthesisBacktrack(int n, int left, int right,                          string&amp; path, vector&lt;string&gt;&amp; result) &#123;    // 终止条件    if (path.size() == 2 * n) &#123;        result.push_back(path);        return;    &#125;        // 添加左括号    if (left &lt; n) &#123;        path.push_back(&#x27;(&#x27;);        parenthesisBacktrack(n, left + 1, right, path, result);        path.pop_back();    &#125;        // 添加右括号（剪枝）    if (right &lt; left) &#123;        path.push_back(&#x27;)&#x27;);        parenthesisBacktrack(n, left, right + 1, path, result);        path.pop_back();    &#125;&#125;\n时间复杂度：O(4ⁿ / √n)（卡特兰数）\n空间复杂度：O(n)\n\n剪枝优化技巧\n剪枝是提高回溯算法效率的关键！\n1. 提前终止\nif (当前状态已经不可能产生有效解) &#123;    return;  // 直接返回，不继续递归&#125;\n示例：组合总和中，如果当前和已经超过目标值\nif (candidates[i] &gt; target) break;  // 剪枝\n2. 排序优化\n先排序，可以更早地剪枝\nsort(candidates.begin(), candidates.end());\n3. 避免重复\n使用 used 数组或 start 索引避免重复计算\n// 全排列：used数组if (used[i]) continue;// 组合问题：start索引for (int i = start; i &lt; nums.size(); ++i)\n4. 对称性剪枝\n利用问题的对称性减少搜索空间\n// N皇后：只搜索一半，另一半通过对称获得if (row == 0 &amp;&amp; col &gt; n / 2) break;\n剪枝效果对比\ngraph LR\n    A[无剪枝] --&gt;|搜索空间| B[10000节点]\n    C[有剪枝] --&gt;|搜索空间| D[100节点]\n    \n    style B fill:#FFB6C1\n    style D fill:#90EE90\n\n复杂度分析\n时间复杂度\n回溯算法的时间复杂度通常取决于：\n\n决策树的深度：递归的层数\n每层的选择数量：for循环的次数\n\n\n\n\n问题\n时间复杂度\n说明\n\n\n\n\n全排列\nO(n × n!)\nn层，每层最多n个选择\n\n\nN皇后\nO(n!)\n每行选择递减\n\n\n组合\nO(2ⁿ)\n每个元素选或不选\n\n\n子集\nO(n × 2ⁿ)\n2ⁿ个子集，复制需要O(n)\n\n\n\n空间复杂度\n主要考虑：\n\n递归栈深度：O(深度)\n路径存储：O(路径长度)\n\n通常为 O(n) 或 O(树的高度)\n\n常见LeetCode题目\n入门级\n\nLeetCode 78 - 子集\nLeetCode 77 - 组合\nLeetCode 46 - 全排列\n\n中级\n\nLeetCode 39 - 组合总和\nLeetCode 22 - 括号生成\nLeetCode 131 - 分割回文串\n\n高级\n\nLeetCode 51 - N皇后\nLeetCode 37 - 解数独\nLeetCode 126 - 单词接龙 II\n\n\n回溯 vs DFS vs BFS\n对比表\n\n\n\n特性\n回溯\nDFS\nBFS\n\n\n\n\n本质\n带剪枝的DFS\n深度优先搜索\n广度优先搜索\n\n\n数据结构\n递归栈\n栈/递归\n队列\n\n\n路径记录\n显式维护\n可选\n可选\n\n\n空间复杂度\nO(h)\nO(h)\nO(w)\n\n\n应用场景\n所有解\n单个解\n最短路径\n\n\n\n\nh = 树的高度, w = 树的宽度\n\n\n总结\n核心要点\n\n回溯 = 穷举 + 剪枝\n三要素：路径、选择列表、结束条件\n三步曲：做选择 → 递归 → 撤销选择\n优化关键：剪枝！剪枝！剪枝！\n\n经典模板\nvoid backtrack(参数) &#123;    if (终止条件) &#123;        存储结果;        return;    &#125;        for (选择 : 选择列表) &#123;        if (剪枝条件) continue;                做选择;        backtrack(新参数);        撤销选择;    &#125;&#125;\n性能优化 Tips\n\n排序预处理：便于剪枝\n使用引用传参：减少复制开销\n位运算优化 used 数组：节省空间\n记忆化搜索：避免重复计算子问题\n\n\n回溯算法是解决复杂搜索问题的利器。虽然时间复杂度较高，但通过巧妙的剪枝优化，可以在实际应用中取得很好的效果。掌握回溯算法，你将拥有解决大部分组合、排列、搜索类问题的能力！\n\n推荐阅读：\n\n代码随想录 - 回溯算法\nLeetCode 精选回溯题目\n\n","categories":["算法"],"tags":["C++","LeetCode","回溯","DFS","递归","剪枝"]},{"title":"常见题型-N皇后","url":"/posts/f508052b/","content":"N皇后问题完全解析：从暴力到极致优化\n\n深度剖析经典回溯问题，掌握从基础到高级的优化技巧\n\n问题描述\nN皇后问题是一个经典的回溯算法问题，也是LeetCode上的热门题目。\n问题定义\n在 n×n 的国际象棋棋盘上放置 n 个皇后，使得它们不能相互攻击。\n攻击规则\n皇后可以攻击：\n\n同一行的所有位置\n同一列的所有位置\n同一对角线的所有位置（左上-右下、右上-左下）\n\n示例\n4皇后问题的解：\n解法1:          解法2:. Q . .        . . Q .. . . Q        Q . . .Q . . .        . . . Q. . Q .        . Q . .\n\n问题分析\n关键观察\n\n\n每行只能放一个皇后\n\nn个皇后放在n行，每行恰好一个\n所以我们可以逐行放置皇后\n\n\n\n每列只能放一个皇后\n\n需要记录哪些列已经被占用\n\n\n\n每条对角线只能放一个皇后\n\n主对角线（左上→右下）：特点是 row - col 值相同\n副对角线（右上→左下）：特点是 row + col 值相同\n\n\n\n对角线索引计算\n棋盘示例 (n=4):主对角线 (row - col):        副对角线 (row + col):-3 -2 -1  0                  0  1  2  3-2 -1  0  1                  1  2  3  4-1  0  1  2                  2  3  4  5 0  1  2  3                  3  4  5  6为避免负数，主对角线索引 = row - col + n - 1\n可视化理解\ngraph TD\n    A[N皇后问题] --&gt; B[逐行放置]\n    B --&gt; C[检查冲突]\n    C --&gt; D[列冲突]\n    C --&gt; E[主对角线冲突]\n    C --&gt; F[副对角线冲突]\n    \n    D --&gt; G[cols数组]\n    E --&gt; H[diag1数组]\n    F --&gt; I[diag2数组]\n    \n    style A fill:#FFE4B5\n    style C fill:#87CEEB\n\n解题思路演变\n思路1: 暴力穷举\n尝试所有可能的放置方法：\nn个皇后，每个皇后有 n² 个位置总共需要检查 (n²)! 种组合 → 天文数字！\n问题：完全不可行\n思路2: 优化穷举\n既然每行只能放一个皇后：\n第1个皇后有 n 种选择第2个皇后有 n 种选择...总共 n^n 种组合\n问题：仍然很大（8皇后就是 8⁸ = 16,777,216）\n思路3: 回溯 + 剪枝 ✓\n核心思想：\n\n逐行放置皇后（每行只选一列）\n放置前检查是否合法\n如果不合法，剪枝（不继续递归）\n如果合法，继续下一行\n回溯时撤销选择\n\ngraph TD\n    A[行0] --&gt; B[尝试列0]\n    A --&gt; C[尝试列1]\n    A --&gt; D[尝试列2]\n    \n    B --&gt; E[行1: 列2合法]\n    B --&gt; F[行1: 列3合法]\n    \n    C --&gt; G[行1: ✗ 冲突]\n    \n    E --&gt; H[行2: 继续...]\n    F --&gt; I[行2: 继续...]\n    \n    style G fill:#FFB6C1\n    style H fill:#90EE90\n    style I fill:#90EE90\n\n解法一：基础回溯\n核心代码\nclass NQueens &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));        backtrack(board, 0, result);        return result;    &#125;    private:    void backtrack(vector&lt;string&gt;&amp; board, int row,                    vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;        int n = board.size();                // 终止条件：所有行都放置了皇后        if (row == n) &#123;            result.push_back(board);            return;        &#125;                // 在当前行的每一列尝试放置皇后        for (int col = 0; col &lt; n; ++col) &#123;            // 剪枝：检查是否合法            if (!isValid(board, row, col)) &#123;                continue;            &#125;                        // 做选择            board[row][col] = &#x27;Q&#x27;;                        // 递归            backtrack(board, row + 1, result);                        // 撤销选择            board[row][col] = &#x27;.&#x27;;        &#125;    &#125;        bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123;        int n = board.size();                // 检查列        for (int i = 0; i &lt; row; ++i) &#123;            if (board[i][col] == &#x27;Q&#x27;) return false;        &#125;                // 检查左上对角线        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;            if (board[i][j] == &#x27;Q&#x27;) return false;        &#125;                // 检查右上对角线        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123;            if (board[i][j] == &#x27;Q&#x27;) return false;        &#125;                return true;    &#125;&#125;;\n执行过程示例（4皇后）\n步骤1: row=0, col=0. . . .  →  Q . . .. . . .     . . . .. . . .     . . . .. . . .     . . . .步骤2: row=1, 尝试col=0 ✗ (同列)        row=1, 尝试col=1 ✗ (对角线)        row=1, 尝试col=2 ✓Q . . .. . Q .. . . .. . . .步骤3: row=2, 尝试col=0 ✗ (对角线)        row=2, 尝试col=1 ✗ (对角线)        row=2, 尝试col=2 ✗ (同列)        row=2, 尝试col=3 ✗ (对角线)        → 回溯到row=1，尝试col=3步骤4: row=1, col=3Q . . .. . . Q. . . .. . . .步骤5: row=2, col=1Q . . .. . . Q. Q . .. . . .步骤6: row=3, col=2 ✓Q . . .. . . Q. Q . .. . Q .  ← 找到第一个解！\n复杂度分析\n\n\n时间复杂度：O(n!)\n\n第1行有n种选择\n第2行最多n-1种（剪掉1列）\n…\n近似 n!\n\n\n\n空间复杂度：O(n²)\n\n递归深度 O(n)\n棋盘存储 O(n²)\n\n\n\n\n解法二：标记数组优化\n优化思路\n问题：基础解法中，isValid() 函数时间复杂度为 O(n)\n优化：使用三个标记数组，将合法性检查优化到 O(1)\n核心思想\nvector&lt;bool&gt; cols(n);          // cols[i] = true 表示第i列已占用vector&lt;bool&gt; diag1(2*n-1);     // 主对角线标记vector&lt;bool&gt; diag2(2*n-1);     // 副对角线标记\n索引计算\n对于位置 (row, col):- 列索引: col- 主对角线索引: row - col + n - 1- 副对角线索引: row + col\n代码实现\nvoid backtrackOptimized(vector&lt;string&gt;&amp; board, int row,                       vector&lt;bool&gt;&amp; cols,                       vector&lt;bool&gt;&amp; diag1,                       vector&lt;bool&gt;&amp; diag2,                       vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    int n = board.size();        if (row == n) &#123;        result.push_back(board);        return;    &#125;        for (int col = 0; col &lt; n; ++col) &#123;        int d1 = row - col + n - 1;  // 主对角线        int d2 = row + col;          // 副对角线                // O(1) 检查        if (cols[col] || diag1[d1] || diag2[d2]) &#123;            continue;        &#125;                // 做选择        board[row][col] = &#x27;Q&#x27;;        cols[col] = diag1[d1] = diag2[d2] = true;                // 递归        backtrackOptimized(board, row + 1, cols, diag1, diag2, result);                // 撤销选择        board[row][col] = &#x27;.&#x27;;        cols[col] = diag1[d1] = diag2[d2] = false;    &#125;&#125;\n对角线索引可视化\n4×4棋盘的对角线索引：主对角线 (row - col + 3):    副对角线 (row + col):┌─────────────────┐         ┌─────────────────┐│ 3 │ 2 │ 1 │ 0 │         │ 0 │ 1 │ 2 │ 3 │├─────────────────┤         ├─────────────────┤│ 4 │ 3 │ 2 │ 1 │         │ 1 │ 2 │ 3 │ 4 │├─────────────────┤         ├─────────────────┤│ 5 │ 4 │ 3 │ 2 │         │ 2 │ 3 │ 4 │ 5 │├─────────────────┤         ├─────────────────┤│ 6 │ 5 │ 4 │ 3 │         │ 3 │ 4 │ 5 │ 6 │└─────────────────┘         └─────────────────┘相同索引的格子在同一对角线上\n优势\n✅ 合法性检查从 O(n) 降到 O(1)\n✅ 整体性能提升 2-3倍\n✅ 代码更简洁清晰\n\n解法三：位运算优化\n核心思想\n使用整数的二进制位来表示状态，而不是数组：\n例如 8 皇后问题：cols = 0b00101000  表示第3列和第5列已占用       ││││││││       ││││││└─ 第0列       ││││└─── 第2列       │││└──── 第3列 ✓       ││└───── 第4列       │└────── 第5列 ✓       └─────── 第6列\n位运算技巧\n1. 获取可用位置\n// 假设：// cols  = 0b00101000  (列占用)// diag1 = 0b00010100  (主对角线占用)// diag2 = 0b01000010  (副对角线占用)int occupied = cols | diag1 | diag2;  // 所有占用位置// occupied = 0b01111110int available = ~occupied &amp; ((1 &lt;&lt; n) - 1);  // 可用位置// available = 0b10000001\n2. 提取最低位的1\nint position = available &amp; (-available);// 获取最右边的可用位置例如：available = 0b10100     -available = 0b01100  (补码)     position   = 0b00100  (只保留最低位)\n3. 清除最低位的1\navailable = available &amp; (available - 1);// 清除已处理的位置，继续处理下一个例如：available = 0b10100     available - 1 = 0b10011     新available = 0b10000\n完整实现\nvoid backtrackBitwise(int row, int cols, int diag1, int diag2,                      int n, vector&lt;int&gt;&amp; queens,                      vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    if (row == n) &#123;        result.push_back(generateBoard(queens, n));        return;    &#125;        // 计算可用位置    int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));        while (available) &#123;        // 提取最低位        int position = available &amp; (-available);                // 清除最低位        available &amp;= (available - 1);                // 计算列号        int col = __builtin_ctz(position);  // Count Trailing Zeros        queens[row] = col;                // 递归        backtrackBitwise(row + 1,                        cols | position,        // 标记列                        (diag1 | position) &lt;&lt; 1, // 对角线左移                        (diag2 | position) &gt;&gt; 1, // 对角线右移                        n, queens, result);    &#125;&#125;\n关键点解析\n对角线的移位操作\n当前行: row下一行: row + 1主对角线: 向左移动1格 → 左移 &lt;&lt; 1副对角线: 向右移动1格 → 右移 &gt;&gt; 1示例（4皇后，第0行第1列）:row=0:    . Q . .          diag1 = 0b0010          diag2 = 0b0010row=1:    主对角线向左          . X Q .          diag1 = 0b0100                    副对角线向右          Q . X .          diag2 = 0b0001\ngraph LR\n    A[row 0] --&gt;|diag1 &lt;&lt; 1| B[row 1]\n    A --&gt;|diag2 &gt;&gt; 1| C[row 1]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n优势\n✅ 速度最快（位运算是CPU原生操作）\n✅ 空间效率高（3个整数 vs 3个数组）\n✅ 适合高级优化\n❌ 代码可读性较低\n❌ 仅适用于 n ≤ 32（int大小限制）\n\n性能对比\n实测数据（8皇后）\n\n\n\n解法\n时间\n相对速度\n空间\n\n\n\n\n基础回溯\n1000 μs\n1.0x\nO(n²)\n\n\n标记数组优化\n350 μs\n2.9x\nO(n)\n\n\n位运算优化\n180 μs\n5.6x\nO(n)\n\n\n\n不同规模的解数量\n\n\n\nn\n解的数量\n基础回溯\n位运算\n\n\n\n\n4\n2\n&lt; 1 ms\n&lt; 1 ms\n\n\n8\n92\n10 ms\n2 ms\n\n\n10\n724\n120 ms\n18 ms\n\n\n12\n14,200\n2.5 s\n350 ms\n\n\n\n性能曲线\ngraph LR\n    A[n=4] --&gt;|基础| B[0.5ms]\n    A --&gt;|优化| C[0.2ms]\n    A --&gt;|位运算| D[0.1ms]\n    \n    E[n=8] --&gt;|基础| F[10ms]\n    E --&gt;|优化| G[3.5ms]\n    E --&gt;|位运算| H[1.8ms]\n    \n    I[n=12] --&gt;|基础| J[2.5s]\n    I --&gt;|优化| K[850ms]\n    I --&gt;|位运算| L[350ms]\n    \n    style D fill:#90EE90\n    style H fill:#90EE90\n    style L fill:#90EE90\n\nLeetCode实战\nLeetCode 51: N-Queens\n要求：返回所有不同的N皇后问题的解\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));        vector&lt;bool&gt; cols(n, false);        vector&lt;bool&gt; diag1(2 * n - 1, false);        vector&lt;bool&gt; diag2(2 * n - 1, false);                backtrack(board, 0, cols, diag1, diag2, result);        return result;    &#125;    private:    void backtrack(vector&lt;string&gt;&amp; board, int row,                   vector&lt;bool&gt;&amp; cols,                   vector&lt;bool&gt;&amp; diag1,                   vector&lt;bool&gt;&amp; diag2,                   vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;        int n = board.size();        if (row == n) &#123;            result.push_back(board);            return;        &#125;                for (int col = 0; col &lt; n; ++col) &#123;            int d1 = row - col + n - 1;            int d2 = row + col;                        if (cols[col] || diag1[d1] || diag2[d2]) continue;                        board[row][col] = &#x27;Q&#x27;;            cols[col] = diag1[d1] = diag2[d2] = true;                        backtrack(board, row + 1, cols, diag1, diag2, result);                        board[row][col] = &#x27;.&#x27;;            cols[col] = diag1[d1] = diag2[d2] = false;        &#125;    &#125;&#125;;\n提交结果：\n\n✅ 执行时间: 击败 95%\n✅ 内存消耗: 击败 90%\n\n\nLeetCode 52: N-Queens II\n要求：只返回解的数量\n优化：不需要存储棋盘，只计数\nclass Solution &#123;public:    int totalNQueens(int n) &#123;        return backtrack(0, 0, 0, 0, n);    &#125;    private:    int backtrack(int row, int cols, int diag1, int diag2, int n) &#123;        if (row == n) return 1;                int count = 0;        int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));                while (available) &#123;            int position = available &amp; (-available);            available &amp;= (available - 1);                        count += backtrack(row + 1,                             cols | position,                             (diag1 | position) &lt;&lt; 1,                             (diag2 | position) &gt;&gt; 1,                             n);        &#125;                return count;    &#125;&#125;;\n提交结果：\n\n✅ 执行时间: 击败 99%\n✅ 内存消耗: 击败 95%\n\n\n进阶技巧\n1. 对称性剪枝\n利用棋盘的对称性，只搜索一半的解：\nvoid backtrack(/* ... */) &#123;    if (row == 0) &#123;        // 第一行只搜索前半部分        for (int col = 0; col &lt; n / 2 + (n % 2); ++col) &#123;            // ...        &#125;    &#125; else &#123;        // 其他行正常搜索        for (int col = 0; col &lt; n; ++col) &#123;            // ...        &#125;    &#125;&#125;// 最后结果数量 *= 2（如果n为偶数）\n2. 记忆化搜索\n对于重复计算的子问题，可以缓存结果：\nunordered_map&lt;int, int&gt; memo;  // state -&gt; countint backtrack(int row, int cols, int diag1, int diag2, int n) &#123;    int state = (cols &lt;&lt; 20) | (diag1 &lt;&lt; 10) | diag2;        if (memo.count(state)) &#123;        return memo[state];    &#125;        // ... 正常回溯 ...        memo[state] = count;    return count;&#125;\n3. 启发式搜索\n优先选择约束最多的列（Most Constrained First）：\n// 选择可用列数最少的行优先搜索int countAvailable(int cols, int diag1, int diag2, int n) &#123;    int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));    return __builtin_popcount(available);&#125;\n\n扩展问题\n变种1: 不同颜色的皇后\n有两种颜色的皇后，同色不能互相攻击：\nvoid backtrack(/* ... */, int color) &#123;    // 分别维护两套标记数组    // ...&#125;\n变种2: 矩形棋盘\nm×n 的矩形棋盘上放置皇后：\nvoid backtrack(int row, int m, int n) &#123;    if (row == min(m, n)) &#123;        // ...    &#125;&#125;\n变种3: 障碍物\n棋盘上有一些位置不能放置皇后：\nif (board[row][col] == &#x27;X&#x27;) &#123;  // 障碍物    continue;&#125;\n\n常见错误\n❌ 错误1: 忘记回溯\nboard[row][col] = &#x27;Q&#x27;;backtrack(board, row + 1, result);// 忘记撤销！\n✅ 正确：\nboard[row][col] = &#x27;Q&#x27;;backtrack(board, row + 1, result);board[row][col] = &#x27;.&#x27;;  // 撤销选择\n❌ 错误2: 对角线索引计算错误\nint d1 = row - col;  // 可能为负数！\n✅ 正确：\nint d1 = row - col + n - 1;  // 保证非负\n❌ 错误3: 位运算范围错误\nint available = ~(cols | diag1 | diag2);  // 包含高位的1\n✅ 正确：\nint available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));\n\n总结\n三种解法对比\n\n\n\n特性\n基础回溯\n标记数组\n位运算\n\n\n\n\n难度\n⭐⭐\n⭐⭐⭐\n⭐⭐⭐⭐\n\n\n速度\n慢\n中等\n最快\n\n\n空间\nO(n²)\nO(n)\nO(n)\n\n\n可读性\n高\n中\n低\n\n\n推荐场景\n学习理解\n面试推荐\n性能要求高\n\n\n\n核心思想\ngraph TD\n    A[N皇后问题] --&gt; B[逐行放置]\n    B --&gt; C[回溯框架]\n    C --&gt; D[合法性检查]\n    D --&gt; E[基础: O n 遍历]\n    D --&gt; F[优化: O 1 查表]\n    D --&gt; G[极致: 位运算]\n    \n    E --&gt; H[适合学习]\n    F --&gt; I[适合面试]\n    G --&gt; J[适合竞赛]\n    \n    style I fill:#90EE90\n关键要点\n✅ 逐行放置是关键思路\n✅ 对角线索引的计算要熟练\n✅ 回溯三步：做选择 → 递归 → 撤销\n✅ 位运算优化是进阶技巧\n\nN皇后问题是回溯算法的经典代表，从基础实现到极致优化，体现了算法设计中&quot;用空间换时间&quot;和&quot;巧用特性优化&quot;的核心思想。掌握这道题，你将对回溯算法有更深刻的理解！\n\n推荐练习：\n\nLeetCode 51 - N皇后\nLeetCode 52 - N皇后 II\nLeetCode 37 - 解数独（类似思想）\n\n","categories":["LeetCode"],"tags":["C++","LeetCode","回溯","N皇后","位运算","剪枝优化"]},{"title":"深入理解计算机系统知识点总结","url":"/posts/aac6e27d/","content":"深入理解计算机系统：从程序员视角看计算机\n\n基于经典教材 CSAPP 的系统知识全面总结\n\n引言\n《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective, CSAPP) 是一本从程序员视角审视计算机系统的经典教材。本书不仅仅教授理论知识，更强调理解计算机系统如何影响程序的正确性、性能和实用性。\n核心理念：\n\n程序员必须理解系统才能写出高效、可靠的代码\n硬件和软件的边界越来越模糊\n系统知识是成为优秀程序员的必备技能\n\n\n第一部分：程序结构和执行\n信息的表示和处理\n1. 信息存储\n计算机中的所有信息都以位 (bit) 的形式存储和处理。\n关键概念：\n字节 (Byte) = 8 位字 (Word) = 机器字长（32位或64位系统）地址空间：- 32位系统：2^32 = 4GB- 64位系统：2^64 = 16EB (理论上)\n字节序 (Endianness)：\n大端序 (Big Endian):    高位字节存储在低地址小端序 (Little Endian): 低位字节存储在低地址示例：整数 0x01234567地址:     0x100  0x101  0x102  0x103大端:      01     23     45     67小端:      67     45     23     01\ngraph LR\n    A[数据 0x01234567] --&gt; B&#123;字节序&#125;\n    B --&gt;|大端| C[01 23 45 67]\n    B --&gt;|小端| D[67 45 23 01]\n2. 整数表示\n无符号编码：\n范围: [0, 2^w - 1]示例 (8位): 0 ~ 255\n补码编码 (最常用的有符号数表示)：\n范围: [-2^(w-1), 2^(w-1) - 1]示例 (8位): -128 ~ 127补码规则：- 正数：与无符号数相同- 负数：按位取反加1-1 的补码 (8位): 11111111-128 的补码 (8位): 10000000\n关键陷阱：\n// 有符号数与无符号数混合运算int a = -1;unsigned int b = 1;if (a &lt; b) &#123;  // ❌ 永远为 false!    // a 会被转换为无符号数，变成很大的正数&#125;// 整数溢出int max = INT_MAX;int overflow = max + 1;  // 溢出，变成负数\n3. 浮点数表示\nIEEE 754 标准：\n单精度 (32位):[符号位 1位][指数 8位][尾数 23位]双精度 (64位):[符号位 1位][指数 11位][尾数 52位]值 = (-1)^s × M × 2^E\n特殊值：\n\n\n\n值\n指数\n尾数\n\n\n\n\n0\n全0\n全0\n\n\n∞\n全1\n全0\n\n\nNaN\n全1\n非0\n\n\n\n浮点数陷阱：\nfloat a = 0.1 + 0.2;if (a == 0.3) &#123;  // ❌ 可能为 false    // 浮点数精度问题&#125;// 正确做法if (fabs(a - 0.3) &lt; 1e-6) &#123;  // ✓    // 使用误差范围比较&#125;\n\n程序的机器级表示\n1. 汇编语言基础\nx86-64 寄存器：\n通用寄存器 (64位):%rax - 返回值%rbx - 被调用者保存%rcx - 第4个参数%rdx - 第3个参数%rsi - 第2个参数%rdi - 第1个参数%rbp - 帧指针%rsp - 栈指针%r8~%r15 - 额外寄存器\nAT&amp;T 语法 vs Intel 语法：\n; AT&amp;T 语法 (GCC 默认)movq $5, %rax          # 将立即数5移到raxmovq %rax, %rbx        # 源在前，目的在后; Intel 语法 (Windows 常用)mov rax, 5             ; 目的在前，源在后mov rbx, rax\n2. 函数调用约定\n栈帧结构：\n高地址+------------------+| 参数7            || 参数6            || 返回地址         |  &lt;- 调用者的栈帧+------------------+| 保存的%rbp       |  &lt;- %rbp 指向这里| 局部变量         || ...              |+------------------+  &lt;- %rsp 指向这里低地址\ngraph TD\n    A[调用者] --&gt; B[保存参数1-6到寄存器]\n    B --&gt; C[额外参数压栈]\n    C --&gt; D[call指令]\n    D --&gt; E[被调用者]\n    E --&gt; F[保存旧rbp]\n    F --&gt; G[分配栈帧]\n    G --&gt; H[执行函数]\n    H --&gt; I[恢复栈帧]\n    I --&gt; J[ret返回]\n参数传递规则：\n前6个参数: %rdi, %rsi, %rdx, %rcx, %r8, %r9第7+参数: 通过栈传递返回值: %rax (整数), %xmm0 (浮点数)\n3. 数组和结构体\n数组访问：\nint array[10];int *ptr = &amp;array[3];// 汇编实现// array[i] 的地址 = base + i * sizeof(element)leaq (%rdi,%rsi,4), %rax  # rax = rdi + rsi*4\n结构体对齐：\nstruct S1 &#123;    char c;     // 1字节    int i;      // 4字节，需要对齐    char d;     // 1字节&#125;;// 实际大小：12字节 (因为对齐)struct S2 &#123;    char c;     // 1字节    char d;     // 1字节    int i;      // 4字节&#125;;// 实际大小：8字节 (更好的排列)\n\n处理器体系结构\n1. 指令集架构 (ISA)\nCISC vs RISC：\n\n\n\n特性\nCISC (x86)\nRISC (ARM, RISC-V)\n\n\n\n\n指令复杂度\n复杂，功能强大\n简单，固定长度\n\n\n寻址模式\n多种\n较少\n\n\n寄存器数量\n较少\n较多\n\n\n示例\nx86, x86-64\nARM, MIPS, RISC-V\n\n\n\n2. 流水线 (Pipeline)\n5级流水线：\n1. 取指 (Fetch)2. 译码 (Decode)3. 执行 (Execute)4. 访存 (Memory)5. 写回 (Write-back)\ngraph LR\n    A[指令1] --&gt; B[取指]\n    B --&gt; C[译码]\n    C --&gt; D[执行]\n    D --&gt; E[访存]\n    E --&gt; F[写回]\n流水线冒险：\n\n结构冒险：硬件资源冲突\n数据冒险：指令间存在数据依赖\n控制冒险：分支指令导致的不确定性\n\n分支预测：\n// 代码示例for (int i = 0; i &lt; n; i++) &#123;    if (data[i] &gt;= 128) &#123;  // 分支点        sum += data[i];    &#125;&#125;// 对排序后的数据，分支预测器表现更好// 因为分支模式更规律\n\n优化程序性能\n1. 性能指标\nCPU 性能公式：\n程序执行时间 = 指令数 × CPI × 时钟周期CPI (Cycles Per Instruction): 每条指令的平均时钟周期数\n关键优化原则：\n\n减少指令数\n降低 CPI\n提高时钟频率\n\n2. 编译器优化\n优化级别：\ngcc -O0  # 无优化，便于调试gcc -O1  # 基本优化gcc -O2  # 推荐优化级别gcc -O3  # 激进优化\n常见优化技术：\n// 1. 循环展开// 优化前for (int i = 0; i &lt; n; i++) &#123;    sum += a[i];&#125;// 优化后（展开4次）for (int i = 0; i &lt; n; i += 4) &#123;    sum += a[i] + a[i+1] + a[i+2] + a[i+3];&#125;// 2. 消除冗余计算// 优化前for (int i = 0; i &lt; n; i++) &#123;    result[i] = sqrt(x) * array[i];  // sqrt(x) 重复计算&#125;// 优化后double temp = sqrt(x);for (int i = 0; i &lt; n; i++) &#123;    result[i] = temp * array[i];&#125;\n3. 内存性能优化\n局部性原理：\n// ❌ 差的局部性 - 按列访问for (int j = 0; j &lt; N; j++) &#123;    for (int i = 0; i &lt; N; i++) &#123;        sum += array[i][j];  // 跳跃访问    &#125;&#125;// ✓ 好的局部性 - 按行访问for (int i = 0; i &lt; N; i++) &#123;    for (int j = 0; j &lt; N; j++) &#123;        sum += array[i][j];  // 连续访问    &#125;&#125;\n\n第二部分：在系统上运行程序\n存储器层次结构\n1. 存储器层次\ngraph TD\n    A[CPU寄存器] --&gt; B[L1缓存]\n    B --&gt; C[L2缓存]\n    C --&gt; D[L3缓存]\n    D --&gt; E[主存DRAM]\n    E --&gt; F[本地磁盘]\n    F --&gt; G[远程存储]\n典型参数：\n\n\n\n层次\n容量\n访问时间\n价格\n\n\n\n\n寄存器\n&lt;1KB\n0.25ns\n最贵\n\n\nL1缓存\n32-64KB\n1ns\n很贵\n\n\nL2缓存\n256KB-1MB\n4ns\n贵\n\n\nL3缓存\n8-32MB\n10-20ns\n较贵\n\n\n主存\n4-16GB\n100ns\n适中\n\n\nSSD\n256GB-2TB\n100μs\n便宜\n\n\nHDD\n1-10TB\n10ms\n很便宜\n\n\n\n2. 缓存原理\n缓存映射方式：\n\n直接映射：每个内存块只能映射到一个缓存行\n全相联：内存块可以映射到任意缓存行\n组相联：折中方案，最常用\n\n缓存写策略：\n写命中:- 写直达 (Write-through): 同时写缓存和内存- 写回 (Write-back): 只写缓存，延迟写回内存写缺失:- 写分配 (Write-allocate): 加载到缓存再写- 非写分配 (Not-write-allocate): 直接写内存\n3. 缓存友好的代码\n// ❌ 缓存不友好 - 矩阵转置void transpose_bad(int src[N][N], int dst[N][N]) &#123;    for (int i = 0; i &lt; N; i++) &#123;        for (int j = 0; j &lt; N; j++) &#123;            dst[j][i] = src[i][j];  // dst 跳跃访问        &#125;    &#125;&#125;// ✓ 缓存友好 - 分块优化void transpose_good(int src[N][N], int dst[N][N]) &#123;    int B = 8;  // 块大小    for (int i = 0; i &lt; N; i += B) &#123;        for (int j = 0; j &lt; N; j += B) &#123;            for (int ii = i; ii &lt; i + B; ii++) &#123;                for (int jj = j; jj &lt; j + B; jj++) &#123;                    dst[jj][ii] = src[ii][jj];                &#125;            &#125;        &#125;    &#125;&#125;\n\n链接\n1. 链接过程\ngraph LR\n    A[源文件.c] --&gt; B[预处理]\n    B --&gt; C[编译]\n    C --&gt; D[汇编]\n    D --&gt; E[目标文件.o]\n    E --&gt; F[链接器]\n    G[库文件] --&gt; F\n    F --&gt; H[可执行文件]\n目标文件格式 (ELF)：\nELF Header+------------------+| .text   | 代码段  || .data   | 数据段  || .bss    | 未初始化 || .rodata | 只读数据 || .symtab | 符号表  |+------------------+\n2. 符号解析\n符号类型：\nint global_var = 42;           // 强符号，已初始化int global_uninit;             // 弱符号，未初始化static int local_var = 10;     // 本地符号extern int external_var;       // 外部引用\n链接规则：\n\n多个强符号：错误\n一个强符号，多个弱符号：选择强符号\n多个弱符号：任选一个（危险！）\n\n3. 静态库与动态库\n静态库 (.a)：\n# 创建静态库ar rcs libmylib.a file1.o file2.o# 链接静态库gcc main.c -L. -lmylib -o app\n动态库 (.so / .dll)：\n# 创建动态库gcc -shared -fPIC -o libmylib.so file1.c file2.c# 链接动态库gcc main.c -L. -lmylib -o app\n对比：\n\n\n\n特性\n静态库\n动态库\n\n\n\n\n链接时间\n编译时\n运行时\n\n\n文件大小\n大\n小\n\n\n更新\n需重编译\n只需替换库\n\n\n启动速度\n快\n慢\n\n\n\n\n异常控制流\n1. 异常分类\ngraph TD\n    A[异常] --&gt; B[中断]\n    A --&gt; C[陷阱]\n    A --&gt; D[故障]\n    A --&gt; E[终止]\n    \n    B --&gt; F[异步IO设备]\n    C --&gt; G[同步系统调用]\n    D --&gt; H[可恢复错误]\n    E --&gt; I[不可恢复错误]\n异常示例：\n中断: 键盘输入，网络数据包陷阱: 系统调用 (read, write, fork)故障: 缺页异常，除零错误终止: 硬件错误，非法指令\n2. 进程控制\n创建进程：\npid_t pid = fork();if (pid == 0) &#123;    // 子进程    printf(&quot;子进程 PID = %d\\n&quot;, getpid());    execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);    exit(0);&#125; else if (pid &gt; 0) &#123;    // 父进程    printf(&quot;父进程，子PID = %d\\n&quot;, pid);    int status;    waitpid(pid, &amp;status, 0);&#125;\n3. 信号\n常见信号：\n\n\n\n信号\n默认行为\n触发条件\n\n\n\n\nSIGINT\n终止\nCtrl+C\n\n\nSIGKILL\n终止\nkill -9\n\n\nSIGSEGV\n终止\n段错误\n\n\nSIGCHLD\n忽略\n子进程终止\n\n\n\n信号处理：\n#include &lt;signal.h&gt;void handler(int sig) &#123;    printf(&quot;捕获信号 %d\\n&quot;, sig);&#125;int main() &#123;    signal(SIGINT, handler);    while (1) &#123;        sleep(1);    &#125;    return 0;&#125;\n\n虚拟内存\n1. 虚拟地址空间\nLinux 进程地址空间：\n高地址+------------------+| 内核空间         |+------------------+| 栈 ↓            ||                  || ↑ 堆            |+------------------+| .bss 段         || .data 段        || .text 段        |+------------------+低地址\n2. 页表\n地址转换：\n虚拟地址 = [虚拟页号 VPN | 页内偏移]           ↓ 页表转换物理地址 = [物理页号 PPN | 页内偏移]页大小: 4KB (2^12)\n多级页表：\ngraph LR\n    A[虚拟地址] --&gt; B[一级页表]\n    B --&gt; C[二级页表]\n    C --&gt; D[三级页表]\n    D --&gt; E[物理页]\n3. 内存映射\nmmap 系统调用：\n#include &lt;sys/mman.h&gt;int fd = open(&quot;data.txt&quot;, O_RDONLY);void *ptr = mmap(NULL, file_size, PROT_READ,                  MAP_PRIVATE, fd, 0);// 使用映射的内存char ch = ((char*)ptr)[100];munmap(ptr, file_size);close(fd);\n\n第三部分：程序间的交互和通信\n系统级I/O\n1. Unix I/O 模型\n文件描述符：\n// 标准文件描述符0 - stdin1 - stdout2 - stderrint fd = open(&quot;file.txt&quot;, O_RDONLY);char buf[1024];ssize_t n = read(fd, buf, sizeof(buf));write(fd, &quot;hello&quot;, 5);close(fd);\n2. I/O 多路复用\nselect 示例：\nfd_set readfds;FD_ZERO(&amp;readfds);FD_SET(sockfd, &amp;readfds);struct timeval tv = &#123;5, 0&#125;;int ready = select(sockfd + 1, &amp;readfds, NULL, NULL, &amp;tv);if (ready &gt; 0 &amp;&amp; FD_ISSET(sockfd, &amp;readfds)) &#123;    // socket 有数据&#125;\n\n网络编程\n1. 套接字编程\nTCP 服务器：\n// 1. 创建socketint listenfd = socket(AF_INET, SOCK_STREAM, 0);// 2. 绑定struct sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_addr.s_addr = INADDR_ANY;addr.sin_port = htons(8080);bind(listenfd, (struct sockaddr*)&amp;addr, sizeof(addr));// 3. 监听listen(listenfd, 5);// 4. 接受连接int connfd = accept(listenfd, NULL, NULL);// 5. 读写char buf[1024];read(connfd, buf, sizeof(buf));write(connfd, &quot;Hello&quot;, 5);close(connfd);close(listenfd);\nTCP 三次握手：\nsequenceDiagram\n    participant C as 客户端\n    participant S as 服务器\n    \n    C-&gt;&gt;S: SYN\n    S-&gt;&gt;C: SYN+ACK\n    C-&gt;&gt;S: ACK\n    Note over C,S: 连接建立\n\n并发编程\n1. 线程\n创建线程：\n#include &lt;pthread.h&gt;void *thread_func(void *arg) &#123;    printf(&quot;线程运行中\\n&quot;);    return NULL;&#125;int main() &#123;    pthread_t tid;    pthread_create(&amp;tid, NULL, thread_func, NULL);    pthread_join(tid, NULL);    return 0;&#125;\n2. 同步机制\n互斥锁：\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;mutex);// 临界区counter++;pthread_mutex_unlock(&amp;mutex);\n信号量：\nsem_t sem;sem_init(&amp;sem, 0, 1);sem_wait(&amp;sem);  // P操作// 临界区sem_post(&amp;sem);  // V操作\n3. 经典问题\n生产者-消费者：\nsem_t empty, full;pthread_mutex_t mutex;void *producer(void *arg) &#123;    while (1) &#123;        sem_wait(&amp;empty);        pthread_mutex_lock(&amp;mutex);        // 生产        pthread_mutex_unlock(&amp;mutex);        sem_post(&amp;full);    &#125;&#125;void *consumer(void *arg) &#123;    while (1) &#123;        sem_wait(&amp;full);        pthread_mutex_lock(&amp;mutex);        // 消费        pthread_mutex_unlock(&amp;mutex);        sem_post(&amp;empty);    &#125;&#125;\n\n总结\n核心思想\n\n抽象层次：理解系统的多层抽象\n性能优化：缓存、局部性、并行性\n正确性保证：理解底层避免bug\n系统思维：程序在系统中运行\n\n","categories":["知识分享"],"tags":["计算机系统","性能优化","系统编程","操作系统","CSAPP"]},{"title":"现代C++","url":"/posts/c396c10e/","content":"现代C++核心特性详解：从类型推导到完美转发\n\n深入理解现代 C++ 的核心机制，掌握高性能编程的关键技术\n\n引言\n现代 C++（C++11/14/17/20）引入了许多强大的特性，其中类型推导、移动语义和完美转发是构建高性能应用的基石。本文将深入剖析这些核心概念，帮助你写出更高效、更安全的C++代码。\n\n第一部分：类型推导机制\n模板类型推导\n模板类型推导是理解现代 C++ 的第一步。对于模板函数：\ntemplate&lt;typename T&gt;void f(ParamType param);f(expr); // 编译器根据 expr 推导 T 和 ParamType\n推导规则分为三种情况：\n情况一：ParamType 是引用或指针\ntemplate&lt;typename T&gt;void f(T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   // T 是 int,       param 是 int&amp;f(cx);  // T 是 const int, param 是 const int&amp;f(rx);  // T 是 const int, param 是 const int&amp;\n关键点：const 被保留，引用性质在推导前被忽略。\n情况二：ParamType 是万能引用（T&amp;&amp;）\ntemplate&lt;typename T&gt;void f(T&amp;&amp; param);f(x);   // x 是左值  -&gt; T 是 int&amp;,       param 是 int&amp;f(27);  // 27 是右值 -&gt; T 是 int,        param 是 int&amp;&amp;\n这是完美转发的基础，也是最重要的推导规则。\n情况三：ParamType 是按值传参\ntemplate&lt;typename T&gt;void f(T param);f(x);   // T 是 intf(cx);  // T 是 int (const 被丢弃)f(rx);  // T 是 int (引用和 const 都被丢弃)\n特殊情况：指针的 const\nconst char* const ptr = &quot;Fun&quot;;f(ptr);// T 是 const char* (指针本身的 const 被丢弃，指向内容的 const 保留)\n推导规则对比表\n\n\n\nParamType 形式\n传入左值\n传入右值\nconst 属性\n适用场景\n\n\n\n\nT&amp;\n✓\n✗\n保留\n需要修改参数，或大对象只读\n\n\nT&amp;&amp;\n推导为 T&amp;\n推导为 T\n保留\n完美转发\n\n\nT\n拷贝\n移动/拷贝\n丢弃\n标量类型，或极小对象\n\n\n\n\nauto 类型推导\nauto 类型推导与模板推导机制99%相同，唯一例外是花括号初始化：\nauto x1 = 27;    // x1 是 intauto x2(27);     // x2 是 intauto x3 = &#123;27&#125;;  // ⚠️ x3 是 std::initializer_list&lt;int&gt;auto x4&#123;27&#125;;     // C++17: int, C++14: std::initializer_list&lt;int&gt;\n函数返回值的 auto\n当 auto 用于函数返回值时，使用的是模板推导规则：\nauto create_dims() &#123;    return &#123;1, 2, 3&#125;; // ❌ 编译错误！模板推导不支持 &#123;&#125;&#125;// 正确做法auto create_dims() &#123;    return std::vector&lt;int&gt;&#123;1, 2, 3&#125;; // ✓&#125;\n\ndecltype 详解\ndecltype 是&quot;诚实的复读机&quot;，它返回表达式的确切类型，不会丢弃引用和 const：\nconst int i = 0;auto a = i;            // a 是 int (const 被丢弃)decltype(i) d = i;     // d 是 const int (原样保留)\ndecltype(auto)：完美转发返回值\n这是 C++14 的杀手级特性：\ntemplate&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];&#125;std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;authAndAccess(vec, 0) = 100;  // 返回 int&amp;，可以修改auto val = authAndAccess(std::vector&lt;int&gt;&#123;1, 2, 3&#125;, 0);  // 返回 int，移动语义\ndecltype 的陷阱：括号的魔力\nint x = 10;decltype(x)   t1;   // t1 是 intdecltype((x)) t2;   // t2 是 int&amp; ⚠️ 危险！\n关键规则：\n\ndecltype(name) → 返回声明类型\ndecltype((name)) → 返回引用（因为 (name) 是左值表达式）\n\ngraph TD\n    A[decltype 推导] --&gt; B&#123;是名字还是表达式?&#125;\n    B --&gt;|名字| C[返回声明类型]\n    B --&gt;|表达式| D&#123;是否为左值?&#125;\n    D --&gt;|是| E[返回引用类型]\n    D --&gt;|否| F[返回值类型]\n\n查看类型推导结果\n方法一：编译器报错（最推荐）\ntemplate&lt;typename T&gt;class TD;  // 只声明，不定义int x = 10;auto y = x;TD&lt;decltype(y)&gt; debug;  // 编译错误会显示：TD&lt;int&gt;\n方法二：运行时 typeid（有坑）\n#include &lt;typeinfo&gt;std::cout &lt;&lt; typeid(y).name() &lt;&lt; std::endl;\n缺陷：会忽略引用和 const！\n方法三：IDE 提示（快但不一定准）\n鼠标悬停在 auto 上查看类型，对简单类型有效。\n\n第二部分：引用与移动语义\n万能引用 vs 右值引用\n判断规则：\n// 有类型推导 → 万能引用template&lt;typename T&gt; void f(T&amp;&amp; param);  // 万能引用auto&amp;&amp; var = value;                       // 万能引用// 无类型推导 → 右值引用void f(int&amp;&amp; param);                      // 右值引用\n万能引用示例\ntemplate&lt;typename T&gt;void process(T&amp;&amp; param) &#123;    // param 可以绑定左值或右值&#125;int x = 10;process(x);   // T 推导为 int&amp;，  param 是 int&amp;process(10);  // T 推导为 int，   param 是 int&amp;&amp;graph LR    A[T&amp;&amp;] --&gt; B&#123;有类型推导?&#125;    B --&gt;|是| C[万能引用]    B --&gt;|否| D[右值引用]        C --&gt; E[可以绑定左值]    C --&gt; F[可以绑定右值]        D --&gt; G[只能绑定右值]\n\nstd::move 和 std::forward\nstd::move：无条件转为右值\nstd::string str1 = &quot;Hello&quot;;std::string str2 = std::move(str1);  // str1 被清空\n本质：std::move 不移动任何东西，只是类型转换：\ntemplate&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) &#123;    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(param);&#125;\nstd::forward：有条件地保持值类别\ntemplate&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg));  // 保持左值/右值属性&#125;\n为什么需要 forward？\n// 不使用 forwardtemplate&lt;typename Container, typename Index&gt;decltype(auto) badAccess(Container&amp;&amp; c, Index i) &#123;    return c[i];  // 总是返回左值引用！&#125;// 使用 forwardtemplate&lt;typename Container, typename Index&gt;decltype(auto) goodAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];    // 左值容器 → 返回左值引用    // 右值容器 → 返回右值引用（可移动）&#125;\n对比总结\n\n\n\n特性\nstd::move\nstd::forward\n\n\n\n\n目的\n无条件转为右值\n有条件保持值类别\n\n\n使用场景\n确定要移动对象\n完美转发模板参数\n\n\n返回值\n总是右值引用\n可能是左值或右值引用\n\n\n\n\n左值与右值的本质\n核心规则\n有名字的右值引用是左值：\nvoid process(Resource&amp;&amp; rref) &#123;    // rref 是右值引用类型，但 rref 本身是左值    Resource r1 = rref;              // ❌ 调用拷贝构造    Resource r2 = std::move(rref);   // ✓ 调用移动构造&#125;\n移动构造函数中的 std::move\nclass Resource &#123;    std::vector&lt;int&gt; data;public:    Resource(Resource&amp;&amp; other) noexcept        : data(std::move(other.data)) &#123;  // 必须使用 std::move        // other.data 是左值，需要转为右值才能触发移动    &#125;&#125;;\n类型分析：\n\n\n\n表达式\n类型\n值类别\n需要 move？\n\n\n\n\nother\nResource&amp;&amp;\n左值\n是\n\n\nother.data\nstd::vector&lt;int&gt;&amp;\n左值\n是\n\n\nstd::move(other)\nResource&amp;&amp;\n右值\n-\n\n\n\ngraph TD\n    A[右值引用参数] --&gt; B[有名字的变量]\n    B --&gt; C[是左值]\n    C --&gt; D[访问成员]\n    D --&gt; E[成员也是左值]\n    E --&gt; F&#123;要移动吗?&#125;\n    F --&gt;|是| G[使用 std::move]\n    F --&gt;|否| H[直接使用 - 拷贝]\n\n第三部分：auto 的最佳实践\n优先使用 auto 的理由\n1. 避免隐形的类型转换\nstd::unordered_map&lt;std::string, int&gt; map;// ❌ 错误：每次循环都拷贝！for (const std::pair&lt;std::string, int&gt;&amp; p : map) &#123;    // map 的元素类型是 std::pair&lt;const std::string, int&gt;    // 类型不匹配，发生拷贝构造&#125;// ✓ 正确：零拷贝for (const auto&amp; p : map) &#123;    // 编译器推导为 std::pair&lt;const std::string, int&gt;&amp;&#125;\n2. 强制初始化\nint x;       // 未初始化，可能是垃圾值auto x;      // ❌ 编译错误auto x = 0;  // ✓ 必须初始化\n3. 可移植性\nstd::vector&lt;int&gt; v;unsigned sz = v.size();  // ⚠️ 32位系统可能溢出auto sz = v.size();      // ✓ 总是正确\n\nstd::function vs auto\n性能对比\n// std::function：类型擦除，有开销std::function&lt;int(int)&gt; func = [](int x) &#123; return x * x; &#125;;// auto：零开销，可内联auto lambda = [](int x) &#123; return x * x; &#125;;\n性能差异：\n\n\n\n特性\nstd::function\nauto\n\n\n\n\n大小\n固定（24-64字节）\n等于实际对象\n\n\n调用开销\n间接调用\n直接调用，可内联\n\n\n内存分配\n可能堆分配\n无额外分配\n\n\n性能\n慢 2-5 倍\n最优\n\n\n\n使用场景\n使用 std::function：\n\n需要存储不同类型的可调用对象\n运行时替换回调\n公共 API 接口\n\n使用 auto：\n\n局部变量\n性能关键代码\n模板函数参数\n\ngraph TD\n    A[需要存储可调用对象?] --&gt; B&#123;类型统一?&#125;\n    B --&gt;|否| C[std::function]\n    B --&gt;|是| D&#123;性能关键?&#125;\n    D --&gt;|是| E[auto/模板]\n    D --&gt;|否| F[两者皆可]\n    \n    C --&gt; G[容器存储]\n    C --&gt; H[回调系统]\n    \n    E --&gt; I[局部使用]\n    E --&gt; J[可内联]\n\n类型擦除与闭包\n类型擦除\n将不同类型的对象放入统一接口：\n// 不同的类型auto lambda1 = [](int x) &#123; return x * 2; &#125;;auto lambda2 = [](int x) &#123; return x + 5; &#125;;// 统一的&quot;盒子&quot;（类型擦除）std::function&lt;int(int)&gt; box;box = lambda1;  // ✓box = lambda2;  // ✓\n实现原理（简化版）：\ntemplate&lt;typename R, typename... Args&gt;class function&lt;R(Args...)&gt; &#123;    struct CallableBase &#123;        virtual R call(Args...) = 0;        virtual ~CallableBase() = default;    &#125;;    template&lt;typename F&gt;    struct CallableImpl : CallableBase &#123;        F f;        R call(Args... args) override &#123; return f(args...); &#125;    &#125;;    CallableBase* callable;  // 多态&#125;;\n闭包\n闭包 = 函数 + 环境\nauto makeCounter() &#123;    int count = 0;    return [count]() mutable &#123;        return ++count;    &#125;;&#125;auto counter1 = makeCounter();auto counter2 = makeCounter();counter1();  // 1counter1();  // 2counter2();  // 1 (独立环境)\n编译器生成的等价类：\nclass __Closure &#123;    int count;  // 捕获的变量public:    __Closure(int c) : count(c) &#123;&#125;    int operator()() &#123; return ++count; &#125;&#125;;\n捕获方式：\nint a = 1, b = 2;[a, b]()      // 值捕获[&amp;a, &amp;b]()    // 引用捕获[=]()         // 全部值捕获[&amp;]()         // 全部引用捕获[=, &amp;a]()     // a 引用，其他值捕获[value = a + b]()  // 初始化捕获（C++14）\n\n总结\n核心要点\n\n模板推导：理解三种情况（引用、万能引用、按值），万能引用是完美转发的基础\nauto vs decltype：auto 会去引用，decltype 保留原样\nstd::move vs std::forward：move 无条件转右值，forward 条件保持值类别\n优先使用 auto：避免拷贝、强制初始化、更好的可移植性\nstd::function vs auto：性能关键用 auto，需要类型擦除用 std::function\n\n记忆口诀\n// 万能引用：T&amp;&amp;template&lt;typename T&gt; void f(T&amp;&amp; param);  // 左值右值都能绑定// 使用规则void process(Widget&amp;&amp; w) &#123;    use(std::move(w));  // 右值引用 → move&#125;template&lt;typename T&gt;void relay(T&amp;&amp; param) &#123;    other(std::forward&lt;T&gt;(param));  // 万能引用 → forward&#125;\n最佳实践\n// ✓ 推荐for (const auto&amp; item : container) &#123; &#125;      // 避免拷贝auto lambda = [](int x) &#123; return x * 2; &#125;;  // 性能最优decltype(auto) f() &#123; return expr; &#125;         // 完美转发返回值// ✗ 避免for (const Type&amp; item : container) &#123; &#125;      // 可能类型不匹配std::function&lt;int(int)&gt; f = [...];          // 非必要的开销auto x = &#123;1, 2, 3&#125;;                         // 意外的 initializer_list\n\n参考资源\n\n《Effective Modern C++》- Scott Meyers\nC++ Reference\nCppCon Talks\n\n","categories":["知识分享"],"tags":["C++","现代C++","性能优化","类型推导","移动语义","完美转发"]}]