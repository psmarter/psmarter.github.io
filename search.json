[{"title":"LeetCode热题100(25.09.29)","url":"/posts/8c812416/","content":"一：两数之和\n\n1. 暴力\n不写\n2. 哈希表\n哈希表通过用空间换时间，使用哈希函数将任意长度的键转换为一个固定范围的数组下标，时间复杂度为O(1)O(1)O(1)\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; hashMap;        for(int i = 0; i &lt; nums.size(); ++i)        &#123;            auto it = hashMap.find(target - nums[i]);       // 返回迭代器            if(it != hashMap.end())             // 和尾后迭代器比对            &#123;                return &#123;it-&gt;second, i&#125;;         // 找到就返回下标            &#125;            hashMap[nums[i]] = i;               // 没找到就把数据添加进hash表        &#125;        return &#123;&#125;;    &#125;&#125;;\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashMap = dict()        for i, num in enumerate(nums):          # 遍历            if target - nums[i] in hashMap:     # 是否存在，可把nums[i]改为num                return [hashMap[target - num], i]            hashMap[nums[i]] = i        return []        \nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;();         // 初始化一个哈希表        for( int i = 0; i &lt; nums.length; ++i)        &#123;            if(hashMap.containsKey(target - nums[i]))           // 这里的K大写            &#123;                return new int[]&#123;hashMap.get(target - nums[i]), i&#125;;            &#125;            hashMap.put(nums[i], i);        &#125;        return new int[0];              // 返回为空    &#125;&#125;\n\n二：移动零\n\n1. 双指针\n题目要求不能复制，同时保证原有序列的顺序不变，因此只能交换非零值和零值的位置。\n\n思路一：处理零值，将零和右边非零值进行交换\n思路二：处理非零值，将非零值和左边零值进行交换\n\n方式一需要不断寻找非零值，性能稍差，因此采用方式二\nclass Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int Left = 0, Right = 0;                // Left的左边均为非零值，其指向第一个零值。Right的右边为未处理的序列，当前指向用于判断零值和非零值        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            if (nums[i])            &#123;                swap(nums[Left], nums[Right]);              // 交换位置                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;;\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        Left = Right = 0        for num in nums:            if num:                nums[Left], nums[Right] = nums[Right], nums[Left]                Left += 1            Right += 1\nclass Solution &#123;    public void moveZeroes(int[] nums) &#123;        int Left = 0;        int Right = 0;        int temp;        for (int i = 0; i &lt; nums.length; ++i)        &#123;            if (nums[i] != 0)            &#123;                temp = nums[Left];                nums[Left] = nums[Right];                nums[Right] = temp;                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;\n\n三：相交链表\n1. Hash表\n将其中一个链表的数据放入哈希表，第二个链表依次判断是否包含即可\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode *&gt; hashTalble;        while (headA)        &#123;            hashTalble.insert(headA);            headA = headA-&gt;next;        &#125;        while (headB)        &#123;            if (hashTalble.count(headB))            &#123;                return headB;            &#125;            headB = headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        hashTable = set()        while headA:            hashTable.add(headA)            headA = headA.next              # 使用.运算符不是-&gt;，非指针                while headB:            if headB in hashTable:                return headB            headB = headB.next        return None             # 空为None        \npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (headA != null)               // 不能直接判断headA        &#123;            hashTable.add(headA);            headA = headA.next;             // 使用.        &#125;        while (headB != null)        &#123;            if (hashTable.contains(headB))            &#123;                return headB;            &#125;            headB = headB.next;        &#125;        return null;            // 使用null    &#125;&#125;\n\n2. 双指针\n使用两个指针指向两个链表的头结点，判断两个指针是否相等，走到末尾如果两者不相同则将指针赋值为另一个链表的头结点继续遍历，如果有相交结点，在不超过第二次遍历一定会在相交结点使两个指针相等\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *pA = headA;        ListNode *pB = headB;        if (!pA || !pB)        &#123;            return nullptr;        &#125;        while (pA != pB)        &#123;            if (pA == nullptr) pA = headB;          // 可用三元运算符替代            else pA = pA-&gt;next;            if (pB == nullptr) pB = headA;            else pB = pB-&gt;next;        &#125;        return pA;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        pA = headA        pB = headB        while pA != pB:             # 也可以用is not            if not pA:              # 或if pA is None:                pA = headB            else:                pA = pA.next            if not pB:                pB = headA            else:                pB = pB.next        return pA\npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if (headA == null || headB == null)            return null;        ListNode pA = headA, pB = headB;        while (pA != pB)        &#123;            pA = (pA == null) ? headB : pA.next;            pB = pB == null ? headA : pB.next;        &#125;        return pA;    &#125;&#125;\n\n四：反转链表\n\n\n1. 迭代反转\n根据头结点可获取到下一个结点，头结点的先前结点为空，可依次遍历将当前结点的指向进行反转，题目要求输出的结果也是反转的，因此需要返回最后一个结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre\n\n2. 递归反转\n依次传入下一个结点，并返回最后一个结点，与上一个解法的区别在于由后向前反转，此时不需要前继结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (!head || !head-&gt;next)            // 链表为空或只有单结点        &#123;            return head;        &#125;        ListNode *Last = reverseList(head-&gt;next);           // 最后一个结点在这里        head-&gt;next-&gt;next = head;        // 这里不能用Last，因为Last不动，而head一直向前        head-&gt;next = nullptr;\t\t\t// 必须设为空，否则第一个结点和第二个结点将互指        return Last;            // 一直返回最后一个结点    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null)        &#123;            return head;        &#125;        ListNode Last = reverseList(head.next);        head.next.next = head;        head.next = null;        return Last;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head or not head.next:            return head        Last = self.reverseList(head.next)\t\t\t// 这里要用self        head.next.next = head        head.next = None        return Last\n\n五：回文链表\n\n1. 数组\n将链表中的数据复制到数组中，然后将数组反转或遍历第一个和最后一个数据进行比较\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        while (head)        &#123;            vals.emplace_back(head-&gt;val);            head = head-&gt;next;        &#125;        for (int i = 0, j = static_cast&lt;int&gt;(vals.size() - 1); i &lt; j; ++i, --j)        &#123;            if (vals[i] != vals[j]) return false;        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();        while (head != null)        &#123;            vals.add(head.val);            head = head.next;        &#125;        for (int i = 0, j = vals.size() - 1; i &lt; j; ++i, --j)        &#123;            if (vals.get(i) != vals.get(j)) return false;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        vals = []        while head:            vals.append(head.val)            head = head.next        return vals == vals[::-1]\t\t\t# 可直接利用反转列表来比对\n\n2. 递归\n递归可以从后往前遍历，但是也需要从前往后的一个结点来进行对比\nclass Solution &#123;private:    ListNode *frontIteration = nullptr;\t\t\t// 从前往后public:    bool isPalindrome(ListNode* head) &#123;        frontIteration = head;        return recursion(frontIteration);    &#125;    bool recursion(ListNode* head)    &#123;        if (head)        &#123;            if (!recursion(head-&gt;next))\t\t// false继续返回false                &#123;                    return false;                &#125;            if (head-&gt;val != frontIteration-&gt;val) return false;\t\t// true则进行比对            frontIteration = frontIteration-&gt;next;\t\t\t// 每一层向后遍历        &#125;        return true;\t\t// 末尾返回true    &#125;&#125;;\nclass Solution &#123;    private ListNode frontIteration = null;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        frontIteration = head;        return recursion(head);    &#125;    public boolean recursion(ListNode head)    &#123;        if (head != null)        &#123;            if (!recursion(head.next))            &#123;                return false;            &#125;            if (head.val != frontIteration.val) return false;            frontIteration = frontIteration.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        self.frontIteration = head              # 成员变量的初始化，如果不在这里需要在__init__中        return self._recursion(head)    def _recursion(self, head: Optional[ListNode]) -&gt; bool:         # _表明内部使用，Optional表示可能的类型，-&gt; bool返回类型        if head:            if not self._recursion(head.next):                return False            if head.val != self.frontIteration.val:                return False            self.frontIteration = self.frontIteration.next        return True\n\n3.快慢指针\n该方法主要是寻找到链表的中间结点，然后将前半部分或者后半部分反转，对两部分进行比较，由于中间需要修改链表，并发处理下需要锁定其他线程或进程对链表的访问。快慢的意思则是通过两个指针，一个步长为2，另一个为1，当快指针到达尾节点时，慢指针到达中间结点，从而减少重复遍历的时间。反转可以使用之前的代码\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if (!head) return true;        ListNode *lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != nullptr)        &#123;            if (head-&gt;val != lastNode-&gt;val) return false;            head = head-&gt;next;            lastNode = lastNode-&gt;next;        &#125;        return true;    &#125;    // 寻找中间节点，    ListNode* interMediateNode(ListNode* head)    &#123;        ListNode *fastNode = head;        ListNode *slowNode = head;        while (fastNode != nullptr &amp;&amp; fastNode-&gt;next-&gt;next != nullptr)        &#123;            fastNode = fastNode-&gt;next-&gt;next;            slowNode = slowNode-&gt;next;        &#125;        return slowNode;    &#125;    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        if (head == null) return true;        ListNode lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != null)        &#123;            if (head.val != lastNode.val) return false;            head = head.next;            lastNode = lastNode.next;        &#125;        return true;    &#125;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;    public ListNode interMediateNode(ListNode head)    &#123;        ListNode fastNode = head;        ListNode slowNode = head;        while (fastNode != null &amp;&amp; fastNode.next.next != null)        &#123;            fastNode = fastNode.next.next;            slowNode = slowNode.next;        &#125;        return slowNode;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        if (not head):            return True        lastNode = self.reverseList(self.interMediateNode(head))        while (head != lastNode and head):            if head.val != lastNode.val:                return False            head = head.next            lastNode = lastNode.next        return True    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre        def interMediateNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fastNode = head        slowNode = head        while fastNode and fastNode.next.next:            fastNode = fastNode.next.next            slowNode = slowNode.next        return slowNode\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.09.30)","url":"/posts/5c81f568/","content":"一：环形链表\n\n1. 哈希表\n遍历节点并将节点存入哈希表，判断表中是否存在之前的节点即可\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return true;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return false;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return true;\t\t\t// 或if (!hashTable.add(head)) return true;            hashTable.add(head);            head = head.next;        &#125;        return false;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        hashTable = set()        while head:            if head in hashTable:                return True            hashTable.add(head)            head = head.next        return False\n\n2. 快慢指针\n通过两个不同的指针来表示行进速度，差值为1，从初始到最后相遇相当于快指针多走了一个环\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return false;        ListNode* fastNode = head-&gt;next;        // 相差一个起始位置，从而进入循环        ListNode* slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return false;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;        &#125;        return true;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        ListNode fastNode = head.next;        // 相差一个起始位置，从而进入循环        ListNode slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == null || fastNode.next == null) return false;            slowNode = slowNode.next;            fastNode = fastNode.next.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        if head is None or head.next is None:            return False        fastNode = head.next;        # 相差一个起始位置，从而进入循环        slowNode = head        while slowNode != fastNode:            if fastNode is None or fastNode.next is None:                return false            slowNode = slowNode.next            fastNode = fastNode.next.next        return True\n\n二：合并两个有序链表\n\n1. 迭代\n依次比较两个链表中的值，较小值放在较大值的前面\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 递归\n根据最小值按照相反方向逐一返回\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (!list1) return list2;        if (!list2) return list1;        if (list1-&gt;val &lt; list2-&gt;val)        &#123;            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);            return list1;        &#125; else        &#123;            list2-&gt;next = mergeTwoLists(list2-&gt;next, list1);            return list2;        &#125;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        if (list1 == null) return list2;        if (list2 == null) return list1;        if (list1.val &lt; list2.val)        &#123;            list1.next = mergeTwoLists(list1.next, list2);            return list1;        &#125; else        &#123;            list2.next = mergeTwoLists(list2.next, list1);            return list2;        &#125;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if list1 == None:            return list2        if list2 == None:            return list1        if list1.val &lt; list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list2.next, list1)            return list2\n\n三：二叉树的中序遍历\n\n1. 递归\n先逐层访问左节点，然后保存当前值，再访问右节点\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        recursion(root);        return nodes;    &#125;    void recursion(TreeNode* root)    &#123;        if (!root) return;        recursion(root-&gt;left);        nodes.emplace_back(root-&gt;val);        recursion(root-&gt;right);    &#125;&#125;;\nclass Solution &#123;    private List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();\t\t// 需要new    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        recursion(root);        return nodes;    &#125;    public void recursion(TreeNode root)    &#123;        if (root == null) return;        recursion(root.left);        nodes.add(root.val);        recursion(root.right);    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        self.nodes = []        self._recursion(root)        return self.nodes    def _recursion(self, root: Optional[TreeNode]):        if not root:            return        self._recursion(root.left)        self.nodes.append(root.val)\t\t\t\t# 这里使用append        self._recursion(root.right)\n\n2. 迭代\n这里需要一个栈来维护树的层次\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            nodes.emplace_back(root-&gt;val);            treeStack.pop();                    // 拿到数据出栈            root = root-&gt;right;       &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            nodes.add(root.val);            root = root.right;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            nodes.append(root.val)            root = root.right        return nodes\n\n3. Morris 中序遍历\n查找第一个左节点，然后遍历该结点的右节点，将最后一个右节点指向根节点，依次循环，访问时向右遍历即可\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        TreeNode* cur = nullptr;        while (root)        &#123;            if (root-&gt;left)            &#123;                cur = root-&gt;left;                while (cur-&gt;right != nullptr &amp;&amp; cur-&gt;right != root )                &#123;                    cur = cur-&gt;right;                &#125;                if (cur-&gt;right == nullptr)                &#123;                    cur-&gt;right = root;                    root = root-&gt;left;                &#125; else                &#123;                    nodes.emplace_back(root-&gt;val);                    cur-&gt;right = nullptr;           // 要赋空，否则死循环                    root = root-&gt;right;                &#125;            &#125; else             &#123;                nodes.emplace_back(root-&gt;val);                root = root-&gt;right;            &#125;        &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        TreeNode cur = null;        while (root != null)        &#123;            if (root.left != null)            &#123;                cur = root.left;                while (cur.right != null &amp;&amp; cur.right != root)     // cur.right != root必须有                &#123;                    cur = cur.right;                &#125;                if (cur.right == null)                &#123;                    cur.right = root;                    root = root.left;                &#125; else                &#123;                    nodes.add(root.val);                    cur.right = null;           // 要赋空，否则死循环                    root = root.right;                &#125;            &#125; else             &#123;                nodes.add(root.val);                root = root.right;            &#125;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        cur = None        while root is not None:            if root.left is not None:                cur = root.left                while cur.right is not None and cur.right is not root:     # cur.right is not root必须有                    cur = cur.right                if cur.right == None:                    cur.right = root                    root = root.left                else:                    nodes.append(root.val)                    cur.right = None           # 要赋空，否则死循环                    root = root.right            else:                nodes.append(root.val)                root = root.right          return nodes\n\n四：二叉树的最大深度\n\n1. 深度优先搜索\n利用递归依次遍历左右节点，取其中的较大值\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; // 使用Math.max    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\t\t# 加self\n\n2. 广度优先搜索\n用队列维护\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(root);        int depth = 0;        while (!treeQueue.empty())        &#123;            int size = treeQueue.size();            while (size &gt; 00)            &#123;                TreeNode* root = treeQueue.front();                treeQueue.pop();                if (root-&gt;left) treeQueue.push(root-&gt;left);                if (root-&gt;right) treeQueue.push(root-&gt;right);                --size;            &#125;            ++depth;        &#125;        return depth    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;();        treeQueue.offer(root);      // 使用offer        int depth = 0;        while (treeQueue.isEmpty() == false)        &#123;            int size = treeQueue.size();            while (size &gt; 0)            &#123;                TreeNode newroot = treeQueue.poll();       // 使用poll                if (newroot.left != null) treeQueue.offer(newroot.left);                if (newroot.right != null) treeQueue.offer(newroot.right);                --size;            &#125;            ++depth;        &#125;        return depth;    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        treeQueue = deque([root])         # 使用deque            depth = 0        while treeQueue:            size = len(treeQueue)            while size &gt; 0:                newroot = treeQueue.popleft()       # 使用popleft                if newroot.left:                    treeQueue.append(newroot.left)      # 使用append                if newroot.right:                    treeQueue.append(newroot.right)                size -= 1            depth += 1        return depth\n\n五：翻转二叉树\n\n1. 递归\n左右节点依次递归，找到叶子节点，然后交换左右位置\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        TreeNode* temp = root-&gt;left;        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = invertTree(temp);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        TreeNode temp = root.left;        root.left = invertTree(root.right);        root.right = invertTree(temp);        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        temp = root.left\t\t# 或平行赋值        root.left = self.invertTree(root.right)        root.right = self.invertTree(temp)        return root\n\n2. 迭代\n用队列维护\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        stack&lt;TreeNode*&gt; treeStack;        TreeNode* cur = nullptr;        TreeNode* temp = nullptr;        treeStack.push(root);        while (!treeStack.empty())        &#123;            cur = treeStack.top();            treeStack.pop();            if (cur-&gt;left != nullptr) treeStack.push(cur-&gt;left);            if (cur-&gt;right != nullptr) treeStack.push(cur-&gt;right);            temp = cur-&gt;left;            cur-&gt;left = cur-&gt;right;            cur-&gt;right = temp;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        Stack&lt;TreeNode&gt; treeStack = new Stack&lt;&gt;();        treeStack.add(root);        TreeNode cur = null;        TreeNode temp = null;        while (!treeStack.isEmpty())        &#123;            cur = treeStack.pop();            if (cur.left != null) treeStack.add(cur.left);            if (cur.right != null) treeStack.add(cur.right);            temp = cur.left;            cur.left = cur.right;            cur.right = temp;        &#125;        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        treeStack = []        treeStack.append(root)        while treeStack:            cur = treeStack.pop()            if cur.left != None: treeStack.append(cur.left)            if cur.right != None: treeStack.append(cur.right)            cur.left, cur.right = cur.right, cur.left        return root\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.11)","url":"/posts/8052a193/","content":"一：电话号码的字母组合\n\n1. 回溯\n这道题的思路和子集很相似，不过需要使用哈希表处理映射关系\nclass Solution &#123;public:    vector&lt;string&gt; ans;    string sub;    unordered_map&lt;char, string&gt; map&#123;            &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;,            &#123;&#x27;3&#x27;, &quot;def&quot;&#125;,            &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;,            &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;,            &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,            &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;,            &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;,            &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;        &#125;;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if (digits.empty()) return ans;        recursion(digits, 0);        return ans;    &#125;    void recursion(string&amp; digits, int cur)    &#123;        if (cur == digits.size())        &#123;            ans.emplace_back(sub);            return;        &#125;        char ch = digits[cur];        auto&amp; subLetter = map.at(ch);        for (auto&amp; ch : subLetter)        &#123;            sub.push_back(ch);            recursion(digits, cur + 1);            sub.pop_back();        &#125;    &#125;&#125;;\n\n二：组合总和\n\n1. 搜索回溯\n这道题的思路也和子集很相似，区别在于子集只有选和不选，必须进入下一层，而当前题目可以包含重复值，可以一直选择一个元素\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; temp;        recursion(candidates, target - 0, ans, temp, 0);        return ans;    &#125;    void recursion(vector&lt;int&gt;&amp; candidates, int&amp;&amp; target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; temp, int cur)    &#123;        if (cur == candidates.size()) return;        if (target == 0)        &#123;            ans.emplace_back(temp);            return;        &#125;        recursion(candidates, target - 0, ans, temp, cur + 1);      // 跳过        if (target - candidates[cur] &gt;= 0)        &#123;            temp.emplace_back(candidates[cur]);     // 选择            recursion(candidates, target - candidates[cur], ans, temp, cur);      // 下一层            temp.pop_back();        &#125;    &#125;&#125;;\n\n三：括号生成\n\n1. 暴力\n使用暴力将所有组合生成并检测是否是有效字符串\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            if (isValid(cur)) ans.emplace_back(cur);            return;        &#125;        cur.push_back(&#x27;(&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();        cur.push_back(&#x27;)&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();    &#125;    bool isValid(string&amp; str)    &#123;        int index = 0;        for (auto&amp; ch : str)        &#123;            if (ch == &#x27;(&#x27;) ++index;     // 左括号加一，右括号减一            else --index;            if (index &lt; 0) return false;        // 说明前面的字符串右括号多于左括号，肯定不是有效字符串        &#125;        return index == 0;    &#125;&#125;;\n\n2. 回溯\n暴力充斥了很多无效的字符串直到最后才做判断，可以在递归过程中就对字符串进行检查\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2, 0, 0);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n, int left, int right)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            ans.emplace_back(cur);            return;        &#125;        if (left &lt; n / 2)        &#123;            cur.push_back(&#x27;(&#x27;);            gengerateAll(ans, cur, n, left + 1, right);            cur.pop_back();        &#125;        if (right &lt; left)        &#123;               cur.push_back(&#x27;)&#x27;);            gengerateAll(ans, cur, n, left, right + 1);            cur.pop_back();        &#125;    &#125;&#125;;\n\n3. 按括号序列的长度递归\n每个有效字符串必是’(‘开头，某个’)'结尾，其组成为“(A)B”，A的可能性为i对，则B为n-i-1对\nclass Solution &#123;public:    shared_ptr&lt;vector&lt;string&gt;&gt; cache[10] = &#123;nullptr&#125;;    vector&lt;string&gt; generateParenthesis(int n) &#123;        return *generate(n);    &#125;    shared_ptr&lt;vector&lt;string&gt;&gt; generate(int n) &#123;        if (cache[n] != nullptr)            return cache[n];        if (n == 0) &#123;            cache[0] = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;&#123;&quot;&quot;&#125;);        &#125; else &#123;            auto result = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;);            for (int i = 0; i != n; ++i) &#123;                auto lefts = generate(i);                auto rights = generate(n - i - 1);                for (const string&amp; left : *lefts)                    for (const string&amp; right : *rights)                        result -&gt; push_back(&quot;(&quot; + left + &quot;)&quot; + right);            &#125;            cache[n] = result;        &#125;        return cache[n];    &#125;&#125;;\n\n四：单词搜索\n\n1. 回溯\n使用dfs来逐个访问节点，已访问的需要标记，并在访问后恢复，因为后续还会访问\nclass Solution &#123;public:    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;        int row = board.size();        int col = board[0].size();        vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col));        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (recursion(board, visited, i, j, word, 0)) return true;        return false;    &#125;    bool recursion(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; word, int cur)    &#123;        if (board[i][j] != word[cur]) return false;        else if (cur == word.size() - 1) return true;\t\t// 应当减少size的调用        visited[i][j] = 1;\t\t // 原地标记更快，不需要额外内存        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\t\t// 这里可使用static提高运行速度        for (auto&amp; dir : directions)        &#123;            int newi = i + dir.first;            int newj = j + dir.second;            if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size())                if (!visited[newi][newj])                    if (recursion(board, visited, newi, newj, word, cur + 1)) return true;        &#125;        visited[i][j] = 0;        return false;    &#125;&#125;;\n\n五：分割回文串\n\n1. 回溯+动态规划\n本题的难点在于状态转移方程\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len, true));        for (int i = len - 1; i &gt;= 0; --i)            for (int j = i + 1; j &lt; len; ++j)                flag[i][j] = (s[i] == s[j]) &amp;&amp; flag[i + 1][j - 1];        // i需要减，j需要加，形成上三角矩阵，这是本题的关键        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (flag[i][j])            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;&#125;;\n\n2. 回溯+记忆化搜索\n这里不使用数组来表示子字符串的状态，而是在递归时不断更新\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len));        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (IsPalindrome(s, i, j) == 1)            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;    int IsPalindrome(string&amp; s, int i, int j)      // 0 、1、-1    &#123;        if (flag[i][j]) return flag[i][j];        if (i &gt;= j) return flag[i][j] = 1;        return flag[i][j] = (s[i] == s[j] ? IsPalindrome(s, i + 1, j - 1) : -1);    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.1)","url":"/posts/2bc0b0cc/","content":"一：对称二叉树\n1. 递归\n每次访问左右两个节点，不相同则为false\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return recursion(root-&gt;left, root-&gt;right);    &#125;    bool recursion(TreeNode* left, TreeNode* right)    &#123;        if (left == nullptr &amp;&amp; right == nullptr) return true;       // 都为空        if (left == nullptr || right == nullptr) return false;      // 其中一个为空        return left-&gt;val == right-&gt;val &amp;&amp; recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left);   // 左节点的左节点与右节点的右节点，左节点的右节点与右节点的左节点    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return recursion(root.left, root.right);    &#125;    public boolean recursion(TreeNode left, TreeNode right)    &#123;        if (left == null &amp;&amp; right == null) return true;              if (left == null || right == null) return false;             return left.val == right.val &amp;&amp; recursion(left.left, right.right) &amp;&amp; recursion(left.right, right.left);       &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._recursion(root.left, root.right)    def _recursion(self, left: Optional[TreeNode], right: Optional[TreeNode]) -&gt; bool:        if left == None and right == None: return True              if (left == None or right == None): return False             return left.val == right.val and self._recursion(left.left, right.right) and self._recursion(left.right, right.left)  \n\n2. 迭代\n使用队列管理左右节点\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return iteration(root, root);    &#125;    bool iteration(TreeNode* left, TreeNode* right)    &#123;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(left);        treeQueue.push(right);        while (!treeQueue.empty())        &#123;            left = treeQueue.front();       // 先进先出            treeQueue.pop();            right = treeQueue.front();            treeQueue.pop();            if (left == nullptr &amp;&amp; right == nullptr) continue;            if (left == nullptr || right == nullptr || left-&gt;val != right-&gt;val) return false;            treeQueue.push(left-&gt;left);            treeQueue.push(right-&gt;right);            treeQueue.push(left-&gt;right);            treeQueue.push(right-&gt;left);        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return iteration(root, root);    &#125;    public boolean iteration(TreeNode left, TreeNode right)    &#123;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        treeQueue.offer(left);        treeQueue.offer(right);        while (!treeQueue.isEmpty())        &#123;            left = treeQueue.poll();       // 先进先出            right = treeQueue.poll();            if (left == null &amp;&amp; right == null) continue;            if (left == null || right == null || left.val != right.val) return false;            treeQueue.offer(left.left);            treeQueue.offer(right.right);            treeQueue.offer(left.right);            treeQueue.offer(right.left);        &#125;        return true;    &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._iteration(root, root)    def _iteration(self, left, right) -&gt; bool:        treeQueue = []        treeQueue.append(left)        treeQueue.append(right)        while (treeQueue):            left = treeQueue.pop()                  right = treeQueue.pop()            if (left == None and right == None): continue            if (left == None or right == None or left.val != right.val): return False            treeQueue.append(left.left)            treeQueue.append(right.right)            treeQueue.append(left.right)            treeQueue.append(right.left)        return True    \n\n二：二叉树的直径\n\n1. 深度优先\n长度为节点数减1，通过递归可获得左右子树的深度，左右子树的深度+1则为经过的节点数\nclass Solution &#123;public:    int diameterOfBinaryTree(TreeNode* root) &#123;        int nodeNum = 1;    // 初始节点为1，也可设为0表示长度        recursion(nodeNum, root);        return  nodeNum - 1;    // 返回长度    &#125;    int recursion(int&amp; nodeNum, TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftNum = recursion(nodeNum, node-&gt;left);        int rightNum = recursion(nodeNum, node-&gt;right);        nodeNum = max(nodeNum, leftNum + rightNum + 1);     // 拿到最大节点        return max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;;\nclass Solution &#123;    public int nodeNum = 0; // 初始长度为0    public int diameterOfBinaryTree(TreeNode root) &#123;        recursion(root);        return  nodeNum;    // 返回长度    &#125;    public int recursion(TreeNode node)    &#123;        if (node == null) return 0;        int leftNum = recursion(node.left);        int rightNum = recursion(node.right);        nodeNum = Math.max(nodeNum, leftNum + rightNum);     // 拿到最大长度        return Math.max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;\nclass Solution:    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:        self.nodeNum = 0        self._recursion(root)        return  self.nodeNum        def _recursion(self, node) -&gt; int:        if (node == None): return 0        leftNum = self._recursion(node.left)        rightNum = self._recursion(node.right)        self.nodeNum = max(self.nodeNum, leftNum + rightNum)             return max(leftNum, rightNum) + 1      \n\n三：将有序数组转换为二叉搜索树\n\n1. 左边中序遍历\n给定升序数组，对于二叉搜索树则是中序遍历，可将数组的中间数据或偏左作为根节点，左右两段分别为左右子树\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);\t\t// 使用length    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n2. 中间中序遍历\n这里是用中间位置或偏右作为中间结点\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + 1) / 2;       // 这里加1        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right + 1) / 2;              TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + 1) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n3. 右边中序遍历\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + rand() % 2) / 2;       // 随机，rand返回一个伪随机的整数        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        Random rand = new Random();         // 随机对象        int mid = (left + right + rand.nextInt(2)) / 2;       // 返回这个范围(2)内的随机整数        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + randint(0, 1)) // 2       # 随机整数的范围，包括起点和终点        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n四：搜索插入位置\n\n1. 二分\n根据二分查找的思想，依次比较中间点\nclass Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2; // 避免溢出的写法，也可使用java的方法            if (nums[mid] == target) &#123;                return mid;             &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;             &#125; else &#123;                right = mid - 1;             &#125;        &#125;        // 循环结束后，left 指针就是目标应该插入的位置        return left;    &#125;&#125;;\nclass Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target &lt;= nums[mid])            &#123;                cur = mid;                right = mid - 1;            &#125; else            &#123;                left = mid + 1;            &#125;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1         cur = right + 1        while (left &lt;= right):            mid = ((right - left) // 2) + left                  if (target &lt;= nums[mid]):                cur = mid                right = mid - 1            else:                left = mid + 1        return cur\n\n五：有效的括号\n\n1. 栈\n先把左括号放入栈中，遇到右括号则弹出栈顶，判断是否相同\nclass Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 != 0) return false;        unordered_map&lt;char, char&gt; unMap = &#123;            &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,            &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;,             &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;&#125;;        // 遇到右括号寻找左括号        stack&lt;char&gt; chStk;        for (auto ch : s)        &#123;            if (unMap.count(ch))            &#123;                if (chStk.empty()) return false;                char top = chStk.top();                chStk.pop();                if (unMap[ch] != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.empty();    &#125;&#125;;\nclass Solution &#123;    public boolean isValid(String s) &#123;        if (s.length() % 2 != 0) return false;        Map&lt;Character, Character&gt; unMap = new HashMap&lt;&gt;();          // 使用Character而非char        unMap.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);        unMap.put(&#x27;]&#x27;, &#x27;[&#x27;);        unMap.put(&#x27;)&#x27;, &#x27;(&#x27;);        Deque&lt;Character&gt; chStk = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; s.length(); ++i)        &#123;            char ch = s.charAt(i);            if (unMap.containsKey(ch))            &#123;                if (chStk.isEmpty()) return false;                char top = chStk.peek();                chStk.pop();                if (unMap.get(ch) != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.isEmpty();    &#125;&#125;\nclass Solution:    def isValid(self, s: str) -&gt; bool:        if (len(s) % 2 != 0): return False        unMap = &#123;            &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,            &#x27;]&#x27;: &#x27;[&#x27;,            &#x27;)&#x27;: &#x27;(&#x27;,        &#125;              chStk =[]        for ch in s:            if (ch in unMap):                if (not chStk): return False                top = chStk[-1]     # 最后一个值                chStk.pop()         # 弹出                if (unMap[ch] != top): return False            else:                chStk.append(ch)        return not chStk\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.10)","url":"/posts/994990d2/","content":"一：实现Trie（前缀树）\n\n1. 字典树\n这是一种用边表示数据的图，节点主要包含两部分，一个是子节点指针，另一部分是用数组模拟的字符数据\nclass Trie &#123;public:    vector&lt;Trie*&gt; sub;    bool endFlag;    Trie() :sub(26), endFlag(false) &#123;&#125;        void insert(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr)        // 不存在子节点，创建新的                root-&gt;sub[ch - &#x27;a&#x27;] = new Trie();            root = root-&gt;sub[ch - &#x27;a&#x27;];       // 移动到子节点        &#125;        root-&gt;endFlag = true;       // 单词结尾标识    &#125;        bool search(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return root-&gt;endFlag;    &#125;        bool startsWith(string prefix) &#123;        Trie* root = this;        for (auto&amp; ch : prefix)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return true;    &#125;&#125;;\n\n二：全排列\n\n1. 回溯\n其本质很像递归和深度优先搜索，类似于走迷宫，先选择一条路，直到达到目标或者发现无法走通进行回退，主要分为三部分：选择、探索、恢复选择\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        recursion(nums, 0, nums.size());        return result;    &#125;    void recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right)        &#123;            result.emplace_back(nums);            return;        &#125;        for (int i = left; i &lt; right; ++i)        &#123;            swap(nums[i], nums[left]);            recursion(nums, left + 1, right);            swap(nums[left], nums[i]);        &#125;    &#125;&#125;;\n\n三：子集\n\n1. 二进制迭代\n假如数组包含n个元素，子集的所有可能为2n2^n2n，因此可以使用一个数值来表示该二进制，然后求出对应的子集\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; (1 &lt;&lt; len); ++i)\t\t\t// 2^n        &#123;            vector&lt;int&gt; temp;            for (int j = 0; j &lt; len; ++j)            &#123;                if (i &amp; (1 &lt;&lt; j)) temp.emplace_back(nums[j]);\t\t\t// 判断第j位的值            &#125;            ans.emplace_back(temp);        &#125;        return ans;    &#125;&#125;;\n\n2. 递归枚举\n逐字符处理，需要考虑每个字符的两种状态\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        recursion(0, nums);        return ans;    &#125;    void recursion(int cur, vector&lt;int&gt;&amp; nums)    &#123;        if (cur == nums.size())        &#123;            ans.emplace_back(temp);            return;        &#125;        temp.emplace_back(nums[cur]);       // 添加字符，存在的情况        recursion(cur + 1, nums);       // 下一个        temp.pop_back();            // 该字符不存在的情况        recursion(cur + 1, nums);    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.12)","url":"/posts/ab7ff250/","content":"一：搜索二维矩阵\n\n1. 两次查找\n第一次在每行的第一个元素查找，然后在该行中查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        auto row = upper_bound(matrix.begin(), matrix.end(), target, [](int target, vector&lt;int&gt;&amp; row)&#123;return target &lt; row[0];&#125;);  // 需要自定义比较函数，因为一个值无法与数组比较        if (row == matrix.begin()) return false;        --row;        return binary_search(row-&gt;begin(), row-&gt;end(), target);    &#125;&#125;;\n\n2. 一次查找\n将二位矩阵展开为一维，然后把索引转换为二维去处理\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int row = matrix.size();        int col = matrix[0].size();        int left = 0, right = row * col - 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;            int cur = matrix[mid / col][mid % col];     // 对列处理            if (cur &gt; target) right = mid - 1;            else if (cur &lt; target) left = mid + 1;            else return true;        &#125;        return false;    &#125;&#125;;\n\n二：在排序数组中查找元素的第一个和最后一个位置\n\n1. 二分查找\n先查找左边界，然后寻找右边界，最后验证\nclass Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = BinarySearch(nums, target, true);        int right = BinarySearch(nums, target, false) - 1;        if (left &gt;= 0 &amp;&amp; left &lt;= right &amp;&amp; right &lt; nums.size() &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)            return vector&lt;int&gt;&#123;left, right&#125;;        return vector&lt;int&gt;&#123;-1, -1&#125;;    &#125;    int BinarySearch(vector&lt;int&gt;&amp; nums, int target, int lowFlag)    &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        int ans = nums.size();        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &gt; target || (nums[mid] &gt;= target &amp;&amp; lowFlag))            &#123;                right = mid - 1;                ans = mid;            &#125;            else                left = mid + 1;        &#125;        return ans;    &#125;&#125;;\n\n三：搜索旋转排序数组\n\n1. 二分查找\n这题比普通的二分稍微复杂一些，主要在于取中间点后，中间点可能大于也可能小于起始元素，但有一边一定是有序的\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int len = nums.size();        if (len == 0) return false;        if (len == 1) return target == nums[0] ? 0 : -1;        int left = 0, right = len - 1;        int mid = 0;        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] == target) return mid;            if (nums[0] &lt;= nums[mid])            &#123;                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid])                    right = mid - 1;                else                    left = mid + 1;            &#125; else            &#123;                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[len - 1])                    left = mid + 1;                else                       right = right -1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n四：寻找旋转排序数组中的最小值\n\n1. 二分查找\n这题和上题类似，主要利用划分后最小值可能存在的位置，左边或者右边\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        while (left &lt; right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &lt; nums[right])                right = mid;            else                left = mid + 1;        &#125;        return nums[left];    &#125;&#125;;\n\n五：最小栈\n\n1. 辅助栈\n栈的实现可以直接使用stack，但这里需要记录最小值，并且常数查找，因此使用辅助栈来记录每一个元素对应的最小值\nclass MinStack &#123;    stack&lt;int&gt; value;    stack&lt;int&gt; min;public:    MinStack() &#123;        min.push(INT_MAX);    &#125;        void push(int val) &#123;        value.push(val);        min.push(std::min(val, min.top()));    &#125;        void pop() &#123;        value.pop();        min.pop();    &#125;        int top() &#123;        return value.top();    &#125;        int getMin() &#123;        return min.top();    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.13)","url":"/posts/b264c311/","content":"一：字符串解码\n\n1. 栈操作\n将数字和左括号入栈，遇到右括号对数据进行处理\nclass Solution &#123;public:    string decodeString(string s) &#123;        vector&lt;string&gt; stk;        int cur = 0;        string digits;        while (cur &lt; s.size())        &#123;            char ch = s[cur];            if (isdigit(ch))            &#123;                digits = GetDigits(s, cur, digits);                stk.push_back(digits);            &#125; else if (isalpha(ch) || ch == &#x27;[&#x27;)                stk.push_back(string(1, s[cur++]));            else            &#123;                ++cur;      // ]直接略过                string sub;                string temp;                while (stk.back() != &quot;[&quot;)                &#123;                    sub = stk.back() + sub;                    stk.pop_back();                &#125;                //reverse(sub.begin(), sub.end());                stk.pop_back();     // 左括号略过                int count = stoi(stk.back());                stk.pop_back();                 while (count--) temp += sub;                stk.push_back(temp);            &#125;        &#125;        string result;        for (auto&amp; s : stk) result += s;        return result;    &#125;    string&amp; GetDigits(string&amp; s, int&amp; cur, string&amp; digits)    &#123;        digits.clear();        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return digits;    &#125;&#125;;\n\n2. 递归\n对数字仍做上述处理，左括号过滤，然后递归处理字符，右括号也过滤\nclass Solution &#123;public:    string s;    int cur = 0;    string decodeString(string s) &#123;        this-&gt;s = s;        return GetString();    &#125;    int GetDigits()    &#123;        string digits;        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return stoi(digits);    &#125;    string GetString()    &#123;        if (cur == s.size() || s[cur] == &#x27;]&#x27;) return &quot;&quot;;        char ch = s[cur];        string sub;        if (isdigit(ch))        &#123;            int repeatTime = GetDigits();            ++cur;            string str = GetString();            ++cur;            while (repeatTime--) sub += str;        &#125; else if(isalpha(ch))        &#123;            sub = string(1, ch);            ++cur;        &#125;        return sub + GetString();    &#125;&#125;;\n\n二：每日温度\n\n1. 暴力\n该题通过使用一个温度数组来记录当前温度的索引，其中温度为下标，值为数组中的索引，通过向前遍历来记录温度的情况\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        vector&lt;int&gt; record(101, INT_MAX);        for (int i = len - 1; i &gt;= 0; --i)        &#123;            int index = INT_MAX;            for (int j = temperatures[i] + 1; j &lt;= 100; ++j)                index = min(index, record[j]);            if (index != INT_MAX)                result[i] = (index - i);            record[temperatures[i]] = i;        &#125;        return result;    &#125;&#125;;\n\n2. 单调栈\n使用一个栈来维护温度，使温度递减，如果温度大于栈顶，则把栈顶弹出，并更新天数，因为此时为栈顶索引遇到的第一个升温天气\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        stack&lt;int&gt; stk;        int temp;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()])            &#123;                temp = stk.top();                stk.pop();                result[temp] = i - temp;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n三：数组中的第K个最大元素\n\n1. 基于快速排序的选择方法\n寻找第K大的元素意味着寻找第n - k小的元素，利用快速排序分治的思想不断递归，可以找到元素所在的位置\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        return QuickChoose(nums, len - k, 0, len - 1);    &#125;    int QuickChoose(vector&lt;int&gt;&amp; nums, int index, int left, int right)    &#123;        if (left == right) return nums[left];        int i = left - 1;        int j = right + 1;        int numFlag = nums[left];        while (i &lt; j)        &#123;            do ++i; while (nums[i] &lt; numFlag);            do --j; while (nums[j] &gt; numFlag);            if (i &lt; j) swap(nums[i], nums[j]);        &#125;        if ( index &lt;= j) return QuickChoose(nums, index, left, j);        else return QuickChoose(nums, index, j + 1, right);    &#125;&#125;;\n\n2. 基于堆排序的选择方法\n选择当前数组作为最大堆，然后将其从第一个非叶子节点重新构建，之后逐个删除顶端元素\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size(), size = len;        BuildHeap(nums, len);        for (int i = len - 1; i &gt; len - k; --i)        &#123;            swap(nums[0], nums[i]);            --size;            Heapify(nums, size, 0);        &#125;        return nums[0];    &#125;    void BuildHeap(vector&lt;int&gt;&amp; nums, int size)    &#123;        for (int i = size / 2 - 1; i &gt;= 0; --i)            Heapify(nums, size, i);    &#125;    void Heapify(vector&lt;int&gt;&amp; nums, int size, int cur)    &#123;        int leftNode = cur * 2 + 1;        int rightNode = cur * 2 + 2;        int largest = cur;        if (leftNode &lt; size &amp;&amp; nums[leftNode] &gt; nums[largest]) largest = leftNode;         if (rightNode &lt; size &amp;&amp; nums[rightNode] &gt; nums[largest]) largest = rightNode;         if (cur != largest)        &#123;            swap(nums[largest], nums[cur]);            Heapify(nums, size, largest);        &#125;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.14)","url":"/posts/fd2555d6/","content":"一：前K个高频元素\n\n1. 堆\n可以使用哈希表将元素出现的次数记录下来，然后对出现次数排序，复杂度为O(nlog⁡(n))O(n\\log(n))O(nlog(n))。但题目要求优于O(nlog⁡(n))O(n\\log(n))O(nlog(n))，需要使用其他方案。这里的时间主要花在了排序上，可以使用堆或快排来对元素进行不完全排序，从而降低时间复杂度。该方法使用最小堆将出现次数小的元素放在栈顶\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        auto commpare = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;return a.second &gt; b.second;&#125;;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(commpare)&gt; pq(commpare);        for (auto&amp; [num, count] : occour)        &#123;            if (pq.size() &lt; k) pq.emplace(num, count);            else if (pq.top().second &lt; count)             &#123;                pq.pop();                pq.emplace(num, count);            &#125;        &#125;        while (!pq.empty())        &#123;            result.emplace_back(pq.top().first);            pq.pop();        &#125;        return result;    &#125;&#125;;\n\n2. 基于快速排序\n其核心思想在于快排的一次循环过后能够将数据按照选定的某个值分为≥和≤两部分，通过比较左右长度便可判断前k最大值所在位置\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; value : occour) values.emplace_back(value);        QuickChoose(values, k, 0, values.size() - 1, result);        return result;    &#125;    void QuickChoose(vector&lt;pair&lt;int, int&gt;&gt;&amp; values, int k, int left, int right, vector&lt;int&gt;&amp; result)    &#123;        if (left &gt; right) return;        if (left == right) &#123;                 // 基本情形            result.push_back(values[left].first);            return;        &#125;        int picked = rand() % (right - left + 1) + left;        swap(values[picked], values[left]);        int pivot = values[left].second;        int i = left - 1;        int j = right + 1;        while (i &lt; j)        &#123;            do ++i; while (values[i].second &gt; pivot);            do --j; while (values[j].second &lt; pivot);            if (i &lt; j) swap(values[i], values[j]);        &#125;        int leftCount = j - left + 1;          if (k &lt;= leftCount) QuickChoose(values, k, left, j, result);        else         &#123;            for (int i = left; i &lt;= j; ++i)                result.emplace_back(values[i].first);            QuickChoose(values, k - leftCount, j + 1, right, result);        &#125;    &#125;&#125;;\n\n二：跳跃游戏\n\n1. 贪心\n假设当前位于x，那么x+nums[x]范围内的元素都是可达的，因此我们只需要维护一个最大的可达范围即可，如果该范围能够覆盖终点，则意味着终点可达\nclass Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int maxSkip = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if ( i &lt;= maxSkip) maxSkip = max(maxSkip, i + nums[i]);            if (maxSkip &gt;= len - 1) return true;        &#125;        return false;    &#125;&#125;;\n\n三：跳跃游戏Ⅱ\n\n1. 反向查找出发位置\n我们从最后一个点出发，先找出最后一步到达终点的前面所有点，取最远位置，然后循环直到出发点即可。为什么可行？我们假设终点为n - 1，其最远距离为x，那么x~n - 1区间内的所有位置都是可达的，假设区间中存在一个点的第二步的上一个位置为y，那么y~该点的距离一定包含x，所以x的第二步一定大于等于y，所以求解出来的步数最优\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int cur = len;        int step = 0;        while (cur &gt; 0)        &#123;            for (int i = 0; i &lt;= cur; ++i)            &#123;                if (i + nums[i] &gt;= cur)                &#123;                    cur = i;                    ++step;                    break;                &#125;            &#125;        &#125;        return step;    &#125;&#125;;\n\n2. 正向查找可到达的最大位置\n这里假设第一步的距离为x，由题意知一定会到达终点，那么第二步应该选择0~x之间能够跳出最远的位置，理论和上一个方法相同，最远位置一定包含其中的点，步骤只会小于等于其他元素\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int step = 0, maxStep = 0, end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt;= maxStep)                maxStep = max(maxStep, i + nums[i]);            if (i == end)            &#123;                end = maxStep;                ++step;            &#125;        &#125;        return step;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.15)","url":"/posts/e43e6497/","content":"一：划分字母区间\n\n1. 贪心\n该题的思路为通过遍历字符串，得到每一个字符最后出现的位置，然后维护一个起始指针，再次遍历字符串更新结束位置，如果达到end则意味着这个子字符串可划分\nclass Solution &#123;public:    vector&lt;int&gt; partitionLabels(string s) &#123;        int array[26];        int len = s.size();        vector&lt;int&gt; result;        for (int i = 0; i &lt; len; ++i)            array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)] = i;        int start = 0, end = 0;        int size = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            size = max(size, array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)]);            end = size;            if (i == end)            &#123;                result.emplace_back(end - start + 1);                start = end + 1;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：颜色分类\n\n1. 单指针\n使用该方式需要两次遍历，一次用于交换0，一次用于交换1，交换其他数据也可以\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;    &#125;&#125;;\n\n2. 双指针\n使用双指针可以同时交换两个数据，比如同时交换0和1，但需要注意交换顺序和对后续交换的影响\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur1 = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur1]);                ++cur1;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                if (cur0 &lt; cur1)                     swap(nums[i], nums[cur1]);                ++cur0;                ++cur1;            &#125;        &#125;    &#125;&#125;;\n\n3. 双指针\n这里我们使用两端用于交换，但是交换之后的数据可能仍然需要交换，因此需要额外处理，知道它不需要交换\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur2 = len - 1;        for (int i = 0; i &lt;= cur2; ++i)        &#123;            while (i &lt;= cur2 &amp;&amp; nums[i] == 2)            &#123;                swap(nums[i], nums[cur2]);                --cur2;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                ++cur0;            &#125;        &#125;    &#125;&#125;;\n\n4. 直接遍历\n该题最简单的方式是将数组遍历得到每个元素的数量然后修改原来的数组即可\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int red = 0, white = 0, blue = 0;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0) ++red;            if (nums[i] == 1) ++white;            if (nums[i] == 2) ++blue;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt; red) nums[i] = 0;            if (i &gt;= red&amp;&amp; i &lt; red + white) nums[i] = 1;            if (i &gt;= red + white &amp;&amp; i &lt; red + white + blue) nums[i] = 2;        &#125;    &#125;&#125;;\n\n三：下一个排列\n\n1. 两遍扫描\n该题需要从后向前找到第一个升序的位置，然后将其与该位置之后的最后一个大于自己的数据进行交换，同时需要对该位置之后的数据重排为升序\n\nclass Solution &#123;public:    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int start = len - 2;        while (start &gt;= 0 &amp;&amp; nums[start] &gt;= nums[start + 1])            --start;        if (start &gt;= 0)        &#123;            int j = len - 1;            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[start])                --j;            swap(nums[start], nums[j]);        &#125;        reverse(nums.begin() + start + 1, nums.end());    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.16)","url":"/posts/cf133754/","content":"一：寻找重复数\n\n1. 二分查找\n最简单的方式应该直接对其排序，然后遍历一遍找出重复值，但是题目要求不能修改原数组且使用常量空间，因此不能应用。这里我们可以注意到值的范围，如果我们把该范围的中间值作为一个临界值，那么数组应该被分为大致相等的两部分，存在重复值的一部分会稍大\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int left = 1, right = len - 1;        int mid = 0;        int ans = -1;        while (left &lt;= right)        &#123;            int count = 0;            mid = ((right - left) &gt;&gt; 1) + left;            for (int i = 0; i &lt; len; ++i)                if (nums[i] &lt;= mid) ++count;            if (count &lt;= mid) left = mid + 1;            else             &#123;                ans = mid;                right = mid - 1;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2. 二进制\n该方法使用二进制位来记录数组中不同元素的二进制位并与值域的二进制位比较\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int ans = 0;        int bitCnt = 0;        int temp = len - 1;        while (temp &gt;&gt;= 1) ++bitCnt;        for (int i = 0; i &lt;= bitCnt; ++i)        &#123;            int x = 0, y = 0;            for (int j = 0; j &lt; len; ++j)            &#123;                if (nums[j] &amp; (1 &lt;&lt; i)) ++x;                if (j &gt; 0 &amp;&amp; (j &amp; (1 &lt;&lt; i))) ++y;            &#125;            if (x &gt; y) ans |= (1 &lt;&lt; i);        &#125;        return ans;    &#125;&#125;;\n\n3. 快慢指针\n数组的索引为0~n-1，值域为1~n-1，那么每个索引都会对应一个值域，至少存在一个值域被两个索引指向，此时构建从索引到值的环，环的入口就是重复节点\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int slow = 0, fast = 0;        do         &#123;            slow = nums[slow];            fast = nums[nums[fast]];        &#125; while (slow != fast);        slow = 0;        while (slow != fast)        &#123;            slow = nums[slow];            fast = nums[fast];        &#125;        return slow;    &#125;&#125;;\n\n二：打家劫舍\n\n1. 动态规划\n由题目可知，一间房子和两间房子的情况是确定的，也就是我们的边界条件，对于房间k，我们有偷和不偷两个选项，但要取其中的较大值\nclass Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        vector&lt;int&gt; sum(len, 0);        sum[0] = nums[0];        sum[1] = max(nums[0], nums[1]);        for (int i = 2; i &lt; len; ++i)        &#123;            sum[i] = max(sum[i - 1], nums[i] + sum[i - 2]);        &#125;        return sum.back();    &#125;&#125;;// 滚动数组优化空间class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        int pre = nums[0], next = max(nums[1], nums[0]);        int temp = 0;        for (int i = 2; i &lt; len; ++i)        &#123;            temp = next;            next = max(next, nums[i] + pre);            pre = temp;        &#125;        return next;    &#125;&#125;;\n\n三：完全平方数\n\n1. 动态规划\n该题需要寻找一个索引使得n - j * j的平方和的数量最小\nclass Solution &#123;public:    int numSquares(int n) &#123;        vector&lt;int&gt; step(n + 1);\t\t// 索引0作为辅助        for (int i = 1; i &lt;= n; ++i)        &#123;            int minStep = INT_MAX;            for (int j = 1; j * j &lt;= i; ++j)            &#123;                minStep = min(minStep, step[i - j * j]);            &#125;            step[i] = minStep + 1;         &#125;        return step[n];    &#125;&#125;;\n\n2. 数学\n四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。\n同时四平方和定理包含了一个更强的结论：当且仅当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，nnn 可以被表示为至多三个正整数的平方和。\n因此，当 n=4k×(8m+7)n = 4^k \\times (8m+7)n=4k×(8m+7) 时，(n) 只能被表示为四个正整数的平方和。此时我们可以直接返回 4。\n当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，我们需要判断到底多少个完全平方数能够表示 nnn。我们知道答案只会是 (1,2,3) 中的一个\nclass Solution &#123;public:    int numSquares(int n) &#123;        if (static_cast&lt;int&gt;(sqrt(n)) * static_cast&lt;int&gt;(sqrt(n)) == n) return 1;        if (IsFormat(n)) return 4;        for (int i = 1; i * i &lt;= n; ++i)        &#123;            int j = n - i * i;            if (static_cast&lt;int&gt;(sqrt(j)) * static_cast&lt;int&gt;(sqrt(j)) == j) return 2;        &#125;        return 3;    &#125;    bool IsFormat(int x)    &#123;        while (x % 4 == 0) x /= 4;        return x % 8 == 7;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.17)","url":"/posts/d6080615/","content":"一：零钱兑换\n\n1. 记忆化搜索\n本质上属于迭代，找出子目标数据的最小值，自顶向下\nclass Solution &#123;public:    vector&lt;int&gt; count;    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        count.resize(amount);        return recursion(coins, amount);    &#125;    int recursion(vector&lt;int&gt;&amp; coins, int amount)    &#123;        if (amount == 0) return 0;        if (amount &lt; 0) return -1;        if (count[amount - 1] != 0) return count[amount - 1];        int minNum = INT_MAX;        for (auto&amp; coin : coins)        &#123;            int temp = recursion(coins, amount - coin);            if (temp &gt;= 0 &amp;&amp; temp &lt; minNum)                minNum = temp + 1;        &#125;        count[amount - 1] = minNum == INT_MAX ? -1 : minNum;        return count[amount - 1];    &#125;&#125;;\n\n2. 动态规划\n使用动态规划的关键点在于找出状态转移方程，该题目可求出当前硬币对应的上一个目标值的最小硬币数量\nclass Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int max = amount + 1;      // 不能使用INT_MAX，见下        vector&lt;int&gt; count(amount + 1, max);     // 这里使用+1把0也算入        count[0] = 0;        for (int i = 1; i &lt;= amount; ++i)        &#123;            for (auto&amp; coin : coins)            &#123;                if (coin &lt;= i)                &#123;                    count[i] = min(count[i], count[i - coin] + 1);      // INT_MAX这里会超出范围                &#125;            &#125;        &#125;        return count[amount] = count[amount] == amount + 1 ? -1 : count[amount];    &#125;&#125;;\n\n二：单词拆分\n\n1. 动态规划\n假设当前位于x，对于0 ~ x的子串需要寻找一个位置 j，使0 ~ j位于给定数组中，然后再判断j + 1 ~ x是否位于数组中\nclass Solution &#123;public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        unordered_set&lt;string&gt; hashWord;        int len = s.size();        for (auto&amp; word : wordDict) hashWord.insert(word);        vector&lt;bool&gt; dp(len + 1);        dp[0] = true;        for (int i = 1; i &lt;= len; ++i)            for (int j = 0; j &lt; i; ++j)                if (dp[j] &amp;&amp; hashWord.find(s.substr(j, i - j)) != hashWord.end())                &#123;                    dp[i] = true;                    break;                &#125;        return dp[len];    &#125;&#125;;\n\n三：最长递增子序列\n\n1. 动态规划\n使用一个数组来记录以给定数组的每个元素结尾的子序列的长度，如果当前值大于某个最长子序列的最后一个值，则把它加入\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        vector&lt;int&gt; dp(len, 1);        for (int i = 0; i &lt; len; ++i)            for (int j = 0; j &lt; i; ++j)                if (nums[i] &gt; nums[j])                    dp[i] = max(dp[i], dp[j] + 1);        return *max_element(dp.begin(), dp.end());    &#125;&#125;;\n\n2. 贪心+二分查找\n使用一个数组来维护最长子序列的最后一个值，如果下个值大于最后一个值则加入，如果不大于则替换数组中首个大于该元素的值\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int size = 1;        vector&lt;int&gt; dp(len + 1, 0);        dp[size] = nums[0];        for (int i = 1; i &lt; len; ++i)        &#123;            if (nums[i] &gt; dp[size])                dp[++size] = nums[i];            else            &#123;                int left = 1, right = size;                int pos = 0;                while (left &lt;= right)                &#123;                    int mid = (left + right) &gt;&gt; 1;                    if (dp[mid] &lt; nums[i])                    &#123;                        pos = mid;                        left = mid + 1;                    &#125; else                        right = mid - 1;                &#125;                dp[pos + 1] = nums[i];            &#125;        &#125;        return size;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.18)","url":"/posts/51901ada/","content":"一：乘积最大子数组\n\n1. 动态规划\n该题的难点在于需要同时处理正值和负值，以x结尾的子串乘上下一个元素有可能继续增大，也有可能变得很小，但如果一个负数乘一个负数可能得出一个很大的结果，因此我们同时维护以x结尾的子串的最大值和最小值\nclass Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;long long&gt; maxM(nums.begin(), nums.end());        vector&lt;long long&gt; minM(nums.begin(), nums.end());        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxM[i] = max(maxM[i - 1] * nums[i], max(minM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM[i] = min(minM[i - 1] * nums[i], min(maxM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));        &#125;        return *max_element(maxM.begin(), maxM.end());    &#125;&#125;;// 滚动数组空间优化class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        long long maxM = nums[0];        long long maxT = nums[0];        long long minM = nums[0];        long long minT = nums[0];        long long ans = nums[0];        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxT = maxM, minT = minM;            maxM = max(maxT * nums[i], max(minT * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM = min(minT * nums[i], min(maxT * nums[i], static_cast&lt;long long&gt;(nums[i])));            ans = max(maxM, ans);        &#125;        return static_cast&lt;int&gt;(ans);    &#125;&#125;;\n\n二：分割等和子集\n\n1. 动态规划\n该题使用二维数组来存储子序列能否目标值，除了前置条件，后一个的判断需要根据先前的结果来判断\nclass Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(target + 1, 0));        for (int i = 0; i &lt; len; ++i)            dp[i][0] = true;        dp[0][nums[0]] = true;        for (int i = 1; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = 1; j &lt;= target; ++j)                if (temp &lt;= j)                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - temp];                else                    dp[i][j] = dp[i - 1][j];        &#125;        return dp[len - 1][target];    &#125;&#125;;// 空间优化class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;int&gt; dp(target + 1, 0);        dp[0] = true;        for (int i = 0; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = target; j &gt;= temp; --j)                dp[j] = dp[j] | dp[j - temp];        &#125;        return dp[target];    &#125;&#125;;\n\n三：不同路径\n\n1. 动态规划\n使用二维数组来存储每个位置的步数，当前位置的步数等于上一行和左边位置的和\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        for (int i = 0; i &lt; m; ++i) dp[i][0] = 1;        for (int i = 0; i &lt; n; ++i) dp[0][i] = 1;        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        return dp[m - 1][n - 1];    &#125;&#125;;// 空间优化class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;int&gt; dp(n);        dp[0] = 1;        for (int i = 0; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[j] = dp[j] + dp[j - 1];        return dp[n - 1];    &#125;&#125;;\n\n2. 组合数学\n对于一个m∗nm*nm∗n的二维数组，本质上有m−1m-1m−1次向下移动和n−1n-1n−1次向右移动，因此属于排列组合\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        long long result = 1;        for (int x = n, y = 1; y &lt; m; ++x, ++y)            result = result * x / y;        return static_cast&lt;int&gt;(result);    &#125;&#125;;\n\n四：最小路径和\n\n1. 动态规划\n该题与上题类似，不过每个元素的值可能不相等，但当前点只能由上和左两个位置得到，选用其中一个最小值和自身值相加即可得到当前点的最小值\nclass Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m = grid.size();        int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i - 1][0] + grid[i][0];        for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i - 1] + grid[0][i];        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = min(dp[i - 1][j] , dp[i][j - 1]) + grid[i][j];        return dp[m - 1][n - 1];    &#125;&#125;;\n\n五：最长回文子串\n\n1. 动态规划\n假设每个字符都为一个回文，对于一个从x到y的字符串，其是否为回文依赖于x+1x+1x+1和y−1y-1y−1是否为字符串，同时需要处理长度为2和为3的情况如“aa”，“bab”\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int len = s.size();        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));        if (len &lt; 2) return s;        for (int i = 0; i &lt; len; ++i) dp[i][i] = true;        int maxLen = 1;        int begin = 0;        for (int l = 2; l &lt;= len; ++l)        &#123;            for (int i = 0; i &lt; len; ++i)            &#123;                int right = l + i - 1;                if (right &gt;= len) break;                if (s[i] != s[right]) dp[i][right] = false;                else                &#123;                    if (right - i &lt; 3) dp[i][right] = true;                    else                    &#123;                        dp[i][right] = dp[i + 1][right - 1];                    &#125;                 &#125;                if (dp[i][right] &amp;&amp; right - i + 1 &gt; maxLen)                &#123;                    maxLen = right - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;\n\n2. 中心扩展算法\n我们以每个字符或者每两个字符为中心然后左右不断扩展，同时用起始位置来维护最大的长度\nclass Solution &#123;public:    int len;    string longestPalindrome(string s) &#123;        len = s.size();        int begin = 0;        int end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            auto [left1, right1] = Expand(s, i, i);            auto [left2, right2] = Expand(s, i, i + 1);            if (right1 - left1 &gt; end - begin)            &#123;                begin = left1;                end = right1;            &#125;            if (right2 - left2 &gt; end - begin)            &#123;                begin = left2;                end = right2;            &#125;        &#125;        return s.substr(begin, end - begin + 1);    &#125;    pair&lt;int, int&gt; Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return &#123;left + 1, right - 1&#125;;    &#125;&#125;;\n\n3. Manacher算法\n这个题非常巧妙，利用了回文的对称性，从而大量降低了重复的计算\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int begin = 0;        int end = -1;       // 取-1为了下面正确的判断，从而使单个字符能够满足条件        string temp = &quot;#&quot;;        for (auto&amp; ch : s)        &#123;            temp += ch;            temp += &#x27;#&#x27;;        &#125;        s = temp;        int len = s.size();        vector&lt;int&gt; arm;        int right = -1, cur = -1;        for (int i = 0; i &lt; len; ++i)        &#123;            int curArm;            if (right &gt;= i)            &#123;                int isysm = 2 * cur - i;                int minArm = min(arm[isysm], right - i);                curArm = Expand(s, i - minArm, i + minArm);             &#125; else            &#123;                curArm = Expand(s, i, i);            &#125;            arm.emplace_back(curArm);            if (i + curArm &gt; right)            &#123;                cur = i;                right = i + curArm;            &#125;            if (curArm * 2 + 1 &gt; end - begin)            &#123;                begin = i - curArm;                end = i + curArm;            &#125;        &#125;        string result;        for (int i = begin; i &lt;= end; ++i)            if (s[i] != &#x27;#&#x27;) result += s[i];        return result;    &#125;    int Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return (right - left - 2)  &gt;&gt; 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.19)","url":"/posts/488b2b9b/","content":"一：最长公共子序列\n\n1. 动态规划\n使用一个二维数组来记录以x和y长度的两个字符串的最大子串\nclass Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        int m = text1.size();        int n = text2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 1; i &lt;= m; ++i)        &#123;            for (int j = 1; j &lt;= n; ++j)                if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;        return dp[m][n];    &#125;&#125;;\n\n二：编辑距离\n\n1. 动态规划\n一共有三种替换方式，对于增加和删除是相对于原数据加1，替换有可能不增加，需要对三种方式取最小值，这里主要使用距离来表示两个字符串的差异\nclass Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m = word1.size();        int n = word2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 0; i &lt;= m; ++i)            dp[i][0] = i;        for (int i = 0; i &lt;= n; ++i)            dp[0][i] = i;        for (int i = 1; i &lt;= m; ++i)            for (int j = 1; j &lt;= n; ++j)            &#123;                int add = dp[i - 1][j] + 1;                int del = dp[i][j - 1] + 1;                int tak = dp[i - 1][j -1];                if (word1[i - 1] != word2[j - 1]) ++tak;                dp[i][j] = min(add, min(del, tak));            &#125;        return dp[m][n];    &#125;&#125;;\n\n三：最长有效括号\n\n1. 动态规划\n使用一个数组来表示以右括号结尾的子串的长度，那么左括号必为0，此时右括号有两种情况\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        vector&lt;int&gt; dp(len, 0);        int result = 0;        for (int i = 1; i &lt; len; ++i)         &#123;            if (s[i] == &#x27;)&#x27;)                if (s[i - 1] == &#x27;(&#x27; &amp;&amp; i &gt;= 2)                    dp[i] = dp[i - 2] + 2;                else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;)                &#123;                    dp[i] = dp[i - 1] + 2;                    int pre = i - dp[i - 1] - 2;                    if (pre &gt;= 0) dp[i] += dp[pre];                &#125;                result = max(result, dp[i]);        &#125;        return result;    &#125;&#125;;\n\n2. 栈\n这个方法相对容易但也需要一些技巧，我们使用索引放入堆栈作为未匹配字符，遇到右括号表明存在匹配从而弹出栈顶数据，使用当前位置减去栈顶未匹配索引即为所求字符串的长度\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        stack&lt;int&gt; stk;        int result = 0;        stk.push(-1);        for (int i = 0; i &lt; len; ++i)            if (s[i] == &#x27;(&#x27;) stk.push(i);            else            &#123;                stk.pop();                if (stk.empty()) stk.push(i);        // 保证有数据作为未匹配字符                else result = max(result, i - stk.top());            &#125;        return result;    &#125;&#125;;\n\n3. 不需要额外的空间\n对于一个有效的字符串一定满足两个条件，一：左右括号数量相等，二：前缀子串的左括号数不小于右括号、后缀子串右括号不小于左括号\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        int result = 0;        int left = 0, right = 0;        for (int i = 0; i &lt; len; ++i)\t\t// 无法处理左括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (right &gt; left) left = right = 0;         // 不合法，重置        &#125;        left = right = 0;        for (int i = len - 1; i &gt;= 0; --i)\t\t\t// 无法处理右括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (left &gt; right) left = right = 0;         // 不合法，重置        &#125;        return result;    &#125;&#125;;\n\n四：数据流的中位数\n\n1. 优先队列\n使用大顶堆和小顶堆来维护有序数组，同时保证大顶堆的长度不小于小顶堆\nclass MedianFinder &#123;public:    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; priLess;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; priGreater;    MedianFinder() &#123;&#125;        void addNum(int num) &#123;        if (priLess.empty() || num &lt;= priLess.top())        &#123;            priLess.push(num);            if (priLess.size() &gt; priGreater.size() + 1)            &#123;                priGreater.push(priLess.top());                priLess.pop();            &#125;        &#125; else        &#123;            priGreater.push(num);            if (priGreater.size() &gt; priLess.size())            &#123;                priLess.push(priGreater.top());                priGreater.pop();            &#125;        &#125;    &#125;    double findMedian() &#123;        if (priLess.size() &gt; priGreater.size()) return priLess.top();        return (static_cast&lt;long long&gt;(priLess.top()) + static_cast&lt;long long&gt;(priGreater.top())) / 2.0;\t// 这里提升精度，否则有可能报错    &#125;&#125;;\n\n2. 有序集合+双指针\n使用multiset来维护一个有序数组，使用两个指针维护中位数，需要对双指针进行较多判断\nclass MedianFinder &#123;public:    multiset&lt;int&gt; nums;    multiset&lt;int&gt;::iterator left, right;    MedianFinder() &#123;left = nums.end(); right = nums.end();&#125;    void addNum(int num) &#123;        int len = nums.size();        nums.insert(num);        if (len == 0) left = right = nums.begin();        else if (len &amp; 1)             if (num &lt; *left) --left;            else ++right;        else            if (num &gt;= *right) ++left;            else if (num &gt;= *left &amp;&amp; num &lt; *right)             &#123;                ++left;                --right;            &#125;            else                --right;    &#125;    double findMedian() &#123;        return (static_cast&lt;long long&gt;(*left) + static_cast&lt;long long&gt;(*right)) / 2.0;    &#125;&#125;;\n\n五：柱状图中最大的矩形\n\n1. 单调栈\n使用两个数组来存储当前元素左右两边高度比自己小的索引，该方法需要维护一个单调栈，剔除比自己大的元素，从而方便查找比自己小的值\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len), right(len);        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            left[i] = stk.empty() ? -1 : stk.top();            stk.push(i);        &#125;        stk = std::stack&lt;int&gt;();        for (int i = len - 1; i &gt;= 0; --i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            right[i] = stk.empty() ? len : stk.top();            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n2. 单调栈+常数优化\n上个方法使用了两个循环，考虑第一个循环是否发现栈顶值被弹出说明它此时已经找到了比它小的右边界，但此时需要对存储右边界的数组的初始值进行限制\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len, -1), right(len, len);\t\t// 从前到后只能正确处理左边界，右边界需要限定        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])\t\t// 考虑递增的数组，此时无法找到元素的右边界            &#123;                right[stk.top()] = i;                stk.pop();            &#125;            left[i] = stk.empty() ? -1 : stk.top();\t\t// 只能处理左边界            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.21)","url":"/posts/82141fca/","content":"一：合并 K 个升序链表\n\n1. 顺序合并\n按照链表合并的逻辑将数组中的链表逐个合并\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        int len = lists.size();        ListNode* retuslt = nullptr;        for (int i = 0; i &lt; len; ++i) retuslt = Merge(retuslt, lists[i]);        return retuslt;    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n2. 分治合并\n将数组中的链表两两配对，依次递归\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        return recursion(lists, 0, lists.size() - 1);    &#125;    ListNode* recursion(vector&lt;ListNode*&gt;&amp; lists, int left, int right)    &#123;        if (left == right) return lists[left];        if (left &gt; right) return nullptr;        int mid = (left + right) &gt;&gt; 1;        return Merge(recursion(lists, left, mid), recursion(lists, mid + 1, right));    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n3. 使用优先队列合并\n根据节点的值将其放入优先队列中，依次取出队列顶端的值，可得到最小的节点\nclass Solution &#123;public:    struct Node    &#123;        int val;        ListNode* p;        bool operator &lt; (const Node &amp;com) const        &#123;            return val &gt; com.val;        &#125;    &#125;;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode head, *cur = &amp;head;        priority_queue&lt;Node&gt; pq;        for (auto &amp;list : lists)             if (list) pq.push(&#123;list-&gt;val, list&#125;);        while (!pq.empty())        &#123;            auto temp = pq.top();            pq.pop();            cur-&gt;next = temp.p;            cur = cur-&gt;next;            if (temp.p-&gt;next) pq.push(&#123;temp.p-&gt;next-&gt;val, temp.p-&gt;next&#125;);        &#125;        return head.next;    &#125;&#125;;\n\n二：K 个一组翻转链表\n\n1. 模拟\n翻转链表的实现很容易，但反转之后需要它的前置和后置节点，以便更新在链表中的结构，所以需要提前保留需要交换的头和尾节点\nclass Solution &#123;public:    ListNode* reverseKGroup(ListNode* head, int k) &#123;        ListNode* result = new ListNode(0);        result-&gt;next = head;        ListNode* pre = result;        while (head)        &#123;            ListNode* tail = pre;            for (int i = 0; i &lt; k; ++i)            &#123;                tail = tail-&gt;next;                if (tail == nullptr) return result-&gt;next;            &#125;            ListNode* next = tail-&gt;next;            tie(head, tail) = Reverse(head, tail);            pre-&gt;next = head;            tail-&gt;next = next;            head = tail-&gt;next;            pre = tail;        &#125;        return result-&gt;next;    &#125;    pair&lt;ListNode*, ListNode*&gt; Reverse(ListNode* head, ListNode* tail)    &#123;        ListNode* pre = nullptr;        ListNode* cur = head;        while (pre != tail)        &#123;            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return &#123;tail, head&#125;;    &#125;&#125;;\n\n三：缺失的第一个正数\n\n1. 哈希表\n想要记录没有出现的数据，通常使用哈希表，这里无法使用额外空间，我们可以对数组进行原地操作\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (auto&amp; num: nums)            if (num &lt;= 0) num = INT_MAX;        for (auto&amp; num: nums)        &#123;            int temp = abs(num);            if (temp &lt;= len) nums[temp - 1] = -abs(nums[temp - 1]);     // 这里可能修改后面的数据，所以取负值        &#125;        for (int i = 0; i &lt; len; ++i)            if (nums[i] &gt; 0) return i + 1;        return len + 1;    &#125;&#125;;\n\n2. 置换\n我们可以尝试把元素的值与数组索引对应\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - 1])                 swap(nums[i], nums[nums[i] - 1]);        for (int i = 0; i &lt; len; ++i)            if (nums[i] != i + 1) return i + 1;        return len + 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.20)","url":"/posts/9b0f2e8b/","content":"一：寻找两个正序数组的中位数\n\n1. 二分查找\n寻找两个数组的中位数即是寻找第 k 小的数，那么对于每一个数组求k / 2 - 1，小的一个元素的左边值应当被排除，更新K值和索引\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        int total = m + n;        if (total &amp; 1) return GetKvalue(nums1, nums2, (total + 1) / 2);        else return ((GetKvalue(nums1, nums2, total / 2) + GetKvalue(nums1, nums2, total / 2 + 1)) / 2.0);    &#125;    int GetKvalue(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)    &#123;        int m = nums1.size();        int n = nums2.size();        int index1 = 0;        int index2 = 0;        while (true)        &#123;            if (index1 == m) return nums2[index2 + k - 1];            if (index2 == n) return nums1[index1 + k - 1];            if (k == 1) return min(nums1[index1], nums2[index2]);            int newIndex1 = min(index1 + k / 2 - 1, m - 1);            int newIndex2 = min(index2 + k / 2 - 1, n - 1);            int pre1 = nums1[newIndex1];            int pre2 = nums2[newIndex2];            if (pre1 &lt;= pre2)            &#123;                k = k - (newIndex1 - index1 + 1);                index1 = newIndex1 + 1;            &#125; else            &#123;                k = k - (newIndex2 - index2 + 1);                index2 = newIndex2 + 1;            &#125;        &#125;    &#125;&#125;;\n\n2. 划分数组\n这个题有点难，将两个数组进行划分，通常左边的最大值如果小于右边的最小值，那么中位数即可判断\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        if (m &gt; n) return findMedianSortedArrays(nums2, nums1);     // 保证第一个数组小        int left = 0, right = m;        // 二分范围        int median1 = 0;        int median2 = 0;        while (left &lt;= right)        &#123;            int i = (left + right) &gt;&gt; 1;        // 第一个数组的中间值            int j = ((m + n + 1) &gt;&gt; 1) - i;       // 第二个数组的中间值            int i_1 = i == 0 ? INT_MIN : nums1[i - 1];            int iNew = i == m ? INT_MAX : nums1[i];            int j_1 = j == 0 ? INT_MIN : nums2[j - 1];            int jNew = j == n ? INT_MAX : nums2[j];            if (i_1 &lt;= jNew)            &#123;                median1 = max(i_1, j_1);                median2 = min(iNew, jNew);                left = i + 1;            &#125; else                right = i - 1;        &#125;        return (m + n) &amp; 1 ? median1 : (median1 + median2) / 2.0;    &#125;&#125;;\n\n二：N 皇后\n\n1. 基于集合的回溯\n使用回溯需要三步，选择、递归、撤销选择，在选择时需要避免行、列以及两个斜线不能冲突\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    unordered_set&lt;int&gt; col;    unordered_set&lt;int&gt; diaR;    unordered_set&lt;int&gt; diaL;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, board);        return result;    &#125;    void recursion(int row, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);     // 全部填充            return;        &#125;         for (int i = 0; i &lt; len; ++i)       // 对当前行遍历可行的列        &#123;            if (col.count(i) || diaR.count(row - i) || diaL.count(row + i)) continue;       // 冲突则下一列            board[row][i] = &#x27;Q&#x27;;        // 选择            col.insert(i);            diaR.insert(row - i);            diaL.insert(row + i);            recursion(row + 1, board);      // 递归            board[row][i] = &#x27;.&#x27;;        // 撤销            col.erase(i);            diaR.erase(row - i);            diaL.erase(row + i);        &#125;    &#125;&#125;;\n\n2. 基于位运算的回溯\n这里使用二进制来表示每一列和斜边的位置情况\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, 0, 0, 0, board);        return result;    &#125;    void recursion(int row, int col, int digR, int digL, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);                return;        &#125;         int avail = ((1 &lt;&lt; len) - 1) &amp; (~(col | digR | digL));\t\t// 可用位置        while (avail != 0)        &#123;            int p = avail &amp; (-avail);\t\t// 最低位的可用位置            int colT = 0;            int temp = p;            while ((temp &gt;&gt;= 1) &gt; 0) ++colT;\t\t// 对应列            board[row][colT] = &#x27;Q&#x27;;            int next_col = col | p;\t\t// 新的二进制            int next_digR = (digR | p) &gt;&gt; 1;            int next_digL = (digL | p) &lt;&lt; 1;            recursion(row + 1, next_col, next_digR, next_digL, board);            board[row][colT] = &#x27;.&#x27;;            avail &amp;= (~p);\t\t// 取消可用位置        &#125;    &#125;&#125;;\n\n三：二叉树中的最大路径和\n\n1. 递归\n这里主要需要使用一个常数来记录最大值，因为不能回溯，而返回值不能叠加\nclass Solution &#123;public:    int result = INT_MIN;    int maxPathSum(TreeNode* root) &#123;        recursion(root);        return result;    &#125;    int recursion(TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftVal = max(recursion(node-&gt;left), 0);        int rightVal = max(recursion(node-&gt;right), 0);        result = max(result, node-&gt;val + leftVal + rightVal);        return node-&gt;val + max(leftVal, rightVal);    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.2)","url":"/posts/ede30f/","content":"一：买卖股票的最佳时机\n\n1. 暴力\n不写\n2. 一次遍历\n记录最低值和利润最高值\nclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int maxP = 0;           // 后面的最大利润        int minP = 1e9;         // 之前的最低值        for (auto price : prices)        &#123;            maxP = max(maxP, price - minP);            minP = min(minP, price);        &#125;        return maxP;    &#125;&#125;;\nclass Solution &#123;    public int maxProfit(int[] prices) &#123;        int maxP = 0;                   int minP = Integer.MAX_VALUE;                 for (int i =  0; i &lt; prices.length; ++i)        &#123;            int price = prices[i];            maxP = Math.max(maxP, price - minP);            minP = Math.min(minP, price);        &#125;        return maxP;    &#125;&#125;\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        maxP = 0                   minP = 1e9                 for price in prices:            maxP = max(maxP, price - minP)            minP = min(minP, price)        return maxP\n\n二：爬楼梯\n\n1. 动态规划\nf(x)=f(x−1)+f(x−2)f(x)=f(x−1)+f(x−2)\nf(x)=f(x−1)+f(x−2)\n爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和，f(0)=1f(0)=1f(0)=1，f(1)=1f(1)=1f(1)=1，对空间的优化使用滚动数组\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;\t\t// 赋值顺序不能反            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sPre, pre, cur = 0, 0, 1        # 赋值        for _ in range(n):      # 遍历，_不使用            sPre = pre            pre = cur            cur = sPre + pre        return cur\n\n2. 矩阵快速幂\n[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix} = \\begin{bmatrix} f(n)+f(n-1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix}\n[11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]\n[f(n+1)f(n)]=[1110]n[f(1)f(0)]\\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n} \\begin{bmatrix} f(1) \\\\ f(0) \\end{bmatrix}\n[f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]\nM=[1110]M = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\nM=[11​10​]\n常规计算M的n次方时间复杂度同上，这里使用快速幂\n**快速幂是一种用于在 O(log⁡n)O(\\log n)O(logn) 时间内计算 ana^nan 的高效算法。它利用了指数的二进制表示来减少乘法运算的次数，通常用于解决指数非常大时可能导致超时的问题。\n基本思想\n传统方法计算 ana^nan 需要进行 n−1n-1n−1 次乘法（即 a×a×⋯×aa \\times a \\times \\dots \\times aa×a×⋯×a）。快速幂则利用以下数学性质：\n\n如果 nnn 是偶数，an=an/2×an/2a^n = a^{n/2} \\times a^{n/2}an=an/2×an/2。\n如果 nnn 是奇数，an=a(n−1)/2×a(n−1)/2×aa^n = a^{(n-1)/2} \\times a^{(n-1)/2} \\times aan=a(n−1)/2×a(n−1)/2×a。\n\n这个思想的核心是将指数 nnn 不断折半。通过将 nnn 转换为二进制形式，我们可以将 ana^nan 的计算分解为一系列乘法和平方操作。例如，要计算 a13a^{13}a13，因为 131313 的二进制是 110111011101，即 13=8+4+113 = 8 + 4 + 113=8+4+1，所以：\na13=a8+4+1=a8×a4×a1a^{13} = a^{8+4+1} = a^8 \\times a^4 \\times a^1a13=a8+4+1=a8×a4×a1\n我们只需要计算 a1,a2,a4,a8a^1, a^2, a^4, a^8a1,a2,a4,a8（通过不断平方得到），然后将这些项相乘即可。这比直接进行 12 次乘法要快得多。\n算法步骤\n\n初始化结果 res = 1。\n将底数 base 设为 aaa。\n当指数 n&gt;0n &gt; 0n&gt;0 时循环：\n\n如果 nnn 的二进制最后一位是 1（即 nnn 为奇数），将 res 乘以 base。\n将 base 自身相乘（base = base * base）。\n将 nnn 右移一位（n = n &gt;&gt; 1），相当于 n=n/2n = n / 2n=n/2。\n\n\n返回 res。\n\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;vector&lt;long long&gt;&gt; init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        vector&lt;vector&lt;long long&gt;&gt; result = matrixPow(init, n);        return result[0][0];    &#125;    vector&lt;vector&lt;long long&gt;&gt; multiplication(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b)      // 二阶矩阵乘法    &#123;         vector&lt;vector&lt;long long&gt;&gt; c(2, vector&lt;long long&gt;(2));        for (int i = 0; i &lt; a.size(); ++i)        &#123;            for (int j = 0; j &lt; b[0].size(); ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    vector&lt;vector&lt;long long&gt;&gt; matrixPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int n)    &#123;        vector&lt;vector&lt;long long&gt;&gt; unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int[][] init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        // 使用int[][]或long        int[][] result = matrixPow(init, n);        return result[0][0];    &#125;    public int[][] multiplication(int[][] a, int[][] b)      // 二阶矩阵乘法    &#123;         int[][] c = new int[2][2];         // 基本数据类型        for (int i = 0; i &lt; a.length; ++i)        &#123;            for (int j = 0; j &lt; b[0].length; ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    public int[][] matrixPow(int[][] a, int n)    &#123;        int[][] unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        init = [[1, 1], [1, 0]]                result = self._matrixPow(init, n)        return result[0][0]    def multiplication(self, a, b):            c = [[1, 1], [1, 0]]              for i in range(2):            for j in range(2):                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]        return c    def _matrixPow(self, a, n):        unit = [[1, 0], [0, 1]]          while n &gt; 0:            if ((n &amp; 1) == 1): unit = self.multiplication(unit, a)            a = self.multiplication(a, a)            n &gt;&gt;= 1        return unit\n\n3. 通项公式\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        double sqrt5 = sqrt(5);        return static_cast&lt;int&gt;(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        double sqrt5 = Math.sqrt(5);        return (int)(Math.round((Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sqrt5 = sqrt(5)        return (int)(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5))\n\n三：杨辉三角\n\n1. 数学分析\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; result(numRows);        for (int i= 0; i &lt; numRows; ++i)        &#123;            result[i].resize(i + 1);            result[i][0] = result[i][i] = 1;            for (int j = 1; j &lt; i; ++j)            &#123;                result[i][j] = result[i - 1][j] + result[i - 1][j - 1];            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        for (int i= 0; i &lt; numRows; ++i)        &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            for (int j = 0; j &lt;= i; ++j)            &#123;                if (j == 0 || j == i) row.add(1);                else row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));            &#125;            result.add(row);        &#125;        return result;    &#125;&#125;\nclass Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        result = []        for i in range(numRows):            row = []            for j in range(0, i + 1):       # 0-i                if j == 0 or j == i: row.append(1)                else: row.append(result[i - 1][j] + result[i - 1][j - 1])            result.append(row)        return result\n\n四：只出现一次的数字\n\n1. 位运算\n题目要求使用空间复杂度为常量，因此常规解法不可用。这里采用异或，性质如下\n\nclass Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result = 0;        for (auto num : nums)            result ^=num;        return result;    &#125;&#125;;\nclass Solution &#123;    public int singleNumber(int[] nums) &#123;        int result = 0;        for (int num : nums)        // 没有auto            result ^=num;        return result;    &#125;&#125;\nclass Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        result = 0        for num in nums:                   result ^=num        return result\t\t# return reduce(lambda x, y: x ^ y, nums) 使用lambda，reduce从可迭代对象中取出第一个和第二个元素，用指定的函数进行计算，将计算结果与第三个元素再次进行计算，直到所有元素处理完毕\n\n五：多数元素\n\n1. 哈希表\n数组的值作为键，出现的次数作为值\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; hashMap;        int count = 0, numberous = 0;        for (auto num : nums)        &#123;            ++hashMap[num];            if (hashMap[num] &gt; count)\t\t// 通过该方式无需再次遍历哈希表            &#123;                count = hashMap[num];                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        int count = 0, numberous = 0;        for (int num : nums)        &#123;            if (hashMap.containsKey(num)) hashMap.put(num, hashMap.get(num) + 1);            else hashMap.put(num, 1);                        if (hashMap.get(num) &gt; count)            &#123;                count = hashMap.get(num) ;                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)\t\t# 统计每个元素的个数，保存为字典        return max(counts.keys(), key = counts.get)\t\t\t# 根据键取出对应的值的最大值\n\n2. 排序\n由于多数总是超过元素总和的二分之一，那么排序后中间的元素一定是多数（奇偶均可）\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)        return max(counts.keys(), key = counts.get)\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Arrays.sort(nums);      // 使用Arrays        return nums[nums.length / 2];    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // 2]\n\n3. 随机化\n随机挑选一个元素作为多数，然后统计\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        while (true)        &#123;            int count = 0;            int right = nums[rand() % nums.size()];\t\t// 也可以假设第一个为多数，依次尝试，比随机时间稍低，因为不会重复            for (auto num : nums)                if (num == right) ++count;            if (count &gt; nums.size() / 2) return right;        &#125;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Random rand = new Random();        while (true)        &#123;            int right = nums[rand.nextInt(nums.length)];            int count = 0;            for (int num : nums)                if (num == right) ++count;            if (count &gt; nums.length / 2) return right;        &#125;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        while True:            right = random.choice(nums)            count = 0            for num in nums:\t\t# 或if sum(1 for elem in nums if elem == candidate) &gt; majority_count:                if num == right: count += 1            if count &gt; len(nums) // 2: return right\n\n4. 分治\n将数据分为两组，多数一定会存在其中一组\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    int recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);\t\t// 两者相等可以直接返回了leftNum == rightNum        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(vector&lt;int&gt;&amp; nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    public int recursion(int[] nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(int[] nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1)    def recursion(self, nums, left, right):        if (left == right): return nums[left]        mid = ((right - left) // 2) + left        leftNum = self.recursion(nums, left, mid)        rightNum = self.recursion(nums, mid + 1, right)        if (self.countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2): return leftNum        if (self.countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2): return rightNum        return -1    def countNum(self, nums, target, lo, hi):        count = 0        for num in nums:            if (num == target):                count +=1        return count    # 官方写法class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        def majority_elem在·ent_rec(lo, hi) -&gt; int:            if lo == hi:                return nums[lo]                        mid = (hi - lo) // 2 + lo            left = majority_element_rec(lo, mid)            right = majority_element_rec(mid + 1, hi)            if left == right:                return left            left_count = sum(1 for i in range(lo, hi + 1) if nums[i] == left)            right_count = sum(1 for i in range(lo, hi + 1) if nums[i] == right)            return left if left_count &gt; right_count else right        return majority_element_rec(0, len(nums) - 1)\n\n5. Boyer-Moore 投票算法\n\n利用多数大于二分之一的性质，所有元素加减之后一定大于零，最后一个零出现的位置意味着之后的第一个元素一定是多数，因为如果不是多数，后面还会出现零\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int right = -1;    int count = 0;    for (auto num : nums)    &#123;        if (count == 0) right = num;        if (num == right) ++count;        else --count;    &#125;    return right;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int right = -1;        int count = 0;        for (int num : nums)        &#123;            if (count == 0) right = num;            if (num == right) ++count;            else --count;        &#125;        return right;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        right = -1        count = 0        for num in nums:            if (count == 0): right = num            if (num == right): count += 1            else: count -= 1        return right\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.22)","url":"/posts/a9394c09/","content":"一：接雨水\n\n1. 动态规划\n使用两个数组维护其左右最大高度，其当前位置的雨水即为左右高度的最小值减去当前值\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        vector&lt;int&gt; LeftH(len);        vector&lt;int&gt; rightH(len);        LeftH[0] = height[0];        rightH[len - 1] = height[len - 1];        for (int i = 1; i &lt; len; ++i)            LeftH[i] = max(LeftH[i - 1], height[i]);        for (int i = len - 2; i &gt;= 0; --i)            rightH[i] = max(rightH[i + 1], height[i]);        for (int i = 0; i &lt; len; ++i)            result += min(LeftH[i], rightH[i]) - height[i];        return result;    &#125;&#125;;\n\n2. 单调栈\n按照递减的顺序将数据放入栈中，如果有数据大于栈顶，则计算其包含的雨水量\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        stack&lt;int&gt; stk;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()])            &#123;                int cur = stk.top();                stk.pop();                if (stk.empty()) break;                int left = stk.top();                int width = i - left - 1;                int hei = min(height[left], height[i]) - height[cur];                result += width * hei;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n3. 双指针\n使用两个指针维护左右的最大值，哪个指针的值小便进行移动\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        int left = 0, right = len - 1;        int leftM = 0, rightM = 0;        while (left &lt; right)        &#123;            leftM = max(leftM, height[left]);            rightM = max(rightM, height[right]);            if (leftM &lt; rightM)            &#123;                result += leftM - height[left];                ++left;            &#125; else            &#123;                result += rightM - height[right];                --right;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：滑动窗口最大值\n\n1. 优先队列\n维护一个当前窗口的优先队列，每次从里面选中一个最大值作为当前窗口的最大值，然后移动窗口并剔除超出边界的队顶元素\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;        for (int i = 0; i &lt; k; ++i) pq.push(&#123;nums[i], i&#125;);        result.emplace_back(pq.top().first);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            pq.push(&#123;nums[i], i&#125;);            while (pq.top().second &lt;= i - k) pq.pop();            result.emplace_back(pq.top().first);        &#125;        return result;    &#125;&#125;;\n\n2. 单调队列\n将优先队列改为双端队列，同时维护有序状态，可将原来操作插入的log⁡(n)\\log(n)log(n)复杂度降低为(n)(n)(n)\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        deque&lt;int&gt; dq;        for (int i = 0; i &lt; k; ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);        &#125;        result.emplace_back(nums[dq.front()]);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);            while (dq.front() &lt;= i - k) dq.pop_front();            result.emplace_back(nums[dq.front()]);        &#125;        return result;    &#125;&#125;;\n\n3. 分块+预处理\n首先将元素分块，并计算出当前元素在该块的前缀最大值和后缀最大值，随后遍历元素取其中的最大值即可\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        vector&lt;int&gt; result;        vector&lt;int&gt; pre(len);        vector&lt;int&gt; suf(len);        for (int i = 0; i &lt; len; ++i)            if (i % k == 0)                pre[i] = nums[i];            else                pre[i] = max(pre[i - 1], nums[i]);        for (int i = len - 1; i &gt;= 0; --i)            if (i == len - 1 || (i + 1) % k == 0)                suf[i] = nums[i];            else                suf[i] = max(suf[i + 1], nums[i]);        for (int i = 0; i &lt;= len - k; ++i)            result.emplace_back(max(pre[i + k - 1], suf[i]));        return result;    &#125;&#125;;\n\n三：最小覆盖子串\n\n1. 滑动窗口\n使用一个窗口来表示当前子串的范围，并在包含所有元素之后尝试缩短长度\nclass Solution &#123;public:    unordered_map &lt;char, int&gt; ori, cnt;    string minWindow(string s, string t) &#123;        for (const auto &amp;c: t)            ++ori[c];        int l = 0, r = -1;        int len = INT_MAX, ansL = -1;        while (r &lt; int(s.size())) &#123;            if (ori.find(s[++r]) != ori.end())                 ++cnt[s[r]];            while (check() &amp;&amp; l &lt;= r) &#123;                if (r - l + 1 &lt; len) &#123;                    len = r - l + 1;                    ansL = l; // 记录最短子串的起始位置                &#125;                if (ori.find(s[l]) != ori.end())                     --cnt[s[l]];                ++l;            &#125;        &#125;        return ansL == -1 ? string() : s.substr(ansL, len);    &#125;    bool check()     &#123;        for (const auto &amp;p: ori)             if (cnt[p.first] &lt; p.second)                 return false;        return true;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.3)","url":"/posts/19f6d24e/","content":"一：字母异位词分组\n\n1. 排序\n字母异位词排序之后相同，可使用哈希表\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str : strs)        &#123;            string key = str;            sort(key.begin(), key.end());            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)        &#123;            result.emplace_back(row.second);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            char[] arrayStr = str.toCharArray();            Arrays.sort(arrayStr);            String key = new String(arrayStr);            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            // getOrDefault 它的作用是：如果 map 中存在 key，则返回 key 对应的值；            // 如果不存在，则返回 new ArrayList&lt;String&gt;() 并添加到 map 中            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            # sorted(st) 返回一个按字母排序的列表 [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;t&#x27;]            # &quot;&quot;.join(...) 将列表中的字符连接成字符串 &quot;aet&quot;            key = &quot;&quot;.join(sorted(str))            hashMap[key].append(str)        return list(hashMap.values())\n\n2. 计数\n跟排序道理相同，只不过增加了字符的次数\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str: strs) &#123;            array&lt;int, 26&gt; counts&#123;&#125;;            for (char ch : str)                 counts[ch - &#x27;a&#x27;] ++;            string key;            for (auto count : counts)                 key += to_string(count) + &quot;#&quot;;            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)            result.emplace_back(row.second);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            int[] counts = new int[26];            for (int i = 0; i &lt; str.length(); i++)                counts[str.charAt(i) - &#x27;a&#x27;]++;            StringBuffer sb = new StringBuffer();            for (int i = 0; i &lt; 26; i++)                if (counts[i] != 0)\t\t\t// 这里也可以使用python的方式，但是必须在字符之间添加分界符，原因是出现次数超过10的字母会导致键不唯一                &#123;                    sb.append((char)(&#x27;a&#x27; + i));                    sb.append(counts[i]);                &#125;            String key = sb.toString();            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            counts = [0] * 26            for ch in str:                counts[ord(ch) - ord(&quot;a&quot;)] += 1            hashMap[tuple(counts)].append(str)\t\t# 直接使用计数数组，注意这里保留了顺序，因为生成的是元组        return list(hashMap.values())\n\n二：最长连续序列\n\n1. 哈希表\n将数据放入哈希表，然后不断寻找它的下一位，时间大概为线性，但有些数据没必要再次寻找，如已经找过的数据\nclass Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; hashSet;        int maxCount = 0;        for (auto num : nums) hashSet.insert(num);        for (auto num : hashSet)        &#123;            if (!hashSet.count(num - 1))            &#123;                int count = 1;                  while (hashSet.count(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = max(maxCount, count);            &#125;        &#125;         return maxCount;                                       &#125;&#125;;\nclass Solution &#123;    public int longestConsecutive(int[] nums) &#123;        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        int maxCount = 0;        for (int num : nums) hashSet.add(num);        for (int num : hashSet)        &#123;            if (!hashSet.contains(num - 1))            &#123;                int count = 1;                  while (hashSet.contains(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = Math.max(maxCount, count);            &#125;        &#125;         return maxCount;        &#125;&#125;\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        hashSet = set(nums)        maxCount = 0        for num in hashSet:            if num - 1 not in hashSet:                count = 1                  while (num + 1) in hashSet:                    count += 1                    num += 1                maxCount = max(maxCount, count)        return maxCount   \n\n三：盛水最多的容器\n\n1. 双指针\n从两端开始，移动小的向中间靠近\nclass Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int left = 0, right = height.size() - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;;\nclass Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0, right = height.length - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = Math.min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = Math.max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, maxA = 0, 0        right = len(height) - 1        while left &lt; right:            curArea = min(height[left], height[right]) * (right - left)            if (height[left] &lt; height[right]): left += 1            else: right -= 1            maxA = max(maxA, curArea)        return maxA\n\n四：三数之和\n\n1. 排序 + 双指针\n首先对数组进行排序，外层循环从左往右，内层从右往左，题目要求三元组不重复意味着相同的值无需处理跳过即可\n当我们想要枚举数组中的两个元素时，如果发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N2)O(N^2)O(N2) 减少至 O(N)O(N)O(N)。为什么是 O(N)O(N)O(N) 呢？这是因为在枚举的过程中，每一步中，“左指针”会向右移动一个位置，而“右指针”会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)O(N)。均摊下来，每次也只向右移动一个位置，因此时间复杂度为 O(N)O(N)O(N)。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0) result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        int length = nums.length;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0)                &#123;                    List&lt;Integer&gt; row = new ArrayList&lt;&gt;();                    row.add(nums[i]);                    row.add(nums[j]);                    row.add(nums[k]);                    result.add(row);                &#125;            &#125;        &#125;        return result;    &#125;&#125;\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        length = len(nums)        result = list()        nums.sort()        for i in range(length):            if i &gt; 0 and nums[i] == nums[i - 1]: continue            k = length - 1            for j in range(i + 1, length):                if j &gt; i + 1 and nums[j] == nums[j - 1]: continue                while nums[i] + nums[j] + nums[k] &gt; 0 and j &lt; k: k -= 1                if j == k: break                if nums[i] + nums[j] + nums[k] == 0:                    result.append([nums[i], nums[j], nums[k]])        return result\n\n五：无重复字符的最长子串\n\n1. 滑动窗口\n通过哈希表维护窗口，两个指针指向字符串，若右指针元素不在哈希表则添加并右移，若包含则左指针右移并剔除当前指向元素\nclass Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        unordered_set&lt;char&gt; hashSet;        int right = 0;        int length = s.size();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.count(s[right]))            &#123;                hashSet.insert(s[right]);                ++right;            &#125;            hashSet.erase(s[i]);            result = max(result, right - i);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();        int right = 0;        int length = s.length();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.contains(s.charAt(right)))            &#123;                hashSet.add(s.charAt(right));                ++right;            &#125;            hashSet.remove(s.charAt(i));            result = Math.max(result, right - i);        &#125;        return result;    &#125;&#125;\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        hashSet = set()        right = 0        length = len(s)        result = 0        for i in range(length):            while (right &lt; length and s[right] not in hashSet):                hashSet.add(s[right])                right += 1            hashSet.remove(s[i])            result = max(result, right - i)        return result\n\n六：找到字符串中所有字母异位词\n\n1. 滑动窗口\np的长度固定，在s中寻找p可使用p的长度的作为窗口宽度，利用当前宽度两个字符串出现的次数即可作为判定\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; pCharCount(26);        vector&lt;int&gt; sCharCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p[i] - &#x27;a&#x27;];            ++sCharCount[s[i] - &#x27;a&#x27;];        &#125;        if (sCharCount == pCharCount) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s[i] - &#x27;a&#x27;];            ++sCharCount[s[i + pL] - &#x27;a&#x27;];            if (sCharCount == pCharCount) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] pCharCount = new int[26];        int[] sCharCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        if (Arrays.equals(pCharCount, sCharCount)) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (Arrays.equals(pCharCount, sCharCount)) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        pCharCount = [0] * 26        sCharCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            pCharCount[ord(p[i]) - 97] += 1            sCharCount[ord(s[i]) - 97] += 1        if (sCharCount == pCharCount): result.append(0)        for i in range(sL - pL):               sCharCount[ord(s[i]) - 97] -= 1            sCharCount[ord(s[i + pL]) - 97] += 1            if (sCharCount == pCharCount): result.append(i + 1)        return result\n\n2. 优化\n不比较两个字符串在窗口的位置，直接比较差值\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; charCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p[i] - &#x27;a&#x27;];            ++charCount[s[i] - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s[i] - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s[i] - &#x27;a&#x27;] == 0) ++dif;            --charCount[s[i] - &#x27;a&#x27;];            if (charCount[s[i + pL] - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s[i + pL] - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s[i + pL] - &#x27;a&#x27;];            if (dif == 0) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] charCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p.charAt(i) - &#x27;a&#x27;];            ++charCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s.charAt(i) - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s.charAt(i) - &#x27;a&#x27;] == 0) ++dif;            --charCount[s.charAt(i) - &#x27;a&#x27;];            if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (dif == 0) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        charCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            charCount[ord(p[i]) - 97] -= 1            charCount[ord(s[i]) - 97] += 1        differ = [c != 0 for c in charCount].count(True)        if (differ == 0): result.append(0)        for i in range(sL - pL):               if charCount[ord(s[i]) - 97] == 1: differ -= 1            elif charCount[ord(s[i]) - 97] == 0: differ += 1            charCount[ord(s[i]) - 97] -= 1            if charCount[ord(s[i + pL]) - 97] == -1: differ -= 1            elif charCount[ord(s[i + pL]) - 97] == 0: differ += 1            charCount[ord(s[i + pL]) - 97] += 1            if (differ == 0): result.append(i + 1)        return result\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.4)","url":"/posts/56b74489/","content":"一：和为K的子数组\n\n1. 枚举\n其实就是暴力，两层循环，python可能会超时\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        int length = nums.length;        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        length = len(nums)        count = 0        for i in range(length):            sum = 0            for j in range(i, length):                sum += nums[j]                if (sum == k): count += 1        return count\n\n2. 哈希表\n遍历时记录所有和并放入哈希表，寻找子串时只寻找当前值与目标值的差，相同值通过哈希表的值来记录\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; hashMap;        hashMap[0] = 1;         // 相同值需要        int sum = 0;        int count = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            if (hashMap.count(sum - k)) count += hashMap[sum - k];            ++hashMap[sum];        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(0, 1);        int sum = 0;        int count = 0;        for (int num : nums)        &#123;            sum += num;            if (hashMap.containsKey(sum - k)) count += hashMap.get(sum - k);            hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        hashMap = &#123;0 : 1&#125;        sum = 0        count = 0        for num in nums:            sum += num            if (sum - k in hashMap): count += hashMap[sum - k]            hashMap[sum] = hashMap.get(sum, 0) + 1        return count\n\n二：最大子数组和\n\n1. 动态规划\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int next = 0;        int result = nums[0];        for (auto&amp; num : nums)        &#123;            next = max(next + num, num);            // 局部最优            result = max(result, next);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int next = 0;        int result = nums[0];        for (int num : nums)        &#123;            next = Math.max(next + num, num);            // 局部最优            result = Math.max(result, next);        &#125;        return result;    &#125;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        next = 0        result = nums[0]        for num in nums:            next = max(next + num, num)                      result = max(result, next)        return result\n\n2. 分治\nclass Solution &#123;public:    struct Status &#123;        int left, right, media, sum;    &#125;;    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1).media;    &#125;    Status recursion(vector&lt;int&gt; &amp;a, int l, int r) &#123;        if (l == r) &#123;            return (Status) &#123;a[l], a[l], a[l], a[l]&#125;;        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;        Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = max(l.left, l.sum + r.left);        int rSum = max(r.right, r.sum + l.right);        int mSum = max(max(l.media, r.media), l.right + r.left);        return (Status) &#123;lSum, rSum, mSum, iSum&#125;;    &#125;;&#125;;\nclass Solution &#123;    public class Status &#123;        public int left, right, media, sum;        public Status(int lSum, int rSum, int mSum, int iSum) &#123;            this.left = lSum;            this.right = rSum;            this.media = mSum;            this.sum = iSum;        &#125;    &#125;    public int maxSubArray(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1).media;    &#125;    public Status recursion(int[] a, int l, int r) &#123;        if (l == r) &#123;            return new Status (a[l], a[l], a[l], a[l]);        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;    public Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = Math.max(l.left, l.sum + r.left);        int rSum = Math.max(r.right, r.sum + l.right);        int mSum = Math.max(Math.max(l.media, r.media), l.right + r.left);        return new Status (lSum, rSum, mSum, iSum);    &#125;;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1).media    def recursion(self, a, l, r):        if l == r:            val = a[l]            return (val, val, val, val)                m = (r + l) // 2        l_sub = self.recursion(a, l, m)        r_sub = self.recursion(a, m + 1, r)          return self.pushUp(l_sub, r_sub)    def pushUp(self, l, r):        l_left, l_right, l_media, l_sum = l        r_left, r_right, r_media, r_sum = r                i_sum = l_sum + r_sum        l_sum_new = max(l_left, l_sum + r_left)        r_sum_new = max(r_right, r_sum + l_right)        m_sum_new = max(max(l_media, r_media), l_right + r_left)                return (l_sum_new, r_sum_new, m_sum_new, i_sum)\n\n3. 前缀法\n参考第一题的第二中解法，时间和空间同动态规划方法\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int minV = 0, maxV = -1e9;        int sum = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            maxV = max(maxV, sum - minV);            minV = min(minV , sum);        &#125;        return maxV;    &#125;&#125;;\n三：合并区间\n\n1. 排序\n对首元素排序，然后判断每个区间的首尾大小即可\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(), intervals.end());        vector&lt;vector&lt;int&gt;&gt; reruslt;        for (int i = 0; i &lt; intervals.size(); ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.back()[1] &lt; left) reruslt.emplace_back(intervals[i]);            else reruslt.back()[1] = max(reruslt.back()[1], right);        &#125;         return reruslt;    &#125;&#125;;\nclass Solution &#123;    public int[][] merge(int[][] intervals) &#123;        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] interval1, int[] interval2) &#123;                return interval1[0] - interval2[0];            &#125;        &#125;);        List&lt;int[]&gt; reruslt = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; intervals.length; ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.get(reruslt.size() - 1)[1] &lt; left) reruslt.add(new int[]&#123;left, right&#125;);            else reruslt.get(reruslt.size() - 1)[1] = Math.max(reruslt.get(reruslt.size() - 1)[1], right);        &#125;         return reruslt.toArray(new int[reruslt.size()][]);    &#125;&#125;\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        result = []        for interval in intervals:            if not result or result[-1][1] &lt; interval[0]: result.append(interval)            else: result[-1][1] = max(result[-1][1], interval[1])        return result\n\n四：轮转数组\n\n1. 额外数组\n使用一个额外数组来存储移动后的元素\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; newNums(nums.size());        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            newNums[(i + k) % nums.size()] = nums[i];        &#125;        return nums.assign(newNums.begin(), newNums.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[] nums, int k) &#123;        int[] newNums = new int[nums.length];        for (int i = 0; i &lt; nums.length; ++i)        &#123;            newNums[(i + k) % nums.length] = nums[i];        &#125;        System.arraycopy(newNums, 0, nums, 0, nums.length);    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        newNums = [0] * len(nums)        for i in range(len(nums)):            newNums[(i + k) % len(nums)] = nums[i]        nums[:] = newNums\n\n2. 环状替换\n以环为单位在数组元素中跳动反转，跳转几次后会回到原点，使用临时值来作为其中一个交换对象，如果遍历交换，则需要多个值来存储交换对象，效率变低\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                swap(nums[cur], curV);            &#125; while(i != cur);        &#125;    &#125;&#125;;\nclass Solution &#123;    public int gcd(int x, int y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;    public void rotate(int[] nums, int k) &#123;        int length = nums.length;        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                int temp = nums[cur];                nums[cur] = curV;                curV = temp;            &#125; while(i != cur);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        length = len(nums)        k = k % length        step = math.gcd(k, length)               for i in range(step):            cur = i            curV = nums[i]            while True:                cur = (cur + k) % length                nums[cur], curV = curV, nums[cur]                if i == cur: break\n\n3. 数组反转\n先将数组反转，然后反转前k个值，最后反转剩余值就得到换位后的数组\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        k = k % nums.size();        reverse(nums, 0, nums.size() - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.size() - 1);    &#125;    void reverse(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j) swap(nums[i], nums[j]);    &#125;&#125;;\nclass Solution &#123;   public void rotate(int[] nums, int k) &#123;        k = k % nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    &#125;    public void reverse(int[] nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j)        &#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        k = k % len(nums)        self.reverse(nums, 0, len(nums) - 1)        self.reverse(nums, 0, k - 1)        self.reverse(nums, k, len(nums) - 1)    def reverse(self, nums, left, right):        while left &lt; right:            nums[left], nums[right] = nums[right], nums[left]            left += 1            right -= 1\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.5)","url":"/posts/4fac75c8/","content":"一：除自身以外数组的乘积\n\n1. 左右乘积列表\n用两个数组分别记录左右两端的乘积\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; left(length);        vector&lt;int&gt; right(length);        vector&lt;int&gt; result(length);        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] left = new int[length] ;        int[] right = new int[length] ;        int[] result = new int[length] ;        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        left = [0] * length        right = [0] * length        result = [0] * length        left[0] = 1        right[length -  1] = 1        for i in range(1, length):            left[i] = nums[i - 1] * left[i - 1]        for j in reversed(range(length - 1)):            right[j] = nums[j + 1] * right[j + 1]        for i in range(length):            result[i] = left[i] * right[i]        return result\n\n2. 空间复杂度O(1)O(1)O(1)的方法\n用结果数组先作为左乘积列表，然后使用临时变量记录每个右乘积并更新数组\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; result(length);        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] result = new int[length] ;        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        result = [0] * length        result[0] = 1        for i in range(1, length):            result[i] = nums[i - 1] * result[i - 1]        rightMul = 1        for j in reversed(range(length)):            result[j] = result[j] * rightMul            rightMul *= nums[j]        return result\n\n二：矩阵置零\n\n1. 使用标记数组\n通过两个数组来记录二维数组中某行或这某列是否包含零\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        vector&lt;int&gt; vRow(nRow);        vector&lt;int&gt; vCol(nCol);        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        int[] vRow = new int[nRow];        int[] vCol = new int[nCol];        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        vRow = [0] * nRow        vCol = [0] * nCol        for i in range(nRow):            for j in range(nCol):                if (matrix[i][j] == 0): vRow[i] = vCol[j] = 1        for i in range(nRow):            for j in range(nCol):                if (vRow[i] == 1 or vCol[j] == 1): matrix[i][j] = 0\n\n2. 使用两个标记变量\n使用第一行和第一列来记录其余位置的零，再使用两个标记变量来记录第一行和第一列的情况\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstRow = false;        bool firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstRow = false;        boolean firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        firstRow = False        firstCol = False        for i in range(nRow):            if (matrix[i][0] == 0): firstCol = True        for i in range(nCol):            if (matrix[0][i] == 0): firstRow = True        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0        if (firstCol == True):            for i in range(nRow):                matrix[i][0] = 0        if (firstRow == True):            for i in range(nCol):                matrix[0][i] = 0\n\n3. 使用一个标记变量\n用左上角的元素作为标记变量\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        flag = False        for i in range(nRow):            if (matrix[i][0] == 0): flag = True            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in reversed(range(nRow)):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0            if flag == True:                matrix[i][0] = 0\n\n三：螺旋矩阵\n\n1. 模拟\n定义一个旋转方向，当遇到边界和访问过的节点进行旋转（属于暴力）\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowCnt = matrix.size();        int colCnt = matrix[0].size();        enum Rule &#123;leftToright, upTodow, rightToleft, downToup&#125;;        Rule myRule = Rule::leftToright;        vector&lt;int&gt; results;        vector&lt;vector&lt;int&gt;&gt; visited(rowCnt, vector&lt;int&gt;(colCnt));        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            int nextRow = row, nextCol = col;            results.emplace_back(matrix[row][col]);            visited[row][col] = 1;            if (myRule == 0) nextCol = col + 1;            if (myRule == 1) nextRow = row + 1;            if (myRule == 2) nextCol = col - 1;            if (myRule == 3) nextRow = row - 1;            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                myRule = static_cast&lt;Rule&gt;((myRule + 1) % 4);            if (myRule == 0) ++col;            if (myRule == 1) ++row;            if (myRule == 2) --col;            if (myRule == 3) --row;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int rowCnt = matrix.length;        int colCnt = matrix[0].length;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int[][] visited = new int[rowCnt][colCnt];        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;        int directionIndex = 0;        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            results.add(matrix[row][col]);            visited[row][col] = 1;            int nextRow = row + directions[directionIndex][0];            int nextCol = col + directions[directionIndex][1];            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                directionIndex = (directionIndex + 1) % 4;            row += directions[directionIndex][0];            col += directions[directionIndex][1];        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        rowCnt, colCnt = len(matrix), len(matrix[0])        results = []        visited = [[0] * colCnt for _ in range(rowCnt)]        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]        direction_index = 0          row, col = 0, 0        for _ in range(rowCnt * colCnt):            results.append(matrix[row][col])            visited[row][col] = True            next_row = row + directions[direction_index][0]            next_col = col + directions[direction_index][1]            if not (0 &lt;= next_row &lt; rowCnt and 0 &lt;= next_col &lt; colCnt and not visited[next_row][next_col]):                direction_index = (direction_index + 1) % 4            row += directions[direction_index][0]            col += directions[direction_index][1]        return results\n\n2. 按层模拟\n每一圈相当于将最外围的数据输出，需要四个循环将四个边界输出，然后通过大的循环来遍历每一圈，注意圈的截止条件\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;;        int bottom = matrix.size() - 1;        int right = matrix[0].size() - 1;        vector&lt;int&gt; results;        int left = 0, top = 0;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.emplace_back(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.emplace_back(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom) \t\t\t// 到这里可能剩余不足围成圈，如1*n或n*1，此时前两个循环已经足够处理，如果不加以限制，那么在n大于1的情况下，下述的循环将会有一个进入导致最后结尾出现多余的数据            &#123;                for (int i = right - 1; i &gt; left; --i) results.emplace_back(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.emplace_back(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int bottom = matrix.length - 1;        int right = matrix[0].length - 1;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int left = 0, top = 0;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return results;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.add(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.add(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom)             &#123;                for (int i = right - 1; i &gt; left; --i) results.add(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.add(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        bottom, right = len(matrix) - 1, len(matrix[0]) - 1        results = list()         left, top = 0, 0        while left &lt;= right and top &lt;= bottom:            for i in range(left, right + 1): results.append(matrix[top][i])            for i in range(top + 1, bottom + 1): results.append(matrix[i][right])            if left &lt; right and top &lt; bottom:                for i in range(right - 1, left, -1): results.append(matrix[bottom][i])                for i in range(bottom, top, -1): results.append(matrix[i][left])            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1        return results\n\n四：旋转图像\n\n1. 辅助数组\n将旋转后的元素放入新的数组\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        auto result = matrix;        int m = matrix.size();        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        matrix.assign(result.begin(), result.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        int[][] result = new int[m][m];        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        for (int i = 0; i &lt; m; i++) &#123;            System.arraycopy(result[i], 0, matrix[i], 0, m);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        n = len(matrix)        result = [[0] * n for _ in range(n)]        for i in range(n):            for j in range(n):                result[j][n - 1 - i] = matrix[i][j]        matrix[:] = result\n\n2. 原地旋转\n参考移动数组的解决方案，这里旋转四次会回到原地，一圈会移动四个数据，那么也就是只需要旋转约四分之一的元素，n的奇的情况下，中间不需要管\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range((m + 1) // 2):                temp = matrix[i][j]                matrix[i][j] = matrix[m - 1 - j][i]                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1]                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1]                matrix[j][m - 1 - i] = temp\n\n3. 翻转\n先水平后主对角线，也可以先竖直\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)                swap(matrix[i][j], matrix[m - i - 1][j]);        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)                swap(matrix[i][j], matrix[j][i]);    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - i - 1][j];                matrix[m - i - 1][j] = temp;            &#125;        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range(m):                matrix[i][j], matrix[m - i - 1][j] = matrix[m - i - 1][j], matrix[i][j]        for i in range(m):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n五：搜索二维矩阵\n\n1. 暴力\n不写\n\n2. 二分\n由于数组左右有序，对每一行使用二分从中间查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        for (auto&amp; row : matrix)        &#123;            auto it = lower_bound(row.begin(), row.end(), target);\t\t\t// 返回不小于目标值的第一个元素的迭代器            if (it != row.end() &amp;&amp; *it == target) return true;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        for (int[] row : matrix)        &#123;            int index = searchInsert(row, target);            if (index != -1) return true;        &#125;        return false;    &#125;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target == nums[mid]) return mid;            else if (target &lt; nums[mid])                     right = mid - 1;            else                left = mid + 1;        &#125;        return -1;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        for row in matrix:            it = bisect.bisect_left(row, target)\t\t\t            if it &lt; len(row) and row[it] == target: return True        return False\n\n3. Z 字形查找\n充分运用题目要求，第二种方法只有了一个条件，但数据从上往下也是递增，从右上角开始，横竖作为边界，也就是说如果某个位置的值小于目标值，行数可以加一，如果大于目标值，则列数应该减一\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m = matrix.size();        int n = matrix[0].size();        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length;        int n = matrix[0].length;        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        m = len(matrix)        n = len(matrix[0])        i = 0        j = n - 1        while i &lt; m and j &gt;= 0:            if (matrix[i][j] == target): return True            elif (matrix[i][j] &gt; target): j -= 1            elif(matrix[i][j] &lt; target): i += 1        return False\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.6)","url":"/posts/6481260b/","content":"一：环形链表2️⃣\n\n1. 哈希表\n这道题的思路和环形链表的方法一相同\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return head;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return head;\t\t\t            hashTable.add(head);            head = head.next;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        hashTable = set()        while head:            if head in hashTable:                return head            hashTable.add(head)            head = head.next        return None\n\n2. 快慢指针\n这道题的思路和环形链表的方法二相同，如果有环相遇点一定在环中，且快指针比慢指针多n圈，进入环之后快指针比慢指针多一圈\n\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return nullptr;        ListNode* fastNode = head;               ListNode* slowNode = head;        while (fastNode != nullptr)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return nullptr;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;            if (fastNode == slowNode)            &#123;                ListNode* cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur-&gt;next;                    slowNode = slowNode-&gt;next;                &#125;                return cur;            &#125;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        if (head == null || head.next == null) return null;        ListNode fastNode = head;               ListNode slowNode = head;        while (fastNode != null)        &#123;            if (fastNode == null || fastNode.next == null) return null;            slowNode = slowNode.next;            fastNode = fastNode.next.next;            if (fastNode == slowNode)            &#123;                ListNode cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur.next;                    slowNode = slowNode.next;                &#125;                return cur;            &#125;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return None        fastNode = head               slowNode = head        while (fastNode != None):            if (fastNode == None or fastNode.next == None): return None            slowNode = slowNode.next            fastNode = fastNode.next.next            if (fastNode == slowNode):                cur = head                while ( cur != slowNode):                     cur = cur.next                    slowNode = slowNode.next                return cur        return None\n\n二：两数相加\n\n1. 模拟\n直接对对应节点的数字进行相加，难点在于处理进位和非对齐的场景\nclass Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        int carry = 0;        ListNode* head = nullptr;        ListNode* cur = nullptr;        while (l1 != nullptr || l2 != nullptr)        &#123;            int num1= l1 ? l1-&gt;val : 0;            int num2= l2 ? l2-&gt;val : 0;            int sum= num1 + num2 + carry;            if (head == nullptr)                cur = head = new ListNode(sum % 10);            else                cur = cur-&gt;next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != nullptr) l1 = l1-&gt;next;            if (l2 != nullptr) l2 = l2-&gt;next;        &#125;        if (carry != 0) cur-&gt;next = new ListNode(carry);        return head;    &#125;&#125;;\nclass Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int carry = 0;        ListNode head = null;        ListNode cur = null;        while (l1 != null || l2 != null)        &#123;            int num1= l1 != null ? l1.val : 0;            int num2= l2 != null ? l2.val : 0;            int sum= num1 + num2 + carry;            if (head == null)                cur = head = new ListNode(sum % 10);            else                cur = cur.next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        if (carry != 0) cur.next = new ListNode(carry);        return head;    &#125;&#125;\nclass Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        carry = 0        head = None        cur = None        while (l1 != None or l2 != None):            num1 = l1.val if l1 else 0            num2 = l2.val if l2 else 0            sum= num1 + num2 + carry            if (head == None):                head = ListNode(sum % 10)                cur = head            else:                cur.next = ListNode(sum % 10)                cur = cur.next            carry = sum // 10            if (l1 != None): l1 = l1.next            if (l2 != None): l2 = l2.next        if (carry != 0): cur.next = ListNode(carry)        return head\n\n三：删除链表的倒数第 N 个结点\n\n1. 计算链表长度\n需要一个虚拟头结点，这样可以删除任意的节点，否则如果只有一个节点并删除自己，则需要单独处理\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        int length = GetLength(head);        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur-&gt;next;        &#125;        cur-&gt;next = cur-&gt;next-&gt;next;        ListNode* ans = dummy-&gt;next;        return ans;    &#125;    int GetLength(ListNode* head)    &#123;        int length = 0;        while (head)        &#123;            head = head-&gt;next;            ++length;        &#125;         return length;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        int length = GetLength(head);        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur.next;        &#125;        cur.next = cur.next.next;        ListNode ans = dummy.next;        return ans;    &#125;    public int GetLength(ListNode head)    &#123;        int length = 0;        while (head != null)        &#123;            head = head.next;            ++length;        &#125;         return length;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        def GetLength(head : Optional[ListNode]) -&gt; Optional[int]:            length = 0            while (head != None):                head = head.next                length += 1            return length        length = GetLength(head)        cur = ListNode(0, head)        dummy = cur        for i in range(1, length + 1 -n):            cur = cur.next        cur.next = cur.next.next        ans = dummy.next        return ans\n\n2. 栈\n用一个栈去存储节点，之后弹出的第n个节点就是需要删除的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        stack&lt;ListNode*&gt; stk;        while (cur != nullptr)         &#123;            stk.push(cur);            cur = cur-&gt;next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.top();        head-&gt;next = head-&gt;next-&gt;next;        return dummy-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        Deque&lt;ListNode&gt; stk = new LinkedList&lt;&gt;();        while (cur != null)         &#123;            stk.push(cur);            cur = cur.next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.peek();        head.next = head.next.next;        return dummy.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        cur = ListNode(0, head)        dummy = cur        stk = list()        while (cur != None):             stk.append(cur)            cur = cur.next        for i in range(n): stk.pop()        head = stk[-1]        head.next = head.next.next        return dummy.next\n\n3. 双指针\n使用两个指针，快指针比慢指针多n个节点，快指针到达末尾则慢指针位置就是需要处理的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* slow = pre;           // 不从head开始的原因在于，可以刚好到达倒数第n节点的前继结点        ListNode* fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast-&gt;next;        while (fast != nullptr)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        slow-&gt;next = slow-&gt;next-&gt;next;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode pre = new ListNode(0, head);        ListNode slow = pre;                 ListNode fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast.next;        while (fast != null)        &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return pre.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        slow = pre                 fast = head        for i in range(n): fast = fast.next        while (fast != None):            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return pre.next\n\n四：两两交换链表中的节点\n\n1. 递归\n终止条件为末尾只有单个节点或没有节点，一个递归需要处理两个节点\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return head;        ListNode* n1 = head-&gt;next;        head-&gt;next = swapPairs(n1-&gt;next);        n1-&gt;next = head;        return n1;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) return head;        ListNode n1 = head.next;        head.next = swapPairs(n1.next);        n1.next = head;        return n1;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return head        n1 = head.next        head.next = self.swapPairs(n1.next)        n1.next = head        return n1\n\n2. 迭代\n我们定义一个前继结点，依次交换后面的两个节点，然后前继结点向前移动两个位置\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* cur = pre;        while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)        &#123;            ListNode* n1 = cur-&gt;next;            ListNode* n2 = cur-&gt;next-&gt;next;            cur-&gt;next = n2;            n1-&gt;next = n2-&gt;next;            n2-&gt;next = n1;            cur = n1;        &#125;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0, head);        ListNode cur = pre;        while (cur.next != null &amp;&amp; cur.next.next != null)        &#123;            ListNode n1 = cur.next;            ListNode n2 = cur.next.next;            cur.next = n2;            n1.next = n2.next;            n2.next = n1;            cur = n1;        &#125;        return pre.next;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        cur = pre        while (cur.next != None and cur.next.next != None):            n1 = cur.next            n2 = cur.next.next            cur.next = n2            n1.next = n2.next            n2.next = n1            cur = n1        return pre.next\n\n五：随机链表的复制\n\n1. 回溯+哈希表\n该题的难度在于随机指针的处理，因为拷贝节点时，随机指针指向的节点可能还未创建，一种方法是先不拷贝随机指针，在第二次循环中再拷贝，或者利用递归的思想反向处理\nclass Solution &#123;public:    unordered_map&lt;Node*, Node*&gt; hashMap;    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return head;        if (!hashMap.count(head))        &#123;            Node* newNode = new Node(head-&gt;val);            hashMap[head] = newNode;            newNode-&gt;next = copyRandomList(head-&gt;next);     // 到这里完成了除随机指针的拷贝            newNode-&gt;random = copyRandomList(head-&gt;random);\t\t// 等效于第二次遍历，此时节点已完成创建        &#125;        return hashMap[head];    &#125;&#125;;\nclass Solution &#123;    public Map&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();    public Node copyRandomList(Node head) &#123;        if (head == null) return head;        if (hashMap.containsKey(head) == false)        &#123;            Node newNode = new Node(head.val);            hashMap.put(head, newNode);            newNode.next = copyRandomList(head.next);                 newNode.random = copyRandomList(head.random);             &#125;        return hashMap.get(head);    &#125;&#125;\nclass Solution:    def __init__(self):        self.hashMap = &#123;&#125;\t\t# 这里初始化    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return head        if (head not in self.hashMap):            newNode= Node(head.val)            self.hashMap[head] = newNode            newNode.next = self.copyRandomList(head.next)                 newNode.random = self.copyRandomList(head.random)             return self.hashMap[head]\n\n2. 迭代+拆分\n将每一个拷贝后的节点作为原节点的后继结点，随机指针则为原指针的随机指针节点的后继位置，空除外\nclass Solution &#123;public:    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return nullptr;        Node* newHead = nullptr;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 建立复制链表        &#123;            Node* newNode = new Node(start-&gt;val);            newNode-&gt;next = start-&gt;next;            start-&gt;next = newNode;        &#125;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 对随机指针赋值        &#123;            if (start-&gt;random != nullptr) start-&gt;next-&gt;random = start-&gt;random-&gt;next;            else start-&gt;next-&gt;random =nullptr;        &#125;        newHead = head-&gt;next;        for (Node* start = head; start != nullptr; start = start-&gt;next)\t\t\t// 恢复原链表，连接新链表        &#123;            Node* newNode = start-&gt;next;            start-&gt;next = start-&gt;next-&gt;next;            newNode-&gt;next = (newNode-&gt;next != nullptr) ? newNode-&gt;next-&gt;next : nullptr;        &#125;        return newHead;    &#125;&#125;;\nclass Solution &#123;    public Node copyRandomList(Node head) &#123;        if (head == null) return null;        Node newHead = null;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            Node newNode = new Node(start.val);            newNode.next = start.next;            start.next = newNode;        &#125;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            if (start.random != null) start.next.random = start.random.next;            else start.next.random =null;        &#125;        newHead = head.next;        for (Node start = head; start != null; start = start.next)\t\t\t        &#123;            Node newNode = start.next;            start.next = start.next.next;            newNode.next = (newNode.next != null) ? newNode.next.next : null;        &#125;        return newHead;    &#125;&#125;\nclass Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return None        start = head        while start:\t            newNode = Node(start.val)            newNode.next = start.next            start.next = newNode            start = newNode.next        start = head        while start:\t            if (start.random != None): start.next.random = start.random.next            else: start.next.random = None            start = start.next.next        newHead = head.next        start = head        while start:\t\t            newNode = start.next            start.next = start.next.next            if newNode.next:                newNode.next = newNode.next.next            start = start.next        return newHead\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.9)","url":"/posts/e3193ac4/","content":"一：岛屿数量\n假期结束了，没有足够时间刷题了，因此往后只采用一种语言解题，方法还是向官方看齐\n\n1. 深度优先搜索\n遍历所有元素，然后将该元素的周围为1的元素设为0，依次递归，直到下一次循环\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    recursion(grid, i, j);      // 当前位置                &#125;            &#125;        return num;    &#125;    void recursion(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)    &#123;        grid[i][j] = 0;     // 访问过的点设为0        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;) recursion(grid, i - 1, j);     // 遍历上下左右四个点        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;) recursion(grid, i, j - 1);        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;) recursion(grid, i + 1, j);        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;) recursion(grid, i, j + 1);    &#125;&#125;;\n\n2. 广度优先搜索\n广度使用队列来维护节点，优先处理队列顶端的前后左右四个元素\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        queue&lt;pair&lt;int, int&gt;&gt; queueNum;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    grid[i][j] = &#x27;0&#x27;;                    queueNum.push(pair(i, j));                    while (!queueNum.empty())                    &#123;                        auto cur = queueNum.front();                        queueNum.pop();                        int i = cur.first;                        int j = cur.second;                        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i - 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i - 1, j));                        &#125;                        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j - 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j - 1));                        &#125;                        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i + 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i + 1, j));                        &#125;                        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j + 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j + 1));                        &#125;                    &#125;                &#125;        return num;    &#125;&#125;;\n\n3. 并查集\n这个数据结构就是为了处理这种“查询两个元素是否属于同一集合”和“合并两个元素所在的集合”的操作而生的。parent.push_back(i * n + j)将每个元素的父节点保存\nclass UnionFind&#123;public:    vector&lt;int&gt; parent;     // 记录父节点    vector&lt;int&gt; depth;      // 记录节点深度    int count = 0;          // 记录独立森林数    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid)       // 初始化森林和父节点列表    &#123;        int row = grid.size();        int col = grid[0].size();        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    parent.emplace_back(i * col + j);       // 父节点为自己                    ++count;            // 森林数量+1                &#125;                else parent.emplace_back(-1);        // 无父节点                depth.emplace_back(0);           // 深度为1            &#125;    &#125;    int Find(int i)          // 查找父节点    &#123;        if (parent[i] != i) parent[i] = Find(parent[i]);        // 父节点不是本身，向上查找        return parent[i];    &#125;    void Unite(int x, int y)            // 联合    &#123;        x = Find(x);                y = Find(y);        if (x != y)     // 两者父节点不相同，相同节点不必处理        &#123;            if (depth[x] &lt; depth[y]) parent[x] = y;           // 深度浅接到深度深的节点，方便查找            else if (depth[x] &gt; depth[y]) parent[y] = x;            else parent[x] = y;            --count;            x &gt; y ? ++depth[y] : ++depth[x];        &#125;    &#125;&#125;;class Solution &#123;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int nr = grid.size();        if (!nr) return 0;        int nc = grid[0].size();        UnionFind uf(grid);        for (int r = 0; r &lt; nr; ++r)             for (int c = 0; c &lt; nc; ++c)                 if (grid[r][c] == &#x27;1&#x27;) &#123;                    grid[r][c] = &#x27;0&#x27;;           // 不需要，只是为了减少重复访问的次数                    if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r-1) * nc + c);                    if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r+1) * nc + c);                    if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c - 1);                    if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c + 1);                &#125;        return uf.count;    &#125;&#125;;\n\n二：腐烂的橘子\n\n1. 多源广度优先搜索\n使用栈来维护每一层，然后依次判断该层每个节点的上下左右是否被感染，因为每分钟只能感染周围\nclass Solution &#123;public:    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int time = 0;        int numFre = 0;        int row = grid.size();         int col = grid[0].size();        queue&lt;pair&lt;int, int&gt;&gt; Q;        if (row == 0 || col == 0 ) return 0;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == 2)                    Q.push(pair&#123;i ,j&#125;);                if (grid[i][j] == 1)                    ++numFre;            &#125;        if (numFre == 0) return 0;        while (!Q.empty())        &#123;            int size = Q.size();            ++time;            for (int i = 0; i &lt; size; ++i)            &#123;                int x = Q.front().first;                int y = Q.front().second;                Q.pop();                if (x - 1 &gt;= 0 &amp;&amp; grid[x - 1][y] == 1)                &#123;                    grid[x - 1][y] = 2;                    Q.push(pair&#123;x - 1, y&#125;);                    --numFre;                &#125;                if (x + 1 &lt; row &amp;&amp; grid[x + 1][y] == 1)                &#123;                    grid[x + 1][y] = 2;                    Q.push(pair&#123;x + 1, y&#125;);                    --numFre;                &#125;                if (y - 1 &gt;= 0 &amp;&amp; grid[x][y - 1] == 1)                &#123;                    grid[x][y - 1] = 2;                    Q.push(pair&#123;x, y - 1&#125;);                    --numFre;                &#125;                if (y + 1 &lt; col &amp;&amp; grid[x][y + 1] == 1)                &#123;                    grid[x][y + 1] = 2;                    Q.push(pair&#123;x, y + 1&#125;);                    --numFre;                &#125;            &#125;        &#125;        if (numFre != 0) return -1;        return time - 1;    &#125;&#125;;\n\n三：课程表\n\n1. 深度优先搜索\n实际上是判断该结构是否为有向无环图，使用0、1、2来表示节点的状态，再次遇到1表示存在环\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; edge;    vector&lt;int&gt; visit;    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        edge.resize(numCourses);        visit.resize(numCourses);         for (auto&amp; it : prerequisites)            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边        for (int i = 0; i &lt; numCourses; ++i)            if (visit[i] == 0)              // 未访问的节点，每一个都判断防止森林的情况                &#123;                    if (!recursion(i)) return false;                &#125;        return true;            &#125;    bool recursion(int i)    &#123;        visit[i] = 1;               // 表示正在访问，还未完成        for (auto sub : edge[i])        // 寻找子节点        &#123;            if (visit[sub] == 0)                &#123;                    if (!recursion(sub)) return false;                &#125;         // 表明子节点存在环，直接返回无需设为已完成            else if(visit[sub] == 1)      // 访问到正在访问的节点，表明出现环                return false;        &#125;        visit[i] = 2;               // 完成访问        return true;    &#125;&#125;;\n\n2. 广度优先搜索\n用队列维护没有入度的节点，然后对每个子节点的入度减一，然后添加子节点到队列，记录的子节点数量和题目要求的值相同表明可以完成课程\nclass Solution &#123;public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;vector&lt;int&gt;&gt; edge;        vector&lt;int&gt; inEdge;        edge.resize(numCourses);        inEdge.resize(numCourses);         for (auto&amp; it : prerequisites)        &#123;            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边            ++inEdge[it[0]];                    // 入边的数量        &#125;        queue&lt;int&gt; q;        int allNum = 0;        for (int i = 0; i &lt; numCourses; ++i)        // 没有入度的节点            if (inEdge[i] == 0) q.push(i);        while (!q.empty())        &#123;            ++allNum;            int cur = q.front();            q.pop();            for (auto&amp; sub : edge[cur])            &#123;                --inEdge[sub];                if (inEdge[sub] == 0) q.push(sub);            &#125;        &#125;        return allNum == numCourses;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"LeetCode热题100(25.10.8)","url":"/posts/fa020b85/","content":"一：二叉树的右视图\n\n1. 深度优先搜索\n通过另一个深度栈来维护每一层唯一的可见值，这个值为后添加的右节点\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        stack&lt;TreeNode*&gt; stk;        stack&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.top();            stk.pop();            int depth = stkDepth.top(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                if (hashMap.count(depth) == false) hashMap[depth] = node-&gt;val;                stk.push(node-&gt;left);                stk.push(node-&gt;right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Deque&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.pop();            int depth = stkDepth.pop();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                if (hashMap.containsKey(depth) == false) hashMap.put(depth, node.val);                stk.push(node.left);                stk.push(node.right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        stack = [(root, 1)]        while stack:            node, depth = stack.pop()            if (node != None):                maxDepth = max(maxDepth, depth)                if (depth not in hashMap): hashMap[depth] = node.val                    stack.append((node.left, depth + 1))                stack.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n2. 广度优先搜索\n类似于深度，这里使用队列执行先进先出，因此从左节点开始向右遍历\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        queue&lt;TreeNode*&gt; stk;        queue&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.front();            stk.pop();            int depth = stkDepth.front(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                hashMap[depth] = node-&gt;val;\t\t\t// 最后一个节点为可见节点                stk.push(node-&gt;left);                stk.push(node-&gt;right);      \t\t// 先弹出左节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Queue&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.add(root);        stkDepth.add(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.remove();            int depth = stkDepth.remove();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                hashMap.put(depth, node.val);                stk.add(node.left);                stk.add(node.right);      // 优先弹出右节点                stkDepth.add(depth + 1);                stkDepth.add(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        queue = deque([(root, 1)])        while queue:            node, depth = queue.popleft()            if (node != None):                maxDepth = max(maxDepth, depth)                hashMap[depth] = node.val                    queue.append((node.left, depth + 1))                queue.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n二：二叉树展开为链表\n\n1. 前序遍历\n前序遍历得到所有节点的数组，然后逐一构建\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        vector&lt;TreeNode*&gt; listTree;        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode* pre = listTree[i - 1];            TreeNode* cur = listTree[i];            pre-&gt;right = cur;            pre-&gt;left = nullptr;        &#125;    &#125;    void PreOrder(TreeNode* node, vector&lt;TreeNode*&gt;&amp; listTree)    &#123;        if (node != nullptr)         &#123;            listTree.emplace_back(node);            PreOrder(node-&gt;left, listTree);            PreOrder(node-&gt;right, listTree);        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        List&lt;TreeNode&gt; listTree = new ArrayList&lt;&gt;();        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode pre = listTree.get(i - 1);            TreeNode cur = listTree.get(i);            pre.right = cur;            pre.left = null;        &#125;    &#125;    public void PreOrder(TreeNode node, List&lt;TreeNode&gt; listTree)    &#123;        if (node != null)         &#123;            listTree.add(node);            PreOrder(node.left, listTree);            PreOrder(node.right, listTree);        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        listTree = list()        self.PreOrder(root, listTree)        for i in range(1, len(listTree)):            pre = listTree[i - 1]            cur = listTree[i]            pre.right = cur            pre.left = None    def PreOrder(self, node, listTree):        if (node != None):            listTree.append(node)            self.PreOrder(node.left, listTree)            self.PreOrder(node.right, listTree)\n\n2. 前序遍历和展开同步进行\n不使用额外数组，使用栈来使遍历和创建新链表同时进行\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        stack&lt;TreeNode*&gt; stk;        stk.push(root);        TreeNode* pre = nullptr;        while (stk.empty() == false)        &#123;            TreeNode* cur = stk.top();            stk.pop();            if (pre != nullptr)            &#123;                pre-&gt;left = nullptr;                pre-&gt;right = cur;            &#125;            if (cur-&gt;right != nullptr) stk.push(cur-&gt;right);     // 先进右节点出栈可以先处理左节点            if (cur-&gt;left != nullptr) stk.push(cur-&gt;left);            pre = cur;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        stk.push(root);        TreeNode pre = null;        while (stk.isEmpty() == false)        &#123;            TreeNode cur = stk.pop();            if (pre != null)            &#123;                pre.left = null;                pre.right = cur;            &#125;            if (cur.right != null) stk.push(cur.right);     // 先进右节点出栈可以先处理左节点            if (cur.left != null) stk.push(cur.left);            pre = cur;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        stk = [root]        pre = None        while (stk):            cur = stk.pop()            if (pre != None):                pre.left = None                pre.right = cur            if (cur.right != None): stk.append(cur.right)                 if (cur.left != None): stk.append(cur.left)            pre = cur\n\n3. 寻找前驱节点\n这个方法有点类似于二叉树的中序遍历中的Morris方法，通过将左子树最后的右节点指向当前节点的右节点，从而建立连接关系，相当于更改了当前链表的结构\n */class Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        auto cur = root;        while (cur != nullptr)        &#123;            if (cur-&gt;left != nullptr)            &#123;                auto node = cur-&gt;left;                auto next = node;                while (node-&gt;right != nullptr) node = node-&gt;right;      // 一直右移找到当前节点的前继结点                node-&gt;right = cur-&gt;right;                cur-&gt;left = nullptr;                cur-&gt;right = next;            &#125;            cur = cur-&gt;right;        &#125;    &#125;&#125;;\t\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        TreeNode cur = root;        while (cur != null)        &#123;            if (cur.left != null)            &#123;                TreeNode node = cur.left;                TreeNode next = node;                while (node.right != null) node = node.right;      // 一直右移找到当前节点的前继结点                node.right = cur.right;                cur.left = null;                cur.right = next;            &#125;            cur = cur.right;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        cur = root        while (cur != None):            if (cur.left != None):                node = cur.left                next = node                while (node.right != None): node = node.right                     node.right = cur.right                cur.left = None                cur.right = next            cur = cur.right\n\n三：从前序与中序遍历序列构造二叉树\n\n1. 递归\n通过前序遍历找到中序遍历的根节点，然后左右划分依次递归，需要先处理左边，因为先序遍历根节点之后是左子树\nclass Solution &#123;private:    unordered_map&lt;int, int&gt; index;public:    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return nullptr;        &#125;        int preorder_root = preorder_left;        int inorder_root = index[preorder[preorder_root]];        TreeNode* root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int n = preorder.size();        for (int i = 0; i &lt; n; ++i) &#123;            index[inorder[i]] = i;        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;\nclass Solution &#123;    private Map&lt;Integer, Integer&gt; indexMap;    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return null;        &#125;        int preorder_root = preorder_left;        int inorder_root = indexMap.get(preorder[preorder_root]);        TreeNode root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n = preorder.length;        indexMap = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; n; i++) &#123;            indexMap.put(inorder[i], i);        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):            if preorder_left &gt; preorder_right:                return None            preorder_root = preorder_left            inorder_root = index[preorder[preorder_root]]            root = TreeNode(preorder[preorder_root])            size_left_subtree = inorder_root - inorder_left            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)            return root        n = len(preorder)        index = &#123;element: i for i, element in enumerate(inorder)&#125;        return myBuildTree(0, n - 1, 0, n - 1)\n\n2. 迭代\n这个解法巧妙的利用了先序和中序的特点，先序从根节点先到达最后一个左节点，中序则从最后一个左节点开始，当先序的某个节点和中序的第一个相等意味着当前节点的左子树结束，此时用栈来维护没有处理右子树的节点即可\nclass Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if (!preorder.size()) &#123;            return nullptr;        &#125;        TreeNode* root = new TreeNode(preorder[0]);        stack&lt;TreeNode*&gt; stk;        stk.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.size(); ++i) &#123;            int preorderVal = preorder[i];            TreeNode* node = stk.top();            if (node-&gt;val != inorder[inorderIndex]) &#123;                node-&gt;left = new TreeNode(preorderVal);                stk.push(node-&gt;left);            &#125;            else &#123;                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;                    node = stk.top();                    stk.pop();                    ++inorderIndex;                &#125;                node-&gt;right = new TreeNode(preorderVal);                stk.push(node-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if (preorder == null || preorder.length == 0) &#123;            return null;        &#125;        TreeNode root = new TreeNode(preorder[0]);        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();        stack.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.length; i++) &#123;            int preorderVal = preorder[i];            TreeNode node = stack.peek();            if (node.val != inorder[inorderIndex]) &#123;                node.left = new TreeNode(preorderVal);                stack.push(node.left);            &#125; else &#123;                while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;                    node = stack.pop();                    inorderIndex++;                &#125;                node.right = new TreeNode(preorderVal);                stack.push(node.right);            &#125;        &#125;        return root;    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None        root = TreeNode(preorder[0])        stack = [root]        inorderIndex = 0        for i in range(1, len(preorder)):            preorderVal = preorder[i]            node = stack[-1]            if node.val != inorder[inorderIndex]:                node.left = TreeNode(preorderVal)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[inorderIndex]:                    node = stack.pop()                    inorderIndex += 1                node.right = TreeNode(preorderVal)                stack.append(node.right)        return root\n\n四：路径总和 III\n\n1. 深度优先搜索\nclass Solution &#123;public:    int rootSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, long targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = rootSum(root, targetSum);        ret += pathSum(root.left, targetSum);        ret += pathSum(root.right, targetSum);        return ret;    &#125;    public int rootSum(TreeNode root, long targetSum) &#123;        int ret = 0;        if (root == null) &#123;            return 0;        &#125;        int val = root.val;        if (val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root.left, targetSum - val);        ret += rootSum(root.right, targetSum - val);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        def rootSum(root, targetSum):            if root is None:                return 0            ret = 0            if root.val == targetSum:                ret += 1            ret += rootSum(root.left, targetSum - root.val)            ret += rootSum(root.right, targetSum - root.val)            return ret                if root is None:            return 0                    ret = rootSum(root, targetSum)        ret += self.pathSum(root.left, targetSum)        ret += self.pathSum(root.right, targetSum)        return ret\n\n2. 前缀和\nclass Solution &#123;public:    unordered_map&lt;long long, int&gt; prefix;    int dfs(TreeNode *root, long long curr, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        curr += root-&gt;val;        if (prefix.count(curr - targetSum)) &#123;            ret = prefix[curr - targetSum];        &#125;        prefix[curr]++;        ret += dfs(root-&gt;left, curr, targetSum);        ret += dfs(root-&gt;right, curr, targetSum);        prefix[curr]--;        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        prefix[0] = 1;        return dfs(root, 0, targetSum);    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, int targetSum) &#123;        Map&lt;Long, Integer&gt; prefix = new HashMap&lt;Long, Integer&gt;();        prefix.put(0L, 1);        return dfs(root, prefix, 0, targetSum);    &#125;    public int dfs(TreeNode root, Map&lt;Long, Integer&gt; prefix, long curr, int targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = 0;        curr += root.val;        ret = prefix.getOrDefault(curr - targetSum, 0);        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);        ret += dfs(root.left, prefix, curr, targetSum);        ret += dfs(root.right, prefix, curr, targetSum);        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        prefix = collections.defaultdict(int)        prefix[0] = 1        def dfs(root, curr):            if not root:                return 0            ret = 0            curr += root.val            ret += prefix[curr - targetSum]            prefix[curr] += 1            ret += dfs(root.left, curr)            ret += dfs(root.right, curr)            prefix[curr] -= 1            return ret        return dfs(root, 0)\n\n五：二叉树的最近公共祖先\n\n1. 递归\nclass Solution &#123;public:    TreeNode* ans;    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root == nullptr) return false;        bool lson = dfs(root-&gt;left, p, q);        bool rson = dfs(root-&gt;right, p, q);        if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        dfs(root, p, q);        return ans;    &#125;&#125;;\nclass Solution &#123;    private TreeNode ans;    public Solution() &#123;        this.ans = null;    &#125;    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) &#123;        if (root == null) return false;        boolean lson = dfs(root.left, p, q);        boolean rson = dfs(root.right, p, q);        if ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root.val == p.val || root.val == q.val);    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        this.dfs(root, p, q);        return this.ans;    &#125;&#125;\nclass Solution:    def __init__(self):        self.ans = None    def dfs(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; bool:        if not root:            return False        lson = self.dfs(root.left, p, q)        rson = self.dfs(root.right, p, q)        if (lson and rson) or ((root.val == p.val or root.val == q.val) and (lson or rson)):            self.ans = root        return lson or rson or (root.val == p.val or root.val == q.val)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.dfs(root, p, q)        return self.ans\n\n2. 存储父节点\nclass Solution &#123;public:    unordered_map&lt;int, TreeNode*&gt; fa;    unordered_map&lt;int, bool&gt; vis;    void dfs(TreeNode* root)&#123;        if (root-&gt;left != nullptr) &#123;            fa[root-&gt;left-&gt;val] = root;            dfs(root-&gt;left);        &#125;        if (root-&gt;right != nullptr) &#123;            fa[root-&gt;right-&gt;val] = root;            dfs(root-&gt;right);        &#125;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        fa[root-&gt;val] = nullptr;        dfs(root);        while (p != nullptr) &#123;            vis[p-&gt;val] = true;            p = fa[p-&gt;val];        &#125;        while (q != nullptr) &#123;            if (vis[q-&gt;val]) return q;            q = fa[q-&gt;val];        &#125;        return nullptr;    &#125;&#125;;\nclass Solution &#123;    Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();    Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();    public void dfs(TreeNode root) &#123;        if (root.left != null) &#123;            parent.put(root.left.val, root);            dfs(root.left);        &#125;        if (root.right != null) &#123;            parent.put(root.right.val, root);            dfs(root.right);        &#125;    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        dfs(root);        while (p != null) &#123;            visited.add(p.val);            p = parent.get(p.val);        &#125;        while (q != null) &#123;            if (visited.contains(q.val)) &#123;                return q;            &#125;            q = parent.get(q.val);        &#125;        return null;    &#125;&#125;\nclass Solution:    def __init__(self):        self.fa = &#123;&#125;        self.visited = set()    def dfs(self, root: &#x27;TreeNode&#x27;):        if root.left:            self.fa[root.left.val] = root            self.dfs(root.left)        if root.right:            self.fa[root.right.val] = root            self.dfs(root.right)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.fa[root.val] = None  # 根节点没有父节点        self.dfs(root)        while p:            self.visited.add(p.val)            p = self.fa.get(p.val) # 使用.get()避免键不存在时出错        while q:            if q.val in self.visited:                return q            q = self.fa.get(q.val)        return None\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"Modelica之带迁移的掠食者猎物方程","url":"/posts/a129a992/","content":"一、经典 LV：单区域两物种\n目标：在经典的掠食-猎物（Lotka–Volterra, LV）两物种模型上，加入区域间迁移。\n做法：把每个区域都当作一个“本地 LV 子系统”，然后用“扩散式”迁移把同类物种在相邻区域之间耦合（从高密度流向低密度），并保证总量守恒。\n最小两区域（A、B）方程：\nx˙A=αxA−βxAyA+Dx(xB−xA),y˙A=δxAyA−γyA+Dy(yB−yA),x˙B=αxB−βxByB+Dx(xA−xB),y˙B=δxByB−γyB+Dy(yA−yB).\\begin{aligned}\n\\dot x_A &amp;= \\alpha x_A - \\beta x_A y_A + D_x (x_B - x_A),\\\\\n\\dot y_A &amp;= \\delta x_A y_A - \\gamma y_A + D_y (y_B - y_A),\\\\\n\\dot x_B &amp;= \\alpha x_B - \\beta x_B y_B + D_x (x_A - x_B),\\\\\n\\dot y_B &amp;= \\delta x_B y_B - \\gamma y_B + D_y (y_A - y_B).\n\\end{aligned}\nx˙A​y˙​A​x˙B​y˙​B​​=αxA​−βxA​yA​+Dx​(xB​−xA​),=δxA​yA​−γyA​+Dy​(yB​−yA​),=αxB​−βxB​yB​+Dx​(xA​−xB​),=δxB​yB​−γyB​+Dy​(yA​−yB​).​\n\n二、代码讲解\n\n⚠️：下述代码仅代表部分功能实现的示例，并不是完整代码，完整代码后续会考虑上传至GitHub\n\n1) 接口层：Interfaces.Species\n作用：一根线同时承载两个量：种群数量（population）和对它的“作用流”（rate，flow 变量）。\nconnector Species &quot;物种连接器：传递种群数量与通量&quot;  Real population &quot;种群数量&quot;;  flow Real rate &quot;作用于种群的通量（正为流入，负为流出）&quot;;  annotation(Icon(graphics=&#123;      Rectangle(extent=&#123;&#123;-80,60&#125;,&#123;80,-60&#125;&#125;, lineColor=&#123;0,0,0&#125;, fillColor=&#123;220,220,255&#125;),      Text(extent=&#123;&#123;-80,65&#125;,&#123;80,85&#125;&#125;, string=&quot;物种&quot;, fontSize=12)&#125;),            Documentation(info=&quot;&lt;html&gt;&lt;p&gt;用于在组件之间传递“种群数量（population）”与其变化通量（rate）。&lt;/p&gt;&lt;/html&gt;&quot;));end Species;\n\n2) 基础组件：繁殖/饥饿/捕食\n\n\nReproduction（繁殖）：对单一物种，增长与数量成正比\nmodel Reproduction &quot;繁殖：增长与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real alpha &quot;出生率比例系数 α&quot;;equation  growth = alpha * species.population &quot;增长 ~ α·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;繁殖&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;繁殖项：&lt;code&gt;growth = α·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Reproduction;\n\n\nStarvation（饥饿/自然死亡）：对单一物种，衰退与数量成正比\nmodel Starvation &quot;饥饿：衰退与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real gamma &quot;饥饿（死亡）系数 γ&quot;;equation  decline = gamma * species.population &quot;衰退 ~ γ·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,220,220&#125;, lineColor=&#123;150,0,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;饥饿&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;饥饿/自然死亡项：&lt;code&gt;decline = γ·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Starvation;\n\n\nPredation（捕食）：两物种相互作用（A=猎物，B=掠食者）\nmodel Predation &quot;捕食：A为猎物，B为捕食者&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Interaction;  parameter Real beta  &quot;猎物被捕食系数 β&quot;;  parameter Real delta &quot;捕食者摄食增殖系数 δ&quot;;equation  b_growth = delta * a.population * b.population &quot;B增长 ~ δ·A·B&quot;;  a_decline = beta  * a.population * b.population &quot;A衰退 ~ β·A·B&quot;;  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,240,200&#125;, lineColor=&#123;120,60,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;捕食&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;经典 Lotka–Volterra 捕食项。&lt;/p&gt;&lt;/html&gt;&quot;));end Predation;\n\n\n\n3) 区域内状态持有者：RegionalPopulation\n作用：把连接器里的 rate 积分成状态 population；这是唯一持有微分方程的地方。\nmodel RegionalPopulation &quot;区域内的单物种种群（带初始化选项）&quot;  encapsulated type InitializationOptions = enumeration(    Free &quot;自由：不施加额外初值条件&quot;,    FixedPopulation &quot;固定初值：指定初始种群&quot;,    SteadyState &quot;稳态：初始导数为0&quot;);  parameter InitializationOptions init = InitializationOptions.Free     annotation(Dialog(group=&quot;初始化&quot;));  parameter Real initial_population = 10     annotation(Dialog(group=&quot;初始化&quot;, enable=init==InitializationOptions.FixedPopulation));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species species     annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  Real population(start=initial_population) &quot;内部状态 = 外部连接器的 population&quot;;initial equation  if init == InitializationOptions.FixedPopulation then    population = initial_population;  elseif init == InitializationOptions.SteadyState then    der(population) = 0;  end if;equation  der(population) = species.rate;  species.population = population;  assert(population &gt;= 0, &quot;种群数量必须非负&quot;);  annotation(Icon(graphics=&#123;    Circle(extent=&#123;&#123;-40,40&#125;,&#123;40,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-50,45&#125;,&#123;50,65&#125;&#125;, string=&quot;区域种群&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;区域内的单物种状态持有者，&lt;code&gt;der(population) = rate&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end RegionalPopulation;\n\n4) 区域两物种子系统：TwoSpecies\n作用：组装“兔-狐”这对物种在单一区域内的 LV 过程。\nmodel TwoSpecies &quot;区域两物种（兔-狐）Lotka–Volterra 子系统&quot;  import RegionalPopulation = ModelicaByExample_CN.Components.LotkaVolterra.Components.RegionalPopulation;  import Reproduction      = ModelicaByExample_CN.Components.LotkaVolterra.Components.Reproduction;  import Starvation        = ModelicaByExample_CN.Components.LotkaVolterra.Components.Starvation;  import Predation         = ModelicaByExample_CN.Components.LotkaVolterra.Components.Predation;  parameter Real alpha = 0.1 &quot;兔出生率 α&quot;;  parameter Real gamma = 0.4 &quot;狐饥饿系数 γ&quot;;  parameter Real initial_rabbit_population = 10 &quot;兔初始数量&quot;;  parameter Real initial_fox_population    = 10 &quot;狐初始数量&quot;;  parameter Real beta  = 0.02 &quot;兔被捕食系数 β&quot;;  parameter Real delta = 0.02 &quot;狐摄食增殖系数 δ&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbits    &quot;本区域的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-10&#125;,&#123;-90,10&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species foxes    &quot;本区域的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  RegionalPopulation rabbit_population(    initial_population=initial_rabbit_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;-60,-10&#125;,&#123;-40,10&#125;&#125;)));  Reproduction reproduction(alpha=alpha)     annotation(Placement(transformation(extent=&#123;&#123;-80,30&#125;,&#123;-60,50&#125;&#125;)));  RegionalPopulation fox_population(    initial_population=initial_fox_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;40,-10&#125;,&#123;60,10&#125;&#125;)));  Starvation fox_starvation(gamma=gamma)     annotation(Placement(transformation(extent=&#123;&#123;60,30&#125;,&#123;80,50&#125;&#125;)));  Predation fox_predation(beta=beta, delta=delta)     annotation(Placement(transformation(extent=&#123;&#123;-10,-10&#125;,&#123;10,10&#125;&#125;)));equation  connect(reproduction.species,      rabbit_population.species);  connect(fox_predation.a,           rabbit_population.species);  connect(fox_starvation.species,    fox_population.species);  connect(fox_population.species,    fox_predation.b);  connect(rabbit_population.species, rabbits);  connect(fox_population.species,    foxes);  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,60&#125;,&#123;60,-60&#125;&#125;, fillColor=&#123;255,255,200&#125;, lineColor=&#123;0,0,0&#125;),    Text(extent=&#123;&#123;-60,65&#125;,&#123;60,85&#125;&#125;, string=&quot;两物种区域&quot;, fontSize=12)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;该子系统组合了：兔（繁殖）+ 狐（饥饿）+ 捕食（A=兔,B=狐）。&lt;/p&gt;&lt;/html&gt;&quot;));end TwoSpecies;\n\n5) 迁移组件：Migration\n作用：把两个区域的同类物种通过“差驱动扩散 + 守恒约束”耦合。\nA端： rateA=k (XA−XB),守恒： rateA+rateB=0.\\text{A端：}\\ \\text{rate}_A = k\\,(X_A - X_B),\\qquad\n\\text{守恒：}\\ \\text{rate}_A + \\text{rate}_B = 0.\nA端： rateA​=k(XA​−XB​),守恒： rateA​+rateB​=0.\nmodel Migration &quot;迁移（扩散）模型：A↔B 两区域&quot;  parameter Real rabbit_migration = 0.001 &quot;兔迁移率&quot;;  parameter Real fox_migration    = 0.005 &quot;狐迁移率&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_a    &quot;区域A的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-40&#125;,&#123;-90,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_b    &quot;区域B的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-40&#125;,&#123;110,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_a    &quot;区域A的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,20&#125;,&#123;-90,40&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_b    &quot;区域B的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,20&#125;,&#123;110,40&#125;&#125;)));equation  // 兔扩散：按两区数量差迁移 + 总量守恒  rabbit_a.rate = (rabbit_a.population - rabbit_b.population) * rabbit_migration;  rabbit_a.rate + rabbit_b.rate = 0 &quot;兔总量守恒&quot;;  // 狐扩散：按两区数量差迁移 + 总量守恒  fox_a.rate    = (fox_a.population    - fox_b.population)    * fox_migration;  fox_a.rate + fox_b.rate = 0 &quot;狐总量守恒&quot;;  annotation(Icon(graphics=&#123;    Line(points=&#123;&#123;-50,0&#125;,&#123;50,0&#125;&#125;, color=&#123;0,0,150&#125;),    Polygon(points=&#123;&#123;45,5&#125;,&#123;55,0&#125;,&#123;45,-5&#125;&#125;, fillPattern=FillPattern.Solid),    Text(extent=&#123;&#123;-60,10&#125;,&#123;60,30&#125;&#125;, string=&quot;迁移&quot;, fontSize=11)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;扩散式迁移：通量与两区域人口差成正比，并通过方程 &lt;code&gt;a.rate + b.rate = 0&lt;/code&gt; 保证总量守恒。&lt;/p&gt;&lt;/html&gt;&quot;));end Migration;\n\n6) 顶层系统：WithMigration\n四个区域（A,B,C,D 都是 TwoSpecies），用三段 Migration 串联成 A↔B↔C↔D。\nmodel WithMigration &quot;四区域：相邻迁移耦合（A↔B↔C↔D）&quot;  extends InitiallyDifferent;  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_AB    &quot;A↔B 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-60,10&#125;,&#123;-20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_BC    &quot;B↔C 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-20,10&#125;,&#123;20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_CD    &quot;C↔D 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;20,10&#125;,&#123;60,30&#125;&#125;)));equation  connect(migrate_AB.rabbit_a, A.rabbits);  connect(migrate_AB.rabbit_b, B.rabbits);  connect(migrate_AB.fox_a,    A.foxes);  connect(migrate_AB.fox_b,    B.foxes);  connect(migrate_BC.rabbit_a, B.rabbits);  connect(migrate_BC.rabbit_b, C.rabbits);  connect(migrate_BC.fox_a,    B.foxes);  connect(migrate_BC.fox_b,    C.foxes);  connect(migrate_CD.rabbit_a, C.rabbits);  connect(migrate_CD.rabbit_b, D.rabbits);  connect(migrate_CD.fox_a,    C.foxes);  connect(migrate_CD.fox_b,    D.foxes);end WithMigration;\n\n三、仿真运行\n在 OpenModelica / MWorks 中使用\nOpenModelica / OMEdit：\n\nFile → Open Model/Library… 选择 ModelicaByExample_CN/package.mo\n打开：ModelicaByExample_CN.Subsystems.LotkaVolterra.Examples.WithMigration\nStopTime = 200，点击 Simulate\nPlot：A.rabbits.population、A.foxes.population、…、D.*\n\nMWorks：\n若对 MSL 版本敏感，把顶层 package.mo 中的\nannotation(uses(Modelica(version=&quot;4.0.0&quot;)))\n改成 MWorks 支持的版本（如 4.1.3），然后直接打开package.mo即可。\n\n结果展示\n各个不同的颜色分别代表了不同区域兔子和狐狸的数量\n\n","categories":["Modelica"],"tags":["Modelica","仿真","综合仿真平台开发"]},{"title":"LeetCode热题100(25.10.7)","url":"/posts/7d9a174a/","content":"一：排序链表\n\n1. 自顶向下归并排序\n对链表不断切分，然后使用合并两个有序链表的方式合并\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        return recursion(head, nullptr);    &#125;    ListNode* recursion(ListNode* left, ListNode* right)    &#123;        if (left == nullptr || left-&gt;next == nullptr) return left;        if (left-&gt;next == right)        &#123;            left-&gt;next = nullptr;            return left;        &#125;        ListNode* slow = left, *fast = left;        while (fast != right)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;            if (fast != right) fast = fast-&gt;next;        &#125;        ListNode* mid = slow;        ListNode* leftNew = recursion(left, mid);        ListNode* rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        return recursion(head, null);    &#125;    public ListNode recursion(ListNode left, ListNode right)    &#123;        if (left == null || left.next == null) return left;        if (left.next == right)        &#123;            left.next = null;            return left;        &#125;        ListNode slow = left, fast = left;        while (fast != right)        &#123;            slow = slow.next;            fast = fast.next;            if (fast != right) fast = fast.next;        &#125;        ListNode mid = slow;        ListNode leftNew = recursion(left, mid);        ListNode rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.recursion(head, None)    def recursion(self, left, right):        if (left == None or left.next == None): return left        if (left.next == right):            left.next = None            return left        slow, fast = left, left        while (fast != right):            slow = slow.next            fast = fast.next            if (fast != right): fast = fast.next        mid = slow        leftNew = self.recursion(left, mid)        rightNew = self.recursion(mid, right)        return self.MergeTwoLists(leftNew, rightNew)     def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 自底向上归并排序\n第一层处理两个节点，将它们断开并排序，第二层结束处理四个节点，其中的两两已经处理好，是有序链表，因此可直接排序，依次迭代\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (head == nullptr) return head;        int length = 0;        ListNode* temp = head;        ListNode* pre = new ListNode(0, head);        while (temp != nullptr)        &#123;            ++length;            temp = temp-&gt;next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode* preCur = pre;            ListNode* cur = pre-&gt;next;            while (cur != nullptr)            &#123;                ListNode* node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur-&gt;next != nullptr; ++i) cur = cur-&gt;next;                ListNode* node2 = cur-&gt;next;                cur-&gt;next = nullptr;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != nullptr &amp;&amp; cur-&gt;next !=nullptr; ++i) cur = cur-&gt;next;                ListNode* next = nullptr;                if (cur != nullptr)                &#123;                    next = cur-&gt;next;                    cur-&gt;next = nullptr;                    cur = next;                &#125;                preCur-&gt;next = MergeTwoLists(node1, node2);                while (preCur-&gt;next != nullptr) preCur = preCur-&gt;next;            &#125;        &#125;        return pre-&gt;next;    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        if (head == null) return head;        int length = 0;        ListNode temp = head;        ListNode pre = new ListNode(0, head);        while (temp != null)        &#123;            ++length;            temp = temp.next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode preCur = pre;            ListNode cur = pre.next;            while (cur != null)            &#123;                ListNode node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur.next != null; ++i) cur = cur.next;                ListNode node2 = cur.next;                cur.next = null;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != null &amp;&amp; cur.next !=null; ++i) cur = cur.next;                ListNode next = null;                if (cur != null)                &#123;                    next = cur.next;                    cur.next = null;                    cur = next;                &#125;                preCur.next = MergeTwoLists(node1, node2);                while (preCur.next != null) preCur = preCur.next;            &#125;        &#125;        return pre.next;    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None): return head        length = 0        temp = head        pre = ListNode(0, head)        while (temp != None):            length += 1            temp = temp.next        sub = 1        while (sub &lt; length):            preCur = pre            cur = pre.next            while (cur != None):                node1 = cur                for i in range(1, sub):                    if cur.next:                        cur = cur.next                    else:                        break                node2 = cur.next                cur.next = None                cur = node2                for i in range(1, sub):                    if cur and cur.next:                        cur = cur.next                    else:                        break                next = None                if (cur != None):                    next = cur.next                    cur.next = None                    cur = next                preCur.next = self.MergeTwoLists(node1, node2)                while (preCur.next != None): preCur = preCur.next            sub *= 2        return pre.next    def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n二：LRU缓存\n\n1. 哈希表+双向链表\n使用哈希表保存键和双向链表的节点，节点保存键值和前后指针，这样每个操作都为常数\nclass LRUCache &#123;private:struct DoubleList&#123;    int key;    int value;    DoubleList* pre;    DoubleList* next;    DoubleList() : key(0), value(0), pre(nullptr), next(nullptr) &#123;&#125;    DoubleList(int _key, int _value) : key(_key), value(_value), pre(nullptr), next(nullptr) &#123;&#125;&#125;;public:    unordered_map&lt;int, DoubleList*&gt; hashMap;    DoubleList* head;    DoubleList* tail;    int capacity = 0;    int size = 0;    LRUCache(int capacity) &#123;        this-&gt;capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head-&gt;next = tail;        tail-&gt;pre = head;    &#125;        int get(int key) &#123;        if (hashMap.count(key) == false) return -1;        else        &#123;            DoubleList* cur = hashMap[key];            AddToHead(DeleteNode(cur));            return cur-&gt;value;        &#125;    &#125;        void put(int key, int value) &#123;        if (hashMap.count(key) == false)        &#123;            DoubleList* newNode = new DoubleList(key, value);            hashMap[key] = newNode;            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList* deleteNode = DeleteNode(tail-&gt;pre);                hashMap.erase(deleteNode-&gt;key);                delete deleteNode;                --size;            &#125;        &#125; else        &#123;            DoubleList* cur = hashMap[key];            cur-&gt;value = value;            AddToHead(DeleteNode(cur));        &#125;    &#125;    DoubleList* DeleteNode(DoubleList* node)    &#123;        node-&gt;next-&gt;pre = node-&gt;pre;        node-&gt;pre-&gt;next = node-&gt;next;        return node;    &#125;    void AddToHead(DoubleList* node)    &#123;        node-&gt;pre = head;        node-&gt;next = head-&gt;next;        head-&gt;next = node;        node-&gt;next-&gt;pre = node;    &#125;&#125;;\nclass LRUCache &#123;    class DoubleList    &#123;        int key;        int value;        DoubleList pre;        DoubleList next;        public DoubleList() &#123;&#125;        public DoubleList(int _key, int _value) &#123;key = _key; value = _value;&#125;    &#125;    Map&lt;Integer, DoubleList&gt; hashMap = new HashMap&lt;&gt;();    DoubleList head;    DoubleList tail;    int capacity = 0;    int size = 0;    public LRUCache(int capacity) &#123;        this.capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head.next = tail;        tail.pre = head;    &#125;        public int get(int key) &#123;        if (hashMap.containsKey(key) == false) return -1;        else        &#123;            DoubleList cur = hashMap.get(key);            AddToHead(DeleteNode(cur));            return cur.value;        &#125;    &#125;        public void put(int key, int value) &#123;        if (hashMap.containsKey(key) == false)        &#123;            DoubleList newNode = new DoubleList(key, value);            hashMap.put(key, newNode);            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList deleteNode = DeleteNode(tail.pre);                hashMap.remove(deleteNode.key);                --size;            &#125;        &#125; else        &#123;            DoubleList cur = hashMap.get(key);            cur.value = value;            AddToHead(DeleteNode(cur));        &#125;     &#125;    public DoubleList DeleteNode(DoubleList node)    &#123;        node.next.pre = node.pre;        node.pre.next = node.next;        return node;    &#125;    public void AddToHead(DoubleList node)    &#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;&#125;\nclass LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.size = 0        self.hashMap = dict()        self.head = DoubleList()        self.tail = DoubleList()        self.head.next = self.tail        self.tail.prev = self.head    def get(self, key: int) -&gt; int:        if (key not in self.hashMap): return -1        else:            cur = self.hashMap[key]            self.AddToHead(self.DeleteNode(cur))            return cur.value    def put(self, key: int, value: int) -&gt; None:        if (key not in self.hashMap):            newNode = DoubleList(key, value)            self.hashMap[key] = newNode            self.AddToHead(newNode)            self.size += 1            if (self.size &gt; self.capacity):                   deleteNode = self.DeleteNode(self.tail.pre)                self.hashMap.pop(deleteNode.key)                self.size -= 1        else:            cur = self.hashMap[key]            cur.value = value            self.AddToHead(self.DeleteNode(cur))    def DeleteNode(self, node):        node.next.pre = node.pre        node.pre.next = node.next        return node    def AddToHead(self, node):        node.pre = self.head        node.next = self.head.next        self.head.next = node        node.next.pre = nodeclass DoubleList:    def __init__(self, key = 0, value = 0):        self.key = key        self.value = value        self.prev = None        self.next = None\n\n三：二叉树的层序遍历\n\n1. 广度优先搜索\n用队列表示每一层，逐层遍历\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if (root == nullptr) return result;        queue&lt;TreeNode*&gt; queueTree;        queueTree.push(root);        while (queueTree.empty() == false)        &#123;            int size = queueTree.size();            result.emplace_back(vector&lt;int&gt;());            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode* newNode = queueTree.front();                queueTree.pop();                result.back().emplace_back(newNode-&gt;val);                if (newNode-&gt;left) queueTree.push(newNode-&gt;left);                if (newNode-&gt;right) queueTree.push(newNode-&gt;right);              &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if (root == null) return result;        Queue&lt;TreeNode&gt; queueTree = new LinkedList&lt;&gt;();        queueTree.offer(root);        while (queueTree.isEmpty() == false)        &#123;            int size = queueTree.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode newNode = queueTree.poll();                level.add(newNode.val);                if (newNode.left != null) queueTree.offer(newNode.left);                if (newNode.right != null) queueTree.offer(newNode.right);              &#125;            result.add(level);        &#125;        return result;    &#125;&#125;\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        result = []        if (root == None): return result        queueTree = deque([root])        while (queueTree):            size = len(queueTree)            level = []            for _ in range(size):                newNode = queueTree.popleft()                level.append(newNode.val)                if (newNode.left != None): queueTree.append(newNode.left)                if (newNode.right != None): queueTree.append(newNode.right)              result.append(level)        return result\n\n四：验证二叉搜索树\n\n1. 递归\n参考二叉树的中序遍历的递归写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        return recursion(root, LONG_MIN, LONG_MAX);    &#125;    bool recursion(TreeNode* node, long long min, long long max)    &#123;        if (node == nullptr) return true;        if (node-&gt;val &lt;= min || node-&gt;val &gt;= max) return false;        bool flagLeft = recursion(node-&gt;left, min, node-&gt;val);        bool flagRight = recursion(node-&gt;right, node-&gt;val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public boolean recursion(TreeNode node, long min, long max)    &#123;        if (node == null) return true;        if (node.val &lt;= min || node.val &gt;= max) return false;        boolean flagLeft = recursion(node.left, min, node.val);        boolean flagRight = recursion(node.right, node.val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def recursion(node, min, max):            if (node == None): return True            if (node.val &lt;= min or node.val &gt;= max): return False            flagLeft = recursion(node.left, min, node.val)            flagRight = recursion(node.right, node.val, max)            return flagLeft and flagRight        return recursion(root, float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;))\n\n2. 中序遍历\n参考二叉树的中序遍历的迭代写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        long long min = (long long)INT_MIN - 1;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            treeStack.pop();                    // 拿到数据出栈            if (root -&gt; val &lt;= min) return false;            min = root -&gt; val;            root = root-&gt;right;       &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            if (root.val &lt;= min) return false;            min = root.val;            root = root.right;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        treeStack = []        min = float(&#x27;-inf&#x27;)        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            if (root.val &lt;= min): return False            min = root.val            root = root.right        return True\n\n五：二叉搜索树中第 K 小的元素\n\n1. 中序遍历\n利用中序遍历得到有序数组，找到数组中的第K个元素即可。迭代用栈管理，栈弹出的顺序就是有序列表，因此第K个就是需要的值\nclass Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())              &#123;            while (root != nullptr)            &#123;                treeStack.push(root);                       root = root-&gt;left;            &#125;            root = treeStack.top();                   treeStack.pop();                    // 第一个出栈的为最小元素，出栈k次即可得到结果            --k;            if (k == 0) break;             root = root-&gt;right;       &#125;        return root-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            --k;            if (k == 0) break;            root = root.right;        &#125;        return root.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            k -= 1            if (k == 0): break            root = root.right        return root.val\n\n2. 记录子树的节点\n把每个节点的左右子树的节点数量记录，此时只需要判断k与子树节点数量的大小，因为左子树一定小于当前节点，右子树大于当前节点。适用于频繁寻找k值\nclass Solution &#123;public:    unordered_map&lt;TreeNode*, int&gt; hashMap;    TreeNode* root;    int kthSmallest(TreeNode* root, int k) &#123;        this-&gt;root = root;        CountNum(root);        return SearchTarget(k);    &#125;    int CountNum(TreeNode* node)    &#123;        if (node == nullptr) return 0;        hashMap[node] = 1 + CountNum(node-&gt;left) + CountNum(node-&gt;right);        return hashMap[node];    &#125;    int GetNum(TreeNode* node)    &#123;        if (node != nullptr &amp;&amp; hashMap.count(node)) return hashMap[node];        else return 0;    &#125;    int SearchTarget(int k)    &#123;        TreeNode* node = root;        while (node != nullptr)        &#123;            int leftNum = GetNum(node-&gt;left);            if (leftNum &lt; k - 1)            &#123;                node = node-&gt;right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node-&gt;left;            else break;        &#125;        return node-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public Map&lt;TreeNode, Integer&gt; hashMap = new HashMap&lt;&gt;();    public TreeNode root;    public int kthSmallest(TreeNode root, int k) &#123;        this.root = root;        CountNum(root);        return SearchTarget(k);    &#125;    public int CountNum(TreeNode node)    &#123;        if (node == null) return 0;        hashMap.put(node, 1 + CountNum(node.left) + CountNum(node.right));        return hashMap.get(node);    &#125;    public int GetNum(TreeNode node)    &#123;        if (node != null &amp;&amp; hashMap.containsKey(node)) return hashMap.get(node);        else return 0;    &#125;    public int SearchTarget(int k)    &#123;        TreeNode node = root;        while (node != null)        &#123;            int leftNum = GetNum(node.left);            if (leftNum &lt; k - 1)            &#123;                node = node.right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node.left;            else break;        &#125;        return node.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        self.hashMap = &#123;&#125;        self.root = root        self.CountNum(self.root)        return self.SearchTarget(k)    def CountNum(self, node):        if (node == None): return 0        self.hashMap[node] = 1 + self.CountNum(node.left) + self.CountNum(node.right)        return self.hashMap[node]    def GetNum(self, node):        if (node != None and node in self.hashMap): return self.hashMap[node]        else: return 0    def SearchTarget(self, k):        node = self.root        while (node != None):            leftNum = self.GetNum(node.left)            if (leftNum &lt; k - 1):                node = node.right                k -= leftNum + 1            elif (leftNum &gt; k - 1): node = node.left            else: break        return node.val\n\n3. 平衡二叉搜索树\n官方给的题解太长了，使用了经典的AVL树数据结构，并添加了一些常用的操作，没必要，简化一下吧\nstruct Node &#123;    int val;    Node * parent;    Node * left;    Node * right;    int size;    int height;    Node(int val, Node * parent) &#123;        this-&gt;val = val;        this-&gt;parent = parent;        this-&gt;left = nullptr;        this-&gt;right = nullptr;        this-&gt;height = 0;         this-&gt;size = 1;     &#125;&#125;;class AVL &#123;public:    Node * root;    AVL(vector&lt;int&gt; &amp; vals) &#123;        if (!vals.empty()) &#123;            root = build(vals, 0, vals.size() - 1, nullptr);        &#125;    &#125;    Node * build(vector&lt;int&gt; &amp; vals, int l, int r, Node * parent) &#123;        int m = (l + r) &gt;&gt; 1;        Node * node = new Node(vals[m], parent);        if (l &lt;= m - 1) &#123;            node-&gt;left = build(vals, l, m - 1, node);        &#125;        if (m + 1 &lt;= r) &#123;            node-&gt;right = build(vals, m + 1, r, node);        &#125;        recompute(node);        return node;    &#125;    void recompute(Node * node) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));        node-&gt;size = 1 + getSize(node-&gt;left) + getSize(node-&gt;right);    &#125;    static int getHeight(Node * node) &#123;        return node != nullptr ? node-&gt;height : 0;    &#125;    static int getSize(Node * node) &#123;        return node != nullptr ? node-&gt;size : 0;    &#125;    int kthSmallest(int k) &#123;        Node * node = root;        while (node != nullptr) &#123;            int left = getSize(node-&gt;left);            if (left &lt; k - 1) &#123;                node = node-&gt;right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node-&gt;left;            &#125;        &#125;        return node-&gt;val;    &#125;&#125;;class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        vector&lt;int&gt; inorderList;        inorder(root, inorderList);        AVL avl(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode * node, vector&lt;int&gt; &amp; inorderList) &#123;        if (node-&gt;left != nullptr) &#123;            inorder(node-&gt;left, inorderList);        &#125;        inorderList.push_back(node-&gt;val);        if (node-&gt;right != nullptr) &#123;            inorder(node-&gt;right, inorderList);        &#125;    &#125;&#125;;\nclass Node &#123;    int val;    Node parent;    Node left;    Node right;    int size;    int height;    Node(int val, Node parent) &#123;        this.val = val;        this.parent = parent;        this.left = null;        this.right = null;        this.height = 0;         this.size = 1;     &#125;&#125;class AVL &#123;    Node root;    AVL(List&lt;Integer&gt; vals) &#123;        if (!vals.isEmpty()) &#123;            root = build(vals, 0, vals.size() - 1, null);        &#125;    &#125;    Node build(List&lt;Integer&gt; vals, int l, int r, Node parent) &#123;        if (l &gt; r) &#123;            return null;        &#125;        int m = l + (r - l) / 2;        Node node = new Node(vals.get(m), parent);        node.left = build(vals, l, m - 1, node);        node.right = build(vals, m + 1, r, node);                recompute(node);        return node;    &#125;    void recompute(Node node) &#123;        if (node == null) return;        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));        node.size = 1 + getSize(node.left) + getSize(node.right);    &#125;    static int getHeight(Node node) &#123;        return node != null ? node.height : 0;    &#125;    static int getSize(Node node) &#123;        return node != null ? node.size : 0;    &#125;    int kthSmallest(int k) &#123;        Node node = root;        while (node != null) &#123;            int left = getSize(node.left);            if (left &lt; k - 1) &#123;                node = node.right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node.left;            &#125;        &#125;        return node.val;    &#125;&#125;class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        List&lt;Integer&gt; inorderList = new ArrayList&lt;&gt;();        inorder(root, inorderList);                if (inorderList.isEmpty() || k &lt;= 0 || k &gt; inorderList.size()) &#123;            return -1;        &#125;        AVL avl = new AVL(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode node, List&lt;Integer&gt; inorderList) &#123;        if (node == null) &#123;            return;        &#125;        inorder(node.left, inorderList);        inorderList.add(node.val);        inorder(node.right, inorderList);    &#125;&#125;\nclass Node:    def __init__(self, val: int, parent: Optional[&#x27;Node&#x27;] = None):        self.val = val        self.parent = parent        self.left = None        self.right = None        self.height = 0        self.size = 1class AVL:    def __init__(self, vals: List[int]):        self.root: Optional[Node] = None        if vals:            self.root = self.build(vals, 0, len(vals) - 1, None)    def build(self, vals: List[int], l: int, r: int, parent: Optional[Node]) -&gt; Optional[Node]:        if l &gt; r:            return None                m = (l + r) // 2        node = Node(vals[m], parent)                node.left = self.build(vals, l, m - 1, node)        node.right = self.build(vals, m + 1, r, node)                self.recompute(node)        return node    def recompute(self, node: Node):        if node is None:            return                    left_height = AVL.get_height(node.left)        right_height = AVL.get_height(node.right)                node.height = 1 + max(left_height, right_height)        node.size = 1 + AVL.get_size(node.left) + AVL.get_size(node.right)    @staticmethod    def get_height(node: Optional[Node]) -&gt; int:        return node.height if node else 0    @staticmethod    def get_size(node: Optional[Node]) -&gt; int:        return node.size if node else 0    def kthSmallest(self, k: int) -&gt; int:        node = self.root        while node:            left_size = AVL.get_size(node.left)                        if left_size &lt; k - 1:                k -= left_size + 1                node = node.right            elif left_size == k - 1:                return node.val            else:                node = node.left                return -1class Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        inorder_list: List[int] = []        self._inorder(root, inorder_list)                if not inorder_list or k &lt;= 0 or k &gt; len(inorder_list):            return -1                    avl = AVL(inorder_list)        return avl.kthSmallest(k)    def _inorder(self, node: Optional[TreeNode], inorder_list: List[int]):        if node is None:            return                    self._inorder(node.left, inorder_list)        inorder_list.append(node.val)        self._inorder(node.right, inorder_list)\n\n","categories":["算法"],"tags":["LeetCode","C++","Python","Java"]},{"title":"Python实战之Web开发-续","url":"/posts/71a5f1f6/","content":"用户账户\n用户添加主题\n在learning_log目录中创建forms.py文件，添加\nfrom django import formsfrom .models import Topicclass TopicForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating topics.&quot;&quot;&quot;    class Meta:        model = Topic        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field\n添加URL：path('new_topic/', views.new_topic, name='new_topic')\n创建视图函数new_topic\ndef new_topic(request):    &quot;&quot;&quot;Add a new topic.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = TopicForm()    else:        # POST data submitted; process data.        form = TopicForm(data=request.POST)        if form.is_valid():            new_topic = form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=new_topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_topic.html&#x27;, context)\n创建模板new_topic.html\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Add a new topic:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;\n链接到页面：&lt;a href = &quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt;\n代码解释：当用户在网页中点击 &lt;a href=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt; 这个链接时，浏览器会跳转到 /new_topic/。这个路径在 urls.py 中由 path('new_topic/', views.new_topic, name='new_topic') 映射到 views.new_topic 函数。\n当请求被送到这个视图函数时，Django 会调用 new_topic(request) 来处理。这个视图首先判断请求的方法是不是 POST。如果用户只是点击链接，还没提交表单，那么请求方法是 GET，程序会创建一个空的表单对象 form = TopicForm()，此时这个表单中没有预填数据，只是用于初次显示在网页上。\n如果用户已经在表单中输入了内容并点击了提交按钮，那么浏览器发送的是 POST 请求，此时视图就会执行 form = TopicForm(data=request.POST) 来从用户提交的数据构造一个表单实例。接着通过 form.is_valid() 检查数据是否合法（比如字段有没有漏填，格式是否正确）。如果验证通过，就执行 form.save()，这会自动创建一条新的 Topic 记录并保存到数据库中。接着用 redirect('learning_log:topic', topic_id=new_topic.id) 跳转到刚创建的主题详情页。\n不论是初次打开页面，还是提交失败（例如空表单或非法输入），视图最后都会调用 render(request, 'learning_log/new_topic.html', context) 来渲染模板，把表单对象传入 context 变量中。\n这个模板 new_topic.html 继承自 base.html，并在 &#123;% block content %&#125; 中放入了一段 HTML 表单。&lt;form action=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot; method=&quot;post&quot;&gt; 声明了该表单提交回自己；&#123;% csrf_token %&#125; 是 Django 要求添加的防跨站攻击标记；&#123;&#123; form.as_div &#125;&#125; 是将表单对象渲染为 HTML 元素。最后 &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt; 是提交按钮。\n添加条目\n代码如下\n# 新建formclass EntryForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating entries.&quot;&quot;&quot;    class Meta:        model = Entry        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field        widgets = &#123;&#x27;text&#x27;: forms.Textarea(attrs=&#123;&#x27;cols&#x27;: 80&#125;)&#125;  # Wider text area        # 添加URLpath(&#x27;new_entry/&lt;int:topic_id&gt;/&#x27;, views.new_entry, name=&#x27;new_entry&#x27;)# 添加视图def new_entry(request, topic_id):    &quot;&quot;&quot;Add a new entry for a particular topic.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = EntryForm()    else:        # POST data submitted; process data.        form = EntryForm(data=request.POST)        if form.is_valid():            new_entry = form.save(commit=False)            new_entry.topic = topic            new_entry.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic_id)    # Display a blank or invalid form.    context = &#123;&#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_entry.html&#x27;, context)\n&#123;# 新建模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Add a new entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Entry&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add a new entry&lt;/a&gt;    &lt;/p&gt;\n代码解释：这一套代码实现了在某个具体主题（Topic）下添加新学习内容（Entry）的功能。它包括一个基于模型的表单 EntryForm，用于生成输入框，主要针对 Entry 模型中的 text 字段，并通过 widgets 设置了一个宽一些的多行文本区域。URL 配置中使用了路径参数 &lt;int:topic_id&gt; 来标识具体主题，这样不同主题就能通过不同链接添加各自的学习记录。视图函数 new_entry 首先获取对应的 Topic 实例，然后根据请求方法判断是初次访问还是表单提交。如果是提交请求，就根据提交内容构造表单并校验，若通过验证，就先创建一个未保存的 Entry 实例，手动指定其 topic 属性，然后保存到数据库，并跳转回该主题的详情页。\n模板部分继承自基础模板 base.html，显示了当前主题的名称，并提供一个表单用于输入新条目。提交按钮下方还包含一个返回原主题页面的链接。最后那段 HTML 链接代码负责在主题详情页中显示“Add a new entry”按钮，点击即可跳转到添加页面。\n\n编辑条目\n代码如下\n# 添加URLpath(&#x27;edit_entry/&lt;int:entry_id&gt;/&#x27;, views.edit_entry, name=&#x27;edit_entry&#x27;)# 添加edit_entry函数def edit_entry(request, entry_id):    &quot;&quot;&quot;Edit an existing entry.&quot;&quot;&quot;    entry = Entry.objects.get(id=entry_id)    topic = entry.topic    if request.method != &#x27;POST&#x27;:        # Initial request; pre-fill form with the current entry.        form = EntryForm(instance=entry)    else:        # POST data submitted; process data.        form = EntryForm(instance=entry, data=request.POST)        if form.is_valid():            form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;entry&#x27;: entry, &#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/edit_entry.html&#x27;, context)\n&#123;# 添加html #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Edit entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Save Changes&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;&lt;li&gt;    &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;Edit entry&lt;/a&gt;    &lt;/p&gt;&lt;/li&gt;\n创建用户\n首先创建一个新的应用程序来管理账户相关的内容\npython .\\manage.py startapp accounts\n在INSTALLED_APPS中添加accounts，并包含accounts的URL：path('accounts/', include('accounts.urls'))\n在accounts中新建urls.py，添加以下内容\nfrom django.urls import path, includeapp_name = &#x27;accounts&#x27;urlpatterns = [    # Include the default auth URLs    path(&#x27;&#x27;, include(&#x27;django.contrib.auth.urls&#x27;)),]\n在templates中新建registration文件夹，添加login.html文件\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;  &#123;% if form.errors %&#125;    &lt;p&gt;Your username and password didn&#x27;t match. Please try again.&lt;/p&gt;  &#123;% endif %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Log in&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;\n随后在settings中添加成功登录后的重定向地址：LOGIN_REDIRECT_URL = 'learning_log:index'\n修改base.html如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt; -    &lt;a href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;Topics&lt;/a&gt; -     &#123;% if user.is_authenticated %&#125;        Hello, &#123;&#123; user.username &#125;&#125;! -        &#123;% else %&#125;        &lt;a href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;Log in&lt;/a&gt; -        &#123;% endif %&#125;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n此时就可以通过http://localhost:8000/accounts/login/来登录了，可以使用我们的管理员账号来测试（提前在管理界面退出）\n\n注销和注册用户\n注销账户\n在base.html中添加注销表单\n&#123;% if user.is_authenticated %&#125;  &lt;hr /&gt;  &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &lt;button name=&#x27;submit&#x27;&gt;Log out&lt;/button&gt;  &lt;/form&gt;&#123;% endif %&#125;\n如果账户登录，那么则在最下方显示一个注销按钮用于注销账户，注销后将页面链接到主页：LOGOUT_REDIRECT_URL = 'learning_log:index'\n注册账户\n# 添加URLpath(&#x27;register/&#x27;, views.register, name=&#x27;register&#x27;)# 创建视图函数def register(request):    &quot;&quot;&quot;Register a new user.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # Display blank registration form.        form = UserCreationForm()    else:        # Process completed form.        form = UserCreationForm(data=request.POST)        if form.is_valid():            new_user = form.save()            # Log the user in and then redirect to home page.            login(request, new_user)            return redirect(&#x27;learning_log:index&#x27;)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;registration/register.html&#x27;, context)\n&#123;# 创建模板 #&#125;&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Register&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接注册界面 #&#125;&lt;a href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register&lt;/a&gt; -\n当用户登录后，base.html 会显示一个“注销”按钮，它触发的是 accounts:logout 路由（即 Django 默认的登出视图），并通过 LOGOUT_REDIRECT_URL = 'learning_log:index' 设置注销后跳转回主页。\n对于注册功能，定义了一个新的 URL 路由 /accounts/register/，并在对应视图函数 register() 中使用 Django 提供的 UserCreationForm 构建注册表单。如果请求为 POST，则处理表单提交并保存用户数据，注册成功后自动登录该用户，并重定向到主页。否则显示一个空白或验证失败的注册表单。\n前端模板继承自 base.html，通过 &#123;% csrf_token %&#125; 加入安全标记，表单本体使用 &#123;&#123; form.as_div &#125;&#125; 渲染输入字段，点击“Register”按钮即可提交注册。\n创建用户数据\n在未登录的状态下，learning_log中的内容除了主页外，其余内容应该均不可访问，对此我们通过装饰器@login_required来限制未登录用户的访问，如果用户未登录，我们将其重定向到登录界面，在settings中添加LOGIN_URL = 'accounts:login'即可\n对于不同的用户，除了主页外，其他的内容应该只能访问自己的部分，我们将数据关联到用户，在Topic中添加owner = models.ForeignKey(User, on_delete=models.CASCADE)，将主题与用户关联。然后把数据库中的内容进行迁移，由于我们新增了owner字段，迁移时会提示我们选择哪一种方式，我们选择“1”让系统自动给我们添加一个默认值，然后将所有的内容迁移到管理账户中，即ID“1”\n\n虽然把主题全部与管理账户进行了关联，但是目前任何用户登录均可访问所有主题，在topics中添加topics = Topic.objects.filter(owner=request.user).order_by('date_added')，将不属于当前用户的所有Topic过滤掉，然后在topic和edit_entry中添加以下代码\nif topic.owner != request.user:    raise Http404\n从而防止用户通过网址直接访问他人的数据\n最后将新的topic关联到当前用户中，添加代码如下\nnew_topic = form.save(commit=False)new_topic.owner = request.usernew_topic.save()\n此时任何用户都可创建自己的账号并拥有自己独立的数据了\n样式更改\n我们的web已经具备基本的功能了，如创建主题、创建与之关联的条目，并且每个用户都有自己的数据而不必担心被其他人访问，但我们的界面还过于简陋，无法吸引用户，因此接下来我们将更改它的布局，使其更加美观\n首先安装django-bootstrap5，我们将使用其中的模板\npip install django-bootstrap5\n然后在INSTALLED_APPS中我们的应用和默认应用之间添加django_bootstrap5，接下来修改base.html\n&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Learning Log&lt;/title&gt;  &#123;% load django_bootstrap5 %&#125;  &#123;% bootstrap_css %&#125;  &#123;% bootstrap_javascript %&#125;&lt;/head&gt;&lt;body&gt;  &lt;nav class=&quot;navbar navbar-expand-md navbar-light bg-light mb-4 border&quot;&gt;    &lt;div class=&quot;container-fluid&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;          Learning Log&lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot;        data-bs-target=&quot;#navbarCollapse&quot; aria-controls=&quot;navbarCollapse&quot;        aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarCollapse&quot;&gt;        &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-md-0&quot;&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;              Topics&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt; &lt;!-- End of links on left side of navbar --&gt;        &lt;!-- Account-related links --&gt;        &lt;ul class=&quot;navbar-nav ms-auto mb-2 mb-md-0&quot;&gt;          &#123;% if user.is_authenticated %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;span class=&quot;navbar-text me-2&quot;&gt;Hello, &#123;&#123; user.username &#125;&#125;.                &lt;/span&gt;&lt;/li&gt;          &#123;% else %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;                  Register&lt;/a&gt;&lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;                  Log in&lt;/a&gt;&lt;/li&gt;          &#123;% endif %&#125;        &lt;/ul&gt; &lt;!-- End of account-related links --&gt;        &#123;% if user.is_authenticated %&#125;          &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;            &#123;% csrf_token %&#125;            &lt;button name=&#x27;submit&#x27; class=&#x27;btn btn-outline-secondary btn-sm&#x27;&gt;              Log out&lt;/button&gt;          &lt;/form&gt;        &#123;% endif %&#125;      &lt;/div&gt; &lt;!-- Closes collapsible parts of navbar --&gt;    &lt;/div&gt; &lt;!-- Closes navbar&#x27;s container --&gt;  &lt;/nav&gt; &lt;!-- End of navbar --&gt;  &lt;main class=&quot;container&quot;&gt;    &lt;div class=&quot;pb-2 mb-2 border-bottom&quot;&gt;      &#123;% block page_header %&#125;&#123;% endblock page_header %&#125;    &lt;/div&gt;    &lt;div&gt;      &#123;% block content %&#125;&#123;% endblock content %&#125;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;&lt;/html&gt;\n修改主页index.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;div class=&quot;p-3 mb-4 bg-light border rounded-3&quot;&gt;    &lt;div class=&quot;container-fluid py-4&quot;&gt;      &lt;h1 class=&quot;display-3&quot;&gt;Track your learning.&lt;/h1&gt;            &lt;p class=&quot;lead&quot;&gt;Make your own Learning Log, and keep a list of the      topics you&#x27;re learning about. Whenever you learn something new      about a topic, make an entry summarizing what you&#x27;ve learned.&lt;/p&gt;      &lt;a class=&quot;btn btn-primary btn-lg mt-1&quot;          href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register &amp;raquo;&lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;&#123;% endblock page_header %&#125;\n修改登录界面login.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% load django_bootstrap5 %&#125;&#123;% block page_header %&#125;  &lt;h2&gt;Log in to your account.&lt;/h2&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;% bootstrap_form form %&#125;    &#123;% bootstrap_button button_type=&quot;submit&quot; content=&quot;Log in&quot; %&#125;  &lt;/form&gt;&#123;% endblock content %&#125;\n修改页面topics的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;Topics&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;ul class=&quot;list-group border-bottom pb-2 mb-4&quot;&gt;    &#123;% for topic in topics %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;          &#123;&#123; topic.text &#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &#123;% empty %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;No topics have been added yet.&lt;/li&gt;    &#123;% endfor %&#125;  &lt;/ul&gt;  &lt;a href=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;&gt;Add a new topic&lt;/a&gt;&#123;% endblock content %&#125;\n修改页面topic条目的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;&#123;&#123; topic.text &#125;&#125;&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add new entry&lt;/a&gt;  &lt;/p&gt;  &#123;% for entry in entries %&#125;    &lt;div class=&quot;card mb-3&quot;&gt;      &lt;!-- Card header with timestamp and edit link --&gt;      &lt;h4 class=&quot;card-header&quot;&gt;        &#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;        &lt;small&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;          edit entry&lt;/a&gt;&lt;/small&gt;      &lt;/h4&gt;      &lt;!-- Card body with entry text --&gt;      &lt;div class=&quot;card-body&quot;&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &#123;% empty %&#125;    &lt;p&gt;There are no entries for this topic yet.&lt;/p&gt;  &#123;% endfor %&#125;&#123;% endblock content %&#125;\n修改后的界面如下\n\n项目部署\n这部分内容主要就是把项目部署到远程服务器上，让其他人访问，全是配置，没啥意思，不搞了\n","categories":["Diango开发"],"tags":["Python"]},{"title":"Python实战之Web开发","url":"/posts/1a56256/","content":"创建Django项目\n我使用Pycharm来创建Django项目，也可以自己手动创建虚拟环境等，配置如下，所有代码可点击这里查看\n\n运行，在浏览器输入http://localhost:8000/，显示如下表明项目创建正确\n\n创建应用程序\n终端输入python manage.py migrate创建数据库，用于将项目相关的信息存储，然后输入python manage.py startapp learning_log来创建应用程序，项目结构如下\n\n.venv/\n\nPython 虚拟环境目录。\n包含你项目安装的所有依赖（如 Django）。\n通常会在 .gitignore 中忽略它。\n\nmanage.py\n\n\n管理工具脚本，用于执行各种 Django 命令，如：\npython manage.py runserver      # 启动开发服务器python manage.py makemigrations # 创建迁移python manage.py migrate        # 应用迁移到数据库python manage.py createsuperuser # 创建管理员账户\n\n\n__init__.py\n\n让该目录成为 Python 包可为空\n\nsettings.py\n\nDjango 项目的配置文件\n包含数据库设置、应用注册、模板路径、静态文件配置、安全设置等\n\nurls.py\n\n\n项目级URL 路由入口\n\n\n将不同的 URL 请求分发给对应的 app 处理\n\n\n通常写法：\nfrom django.urls import path, includeurlpatterns = [    path(&#x27;admin/&#x27;, admin.site.urls),    path(&#x27;&#x27;, include(&#x27;learning_log.urls&#x27;)),  # 指向 app 的 url]\n\n\nwsgi.py\n\n用于部署到 WSGI 服务器\n生产环境使用\n\nasgi.py\n\n用于部署到 ASGI 服务器\n用于支持 WebSocket、异步视图\n\n__init__.py\n\n表示这是一个 Python 包\n\nadmin.py\n\n\n用于注册模型到 Django 管理后台（admin site）\n\n\n示例：\nfrom django.contrib import adminfrom .models import Entryadmin.site.register(Entry)\n\n\napps.py\n\n定义 app 的元信息，通常不需修改\n当你在 INSTALLED_APPS 中注册 app 时，这里也会用到\n\nmodels.py\n\n定义数据模型（Model）类\n每个模型对应数据库中的一张表\n\nviews.py\n\n视图函数，用来处理用户请求并返回响应\n例如返回 HTML 页面、JSON 数据等\n\ntests.py\n\n单元测试文件，可编写自动化测试\nDjango 内建测试框架基于 Python 的 unittest\n\nmigrations/\n\n\n自动生成的数据库迁移文件\n\n\n每当你修改模型（models.py）并运行：\npython manage.py makemigrations\n就会在此生成一个迁移脚本，用于记录数据库变更\n\n\ntemplates/\n\n存放 HTML 模板文件的目录\n用于 Django 的模板引擎渲染页面\n\n例如：\n你可以在 templates/ 中创建 index.html，然后在视图中渲染：\nfrom django.shortcuts import renderdef index(request):    return render(request, &#x27;index.html&#x27;)\ndb.sqlite3\n\n默认使用的 SQLite 数据库文件\n存储了你项目所有模型的数据内容\n\n\n\n\n文件/文件夹\n作用说明\n\n\n\n\n.venv/\n虚拟环境，包含依赖\n\n\nmanage.py\n管理命令脚本\n\n\nDjangoProject/settings.py\n项目配置\n\n\nDjangoProject/urls.py\nURL 路由入口\n\n\nDjangoProject/wsgi.py\n部署用 WSGI 接口\n\n\nlearning_log/\n自定义 app\n\n\nmodels.py\n定义数据库模型\n\n\nviews.py\n编写视图函数\n\n\nadmin.py\n注册后台模型\n\n\nmigrations/\n数据库变更记录\n\n\ntemplates/\nHTML 模板目录\n\n\ndb.sqlite3\nSQLite 数据库文件\n\n\n\n应用设置\n修改models.py文件如下\nfrom django.db import models# Create your models here.class Topic(models.Model):    &quot;&quot;&quot;A topic the user is learning about.&quot;&quot;&quot;    text = models.CharField(max_length=200)    date_added = models.DateTimeField(auto_now_add=True)    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        return self.text\n在settings.py的INSTALLED_APPS中添加learning_log，然后执行数据库迁移，如下\npython manage.py makemigrationspython manage.py migrate \n\n创建超级用户\n输入python manage.py createsuperuser来创建管理者，账户名、密码、邮箱自行设置，其中密码会被隐藏\n\n随后在admin.py文件中修改代码如下\nfrom django.contrib import adminfrom learning_log.models import Topic# Register your models here.admin.site.register(Topic)\n这段代码用于向管理网站注册Topic\n由于我在创建项目时没有勾选“启用Django admin”，因此这里需要对项目进行简单的更改\n\n\n将urls.py中注释的部分取消\n# from django.contrib import adminfrom django.urls import pathurlpatterns = [    #    path(&#x27;admin/&#x27;, admin.site.urls),]\n\n\n在settings.py的INSTALLED_APPS中添加django.contrib.admin\n\n\n访问http://localhost:8000/admin/，显示如下\n\n输入账户和密码，登录进去界面显示如下\n\nUser和Group是Django自动在管理网站添加的模型，而Topic是我们刚刚自己添加的。此时可以点击Topic，添加任意的主题\n定义Entry\n在models.py中添加如下代码\nclass Entry(models.Model):    &quot;&quot;&quot;Something specific learned about a topic.&quot;&quot;&quot;    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)    text = models.TextField()    date_added = models.DateTimeField(auto_now_add=True)    class Meta:        verbose_name_plural = &#x27;entries&#x27;    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        if len(self.text) &gt; 50:            return f&quot;&#123;self.text[:50]&#125;...&quot;        else:            return self.text\n这里主要说一下两个地方\n\n\ntopic = models.ForeignKey(Topic, on_delete=models.CASCADE)是将每一条 Entry 都关联一个 Topic，形成多对一的关系\n\n\n元信息配置（Meta）：默认 Django 会把模型名称小写加 “s” 做复数，这句是为了告诉 Django这个模型的复数名称设置为 entries，而不是默认的 Entrys\n\n\n由于修改了模型文件，因此我们需要再次迁移数据库，执行\npython manage.py makemigrations learning_logpython manage.py migrate \n然后在管理网站注册Entry：admin.site.register(Entry)（有关模型导入的问题这里不做叙述）\n进入管理网站后会发现多出了一个Entries条目，进入该条目，点击下拉框就可以选择对应的主题，如下图\n\n这时候我们就可以创建条目并将其与对应的主题相关联。不过，目前除了后台管理界面，我们还没任何可供用户访问的界面，下一步我们将尝试创建一个网页来让其他人访问\n创建网页\n使用Django创建网页主要分为三个步骤，定义URL、编写视图、编写模板，完成这三个部分的顺序通常无关紧要，每个人都可以按照个人喜好来实现\n映射URL\n当前http://localhost:8000返回默认的Django网站，下面进行修改，打开urls.py文件，在urlpatterns中添加path('', include('learning_log.urls')),表示我们导入应用learning_log中的url。然后在应用learning_log中添加urls.py文件，内容如下\nfrom django.urls import pathfrom . import viewsapp_name = &#x27;learning_log&#x27;urlpatterns = [    # Home page    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),]\n这段代码主要为当前 app 即（learning_log）配置 URL 路由，其中app_name = 'learning_log'，给这个 app 的 URL 配置一个命名空间，防止与其他 app 中的 URL 名称冲突，在模板中使用 &#123;% url 'learning_log:index' %&#125; 就能明确地调用这个 URL。urlpatterns 是 Django 查找 URL 的核心列表，每一个 path() 定义了一个 URL 与视图的映射。path('', views.index, name='index'),第一个参数是一个字符串用于正确的路由请求，这里表示匹配根路径，第二个参数表示当匹配到 / 时，调用 views.py 中的 index() 函数，第三个参数给这个 URL 取了一个名字叫 'index'，在模板中可以用 &#123;% url 'learning_log:index' %&#125; 来反向生成地址\n编写视图\n视图函数接受请求中的信息，准备好生成网页所需的数据，然后将其发送给浏览器。在前面我们调用了 views.py 中的 index() 函数，但该函数还未编写，打开views.py文件，添加代码如下\nfrom django.shortcuts import render# Create your views here.def index(request):    return render(request, &#x27;learning_log/index.html&#x27;)\n它接受一个 request 对象作为参数，这是 Django 在用户访问网页时自动传入的请求信息对象。函数的返回值是 render(request, 'learning_log/index.html')，表示让 Django 去找一个路径为 learning_log/index.html 的模板文件，并渲染它，默认的模板查找路径为app/templates/app_name/文件名.html\n编写模板\n模板定义网页的外观，每当访问网页时，Django都将填入相关的数据用于显示，我们的template文件夹位于根目录，所以无需在app目录中重新创建，但需要在settings.py的TEMPLATES中检查是否存在'DIRS': [BASE_DIR / 'templates']，以便正确检索html文件\n在template文件夹中创建learning_log文件夹并在其中创建index.html，添加代码如下\n&lt;p&gt;Learning Log&lt;/p&gt;&lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.&lt;/p&gt;\n这里添加了两个段落，运行访问界面如下\n\n创建其他网页\n创建父模板\n在index.html所在的目录中，创建一个base.html文件，这个模板将包含所有页面的通用元素，并将所有子模板都继承它，添加内容如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;\n这段表示页面顶部的一个链接，点击后会跳转到名为 'learning_log:index' 的 URL 对应的页面。\n\n&#123;% url 'learning_log:index' %&#125; 是 Django 模板语言提供的 URL 反向解析标签。\n'learning_log' 是在 learning_log/urls.py 中定义的 app_name。\n'index' 是在 urlpatterns 中为首页设置的 name。\n\n所以最终这个标签会被渲染为：\n&lt;a href=&quot;/&quot;&gt;Learning Log&lt;/a&gt;\n如果将 index 页面映射到 /，那么这个链接就是返回首页的作用。\n&#123;% block content %&#125;&#123;% endblock content %&#125;\n这是 Django 模板语言中非常关键的部分，称为 模板块（template block），它用于定义“可扩展区域”。\n解释如下：\n\n&#123;% block content %&#125;` 是定义一个名为 `content` 的内容区块。\n- `&#123;% endblock content %&#125; 表示这个区块的结束。\n\n换句话说，子模板可以继承这个模板，并用自己的内容替换掉这个 block 区域，例如：\n&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;h2&gt;This is the home page!&lt;/h2&gt;&#123;% endblock content %&#125;\n创建子模板\n重写index.html文件，使其继承base.html，如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.    &lt;/p&gt;&#123;% endblock content %&#125;\n这里将index从base继承下来，使用&#123;% block content %&#125;`定义一个`content`并插入内容，使用`&#123;% endblock content %&#125;结束content块，里面内容将显示在界面上，此时通过修改父模板将修改所有继承它的界面，方便统一管理\n显示所有主题的页面\n首先定义URL，添加path('topics/',  views.topics, name='topics')，在视图中定义topics函数如下\ndef topics(request):    &quot;&quot;&quot;Show all topics.&quot;&quot;&quot;    topics = Topic.objects.order_by(&#x27;date_added&#x27;)    context = &#123;&#x27;topics&#x27;: topics&#125;    return render(request, &#x27;learning_log/topics.html&#x27;, context)\n将所有主题按照时间顺序排序并返回，然后创建topics.html，内容如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topics&lt;/p&gt;    &lt;ul&gt;        &#123;% for topic in topics %&#125;            &lt;li&gt;&#123;&#123; topic.text &#125;&#125;&lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No topics have been created yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;&#123;% endblock content %&#125;\n这里主要将topics中的内容通过无序列表的方式呈现出来。随后在base.html中添加连字符以及代码&lt;a href=&quot;&#123;% url 'learning_log:topics' %&#125;&quot;&gt;Topics&lt;/a&gt;，这将产生一个与Topics匹配的URL链接，访问http://localhost:8000/topics/，如下![image-20250712114413813](https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/Python实战之Web开发%2F2025-07-12-23-47-46-91b35a.png)\n显示特定主题\n我们已经创建了两次页面，对其基本流程应该有所了解了，后续关于URL、视图、模板相关的内容将进行简略，我们再次创建一个页面用于显示特定的主题及其所有的条目\n# URLpath(&#x27;topics/&lt;int:topic_id&gt;/&#x27;, views.topic, name=&#x27;topic&#x27;)# topic函数def topic(request, topic_id):    &quot;&quot;&quot;Show a single topic and all its entries.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    entries = topic.entry_set.order_by(&#x27;-date_added&#x27;)    context = &#123;&#x27;topic&#x27;: topic, &#x27;entries&#x27;: entries&#125;    return render(request, &#x27;learning_log/topic.html&#x27;, context)\n&#123;# 模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topic:&#123;&#123; topic.text &#125;&#125;&lt;/p&gt;        &lt;p&gt;Entries:&lt;/p&gt;    &lt;ul&gt;            &#123;% for entry in entries %&#125;            &lt;li&gt;                &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;                &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;            &lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No entries have been created for this topic yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% endblock content %&#125;\n在topic函数中先通过id获取到特定的主题，然后将主题中的条目降序排列，最后将Topic和Entries返回。模板主要把entries按照特定的格式显示，“|”表示过滤符，也就是将时间按照：January 1, 2025 23:00格式。linebreaks是将文本中的换行符转变为浏览器理解的内容。\n然后修改topics.html，将每个主题都映射为对应的链接\n&#123;% for topic in topics %&#125;    &lt;li&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic.text &#125;&#125;&lt;/a&gt;    &lt;/li&gt;\n运行之后在Topic页面点击主题，显示如下\n\n","categories":["Diango开发"],"tags":["Python"]},{"title":"Python实战之外星人入侵《一》","url":"/posts/25297ba4/","content":"武装飞船\n由于不经常用Python写程序，最近在用Python写一个可视化工具时，惊觉发现自己的Python水平严重下滑，因此又重新拿起了《Python编程-从入门到实践》这本书。\n经过简单的复习，觉得还是有必要把书中的项目给练习一遍，同时也通过Blog记录一下我的实现过程，该篇文章以及后续系列将会讲解这本书中的“外星人入侵”项目，经过第十二、十三、十四章的阅读，我觉得在开始编程之前有必要先分析一下要实现的功能以及项目的整体架构，姑且就按照书上的顺序来吧。\n这里我们需要四个类，分别是主程序类AlienInvasion、子弹类Bullet、设置类Settings、飞船类Ship，主程序类主要用于初始化游戏界面，然后通过循环来更新游戏，子弹类和飞船类主要用于自身属性的初始化、显示和更新位置，设置类主要包含游戏的界面大小、飞船和子弹的移动速度等。整体结构大致如下\n\n游戏入口\n我的IDE是Pycharm，首先创建一个名为 Alien-Invasion-Project 并初始化了git仓库的项目，后续的所有开发代码都将放到我的Gitghub Alien-Invasion-Project 同名仓库中，有兴趣可以访问查看。这里我们首先安装开发需要用到的模块pygame，使用命令pip instal pygame即可，如下\n\n提示“Successfully ……”表明安装成功，也可使用书中的命令python -m pip install --user pygame来安装\n初步实现界面\n先创建一个alien_invasion.py文件，用来实现界面的初始化，然后创建AlienInvasion类，添加如下代码\nimport  pygameclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.screen = pygame.display.set_mode((800, 600))        pygame.display.set_caption(&quot;外星人来喽&quot;)    def run_game(self):        # 游戏主循环        while True:            passif __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\n这里我们通过pygame.init()来实现游戏环境的初始化，然后设置了一个800*600的游戏界面，再通过pygame.display.set_caption(&quot;外星人来喽&quot;)来设置游戏界面的Title，同时我们定义一个run_game函数用来进入游戏，这里添加了一个while的死循环，通过pass占位符来保持界面的显示，并在main里面完成游戏类的实例化和进入游戏中的循环，运行程序，如下图\n\n大致就是一个黑框框，里面什么都没有，由于我们只初始化了游戏界面的大小和标题，因此不会有其他的内容，同时各位应该也能注意到运行之后电脑很卡，这是因为我们在程序中添加了一个死循环，下面我们来对程序进行优化\n优化界面\n我们在其中添加事件处理程序来监听事件，首先导入系统模块sys，然后删除pass，在循环中添加如下代码\nfor event in pygame.event.get():    if event.type == pygame.QUIT:        pygame.quit()        sys.exit()\n这段程序表明我们一直在监听事件，如果有退出的事件发生，我们将调用pygame和系统的退出函数来结束游戏的运行，这时候运行代码，就不会卡了，同时点击X号也能正常退出\n下一步我们对游戏界面填充背景色，同时控制游戏的刷新的帧率\n添加成员变量bg_color，并在while循环中通过screen.fill()来绘制屏幕，然后使用pygame.display.flip()来使屏幕显示出来，运行结果如下\n\n帧率的控制主要通过限制循环中屏幕刷新的时间来实现，添加成员变量clock来定义时钟，然后在循环的末尾启动计时，我们这里设个90帧，代码如下\nclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.clock = pygame.time.Clock()        ……    def run_game(self):        # 游戏主循环        while True:            ……            # 控制游戏帧率            self.clock.tick(90)\n封装Settings类\n为了方便，我们可以把游戏设置相关的内容统一组织起来，放入单独的类中，比如屏幕大小，背景颜色等\n创建settings.py文件，并在其中添加Settings类，将屏幕大小，背景颜色甚至帧率等添加到类中，如下\nclass Settings:    def __init__(self):        self.screen_width = 800        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;\n在主程序创建Settings的实例，并用其中的属性替换掉原来的硬编码行为，这样便于我们理解和组织代码以及后续拓展开发\n创建Ship类\n这里我们要在游戏界面创建一个飞船，首先需要准备一张照片，创建文件夹imgs，将书中源码位置的图片复制到imgs下，并添加新文件ship.py，Ship类要加载图片显示，初始位置应当位于屏幕中心底部，并且支持左右移动，代码如下\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(&#x27;imgs/ship.bmp&#x27;)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += 3        if self.moving_left and self.rect.left &gt; 0:            self.x -= 3        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n突然发现写博客还是比较费时间的，这里就不过多解释了，完成Ship类之后就需要对主程序进行更改了，我们对原来的代码进行重构，因为要添加左右移动的消息，所以将while循环中的内容简化，尽可能的封装为函数模块，大致分为事件检测、事件执行、飞船更新、屏幕更新等\n事件检测：\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP:            self._check_keyup_events(event)\n判断消息类型，如果是退出，就结束游戏，如果是键盘按键按下或者是键盘按键松开，则执行对应的函数\n事件执行：\ndef _check_keydown_events(self, event):    &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = True    elif event.key == pygame.K_LEFT:        self.ship.moving_left = True    elif event.key == pygame.K_q:        pygame.quit()        sys.exit()\n如果键盘按下，则判断按下的是哪一个键，右键激活飞船的右移动标识，左键则激活左移动标识，如果是q键，同样执行退出，这是为了方便用户结束游戏而不用每次都点击右上角X号\ndef _check_keyup_events(self, event):    &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = False    elif event.key == pygame.K_LEFT:        self.ship.moving_left = False\n如果键盘松开，则根据松开的按键来结束对应的移动标识\n屏幕更新：\ndef _update_screen(self):    &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;    self.screen.fill(self.settings.bg_color)    self.ship.draw()    pygame.display.flip()\n综上，while循环目前应该包含的内容如下\nwhile True:    # 监听事件    self._check_events()    # 更新飞船位置    self.ship.update()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n运行\n\n这个时候我们的飞船就可以正常移动了\n创建Bullet类\n首先创建bullet.py文件，在其中创建Bullet类，为了便于管理子弹，我们采用群组的方式将其继承Sprite，Bullet类应当包含颜色、大小、速度等，同时绘制自身并更新位置，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        self.color = (60, 60, 60)        self.rect = pygame.Rect(0, 0, 3, 15)               self.speed = 4        self.rect.midtop = self.game.ship.rect.midtop()        self.y = float(self.rect.y)    def update(self):        self.y -= self.speed        self.rect.y = self.y    def draw(self):        pygame.draw.rect(self.game.screen, self.color, self.rect)\n更改主程序代码，以pygame.sprite.Group()的方式创建子弹群组，在按下键盘事件中添加空格的侦听，并添加发射子弹的函数，然后在主循环中添加更新子弹的函数，用于更新子弹的位置并删除超出屏幕的子弹，最后在刷新屏幕的函数中添加显示子弹的代码，主要添加内容如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)            def _fire_bullet(self):    &quot;&quot;&quot;发射子弹&quot;&quot;&quot;    if len(self.bullets) &lt; 6:        new_bullet = Bullet(self)        self.bullets.add(new_bullet)\n运行如下\n\n这样就可以正常发射子弹了。下面我们还需要对代码进行简单的修改，将子弹的相关配置放入Settings中\n代码优化\n跟设置相关的内容我们应该放在Settings类当中，同时尽可能的减少硬编码的行为，优化后的完整代码如下\nalien_invasion.py\nimport  pygameimport sysfrom settings import Settingsfrom ship import Shipfrom bullet import Bulletclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.settings = Settings()        self.clock = pygame.time.Clock()        self.screen = pygame.display.set_mode((self.settings.screen_width, self.settings.screen_height))        pygame.display.set_caption(self.settings.TITLE)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()    def run_game(self):        # 游戏主循环        while True:            # 监听事件            self._check_events()            # 更新飞船位置            self.ship.update()            # 更新子弹位置            self._update_bullets()            # 更新屏幕            self._update_screen()            # 控制游戏帧率            self.clock.tick(self.settings.FPS)    def _check_events(self):        &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)    def _check_keydown_events(self, event):        &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            pygame.quit()            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()    def _check_keyup_events(self, event):        &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    def _update_screen(self):        &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        for bullet in self.bullets.sprites():            bullet.draw()        self.ship.draw()        pygame.display.flip()    def _update_bullets(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.bullets.update()        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                self.bullets.remove(bullet)    def _fire_bullet(self):        &quot;&quot;&quot;发射子弹&quot;&quot;&quot;        if len(self.bullets) &lt; self.settings.bullet_limit:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)if __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\nbullet.py\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 设置子弹的属性        self.color = self.game.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.game.settings.bullet_width, self.game.settings.bullet_height)        # 将子弹放在飞船的顶部        self.rect.midtop = self.game.ship.rect.midtop\t\t        # 子弹的y轴位置        self.y = float(self.rect.y)    def update(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.y -= self.game.settings.bullet_speed        self.rect.y = self.y    def draw(self):        &quot;&quot;&quot;绘制子弹&quot;&quot;&quot;        pygame.draw.rect(self.game.screen, self.color, self.rect)\nsettings.py\nclass Settings:    def __init__(self):        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;        self.screen_width = 1600        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;        # 飞船设置        self.ship_image_path = &#x27;imgs/ship.bmp&#x27;        self.ship_speed = 3        # 子弹设置        self.bullet_color = (60, 60, 60)        self.bullet_speed = 4        self.bullet_width = 3        self.bullet_height = 15        self.bullet_limit = 10\nship.py\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(self.game.settings.ship_image_path)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += self.game.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:            self.x -= self.game.settings.ship_speed        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《三》","url":"/posts/5821342e/","content":"添加Play按钮\n首先在Setting中添加如下代码\n# 按钮设置self.button_color = (0, 255, 0)self.button_width = 200self.button_height = 50self.button_text_color = (255, 255, 255)self.button_font = 48self.play_button_text = &quot;Play&quot;\n将按钮的相关属性加入到设置相关的类中，然后创建button.py文件，添加如下代码\nimport pygame.fontclass Button:    def __init__(self, game, msg):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.button_font)        self.rect = pygame.Rect(0, 0, self.game.settings.button_width, self.game.settings.button_height)        self.rect.center = self.game.screen.get_rect().center        self._pre_msg(msg)    def _pre_msg(self, msg):        &quot;&quot;&quot;将msg渲染为图像&quot;&quot;&quot;        self.msg_image = self.font.render(msg, True, self.game.settings.button_text_color, self.game.settings.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw(self):        &quot;&quot;&quot;绘制按钮&quot;&quot;&quot;        self.game.screen.fill(self.game.settings.button_color, self.rect)        self.game.screen.blit(self.msg_image, self.msg_image_rect)\n__init__()函数用于按钮的初始化，如按钮的大小、字体、位置等，_pre_msg()函数用于将字符串消息转换为图像并填充到矩形中，draw()函数用于绘制按钮\n接下来我们在主程序中将game_active设为False，从而为了显示按钮，然后添加按钮属性self.play_button = Button(self, self.settings.play_button_text)，接着在更新屏幕的地方判断如果游戏处于非活跃状态就显示按钮\nif not self.game_active:    self.play_button.draw()\n现在运行游戏\n\n开始游戏\n此时点击按钮并没有做出反应，因为我们还没有添加鼠标点击响应的事件，首先在_check_events中添加如下代码\nelif event.type == pygame.MOUSEBUTTONDOWN:    mouse_pos = pygame.mouse.get_pos()    self._check_play_button(mouse_pos)\n上述代码用于检测是否有鼠标按下，如果有则获取鼠标点击的位置，然后将变量传递给_check_play_button，现在我们添加该函数\ndef _check_play_button(self, mouse_pos):    &quot;&quot;&quot;响应Play按钮的点击事件&quot;&quot;&quot;    if self.play_button.rect.collidepoint(mouse_pos):        # 重置游戏状态        self.status.reset_status()        self.game_active = True        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 创建新的外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()\n一旦有点击事件的发生，我们就判断点击位置是否位于按钮中，如果是，则重置游戏状态并清空所有子弹和外星人，创建新的外星人和飞船，从而表明我们开启了新游戏，运行如下\n\n游戏优化\n当前游戏中还存在Bug，如果我们点击按钮所在区域，即便是按钮已经消失但仍会做出响应并重置游戏，因为我们的鼠标点击事件还会判断其点击位置与按钮位置重合，因此我们需要对判断做出优化\nif self.play_button.rect.collidepoint(mouse_pos) and not self.game_active:\n将_check_play_button函数中的if判断语句改为上述代码，从而防止其在游戏运行时仍会执行重置代码\n另外，玩游戏时我们应该将光标隐藏，在游戏结束时显示光标\n在_check_play_button的末尾添加pygame.mouse.set_visible(False)，游戏开始将光标隐藏，在_ship_hit的else块的末尾添加pygame.mouse.set_visible(True) ，游戏结束时将光标显示\n提升趣味性\n在Settings中添加如下代码\n    # 游戏速度设置    self.speed_scale = 1.1    self.init_settings()def init_settings(self):    &quot;&quot;&quot;初始化游戏的动态设置&quot;&quot;&quot;    self.ship_speed = 30    self.bullet_speed = 10    self.alien_speed = 10    self.alien_drop_speed = 10    self.alien_direction = 1def increase_speed(self):    &quot;&quot;&quot;提高游戏速度设置&quot;&quot;&quot;    self.ship_speed *= self.speed_scale    self.bullet_speed *= self.speed_scale    self.alien_speed *= self.speed_scale    self.alien_drop_speed *= self.speed_scale\nspeed_scale用于控制游戏增长的速度，init_settings用于初始化设置，increase_speed用于将相关参数增长从而提高游戏难度\n在_check_bullet_alien_collisions中，如果外星人全部被击落，我们就调用self.settings.increase_speed()增加游戏速度。当然每次开启新游戏时，应当将所有设置还原，在_check_play_button的if语块的第一行添加self.settings.init_settings()，这将使得新游戏的属性为初始化值\n记录分数\n在GameStatus中添加属性self.score = 0用于重置分数，在Settings中添加分数相关设置\n# 游戏分数设置self.score_text_color = (30, 30, 30)self.score_font = 48\n然后创建gamescore.py文件添加如下代码\nimport pygame.fontclass GameScore:    def __init__(self, game):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.score_font)        self.prep_score()    def prep_score(self):        &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;        score_str = str(self.game.status.score)        self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)        self.score_rect = self.score_image.get_rect()        self.score_rect.right = self.game.screen.get_rect().right - 20        self.score_rect.top = 20    def show_score(self):        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;        self.game.screen.blit(self.score_image, self.score_rect)\n在主程序中添加成员self.score = GameScore(self)，随后在更新屏幕函数中显示分数面板self.score.show_score()，此时运行游戏就能显示分数面板了\n更新得分\n在Settings的init_settings中添加self.alien_points = 50，用于表示每个外星人击落的初始得分，然后在主程序的_check_bullet_alien_collisions中添加\nif collisions:    for aliens in collisions.values():        self.status.score += self.settings.alien_points * len(aliens)    self.score.prep_score()\n表示每次击中一个外星人则对其进行加分，同时击落多个外星人也能同时记分，当然每次开始游戏我们也要重置分数，在_check_play_button中添加self.score.prep_score()，用新的分数来初始化记分面板\n对于不同速度的外星人，我们也应该增加其击落分数，在Settings中添加self.score_scale = 1.5表示外星人的分数增长速度，然后在increase_speed中添加self.alien_points = int(self.alien_points * self.score_scale)，更新新的外星人分数，最后再对分数进行取舍，在GameScore的prep_score中修改代码如下\ndef prep_score(self):    &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;    rounded_score = round(self.game.status.score, -1)    score_str = f&quot;&#123;rounded_score:,&#125;&quot;  # 使用逗号分隔千位    self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.score_rect = self.score_image.get_rect()    self.score_rect.right = self.game.screen.get_rect().right - 20    self.score_rect.top = 20\n表示我们通过round函数将分数取为10的整数倍，这样每个外星人的分数都是10的倍数了\n获取最高分\n在GameStatus添加新属性self.max_score = 0用来记录最高分，随后在GameScore中添加新函数\ndef prep_high_score(self):    &quot;&quot;&quot;将最高得分渲染为图像&quot;&quot;&quot;    high_score = round(self.game.status.max_score, -1)    high_score_str = f&quot;&#123;high_score:,&#125;&quot;    self.high_score_image = self.font.render(high_score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.high_score_rect = self.high_score_image.get_rect()    self.high_score_rect.centerx = self.game.screen.get_rect().centerx    self.high_score_rect.top = self.score_rect.top    def check_high_score(self):    &quot;&quot;&quot;检查是否达到了新的最高得分&quot;&quot;&quot;    if self.game.status.score &gt; self.game.status.max_score:        self.game.status.max_score = self.game.status.score        self.prep_high_score()\n这里将最高分渲染为图像并放置在屏幕正中央的上方，在__init__中调用prep_high_score，然后在show_score中将high_score_image显示出来，并在主程序中每当碰撞发生时就调用check_high_score判断当前分数是否超过了最高分，运行如下\n\n显示等级和飞船数\n在GameStatus的reset_status中添加self.level = 1，在GameScore的__init__添加函数self.prep_level()，代码如下\ndef prep_level(self):    &quot;&quot;&quot;将当前关卡渲染为图像&quot;&quot;&quot;    level_str = str(self.game.status.level)    self.level_image = self.font.render(level_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.level_rect = self.level_image.get_rect()    self.level_rect.right = self.score_rect.right    self.level_rect.top = self.score_rect.bottom + 10\n将等级渲染为图片并显示在得分的正下方，然后在show_score中添加self.game.screen.blit(self.level_image, self.level_rect)来显示图像，在主程序中清除所有外星人之后提升等级，代码如下\nif not self.aliens:    # 如果没有外星人了，重新创建外星人舰队    self._create_fleet()    self.bullets.empty()    self.settings.increase_speed()    # 提升关卡    self.status.level += 1    self.score.prep_level()\n最后在_check_play_button中重置等级，调用self.score.prep_level()即可，运行如下\n\n接下来我们要显示剩余飞船数，这里我们对飞船也要使用Sprite，更改Ship类如下\nclass Ship(Sprite):    def __init__(self, game):        super().__init__()\n将Ship继承自Sprite，在GameScore中添加函数prep_ships如下\ndef prep_ships(self):    &quot;&quot;&quot;显示剩余飞船数量&quot;&quot;&quot;    self.ships = Group()    for ship_number in range(self.game.status.ships_left):        ship = Ship(self.game)        ship.rect.x = 10 + ship_number * ship.rect.width        ship.rect.y = 10        self.ships.add(ship)\n这个函数用于根据剩余的飞船数量来创建飞船对象并调整位置，然后在初始化的函数中添加self.prep_ships()。下一步我们就要绘制飞船了，在show_score中添加self.ships.draw(self.game.screen)即可，然后在主程序的游戏开始和飞船被撞击的地方调用self.score.prep_ships()就能够正常加载和显示剩余飞船了，如下\n\n游戏Bug更改\n到上述部分我们就完成了书中的所有内容，但经过我的测试，这款游戏存在一定的Bug，看图\n\n是不是很奇怪？游戏还没有开始怎么就出现了一条横线？其实这是因为我们通过循环来侦听不同事件的发生，如果在游戏开始之前点击空格按钮，那么就会执行发射子弹的函数。但此时游戏状态并没有被激活，因此这条横线会停在这里，而且由于我们的子弹比较大，我们的飞船图像并不能完全遮盖子弹，所以就出现了这种现象，但从逻辑上来讲，如果我们不停按空格，程序应该每次都会执行空格所对应的响应，所以这里我们对其进行修改\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN and self.game_active:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP and self.game_active:            self._check_keyup_events(event)        elif event.type == pygame.MOUSEBUTTONDOWN:            mouse_pos = pygame.mouse.get_pos()            self._check_play_button(mouse_pos)\n上述代码主要增加了当键盘响应时游戏是否处于激活状态，如果游戏未激活则不响应任何按键，此时我们无论按键盘上的哪里，都不会再次出现上述的情况了，至此，该项目就完全结束了。源码访问点击这里\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《二》","url":"/posts/153f977c/","content":"创建Alien类\n创建一个alien.py文件，并把书中源码的alien.bmp图片拷贝到我们的imgs文件夹中，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Alien(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 加载外星人图片        self.image = pygame.image.load(&#x27;imgs/alien.bmp&#x27;)        self.rect = self.image.get_rect()        # 设置外星人初始位置        self.rect.x = self.rect.width        self.rect.y = self.rect.height        # 外星人当前的x轴位置        self.x = float(self.rect.x)\n创建Alien实例\n由于外星人通常是成批次出现，因此我们也要通过Sprite管理，如self.aliens = pygame.sprite.Group()，这里我们单独创建一个函数用于外星人的生成\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    self.aliens.add(alinen)\n然后在更新屏幕的函数中添加如下代码用于外星人在屏幕上的显示\nself.aliens.draw(self.screen)\n运行\n\n此时在屏幕的左上角已经出现了一个外星人\n创建Alien舰队\n上述我们在_create_fleet中只生成了一个外星人，下面进行修改来生成多行外星人，代码如下\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    alien_width = alinen.rect.width    alien_height = alinen.rect.height    current_x, current_y = alien_width, alien_height    # 计算屏幕可以容纳多少个外星人    while current_y &lt; (self.settings.screen_height - 3 * alien_height):        while current_x &lt; (self.settings.screen_width - 2 * alien_width):            self._create_alien(current_x, current_y)            current_x += 2 * alien_width        # 重置当前x位置，移动到下一行        current_y += 2 * alien_height        current_x = alien_widthdef _create_alien(self, current_x, current_y):    &quot;&quot;&quot;创建一个外星人&quot;&quot;&quot;    alien = Alien(self)    alien.x = current_x    alien.rect.x = current_x    alien.rect.y = current_y    self.aliens.add(alien)\n这里我们先生成一个实例，然后获取到它的宽度和高度并赋值为当前的x轴位置和y轴位置，内层循环用来生成一行外星人，从距离屏幕一个外星人的宽度开始，每隔一个外星人宽度创建一个实例，直到屏幕宽度不满足两个外星人的宽度为止，外层循环首先更新y轴位置，将其下移两个外星人的高度，然后初始化当前的x轴位置，再次创建一行，直到屏幕高度不满足三个外星人的高度位置为止，运行如下\n\n此时我们已经创建了一个外星人的舰队\n移动舰队\n在Setting中添加如下代码\n# 外星人设置self.alien_speed = 1self.alien_drop_speed = 10self.alien_direction = 1  # 1表示向右移动，-1表示向左移动\n分别表示外星人的水平速度、下降速度、水平方向\n然后在Alien中添加更新位置的函数\ndef update(self):    &quot;&quot;&quot;更新外星人位置&quot;&quot;&quot;    self.x += self.game.settings.alien_speed * self.game.settings.alien_direction    self.rect.x = self.x\n通过alien_direction来决定水平方向的移动，但这样只会让舰队朝着一个方向不停移动直到超出屏幕范围，在舰队即将到达屏幕边缘时，我们应该改变它的方向，让它朝着相反的方向移动，并下降一段距离。先添加边缘检测函数，如下\ndef check_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    screen_rect = self.game.screen.get_rect()    if self.rect.right &gt;= screen_rect.right or self.rect.left &lt;= 0:        return True    return False\n先获取屏幕大小，然后根据外星人所在的位置判断是否超出了屏幕边界，超了就返回True，否则返回就False\n随后我们在主程序添加检测函数，并在到达边缘时使其下降一段距离\ndef _check_fleet_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.check_edges():            self._change_fleet_direction()            breakdef _change_fleet_direction(self):    &quot;&quot;&quot;改变外星人舰队的方向&quot;&quot;&quot;    for alien in self.aliens.sprites():        alien.rect.y += self.settings.alien_drop_speed    self.settings.alien_direction *= -1\n对于每一个外星人我们都检测其是否超出了屏幕范围，然后改变所有外星人其移动方向，并下降一段距离，此时我们在更新外星人位置的函数中调用检测边界函数，运行结果如下\n\n射击外星人\n此时我们发射子弹，子弹并不能击落外星人，而是会直接穿过外星人，因为我们还没有做子弹和外星人的碰撞检测，下面我们来逐步实现这一过程\n检测子弹和外星人的碰撞\n要实现这个功能非常简单，我们只需要利用pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)这个函数即可，前两个参数分别表示子弹群组和外星人群组，后面两个参数表示碰撞后是否消失，True表明碰撞后子弹和外星人均消失。但这样还有个缺陷，就是我们把外星人全部击落之后，屏幕将没有外星人了，我们应该在打完所有外星人之后重新生成新的外星人舰队，代码如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)                self._check_bullet_alien_collisions()def _check_bullet_alien_collisions(self):    &quot;&quot;&quot;检查子弹与外星人碰撞&quot;&quot;&quot;    collisions = pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)    if not self.aliens:        # 如果没有外星人了，重新创建外星人舰队        self._create_fleet()        self.bullets.empty()\n我们在更新子弹的后面加入了调用检测碰撞的函数，并在所有外星人消失后重新生成新的外星人舰队，同时清除所有子弹，从而使我们继续游戏\n检测飞船和外星人的碰撞\n如果按照上述的逻辑，那么这个游戏将没有终止的时候，为此应该加入游戏结束的一些条件，比如我们的飞船和外星人发生了碰撞，在更新外星人的函数中添加代码如下\n# 检测外星人和飞船的碰撞if pygame.sprite.spritecollideany(self.ship, self.aliens):    print(&quot;飞船被外星人撞了！&quot;)\nspritecollideany(self.ship, self.aliens)函数接收一个精灵和一个编组，用于检测飞船是否有和外星人碰撞，如果发生碰撞，将打印&quot;飞船被外星人撞了！&quot;。通常来讲，我们不应当在飞船撞毁之后直接结束游戏，而是应该给予玩家多次机会，下面我们创建一个game_status.py文件，用于记录游戏信息，内容如下\nclass GameStatus:    def __init__(self, game):        &quot;&quot;&quot;初始化游戏状态&quot;&quot;&quot;        self.ships_left = None        self.game = game        self.reset_status()            def reset_status(self):        &quot;&quot;&quot;重置游戏状态&quot;&quot;&quot;        self.ships_left = self.game.settings.ship_limit\n同时在Settings中添加self.ship_limit = 3，表明飞船最多只有三次，ships_left则用来记录剩余的飞船数量\n下面我们对主程序进行修改，添加一个用于游戏状态表示的实例：self.status = GameStatus(self)，然后创建撞击后的响应函数，如下\ndef _ship_hit(self):    &quot;&quot;&quot;响应飞船被外星人撞击的事件&quot;&quot;&quot;    if self.status.ships_left &gt; 0:        # 减少剩余飞船数量        self.status.ships_left -= 1        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 重新创建外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()        # 暂停一段时间        sleep(1)    else:        print(&quot;游戏结束！&quot;)\n如果被撞击并且飞船数量大于0，则减少一个飞船数量并清空子弹和外星人，从而生成新的外星人和飞船。删除碰撞函数里print()函数，替换为_ship_hit()，并在Ship中添加如下函数\ndef center_ship(self):    &quot;&quot;&quot;将飞船放在屏幕底部中央&quot;&quot;&quot;    self.rect.midbottom = self.game.screen.get_rect().midbottom    self.x = float(self.rect.x)\n使新生成的飞船位于屏幕底部中心\n到达屏幕底部边缘\n如果外星人到达屏幕底部，我们同样应该跟碰撞一样响应，添加屏幕下边缘检测函数\ndef _check_alien_bottom(self):    &quot;&quot;&quot;检查外星人是否到达屏幕底部&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.rect.bottom &gt;= self.settings.screen_height:            self._ship_hit()            break\n检查每个外星人的底部是否超过了屏幕的高度，如果超过则调用_ship_hit()函数。在更新外星人的最后添加self._check_alien_bottom()，此时当外星人到达屏幕底部游戏也将重置\nGameOver\n细心一点可能会注意到，当我们死亡超过三次时，游戏仍然没有结束，事实上它永远也不会结束，因为我们在_ship_hit()函数中，当ships_left小于0时，只是调用了print(&quot;游戏结束！&quot;)，其他什么也没有做，因此ships_left只会越来越小，我们应该为其添加一个游戏标识，如果标识为False则终止某些部分的运行，从而实现游戏的结束。在主程序添加self.game_active = True，并将print(&quot;游戏结束！&quot;)替换为self.game_active = False，同时修改主循环如下\n# 游戏主循环while True:    # 监听事件    self._check_events()    if self.game_active:        # 更新飞船位置        self.ship.update()        # 更新子弹位置        self._update_bullets()        # 更新外星人位置        self._update_aliens()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"VSCode插件开发-文件统计功能","url":"/posts/57a69459/","content":"修改package.json\n在开发 VS Code 插件时，package.json 是整个插件的“说明书”。这里以一个简单的功能为例进行测试\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;],&quot;main&quot;: &quot;./out/extension.js&quot;,&quot;contributes&quot;: &#123;  &quot;commands&quot;: [    &#123;      &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,      &quot;title&quot;: &quot;File State&quot;,      &quot;category&quot;: &quot;Code Auto Test&quot;    &#125;  ],  &quot;menus&quot;: &#123;    &quot;editor/context&quot;: [      &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ],    &quot;explorer/context&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ]  &#125;&#125;\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;]\n\n意义：插件不会在 VS Code 启动时就加载，而是在用户执行命令 code-auto-test.getFileState 时激活。\n优势：提升启动性能，遵循 VS Code 插件的延迟加载机制。\n\n指定插件的主入口\n&quot;main&quot;: &quot;./out/extension.js&quot;\n\n指向插件的主模块，通常是 TypeScript 编译后的文件。\nextension.js 中通常包含 activate(context) 和 deactivate() 函数，用于插件的生命周期管理。\n\n注册自定义命令\n&quot;commands&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;title&quot;: &quot;File State&quot;,    &quot;category&quot;: &quot;Code Auto Test&quot;  &#125;]\n\ncommand：命令的唯一标识符，供代码调用。\ntitle：在命令面板（Ctrl+Shift+P）中的显示名称。\ncategory：命令分类，显示为 &quot;Code Auto Test: File State&quot;。\n\n执行位置包括：\n\n命令面板\n上下文菜单（通过 menus 配置）\n\n集成到右键菜单中\n编辑器右键菜单\n&quot;editor/context&quot;: [  &#123;    &quot;when&quot;: &quot;editorFocus&quot;,    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：当编辑器中有焦点时，在右键菜单的“导航”区域显示。\nwhen: 上下文条件，这里为 editorFocus 表示编辑器有焦点时才显示。\n\n资源管理器右键菜单\n&quot;explorer/context&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：资源管理器（文件树）右键菜单中。\n可用于对选中的文件/文件夹执行操作。\n\n通过这段简单的配置，我们实现了一个功能完整的 VS Code 插件功能点：\n\n\n\n功能\n实现方式\n\n\n\n\n延迟激活\nactivationEvents 指定命令触发激活\n\n\n注册命令\ncontributes.commands\n\n\n集成编辑器右键菜单\nmenus.editor/context\n\n\n集成资源管理器右键菜单\nmenus.explorer/context\n\n\n\n这套模式是编写 VS Code 插件的基础，适用于各种需要通过右键或命令面板触发逻辑的场景，比如自动测试、代码分析、格式化工具等。\n修改extension.ts\n查看文件状态的命令实现（extension.ts）\n我们前面在 package.json 中注册了命令 code-auto-test.getFileState，接下来在插件主入口文件中进行具体实现。\n文件路径：src/extension.ts\n// 引入 VS Code 扩展 APIimport * as vscode from &#x27;vscode&#x27;;import * as fs from &#x27;fs&#x27;;// 插件激活时触发export function activate(context: vscode.ExtensionContext) &#123;\tconsole.log(&#x27;插件已激活：code-auto-test&#x27;);\t// 注册 getFileState 命令\tconst disposable = vscode.commands.registerCommand(&#x27;code-auto-test.getFileState&#x27;, (uri: vscode.Uri) =&gt; &#123;\t\t// 获取文件路径\t\tconst filePath = uri.fsPath;\t\t// 异步获取文件信息\t\tfs.stat(filePath, (err, stats) =&gt; &#123;\t\t\tif (err) &#123;\t\t\t\tvscode.window.showErrorMessage(`获取文件信息失败: $&#123;err.message&#125;`);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 判断是否为文件夹\t\t\tif (stats.isDirectory()) &#123;\t\t\t\tvscode.window.showWarningMessage(&#x27;检测的是文件夹，不是文件，请重新选择！&#x27;);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 若是普通文件，显示基本信息\t\t\tif (stats.isFile()) &#123;\t\t\t\tconst size = stats.size;\t\t\t\tconst createTime = stats.birthtime.toLocaleString();\t\t\t\tconst modifyTime = stats.mtime.toLocaleString();\t\t\t\tvscode.window.showInformationMessage(\t\t\t\t\t` 文件大小: $&#123;size&#125; 字节\\n 创建时间: $&#123;createTime&#125;\\n 修改时间: $&#123;modifyTime&#125;`,\t\t\t\t\t&#123; modal: true &#125;\t\t\t\t);\t\t\t&#125;\t\t&#125;);\t\t// 调试用：同步读取 stat 信息输出日志\t\ttry &#123;\t\t\tconst statsSync = fs.statSync(filePath);\t\t\tconsole.log(&#x27;statSync:&#x27;, statsSync);\t\t\tconsole.log(&#x27;isFile:&#x27;, statsSync.isFile());\t\t&#125; catch (err) &#123;\t\t\tconsole.error(&#x27;statSync 读取失败:&#x27;, err);\t\t&#125;\t&#125;);\t// 将命令加入插件上下文中\tcontext.subscriptions.push(disposable);&#125;// 插件被卸载时触发export function deactivate() &#123;&#125;\n\n\n\n功能点\n说明\n\n\n\n\nvscode.Uri\n命令参数自动传入，支持从资源管理器中点击文件触发命令。\n\n\nfs.stat()\n异步获取文件状态，包含文件大小、创建时间、修改时间等。\n\n\nfs.statSync()\n同步版本，用于调试或日志输出。\n\n\nvscode.window.showInformationMessage(..., &#123; modal: true &#125;)\n使用模态窗口展示信息，确保用户注意查看。\n\n\n\n在编辑器中右键文件：\n\n显示：File State\n点击后弹出文件大小、创建时间、修改时间\n\n在资源管理器中右键文件：\n\n同样支持显示该命令\n若选中文件夹则给出提示\n\n\n通过 package.json + extension.ts，我们构建了一个结构完整、功能清晰的 VS Code 插件，具备以下特征：\n\n延迟激活（按需加载）\n支持右键菜单调用\n使用原生 Node.js 文件系统 API 获取信息\n弹出信息提示（用户交互友好）\n\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"Simulink调用外部Dll交互《三》","url":"/posts/ee275623/","content":"介绍\n本文主要实现了Simulink下模块化GUI与外部Dll数据交互的功能。首先将需要用到的交互接口封装，导出为C风格的函数，然后在模块中创建可视化界面并导入外部Dll，用于显示和操作数据，并在修改数据后通过接口保存到文件，如果成功，则与后续接口通信，调用求解器并显示结果\n导出交互接口\n// 参数交互EXPORT_API void LoadParametersFromIni(void* p, const char* filename);EXPORT_API int GetGlobalParameterCount(void* p);EXPORT_API const char* GetParameterName(void* p, int index);EXPORT_API double GetParameterValue(void* p, int index);EXPORT_API double GetParameterMin(void* p, int index);EXPORT_API double GetParameterMax(void* p, int index);EXPORT_API const char* GetParameterDescription(void* p, int index);EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath);\n//-------------参数交互用-------------------   EXPORT_API void LoadParametersFromIni(void* p, const char* filename) &#123;       if (!p || !filename) return;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       proc-&gt;LoadIniParametersToGlobalParameter(filename);  // 调用现有方法   &#125;   EXPORT_API int GetGlobalParameterCount(void* p) &#123;       if (!p) return 0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       return static_cast&lt;int&gt;(proc-&gt;m_vglobalParams.size());   &#125;   EXPORT_API const char* GetParameterName(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetName().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API double GetParameterValue(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetValue();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMin(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMin();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMax(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMax();       &#125;       return 0.0;   &#125;   EXPORT_API const char* GetParameterDescription(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetDescription().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath) &#123;       if (!p || !paramName || !projectPath) &#123;           return false;       &#125;       try &#123;           auto proc = static_cast&lt;CXXXProcessor*&gt;(p);           // 调用 C++ 类成员函数进行参数修改           return proc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);                   &#125;       catch (const std::exception&amp; e) &#123;           std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;           return false;       &#125;   &#125;\n这段代码主要是通过 C++ 的 EXPORT_API 宏将 CXXXProcessor 类的相关函数暴露为 API 接口，允许外部调用进行参数的读取、修改以及加载配置。\n1. EXPORT_API 宏\n每个函数前面都使用了 EXPORT_API 宏，这通常是为了将这些函数导出为 DLL 接口，让外部应用可以调用这些函数。这种做法常见于需要将 C++ 类和方法暴露给其他编程语言（如 Python 或 C#）的情况。EXPORT_API 一般在头文件中定义，并用来标记需要导出的函数。\n2. 参数校验\n在所有函数内部，第一步都是检查指针或参数是否为空或无效。例如：\nif (!p || !filename) return;\n这种做法可以确保在程序运行时避免因为传入无效参数而导致的崩溃，增强了代码的鲁棒性。\n3. static_cast 类型转换\n很多地方使用了 static_cast 来进行类型转换。比如：\nauto proc = static_cast&lt;CXXXProcessor*&gt;(p);\n这里 p 是一个 void* 类型的指针，指向 CXXXProcessor 类型的对象。static_cast 将 void* 转换成 CXXXProcessor* 类型，以便调用该类的成员函数。通过这种方式，可以在不暴露类内部实现的情况下，提供面向外部的 API 接口。\n4. 函数功能设计\n加载参数 (LoadParametersFromIni)\nproc-&gt;LoadIniParametersToGlobalParameter(filename);\n该函数的设计目的是加载指定的 .ini 配置文件，并将参数值导入到类内部的全局参数列表中。它的设计思想是将文件读取与内存中数据的存储解耦，便于后续的参数操作。\n参数获取函数\n包括：\n\nGetGlobalParameterCount：返回全局参数的数量。\nGetParameterName、GetParameterValue、GetParameterMin、GetParameterMax：返回指定参数的不同属性（名称、值、最小值、最大值）。\nGetParameterDescription：返回参数的描述信息。\n\n这些函数的设计方式非常直观，主要是通过访问类内部 m_vglobalParams 成员（一个存储参数的容器，如 std::vector）来返回相应的信息。每个函数都首先检查传入的索引是否有效，确保在访问数组或容器时不会越界。\n修改参数 (RewriteBWIIni_Param)\nproc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);\n此函数负责修改指定参数的值并将其更新回 .ini 配置文件中。它利用 CXXXProcessor 类中的现有方法 RewriteBWIIni_Param 来执行实际的修改操作。在设计上，这个函数有一个异常处理机制（try-catch 语句），用于捕获运行时可能出现的异常，防止程序崩溃。错误信息会通过 std::cerr 输出，便于调试。\n5. 数据封装与分离\n函数内部使用了 CXXXProcessor 类封装了所有参数相关的操作，外部调用者仅通过接口来操作这些数据。这样的封装设计符合面向对象编程（OOP）的原则，数据与操作方法分离，外部只关心接口而无需了解内部实现细节。\n\nm_vglobalParams 是存储所有全局参数的容器，封装了参数的读取、修改等操作。\nCXXXProcessor 类中提供了对参数的处理函数，如 LoadIniParametersToGlobalParameter 和 RewriteBWIIni_Param，而 API 函数仅暴露必要的接口给外部调用。\n\n6. 错误处理与返回值\n大多数函数都进行了参数校验和错误处理。比如 GetParameterName 和其他类似的获取参数信息的函数都返回 nullptr 或默认值（如 0.0），当输入无效时避免出现错误：\nif (!p || index &lt; 0) return nullptr;\nRewriteBWIIni_Param 函数则使用 try-catch 机制来捕获异常，确保在发生异常时能返回 false，并输出错误信息。\n7. 代码设计的一致性与可扩展性\n\n所有获取参数的函数（如 GetParameterName、GetParameterValue 等）具有一致的接口设计，参数索引作为输入，返回相关数据。这使得 API 易于扩展和维护，后期可以轻松增加更多的参数获取功能。\nRewriteBWIIni_Param 与加载参数的功能解耦，遵循了单一职责原则，使得每个函数都专注于自己的一部分工作，易于理解和测试。\n\nMatlab GUI实现\n将上个步骤的代码编译为Dll，并把其头文件、dll文件以及所有用到的其他dll拷贝到Matlab的运行环境下\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0        start_import_gui(block.BlockHandle);  % 传递块句柄给 GUI        block.Dwork(1).Data = 1;  % 设置 GUI 已启动标志    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        % 自动开始仿真，无需手动输入        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;  % 设置已启动标志    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            % 检查仿真是否正在运行，若正在运行则停止            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                % 如果仿真正在运行，取消仿真                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            % 如果没有仿真，或其他错误，则跳过            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(blockHandle)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.blockHandle = blockHandle;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end\n这段代码是一个用于在 Simulink 模型中调用自定义 S-Function 的实现，目的是在仿真过程中与图形用户界面 (GUI) 交互，导入和修改参数。\nS-Function 主体\n首先，sfun_callInterface 函数是 S-Function 的入口，调用了 setup 函数来进行初始化配置。setup 函数为 S-Function 设置了输入输出端口、采样时间、以及仿真相关的回调方法。\nsetup 函数\n在 setup 函数中，设置了 S-Function 的输入和输出端口配置。它没有输入端口，只有一个输出端口，并且输出的维度和数据类型进行了设定。该端口的采样模式为 Sample，表示输出数据为常规的样本数据。\n此外，SampleTimes 被设置为 [0 0]，这意味着该 S-Function 会立即执行并且不会进行周期性的采样。通过注册 PostPropagationSetup, InitializeConditions, Outputs, 和 Terminate 四个方法，定义了仿真生命周期内不同阶段的行为。\n最后，set_param 设置了 OpenFcn 触发，指向了 start_import_gui 函数，用于启动 GUI 界面。\nPostPropagationSetup 函数\n该函数用于声明 S-Function 中的 DWork（数据工作区）。DWork 是用来存储状态信息的地方。这里定义了三个 DWork 变量：\n\nguiLaunched 用于标识 GUI 是否已启动。\nconfirmationFlag 用于存储从 GUI 获取的确认状态。\nsimStarted 用于标记仿真是否已经启动。\n\n这些 DWork 变量的作用是确保 GUI 在需要时只启动一次，并且管理仿真状态，防止重复操作。\nInitCond 函数\nInitCond 函数在每次仿真开始时被调用，用来初始化 DWork 变量。在这里，所有的标志变量（guiLaunched, confirmationFlag, simStarted）都被初始化为 0，表示 GUI 尚未启动，确认标志为未设置，仿真尚未开始。\nOutputs 函数\nOutputs 函数是在仿真过程中持续被调用的，用来控制和更新仿真输出。首先，它获取了 GUI 启动状态、确认标志和仿真启动状态。如果 GUI 尚未启动，则调用 start_import_gui 函数启动 GUI 界面，并将 guiLaunched 标志设为 1。\n如果 GUI 已经启动，尝试从基础工作空间获取 confirmationFlag 变量的值。如果获取到有效值，则更新 DWork 中的 confirmationFlag。\n然后，函数检查确认标志的值：\n\n如果 confirmationFlag 为 1 且仿真尚未启动，则自动启动仿真，并将 simStarted 设为 1。\n如果 confirmationFlag 为 -1，表示取消，尝试停止正在运行的仿真。\n\nTerminate 函数\nTerminate 函数在仿真结束时调用，主要作用是清理基础工作空间中的标志变量 confirmationFlag，以防止在下次仿真中出现残留的状态信息。\nstart_import_gui 函数\nstart_import_gui 函数用于创建并显示 GUI 窗口。首先，它计算并设置窗口居中显示的坐标。然后，创建了一个图形界面，并在其中添加了以下元素：\n\n一个按钮用来触发数据导入。\n一个表格用来显示导入的数据。\n一个文本框用来显示当前选择的文件夹路径。\n“确认”和“取消”按钮，用来控制数据导入和取消操作。\n\n此外，在 GUI 初始化时加载了一个动态链接库（DLL），用于后续的参数导入和修改操作。\n调用Dll\n% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\nimport_data 函数\nimport_data 函数是在用户点击导入按钮时调用的。它弹出一个文件夹选择对话框，允许用户选择包含数据文件的文件夹。如果用户选择了文件夹并且其中包含 bwiparamtemp.ini 文件，程序会调用 DLL 函数读取该文件中的参数并将其显示在表格中。\nconfirm_action 函数\nconfirm_action 函数在用户点击“确认”按钮时被调用。它从表格中读取每个参数的名称和值，并将更新的参数通过 DLL 保存到指定路径的 .ini 文件中。如果参数值有变化，则执行更新操作。\n更新成功后，将 confirmationFlag 设置为 1，表示操作已完成，仿真可以开始。\ncancel_action 函数\ncancel_action 函数在用户点击“取消”按钮时调用。它将 confirmationFlag 设置为 -1，表示取消操作，然后关闭 GUI 窗口。\nclose_gui 函数\nclose_gui 函数用于关闭 GUI 窗口时调用。它会卸载已经加载的 DLL，并释放其他资源。\n总结\n这段代码实现了一个与 Simulink 模型交互的 GUI 系统，允许用户在仿真过程中导入和修改参数，启动或停止仿真。代码通过 S-Function 接口与 Simulink 仿真框架进行集成，并使用 MATLAB 图形界面元素提供用户交互界面。设计上使用了 DWork 数据工作区来存储和管理仿真状态，并通过回调函数实现不同阶段的功能。\n关于文件在不同运行环境下编码不同的问题\n\n其主要原因在于，Matlab的运行环境和Visual Studio不同，而封装的读写代码中用到了windows的API，该API会根据运行编译环境来选择不同的写入方式，而Matlab默认使用UTF-8，从而导致写入数据时中文出现乱码的情况，如下图\n\n如果不需要在多个环境下运行（如Unicode），我们可以固定写入方式，如读写均采用ANSI方式\nchar *CIniFile::ReadString(string &amp;m_Sec, string &amp;m_Ident, char *m_Def)&#123;\tGetPrivateProfileStringA(m_Sec.c_str(), m_Ident.c_str(), m_Def, Buffer, sizeof(Buffer), m_Name);\treturn Buffer;&#125;bool CIniFile::WriteString(const char *m_Sec, const char *m_Ident, const char *m_Val)&#123;\treturn (bool)WritePrivateProfileStringA(m_Sec, m_Ident, m_Val, m_Name);&#125;\n也可以使用开源替代库来替代原有的ini操作类，如SimpleIni，或者自己手动检测编码，手动写入，如下\nvoid CIniFile::detectEncoding() &#123;\tm_isUtf8 = false;\tm_hasUtf8BOM = false;\tunsigned char bom[3] = &#123; 0,0,0 &#125;;\tif (FILE* f = std::fopen(m_Name, &quot;rb&quot;)) &#123;\t\tstd::fread(bom, 1, 3, f);\t\tstd::fclose(f);\t\tif (bom[0] == 0xEF &amp;&amp; bom[1] == 0xBB &amp;&amp; bom[2] == 0xBF) &#123;\t\t\tm_isUtf8 = true;\t\t\tm_hasUtf8BOM = true;\t\t&#125;\t&#125;\t// 如果无 BOM：保守视为 MBCS/ANSI（如 GBK）；这样不会把老文件强转 UTF-8。&#125;bool CIniFile::saveInternal() &#123;\tif (!m_loaded) return false;\t// UTF-8 文件：是否写 BOM：保持与原文件一致\tconst bool addSig = (m_isUtf8 &amp;&amp; m_hasUtf8BOM);\t// 如果是 GB2312/GBK 编码，保存时不写 BOM\tif (!m_isUtf8) &#123;\t\tSI_Error rc = m_ini.SaveFile(m_Name, false); // No BOM for MBCS/ANSI\t\tif (rc &lt; 0) return false;\t&#125;\telse &#123;\t\t// 保存为 UTF-8 编码，并且根据原文件是否有 BOM 来决定是否加 BOM\t\tSI_Error rc = m_ini.SaveFile(m_Name, addSig);\t\tif (rc &lt; 0) return false;\t&#125;\tm_dirty = false;\treturn true;&#125;\n\n注意：如果非同一个项目，需要把所有用到的项目进行编译，并把运行需要的dll文件拷贝到Matlab环境下\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"关于Clash开启TUN无法联网的问题","url":"/posts/78c6fb80/","content":"之前我一直在用 Clash for Windows 科学上网。后来为了使用 Google 的反重力（Antigravity）软件，需要开启 TUN 模式，但我这边出现了一个非常折磨人的问题：只要一打开 TUN，就直接断网。\n这期间我在网上翻了无数帖子、试了无数“玄学设置”，都没能根治。中间还换过同门的一款 CFW（确实能开 TUN 正常用），但它有一个新毛病：会随机掉网——有时一瞬间，有时持续十几秒，尤其在和 AI 对话时，断一下就可能导致长回答直接中断，反复重试也很浪费时间。\n于是我决定换到口碑更好、且仍在维护的 Clash Verge Rev。结果安装后发现：开启 TUN 依然无法联网。这让我意识到：问题不在某一款软件，而在我的网络环境/路由策略上。\n直到某次我无意间翻日志，看到了“不太一样”的提示（大意是内核选择的出口接口/路由不对），我才突然反应过来——\n\n\n我的以太网（Ethernet）连的是内网。\n如果系统默认把“以太网”当成更优先的出口，Clash 开启 TUN 后把流量按默认路由丢给以太网，那怎么可能访问公网？\n\n所以真正要解决的不是“怎么调 Clash”，而是：\n让系统默认出口走 WLAN（Wi-Fi），而不是以太网。\n下面记录两种我亲测有效的方案。\n\n症状表现\n\n\nClash Verge Rev（或其他支持 TUN 的客户端）开启 TUN 后：\n\n浏览器打不开网页 / 全局断网\n或日志里出现 IP/路由相关报错（比如出口接口选择异常、路由不可达等）\n\n\n关闭 TUN 一切恢复正常\n\n\n根因：默认路由/接口优先级选错了\nWindows 在多网卡并存时，会根据 接口跃点数（Interface Metric）、路由表等规则决定默认出口。\n如果你的 以太网优先级高于 Wi-Fi，系统就可能优先走以太网默认路由——而你这条以太网只通内网，不通公网，于是“看起来像是 TUN 把网搞没了”。\n\n方案一：禁用以太网（有副作用）\n适用场景：你暂时不需要访问内网服务，只想立刻恢复公网。\n操作步骤\n\nWin + R 输入 ncpa.cpl 回车（打开“网络连接”）\n找到 以太网（Ethernet） → 右键 → 禁用\n再打开 Clash 的 TUN，通常就能直接联网\n\n缺点\n\n禁用后 无法访问内网资源（例如内网服务器、NAS、实验室网段等）\n需要内网时还得手动启用回来\n\n\n方案二：提升 WLAN 优先级（推荐）\n核心思路：把 Wi-Fi 的 Metric 调小（优先级更高），把 以太网的 Metric 调大（优先级更低）。\n这样默认出口走 Wi-Fi，但你访问内网网段时，依然可以走以太网（只要路由存在）。\n方法 A：图形界面修改（稳定、直观）\n\n建议 IPv4 和 IPv6 都改一下，避免某些环境下“IPv6 先走错”。\n\n\n\nWin + R → 输入 ncpa.cpl\n\n\n\n右键 Wi-Fi → 属性\n\n\n\n双击 Internet 协议版本 4 (TCP/IPv4) → “高级…”\n\n\n\n\n取消勾选 自动跃点数（Automatic metric）\n\n\n在“接口跃点数”填一个较小值，例如：5 或 10\n\n\n\nIPv6（TCP/IPv6）同样操作一遍（可选但推荐）\n\n\n\n\n右键 以太网 → 属性\n\n操作同上\n\n\n同样进入 IPv4/IPv6 高级设置\n取消自动跃点数\n设置一个较大的值，例如：50 / 100\n\n\n\n修改后一般无需重启，断开重连 Wi-Fi/以太网或重启 Clash 即可。\n\n方法 B：命令行修改（适合记录/脚本化）\n以管理员身份打开 PowerShell，然后：\n# 查看当前接口与跃点数Get-NetIPInterface | Sort-Object InterfaceMetric | Format-Table ifIndex,InterfaceAlias,AddressFamily,InterfaceMetric# 把 Wi-Fi 提高优先级（metric 更小）Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv4 -InterfaceMetric 5Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv6 -InterfaceMetric 5# 把 Ethernet 降低优先级（metric 更大）Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv4 -InterfaceMetric 50Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv6 -InterfaceMetric 50\n\n这是我修改后的配置\n\n注意：不同机器网卡名称可能不是 WLAN / 以太网，以你 Get-NetIPInterface 里看到的 InterfaceAlias 为准。\n\n进阶：用 Proxifier 给 AI 工具做应用级代理，减少对话断连\n即便把 TUN 问题解决了，我还遇到过 AI 工具网络不稳定、对话偶发中断 的情况。很多 AI 客户端/IDE 插件并不总是“乖乖走系统代理”，或者在网络切换时连接更容易抖动。\n我的做法是：不用全局折腾，把 AI 相关进程强制走 Clash 的本地 SOCKS5 代理（应用级代理），让它们的网络路径更一致，从而减少断连。\n下面以我当前配置为例：\n1）在 Proxifier 添加 Clash 的 SOCKS5 代理\n打开 Proxifier：\n\n\nProfile → Proxy Servers... → Add...\n或点击图中位置\n\n\n\n\n按如下填写：\n\n\nAddress：127.0.0.1\n\n\nPort：7897\n\n\nProtocol：SOCKS Version 5\n\n\nAuthentication 不用勾（一般 Clash 本地不需要）\n\n\n\n\n\n点 Check 测试连通性，确认 OK\n\n\n\n\n提醒：7897 是我这边 Clash 的 SOCKS 端口，你的端口以 Clash/Verge 的端口设置为准。\n\n2）新增一条“AI”规则，只代理指定程序\n\n\nProfile → Proxification Rules... → Add...\n或点击图中位置\n\n\n\n\nName：AI（勾选 Enabled）\n\n\nApplications：填入需要强制走代理的程序：\n\nantigravity.exe; language_server_windows_x64.exe; cursor.exe\n\n\n\nTarget hosts：留空（表示不限制域名）\n\n\nTarget ports：Any\n\n\nAction：选择刚才创建的代理\n\nProxy SOCKS5 127.0.0.1\n\n\n\n最后把 AI 规则放到 Default 规则之上（规则是从上往下匹配的），避免被默认规则抢先匹配。\n\n\n3）效果\n\n只有 AI 相关进程走代理\n内网/其他软件照常走直连或按你自己的规则走\n对话连接更稳定：不会因为某些程序绕过系统代理而“时通时不通”，也更不容易在长对话时突然断掉\n\n","categories":["Clash"],"tags":["Clash","Proxifier","Tun"]},{"title":"Simulink调用外部Dll可视化《二》","url":"/posts/4e6df0d5/","content":"介绍\n这篇文章主要实现在Simulink中可视化的工作，由于自身求解工具的可视化代码采用C++编程，同时与项目耦合过多，难以独立摘出或通过Matlab重现，因此这里采用新建桥接工程将所有需要用到的可视化代码封装并导出\n封装Dll并导出C函数\n首先在VS中新建空项目工程并进行配置，主要是关于项目依赖、导出Dll相关，然后将所有可能用到的代码进行简化和封装，我这里采用的类进行管理，由于跟项目相关不进行展示，新建XXXBridgeDLL.h和XXXBridgeDLL.cpp用于导出C接口供Matlab调用，内容如下\n#pragma once#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    EXPORT_API void* CreateProcessor();    EXPORT_API void DeleteProcessor(void* p);    EXPORT_API int  ReadXXXDat(void* p, const char* folder, int* pNumPts);        EXPORT_API int   GetPointCount(void* p);                      /* 返回总点数         */    EXPORT_API int   CopyX_mm(void* p, double* out, int max);  /* 轴向坐标 (mm)     */    EXPORT_API int   CopyPower(void* p, double* out, int max);  /* 输出功率 (W)      */    EXPORT_API int   CopyGain(void* p, double* out, int max);  /* 增益 (dB)         */    EXPORT_API int   CopyEff(void* p, double* out, int max);  /* 效率 (%)          */#ifdef __cplusplus&#125;#endif\n这段代码是一个 C/C++ 动态链接库（DLL）的头文件（.h），用于定义向外部导出的一组函数接口。\n\nDLL 导出宏定义部分\n#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif\n\n作用：用于在不同编译阶段切换导出/导入。\n\n如果编译的是 DLL 本身（定义了 XXXBRIDGEDLL_EXPORTS），则 EXPORT_API 展开为 __declspec(dllexport)，导出符号；\n如果是使用 DLL 的客户端程序，则展开为 __declspec(dllimport)，用于导入符号。\n\n\n\n\nextern &quot;C&quot; 块\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif...#ifdef __cplusplus&#125;#endif\n\n使得这些函数按照 C语言方式 进行链接（不进行 C++ 名字改编 / name mangling），以便在 C/C++/Python/MATLAB 等跨语言调用时保持接口兼容。\n\n\n导出的函数接口\nEXPORT_API void* CreateProcessor();\n\n创建一个处理器对象，返回一个 void* 指针（通常是一个类的实例地址）。\n\nEXPORT_API void DeleteProcessor(void* p);\n\n删除处理器对象，释放资源。\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pNumPts);\n\n从指定文件夹读取数据，p 是处理器对象指针，folder 是数据路径，pNumPts 用于返回读取到的点数。\n\n\n数据访问函数（数据从内存复制出来）\nEXPORT_API int GetPointCount(void* p);\n\n获取数据点总数。\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max);\n\n复制轴向坐标数据（单位：mm）到 out 指针所指向的数组，max 是允许写入的最大点数。\n\nEXPORT_API int CopyPower(void* p, double* out, int max);\n\n复制输出功率数据（单位：瓦特）。\n\nEXPORT_API int CopyGain(void* p, double* out, int max);\n\n复制增益数据（单位：dB）。\n\nEXPORT_API int CopyEff(void* p, double* out, int max);\n\n复制电子效率数据（单位：百分比）。\n\n这个 DLL 接口提供了一个基于文件夹读取仿真结果（XXX仿真输出），并通过一系列函数获取：\n\n坐标（X）\n功率（Power）\n增益（Gain）\n效率（Eff）\n\n#define XXXBRIDGEDLL_EXPORTS#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125; extern &quot;C&quot; &#123;    EXPORT_API void* CreateProcessor() &#123; return new CXXXProcessor(); &#125;    EXPORT_API void  DeleteProcessor(void* p) &#123; delete static_cast&lt;CXXXProcessor*&gt;(p); &#125;    EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;        if (!p || !folder || !pts) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        bool ok = proc-&gt;ReadXXXDat(folder);        *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;        return ok;    &#125;    EXPORT_API int GetPointCount(void* p) &#123;        return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;    &#125;    EXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;        if (!p || !out || max &lt;= 0) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);        for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;        return n;    &#125;    EXPORT_API int CopyPower(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);    &#125;    EXPORT_API int CopyGain(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);    &#125;    EXPORT_API int CopyEff(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);    &#125;&#125;\n这段代码是 XXXBridgeDLL.dll 的 实现部分（C++源文件），与之前的头文件 XXXBridgeDLL.h 搭配使用，向外部程序提供接口来访问 XXX 仿真数据\n\n文件头部设置\n#define XXXBRIDGEDLL_EXPORTS\n\n定义此宏意味着当前正在编译 DLL，因此头文件中的 EXPORT_API 会变成 __declspec(dllexport)，导出接口。\n\n\n#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;\n\n引入头文件和 STL 库。CXXXProcessor 是处理器类，核心功能由它实现，接口只是封装。\n\n\n匿名命名空间 copyVector\nnamespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125;\n\n作用：通用的向 double* out 中复制数据的函数模板。\nSRC_GETTER 是一个 Lambda，返回某个 vector&lt;double&gt; 的引用。\n使用匿名命名空间是为了限定作用域（防止链接冲突）。\n\n\n导出接口（extern &quot;C&quot;）\n\nCreateProcessor\n\nEXPORT_API void* CreateProcessor() &#123;    return new CXXXProcessor();&#125;\n\n返回新建的处理器对象（指针以 void* 形式传出，保持 C 接口风格）。\n\n\nDeleteProcessor\n\nEXPORT_API void DeleteProcessor(void* p) &#123;    delete static_cast&lt;CXXXProcessor*&gt;(p);&#125;\n\n释放 CreateProcessor() 创建的对象。\n\n\nReadXXXDat\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;    if (!p || !folder || !pts) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    bool ok = proc-&gt;ReadXXXDat(folder);    *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;    return ok;&#125;\n\n调用 CXXXProcessor::ReadXXXDat(folder) 加载文件夹中的数据。\n加载成功后将数据点数写入 pts。\nm_vdpX 是轴向坐标数组。\n\n\nGetPointCount\n\nEXPORT_API int GetPointCount(void* p) &#123;    return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;&#125;\n\n返回总的数据点数（坐标数量）。\n\n\nCopyX_mm\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;    if (!p || !out || max &lt;= 0) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);    for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;    return n;&#125;\n\n将轴向坐标 m_vdpX（单位：米）转换为毫米（乘以 1000）并复制到 out 缓冲区。\n\n\nCopyPower, CopyGain, CopyEff\n\nEXPORT_API int CopyPower(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);&#125;\n\n通过 copyVector 模板复制 PowerOut 数据。\n\nEXPORT_API int CopyGain(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);&#125;\n\n复制增益（Gain）数据。\n\nEXPORT_API int CopyEff(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);&#125;\n\n复制效率（Eff）数据。\n\n\n模块用途概览\n\n\n\n函数名\n功能描述\n\n\n\n\nCreateProcessor\n创建处理器对象\n\n\nDeleteProcessor\n释放处理器对象\n\n\nReadXXXDat\n从指定目录读取 XXX 数据文件\n\n\nGetPointCount\n获取总数据点数\n\n\nCopyX_mm\n获取轴向坐标（单位 mm）\n\n\nCopyPower\n获取输出功率（单位 W）\n\n\nCopyGain\n获取增益（单位 dB）\n\n\nCopyEff\n获取电子效率（单位 %）\n\n\n\n编译成功后会在指定目录生成dll文件，把dll文件和导出函数头文件放到Matlab的工作目录下供其使用\nMatlab及Simulink调用Dll\n在Matlab中新建m文件，内容如下\n% 0. 环境与路径dll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);endp   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;% --- 指针缓冲区 ---xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);x    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;% --- 绘图 ---figure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);% --- 清理 ---calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n这段 MATLAB 代码演示了如何通过调用 C++ 动态链接库 XXXBridgeDLL.dll 来读取 XXX 仿真数据，并绘制输出功率、增益和效率随轴向位置变化的曲线\n\n1. 加载 DLL 与设置路径\ndll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);end\n\n设置 DLL 文件路径、头文件路径和数据文件夹路径。\n如果 DLL 尚未加载，则调用 loadlibrary 加载 DLL 并注册其接口函数。\n\n\n2. 创建处理器并读取数据\np   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;\n\n创建处理器实例 p（C++ 对象的指针）。\n申请一个 int32 类型的指针 nPt 用于返回数据点数量。\n调用 ReadXXXDat 从 dir 文件夹读取仿真数据。\n将数据点个数保存在 N 中。\n\n\n3. 分配输出缓冲区并复制数据\nxPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);\n\n为四类数据创建指针缓冲区，长度为 N。\n通过调用 DLL 中的接口函数将数据从 C++ 内部复制到 MATLAB 缓冲区中。\n\n\n4. 将指针值转换为 MATLAB 向量\nx    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;\n\n将指针对象中的数据取出，转换为 MATLAB 可用的数组。\n\n\n5. 绘制仿真结果曲线\nfigure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);\n\n打开一个新图像窗口，将三种数据绘制在三个子图中：\n\n输出功率 vs. 坐标\n增益 vs. 坐标\n效率 vs. 坐标\n\n\n\n\n6. 清理资源\ncalllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n\n释放处理器对象 p。\n卸载 DLL，释放系统资源。\n\n这段代码实现了：\n\n加载 DLL 并创建处理器。\n调用 C++ 函数读取 XXX 仿真数据。\n将结果复制到 MATLAB 并绘图。\n使用完后清理资源，避免内存泄漏。\n\n运行效果如下\n\n与求解工具链接\n现在的可视化模块只是通过硬编码的方式读取指定文件，下面需要把求解工具和可视化链接，通过求解工具输出的参数来进行泛型可视化\n修改现有的调用求解工具S Function代码\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\n这段代码是一个 Level-2 MATLAB S-Function，用于在 Simulink 中检测输入信号的 上升沿（从0变为1），然后异步启动一个外部 EXE 程序（XXX.exe），并轮询进程状态，完成后自动停止仿真。\n\n\n\n步骤\n说明\n\n\n\n\n①\n输入信号从 0 → 1，触发启动 XXX.exe\n\n\n②\n启动进程，记录 PID 和运行状态\n\n\n③\n每 0.5 秒轮询一次，判断进程是否结束\n\n\n④\n若 EXE 正常退出，则输出状态为 2，仿真停止；否则输出 -1 并停止\n\n\n⑤\n清理进程资源，防止残留\n\n\n\n\n调用工具代码解释\n\n顶部函数入口\n\nfunction sfun_callXXX(block)    setup(block);end\n\nS-Function 的主函数入口，调用 setup() 注册接口。\n\n\nsetup(block)：配置端口、采样、方法等\n\nblock.NumInputPorts  = 1;  % 输入1个信号（控制启动）block.NumOutputPorts = 1;  % 输出当前状态（0, 1, 2, -1）block.SampleTimes = [0.5 0];  % 每 0.5 秒执行一次block.RegBlockMethod(...)    % 注册各阶段的回调函数set_param(..., &#x27;StopTime&#x27;, &#x27;inf&#x27;);  % 设置仿真不主动终止\n\nPostProp：声明离散状态（DWork）\n\nblock.NumDworks = 3;names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;\n\nprevU：上一时刻输入值（检测上升沿用）\nexeState：执行状态（0=未启动，1=运行中，2=正常退出，-1=错误）\npid：外部进程 PID\n\n\nInitCond：初始化 DWork 数据\n\nblock.Dwork(1).Data = 0;  % 上一时刻输入值block.Dwork(2).Data = 0;  % exeStateblock.Dwork(3).Data = 0;  % pid\n\nOutputs(block)：主逻辑处理区\n\nu = block.InputPort(1).Data;\n上升沿触发：启动外部 EXE\nif u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0    [ok, procObj, pid, exeState] = launchExe(...);end\n运行中：轮询状态（每次采样调用）\nif exeState == 1    [exeState, pid] = pollProcessExitStatus(...);    if exeState == 2 || exeState == -1        stopSimulation(block);  % 进程完成 → 停止仿真    endend\n输出当前状态并保存状态数据\nblock.OutputPort(1).Data = exeState;\n\nTerminate：终止残留进程（防挂后台）\n\nif ~isempty(procObj)    terminateProcess(procObj);end\n内部 helper 函数说明\nlaunchExe(exePath, paramPath)\n\n启动 XXX.exe\n参数格式是 '1|1|参数路径'\n返回是否成功、进程对象、PID、状态\n\npollProcessExitStatus(procObj, pid)\n\n检查进程是否已退出\n如果异常，也尝试通过 PID 判断\n根据 ExitCode 判断：\n\n0 → 正常结束（返回状态 2）\n非 0 → 异常（状态 -1）\n\n\n\nisProcAlive(pid)\n\n尝试通过 PID 检查进程是否还活着\n\nterminateProcess(procObj)\n\n如果进程还在运行，则强制结束并释放资源\n\nstopSimulation(block)\n\n调用 Simulink 命令强制停止整个仿真\n\n状态码含义总结\n\n\n\n状态码\n含义\n\n\n\n\n0\n初始未启动\n\n\n1\n正在运行 EXE\n\n\n2\nEXE 正常退出\n\n\n-1\n启动或执行异常\n\n\n\n修改M文件\n将调用dll的Matlab代码改为S Function的方式，并通过1→2来进行触发，代码如下\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)end\n这段代码实现了一个 MATLAB Level-2 S-Function，主要功能是当输入信号为 2 时触发外部 DLL（XXXBridgeDLL.dll）的数据读取和处理，之后进行数据的可视化。\n总体功能流程\n\n输入信号：该 S-Function 监听一个输入信号 u。\n脉冲触发：当信号 u == 2 且前一时刻 prevU != 2 时，触发读取数据。\n调用 DLL：加载外部 DLL (XXXBridgeDLL.dll)，读取 XXX 仿真数据。\n数据处理与绘图：读取坐标、功率、增益和效率数据，并绘制图形。\n清理资源：在操作完成后，清理 DLL 资源。\n\n代码分解\n\nsfun_callXXXProcess(block)\n\nfunction sfun_callXXXProcess(block)    setup(block);end\n\n这是 S-Function 的入口函数，调用 setup(block) 设置仿真模块的基本配置。\n\n\nsetup(block): 配置端口、采样时间与方法\n\nfunction setup(block)    block.NumInputPorts  = 1;  % 一个输入端口    block.NumOutputPorts = 0;  % 无输出端口    block.SampleTimes        = [0.5 0];  % 每 0.5 秒触发一次    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;  % 默认的仿真状态兼容性    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);end\n\n配置输入端口和采样时间（每 0.5 秒触发一次）。\n注册方法：PostPropagationSetup、InitializeConditions、Outputs 和 Terminate。\n\n\nPostProp(block): 声明 DWork 状态变量\n\nfunction PostProp(block)    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevU&#x27;;  % 存储上一时刻的输入信号    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;  % double 类型    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end\n\n声明一个名为 prevU 的 DWork 变量，用于保存前一时刻的输入信号值。\n\n\nInitCond(block): 初始化 DWork 数据\n\nfunction InitCond(block)    block.Dwork(1).Data = 0;  % 初始化 `prevU` 为 0end\n\n初始化时，prevU 设置为 0，表示初始状态。\n\n\nOutputs(block): 主逻辑处理区\n\nfunction Outputs(block)    u = block.InputPort(1).Data;  % 获取当前输入信号    prevU = block.Dwork(1).Data;  % 获取前一时刻的输入信号    if u == 2 &amp;&amp; prevU ~= 2        % 读取 XXX 数据        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);  % 加载 DLL        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);  % 创建处理器对象        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);  % 读取数据        N = nPt.Value;  % 获取数据点数量        % 初始化指针缓冲区        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        % 从 DLL 中复制数据到指针        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;, p, effPtr, N);        % 获取数据        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % 绘图        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % 清理资源        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end\n\n当 u == 2 时，调用 XXXBridgeDLL.dll 进行数据读取，获取 x（坐标）、pow（功率）、gain（增益）和 eff（效率）数据。\n使用 figure 绘制三张子图，显示输出功率、增益和效率随坐标的变化。\n在操作完成后，清理 DLL 资源。\n\n\nTerminate(~): 清理\n\nfunction Terminate(~)end\n\n在仿真结束时，Terminate 函数被调用，但在这个实现中没有进行额外操作。\n\n工作流程\n\n输入信号：当输入信号为 2 时，触发外部 EXE 进程。\n调用 DLL：通过 XXXBridgeDLL.dll 读取 XXX 仿真数据。\n数据处理与绘图：读取数据并绘制输出功率、增益和效率曲线。\n清理：仿真结束后清理 DLL 资源。\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"Simulink调用外部工具仿真《一》","url":"/posts/51a3b25e/","content":"该项目旨在使用Simulink来完成某些计算和仿真，计算工具采用自己的求解器，因此Simulink在这里的作用主要为模拟输入输出接口和触发信号，后续可能会引入优化器来对参数进行优化，本篇作为开头，主要介绍如何使用Simulink调用外部工具。\n创建m文件\n首先打开Matlab，指定工作路径，在命令行窗口输入edit sfun_callXXX从而在当前路径下创建sfun_callXXX.m文件，输入下述代码\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);endfunction setup(block)    % 一个输入端口：触发信号（1 表示触发执行）    block.NumInputPorts = 1;    block.SetPreCompInpPortInfoToDynamic;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    % 一个输出端口：执行状态    block.NumOutputPorts = 1;    block.SetPreCompOutPortInfoToDynamic;    block.OutputPort(1).Dimensions   = 1;    block.OutputPort(1).DatatypeID   = 0;    block.OutputPort(1).Complexity   = &#x27;Real&#x27;;    % 一个 Dwork 变量：用于保存上一个输入（用于边沿检测）    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevInput&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;    % 每 1 秒调用一次    block.SampleTimes = [1.0 0.0];    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.InitializeConditions = @InitConditions;    block.Outputs              = @Output;endfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值：输入未触发endfunction Output(block)    u = block.InputPort(1).Data;    prev = block.Dwork(1).Data;    % 只在输入从 0 → 1 的跳变时执行    if u == 1 &amp;&amp; prev == 0        % 配置路径        exePath = &#x27;I:\\XXX.exe&#x27;;        paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        % 检查 EXE 是否存在        if ~isfile(exePath)            warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);            block.OutputPort(1).Data = -2;            block.Dwork(1).Data = u;            return;        end        % 检查参数路径是否存在        if ~isfolder(paramPath)            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);            block.OutputPort(1).Data = -3;            block.Dwork(1).Data = u;            return;        end        % 构造命令        exePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];        paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];        args = [&#x27;1|1|&#x27; paramPathQuoted];        cmd = [exePathQuoted &#x27; &#x27; args];        disp([&#x27;[XXX] 正在执行: &#x27; cmd]);        % 执行命令        status = system(cmd);        if status == 0            block.OutputPort(1).Data = 1;  % 成功        else            block.OutputPort(1).Data = -1; % 执行失败        end    else        block.OutputPort(1).Data = 0;  % 无触发    end    % 更新 Dwork 状态    block.Dwork(1).Data = u;end\n该函数的主要作用是在 Simulink 中通过输入触发器调用外部程序 XXX.exe，实现如下特性：\n\n支持多次触发执行，但只在输入信号从 0 到 1 的上升沿执行\n执行结果通过输出端口返回状态码：\n\n1 → 执行成功；\n-1 → 执行失败；\n-2 → EXE 路径不存在；\n-3 → 参数路径不存在；\n0 → 没有触发。\n\n\n\n主函数部分\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);end\n这是主入口函数，Simulink 在加载该 S-Function 时会调用这个函数。block 是代表这个 S-Function 块的对象，包含输入输出、状态等所有接口\nfunction setup(block)\nblock.NumInputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;  % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;\n设置只有 1 个输入端口，类型为 double 实数，输入数据是一个触发信号，为 1 表示要执行 XXX.exe\nblock.NumOutputPorts = 1;block.SetPreCompOutPortInfoToDynamic;block.OutputPort(1).Dimensions   = 1;block.OutputPort(1).DatatypeID   = 0;block.OutputPort(1).Complexity   = &#x27;Real&#x27;;\n也只有 1 个输出端口，用于输出执行状态\nblock.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;block.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;\nDwork 是 S-Function 中的离散状态变量，在仿真期间保留，这里用来保存上一时刻的输入值，从而判断是否出现了 0→1 的跳变（上升沿）\nblock.SampleTimes = [1.0 0.0];block.SimStateCompliance = &#x27;DefaultSimState&#x27;;block.InitializeConditions = @InitConditions;block.Outputs              = @Output;\nSampleTimes = [1.0 0.0] → 每 1 秒调用一次 Output 函数，注册初始化函数和主输出函数\n初始化函数 InitConditions\nfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值设为0，表示“未触发”end\n初始化 Dwork 状态变量，表示开始时没有任何触发信号\n主执行函数 Output\nfunction Output(block)\nu = block.InputPort(1).Data;prev = block.Dwork(1).Data;\nu 是当前输入值，prev 是上一个采样时刻的输入值，用于检测跳变\nif u == 1 &amp;&amp; prev == 0\n\n只有从 0 → 1 的跳变，才执行外部命令\n如果持续为 1，不会重复执行\n\nexePath = &#x27;...XXX.exe&#x27;;paramPath = &#x27;...指定输入&#x27;;\nexePath 是要调用的外部可执行文件路径，paramPath 是输入数据或配置文件的路径\nif ~isfile(exePath)    warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);    block.OutputPort(1).Data = -2;    block.Dwork(1).Data = u;    return;endif ~isfolder(paramPath)    warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);    block.OutputPort(1).Data = -3;    block.Dwork(1).Data = u;    return;end\n\n如果 EXE 不存在 → 返回 -2\n如果参数目录不存在 → 返回 -3\n\nexePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];args = [&#x27;1|1|&#x27; paramPathQuoted];cmd = [exePathQuoted &#x27; &#x27; args];disp([&#x27;[XXX] 正在执行: &#x27; cmd]);\n\n\n把路径加引号是为了防止路径中有空格报错\n\n\n执行命令类似于（根据自己的可执行文件进行修改，这里的1|1|是参数需要）\n&quot;I:\\...\\XXX.exe&quot; 1|1|&quot;C:\\Users\\...\\指定输入&quot;\n\n\nstatus = system(cmd);if status == 0    block.OutputPort(1).Data = 1;  % 成功else    block.OutputPort(1).Data = -1; % 失败end\n\nsystem(cmd) 用于调用系统命令\n如果返回值为 0，表示执行成功 → 输出 1\n否则 → 输出 -1\n\nelse    block.OutputPort(1).Data = 0;  % 无触发，不执行end\n\n输入无变化或不是上升沿时，输出 0\n\nblock.Dwork(1).Data = u;\n\n用当前输入值覆盖 Dwork，供下一次仿真调用使用\n\n\n\n\n输出值\n含义\n\n\n\n\n1\n成功执行 XXX.exe\n\n\n-1\n执行失败\n\n\n-2\n找不到 EXE\n\n\n-3\n参数目录不存在\n\n\n0\n无触发（未上升沿）\n\n\n\n代码流程概览\n\n\n\n阶段\nSimulink 触发\n函数\n功能描述\n\n\n\n\n模块加载时\nSimulink 加载模型\nsfun_callXXX() → setup()\n初始化输入输出端口、采样时间、Dwork 状态变量等\n\n\n仿真开始时\n点击仿真按钮 Run\nInitializeConditions()\n将 prevInput 初始化为 0\n\n\n每个仿真步\n每秒调用一次\nOutput()\n检测输入信号是否跳变为 1，如果是就执行 XXX.exe\n\n\n\n在Simulink中使用S Function\n在命令行窗口输入simulink或直接点击菜单面板“Simulink”来打开Simulink仿真工具，新建空白模型\n\n将该模型保存到当前目录下（与上述.m文件相同），在库浏览器中依次将Constant、Level-2 MATLAB S-Function（不能直接选S-Function，因为我们的代码是针对Level 2的）、Display模块拖入，并连接如下\n\n双击S-Function模块，将 S-function name 设为 sfun_callXXX，确认之后提示出错。\n这里的主要原因为MATLAB Level-2 S-Function 的 Dwork 区只能在 PostPropagationSetup() 阶段设置，而目前把 NumDworks 和 Dwork 配置写在了 setup() 里，这是不允许的，修改如下\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function：检测 0→1 边沿并调用 XXX.exe    setup(block);end%-----------------------------------------------------------%function setup(block)%% 1. 端口block.NumInputPorts  = 1;block.NumOutputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.SetPreCompOutPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;   % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;block.OutputPort(1).Dimensions = 1;block.OutputPort(1).DatatypeID = 0;block.OutputPort(1).Complexity = &#x27;Real&#x27;;%% 2. 采样时间（每 1 s 执行一次）block.SampleTimes = [1 0];%% 3. S-Function 状态机合规block.SimStateCompliance = &#x27;DefaultSimState&#x27;;%% 4. 注册回调 —— 用 RegBlockMethod（关键）block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostPropSetup);block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitConditions);block.RegBlockMethod(&#x27;Outputs&#x27;,              @Output);end%-----------------------------------------------------------%function PostPropSetup(block)%% Dwork 在此阶段声明block.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;  % doubleblock.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;end%-----------------------------------------------------------%function InitConditions(block)%% 仿真开始时：prevInput 置零block.Dwork(1).Data = 0;end%-----------------------------------------------------------%function Output(block)%% 边沿检测 + 执行外部 EXEu    = block.InputPort(1).Data;prev = block.Dwork(1).Data;if u == 1 &amp;&amp; prev == 0    % 路径设定    exePath   = &#x27;I:\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    % -------- 路径检查（兼容旧版 MATLAB：用 exist） --------    if exist(exePath,&#x27;file&#x27;) ~= 2        warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath);        block.OutputPort(1).Data = -2;    elseif exist(paramPath,&#x27;dir&#x27;) ~= 7        warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);        block.OutputPort(1).Data = -3;    else        % 构造命令        cmd = [&#x27;&quot;&#x27; exePath &#x27;&quot; 1|1|&quot;&#x27; paramPath &#x27;&quot;&#x27;];        disp([&#x27;[XXX] 执行: &#x27; cmd]);        status = system(cmd);        block.OutputPort(1).Data = double(status == 0) * 2 - 1;  % 1 成功 /-1 失败    endelse    block.OutputPort(1).Data = 0;                                % 未触发end% 更新上周期输入block.Dwork(1).Data = u;end\n运行仿真，观察到Display显示为1表明正确调用执行，为了方便截图，我把Display换为Scope，观察如下\n\n第一秒，输入从0→1 调用exe成功并输出1，第二秒没有跳变发生，输出为0\nSimulink 对该 S-Function 模块的调用时序如下\n\n\n\n时间\n执行\n来自 S-Function 的函数调用\n说明\n\n\n\n\n0s\n初始化\nsetup() → InitializeConditions()\n初始化端口、状态变量（prevInput=0）\n\n\n每秒\n仿真步\nOutput() 被调用一次\n判断输入信号是否从 0→1 变化，若是就调用 EXE\n\n\n\n假设输入信号如下\n\n\n\n步数\n输入 u\nprevInput\n是否执行 EXE？\n输出值\n\n\n\n\n1\n0\n0\n否\n0\n\n\n2\n1\n0\n是（跳变）\n1 / -1\n\n\n3\n1\n1\n否\n0\n\n\n4\n0\n1\n否\n0\n\n\n5\n1\n0\n是（跳变）\n1 / -1\n\n\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"创建VS Code插件","url":"/posts/7d850c90/","content":"本人打算创建一个VS Code插件用于调试代码，拟结合AI用于生成测试用例，分析代码等\n环境准备\n安装Node.is\nVS Code 插件开发使用 JavaScript / TypeScript 编写，需要 Node.js 来运行开发脚本和构建流程\n官网：https://nodejs.org\n安装后验证是否成功\nnode -v\n\n安装脚手架\n这里会用到yo和generator-code\nyo 是 Yeoman 的命令行工具，是一个用于快速生成项目脚手架的工具，类似于项目生成器\ngenerator-code 是一个 Yeoman 生成器插件，专门用于生成 VS Code 插件项目 的脚手架。\n全局安装yo和generator-code\nnpm i -g yo generator-code\n我这里已经安装过了，输出如下\n\n创建VS Code插件项目\n新建工程\n在你需要创建插件的目录下输入\nyo code\n执行如下\n\n\n[!NOTE]\n这里将会依次问你如下几个问题\n\n选择你的插件类型\n插件的名字\n插件的唯一标识\n插件的描述\n是否需要git仓库\n打包工具选择\n选择包管理工具\n\n\n我的配置如图\n\n选择完成之后出现如下内容\n\n然后可以选择打开新建的工程或者直接跳过，这里选择第一个，打开之后项目结构如图所示，其中最重要的文件是package.json和extension.js，到这里一个VS Code的框架算是基本完成了。\n\n目录介绍\n\n[!NOTE]\n.vscode: 里面的文件是用来测试插件或者测试代码的一些文件。\nnode_modules: 第三方依赖。\nsrc/test：测试文件。\nsrc/extension.ts：插件的主文件\n\npackage.json文件\n该文件是vscode扩展的清单文件，具体可以看文档：发布内容配置\n&#123;  &quot;name&quot;: &quot;code-auto-test&quot;,\t// 插件名  &quot;displayName&quot;: &quot;code-auto-test&quot;,\t// 应用市场显示的名字  &quot;description&quot;: &quot;自动执行代码测试&quot;,\t// 插件描述  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;engines&quot;: &#123;    &quot;vscode&quot;: &quot;^1.101.0&quot;  &#125;,  &quot;categories&quot;: [    &quot;Other&quot;\t// 扩展类别  ],   // 激活事件组，在那些事件情况下被激活  &quot;activationEvents&quot;: [],   // 插件的主入口文件  &quot;main&quot;: &quot;./out/extension.js&quot;,  &quot;contributes&quot;: &#123;     // 命令    &quot;commands&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.helloWorld&quot;,        &quot;title&quot;: &quot;Hello World&quot;      &#125;    ]  &#125;,  &quot;scripts&quot;: &#123;    &quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,    &quot;compile&quot;: &quot;tsc -p ./&quot;,    &quot;watch&quot;: &quot;tsc -watch -p ./&quot;,    &quot;pretest&quot;: &quot;npm run compile &amp;&amp; npm run lint&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;test&quot;: &quot;vscode-test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@types/vscode&quot;: &quot;^1.101.0&quot;,    &quot;@types/mocha&quot;: &quot;^10.0.10&quot;,    &quot;@types/node&quot;: &quot;20.x&quot;,    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.31.1&quot;,    &quot;@typescript-eslint/parser&quot;: &quot;^8.31.1&quot;,    &quot;eslint&quot;: &quot;^9.25.1&quot;,    &quot;typescript&quot;: &quot;^5.8.3&quot;,    &quot;@vscode/test-cli&quot;: &quot;^0.0.10&quot;,    &quot;@vscode/test-electron&quot;: &quot;^2.5.2&quot;  &#125;&#125;\nextension.js文件\n入口文件，即package.json中main字段对应的文件，文件中有导出两个方法：activate和deactivate\n测试\n在package.json文件中添加激活事件\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.helloWorld&quot;],\n终端进入项目\ncd code-auto-testnpm installnpm run compile\n这会将 src/extension.ts 编译到 out/extension.js，为插件运行做好准备\nF5运行插件，会启动扩展宿主环境，打开任意文件夹，按下ctrl+shift+p 并输入helloworld\n\n确认选择Hello World，右下角出现如图内容表明运行成功\n\n先到这吧，累了😮‍💨\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"Ascend C算子开发能力认证（中级）","url":"/posts/9e1eacb0/","content":"认证要求\n实现Ascend C算子Sigmoid,算子命名为SigmoidCustom,编写其kernel侧代码、host侧代码,并完成aclnn算子调用测试。\n相关算法:\nsigmoid(x)=1/(1+exp(−x))sigmoid(x) = 1/(1 + exp(-x))\nsigmoid(x)=1/(1+exp(−x))\n\n实现流程\n环境初始配置\n由于华为的ModelAtrs平台每次重启会把环境中除work目录之外的内容全部清除，因此每次需要重新设置环境，执行\nbash init_env.shsource ~/.bashrcsource /home/ma-user/Ascend/ascend-toolkit/set_env.shchmod +x -R *\n上述命令依次用于下载包、配置环境变量以及脚本权限等\n代码编写\n从认证平台下载压缩包，解压之后包含SigmoidCustom和AclNNInvocation两个文件夹，SigmoidCustom中的内容主要完成代码编写、编译运行等，AclNNInvocation用于实现调用、测试等\n文件主要内容如下\n\nHost测实现\n首先在sigmoid_custom_tiling.h完成tiling结构体设计，在代码的注释后添加如下内容\nTILING_DATA_FIELD_DEF(uint32_t, totalLength);TILING_DATA_FIELD_DEF(uint32_t, tileNum);\n然后在sigmoid_custom.cpp中的注释后添加\nuint32_t totalLength = context-&gt;GetInputShape(0)-&gt;GetOriginShape().GetShapeSize();context-&gt;SetBlockDim(BLOCK_DIM);tiling.set_totalLength(totalLength);tiling.set_tileNum(TILE_NUM);tiling.SaveToBuffer(context-&gt;GetRawTilingData()-&gt;GetData(), context-&gt;GetRawTilingData()-&gt;GetCapacity());context-&gt;GetRawTilingData()-&gt;SetDataSize(tiling.GetDataSize());size_t *currentWorkspace = context-&gt;GetWorkspaceSizes(1);currentWorkspace[0] = 0;return ge::GRAPH_SUCCESS;\nDevice测实现\n这里的代码稍微复杂，需要用户自行实现核函数的初始化、内存迁移、算法实现等，完整代码如下\n#include &quot;kernel_operator.h&quot;using namespace AscendC;constexpr int32_t BUFFER_NUM = 2;class KernelSigmoid &#123;public:    __aicore__ inline KernelSigmoid() &#123;&#125;    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, uint32_t totalLength, uint32_t tileNum)    &#123;        //考生补充初始化代码        this-&gt;blockLength = totalLength / AscendC::GetBlockNum();        this-&gt;tileNum = tileNum;        this-&gt;tileLength = this-&gt;blockLength / tileNum / BUFFER_NUM;        xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        yGm.SetGlobalBuffer((__gm__ DTYPE_Y *)y + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        pipe.InitBuffer(inQueueX, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(outQueueY, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer1, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer2, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer3, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer4, this-&gt;tileLength * sizeof(half));    &#125;    __aicore__ inline void Process()    &#123;        //考生补充对“loopCount”的定义，注意对Tiling的处理        int32_t loopCount = this-&gt;tileNum * BUFFER_NUM;        for (int32_t i = 0; i &lt; loopCount; i++) &#123;            CopyIn(i);            Compute(i);            CopyOut(i);        &#125;    &#125;private:    __aicore__ inline void HighPrecisionReciprocal(LocalTensor&lt;half&gt;&amp; dst,                                               const LocalTensor&lt;half&gt;&amp; src,                                               int32_t length,                                               int iterations = 2)    &#123;        LocalTensor&lt;half&gt; tmp = tmpBuffer4.Get&lt;half&gt;();        half two = 2.0h,negone=-1.0h;        // 初始近似值 (可以使用硬件Reciprocal的初始值)        AscendC::Reciprocal(dst, src, length);        // 牛顿迭代: x_&#123;n+1&#125; = x_n * (2 - a * x_n)        for (int i = 0; i &lt; iterations; ++i) &#123;            AscendC::Mul(tmp, src, dst, length);    // tmp = a * x_n            AscendC::Muls(tmp, tmp, negone, length);   // tmp = 2 - a * x_n            AscendC::Adds(tmp, tmp, two, length);            AscendC::Mul(dst, dst, tmp, length);     // x_&#123;n+1&#125; = x_n * tmp        &#125;    &#125;    __aicore__ inline void CopyIn(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();        AscendC::DataCopy(xLocal, xGm[progress * this-&gt;tileLength], this-&gt;tileLength);        inQueueX.EnQue(xLocal);    &#125;    __aicore__ inline void Compute(int32_t progress)    &#123;        //考生补充算子计算代码        LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;();        LocalTensor&lt;half&gt; yLocal = outQueueY.AllocTensor&lt;half&gt;();                LocalTensor&lt;half&gt; tmp1 = tmpBuffer1.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp2 = tmpBuffer2.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp3 = tmpBuffer3.Get&lt;half&gt;();                half one=1.0,negone=-1.0;        AscendC::Muls(tmp1, xLocal, negone, this-&gt;tileLength);        AscendC::Exp(tmp2, tmp1, this-&gt;tileLength);        AscendC::Adds(tmp3, tmp2, one, this-&gt;tileLength);                HighPrecisionReciprocal(yLocal,tmp3,this-&gt;tileLength,2);        outQueueY.EnQue&lt;half&gt;(yLocal);        inQueueX.FreeTensor(xLocal);    &#125;    __aicore__ inline void CopyOut(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; yLocal = outQueueY.DeQue&lt;half&gt;();        AscendC::DataCopy(yGm[progress * this-&gt;tileLength], yLocal, this-&gt;tileLength);        outQueueY.FreeTensor(yLocal);    &#125;private:    TPipe pipe;    //create queue for input, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;    //create queue for output, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueY;    GlobalTensor&lt;half&gt; xGm;    GlobalTensor&lt;half&gt; yGm;    //考生补充自定义成员变量    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;    uint32_t blockLength;    uint32_t tileNum;    uint32_t tileLength;&#125;;extern &quot;C&quot; __global__ __aicore__ void sigmoid_custom(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling) &#123;    GET_TILING_DATA(tiling_data, tiling);    KernelSigmoid op;    //补充init和process函数调用内容    op.Init(x, y, tiling_data.totalLength, tiling_data.tileNum);    op.Process();&#125;\n代码解释\n一个自定义算子的生命周期\n在深入代码之前，我们先理解一下从编写到执行，这个 SigmoidCustom 算子经历了什么：\n\n\n开发阶段: 您编写了算子定义、Tiling 逻辑和 Kernel 实现这几个文件。\n\n\n编译阶段: 使用 CANN 提供的工具链进行编译。编译器会分别处理 Host 端代码（编译成标准的 CPU 可执行指令）和 Device 端代码（编译成 AI Core 能理解的 CUBE 指令）。同时，OP_ADD(SigmoidCustom) 宏会将算子的元信息（如输入输出、Tiling 函数地址等）注册到昇腾的算子库中。\n\n\n图构建与下发阶段: 当用户在一个神经网络模型（例如用 MindSpore 或 PyTorch）中调用 SigmoidCustom 时，前端框架会将模型转换为昇腾的计算图（Graph）。图编译器（Graph Engine, GE）会解析这个图，当遇到 SigmoidCustom 节点时，它会：\na.  调用 InferShape 和 InferDataType 函数，在不运行实际计算的情况下，静态推断出这个节点输出的形状和数据类型，以便为整个网络预先分配好内存。\nb.  调用 TilingFunc 函数，根据当前节点的输入张量大小，生成具体的任务切分方案（即 TilingData）。\nc.  将编译好的 Kernel CUBE 指令和 TilingData 打包成一个任务，下发给 NPU 的任务调度器（Task Scheduler）。\n\n\n执行阶段: NPU 的任务调度器根据 TilingData 中的 blockDim 信息，唤醒指定数量的 AI Core。每个被唤醒的 AI Core 都会接收到 Kernel CUBE 指令和 TilingData 的一份拷贝，然后从 sigmoid_custom 这个 __global__ 入口函数开始，独立地执行计算任务。\n\n\nHost 端代码深度解析 (CPU 侧)\nHost 端代码的核心目标是**“定义规则”和“制定计划”**，它不参与实际的数值计算。\n1.1 算子接口定义\n这部分代码是 SigmoidCustom 算子与 CANN 框架交互的“接口”或“驱动”。框架本身不知道你这个算子具体怎么算，但通过这个定义，它知道了如何使用你。\n\nthis-&gt;Input(&quot;x&quot;)... 和 this-&gt;Output(&quot;y&quot;)...: 这不仅仅是定义了输入输出的名称，更重要的是定义了数据依赖关系。图编译器根据这个关系来构建计算图的拓扑结构，决定算子执行的先后顺序。\n.DataType(&#123;ge::DT_FLOAT16&#125;).Format(&#123;ge::FORMAT_ND&#125;): 这是算子的能力声明。它告诉框架：“我能处理 FP16 类型的数据，并且不关心输入的具体维度（ND 格式）。” 如果上游算子的输出格式不匹配，图编译器会自动插入一个转置（Transpose）或类型转换（Cast）算子来适配。\nthis-&gt;SetInferShape(ge::InferShape): 这是一个至关重要的静态分析钩子。在模型编译时，真实的输入数据还不存在，但其形状（Shape）是已知的。框架会调用 InferShape 函数，让算子根据输入的 Shape &quot;预言&quot;自己输出的 Shape。对于 Sigmoid 这种 Element-wise（逐元素）操作，输出形状与输入形状完全相同，所以实现很简单：*y_shape = *x1_shape;。这使得框架可以在运行前就规划好整个模型的内存布局。\nthis-&gt;AICore().SetTiling(optiling::TilingFunc): 这是将**“计划制定者”**（Tiling 函数）与算子本身绑定的关键。框架知道，每当需要执行这个算子时，都应该去调用 TilingFunc 来获取详细的执行计划。\n\n1.2 Tiling 函数\nTiling 函数是 Host 端的智慧所在，它在 CPU 上运行，为即将开始的 Device 端计算制定精密的作战计划。\n\ngert::TilingContext\\* context: context 对象是框架传递给 Tiling 函数的**“情报手册”**。它包含了关于当前任务的所有上下文信息，最主要的就是 context-&gt;GetInputShape(0)，它让 Tiling 函数知道了待处理的数据有多大。\n核心决策:\n\n总览全局: uint32_t totalLength = ...GetShapeSize() 获取了总工作量。\n分配兵力: context-&gt;SetBlockDim(BLOCK_DIM) 决定了要动用多少个 AI Core（这里硬编码为8）。这是一个关键的并行策略决策。如果 totalLength 很小，可能只用一个 AI Core 更高效（避免多核通信开销）；如果 totalLength 巨大，则可以用满所有可用的 Core。\n制定指令:\n\ntiling.set_totalLength(totalLength): 把全局信息写入“指令书” (TilingData)。\ntiling.set_tileNum(TILE_NUM): 决定每个 AI Core 内部的流水线深度或切分粒度。这个值会影响性能，需要根据计算量和数据搬运量的比例（计算访存比）来权衡。TILE_NUM 越大，tileLength 就越小，数据搬运更频繁，但每个计算任务的延迟也更低，有利于流水线隐藏延迟。\n\n\n\n\n信息传递: tiling.SaveToBuffer(...) 将填满信息的 TilingData 结构体序列化为一段连续的内存块。这段内存块将和编译好的 Kernel 代码一起被发送到 Device 端，成为每个 AI Core 执行任务的依据。\n\nDevice 端代码深度解析 (AI Core 侧)\nDevice 端代码是**“一线士兵”**，它们根据 Host 发来的计划，在自己的阵地（AI Core）上高效地执行计算。\n2.1 内存模型与数据并行 (SPMD)\n\nGM_ADDR x, GM_ADDR y: GM_ADDR 是 Global Memory Address 的缩写，代表全局内存中的一个地址。x 和 y 是输入和输出张量在全局内存中的起始地址。\nSPMD (Single Program, Multiple Data): 这是 AI Core 的核心工作模式。所有被唤醒的 AI Core 都执行同一份程序代码（Single Program），但处理的数据各不相同（Multiple Data）。\nAscendC::GetBlockIdx(): 这是实现 SPMD 的关键。该函数返回当前 AI Core 的唯一ID（从0到 blockDim-1）。\nxGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), ...): 这行代码是数据划分的精髓。\n\n(__gm__ DTYPE_X *)x: 将全局内存地址 x 转换为一个指向 FP16 类型的指针。\n... + this-&gt;blockLength * AscendC::GetBlockIdx(): 计算偏移量。\n\n对于 ID=0 的 Core，偏移量是 blockLength * 0 = 0，它处理从 x 开始的数据。\n对于 ID=1 的 Core，偏移量是 blockLength * 1，它处理紧接着第一块的数据。\n…\n\n\n通过这种方式，totalLength 的数据被完美地分割成了 blockDim 份，每个 AI Core 都只关心自己负责的那一段，实现了无冲突的数据并行。\n\n\n\n2.2 本地内存与流水线 (TPipe, TQue)\nAI Core 的性能源泉在于其内部极速的本地内存（LM）和向量计算单元。流水线的目标就是让计算单元永远不要因为等待数据而停工。\n\nTPipe, TQue: 这不是硬件，而是 Ascend C 提供的软件抽象，用于简化对硬件 DMA（数据搬运单元）和本地内存的管理。\nInitBuffer: 在 Init 方法中，pipe.InitBuffer(inQueueX, BUFFER_NUM, ...) 相当于在本地内存中划分出 BUFFER_NUM (即2) 块独立的区域，并由 inQueueX 这个队列对象来管理。\n双缓冲 (Double Buffering) 详解: BUFFER_NUM=2 构成了双缓冲。想象有两块缓冲区 A 和 B：\n\nCopyIn: 调用 inQueueX.AllocTensor&lt;half&gt;() 会从空闲的缓冲区队列中取出一个（比如A），然后 DataCopy 指令启动 DMA 将 GM 数据拷贝到 A。完成后 inQueueX.EnQue(A) 将 A 标记为“已填充，可供计算”。\nCompute: 调用 inQueueX.DeQue&lt;half&gt;() 会从“已填充”队列中取出一个（比如A），然后计算单元对 A 中的数据进行计算。\n重叠执行: 当计算单元正在处理 A 的数据时，CopyIn 阶段可以同时向另一个空闲的缓冲区 B 中拷贝下一批数据。当 A 计算完成，B 也正好拷贝完成，计算单元可以马不停蹄地开始处理 B，而 DMA 则开始将 A 的计算结果写回 GM。\n\n\nfor 循环的流水线建立过程:\n\n迭代 i=0: CopyIn(0) 开始（数据块0从GM-&gt;LM），Compute(0) 和 CopyOut(0) 等待。\n迭代 i=1: CopyIn(1) 开始（数据块1从GM-&gt;LM），同时 Compute(0) 开始（处理数据块0）。CopyOut(1) 等待。\n迭代 i=2: CopyIn(2) 开始，Compute(1) 开始，CopyOut(0) 开始（将数据块0的结果从LM-&gt;GM）。至此，三级流水线完全建立，DMA的读、计算单元、DMA的写三个硬件部件都在满负荷工作。\n\n\n\n2.3 向量计算与硬件指令\n\nAscendC::Muls, AscendC::Exp, AscendC::Adds: 这些函数被称为内置函数（Intrinsics）。它们在编译时会被直接映射为 AI Core 的一条或多条向量指令。\n例如，AscendC::Exp(tmp2, tmp1, this-&gt;tileLength) 不是一个循环，而是一条指令。它告诉向量计算单元：“对 tmp1 指向的 tileLength 个半精度浮点数，逐个执行指数运算，并将结果存放到 tmp2 中”。这种 SIMD（单指令多数据） 的处理方式是 AI Core 性能的根本来源。\n\n2.4 数值计算优化\n\n问题: 硬件通常提供速度快但精度有限的近似计算指令，比如求倒数。对于某些需要高精度的算法，这可能导致误差累积。\n解决方案: 牛顿-拉弗森迭代法是一种经典的数值分析方法，可以用来求方程的根。对于求 1/a，相当于求方程 f(x) = 1/x - a 的根。\n代码映射:\n\nAscendC::Reciprocal(dst, src, length);: 使用硬件指令得到一个初始近似值 x_0 (即 dst)。src 是 a。\nAscendC::Mul(tmp, src, dst, length);: 计算 a * x_n，结果存入 tmp。\nAscendC::Muls(tmp, tmp, negone, length);: 变为 - (a * x_n)。\nAscendC::Adds(tmp, tmp, two, length);: 变为 2 - a * x_n。\nAscendC::Mul(dst, dst, tmp, length);: 计算 x_n * (2 - a * x_n)，得到 x_&#123;n+1&#125;，并覆盖回 dst。\n\n\n这个 for 循环每迭代一次，结果的精度就会翻倍。迭代2次就能获得非常高的精度，这体现了算法与硬件结合的优化思想。\n\n运行测试\n在运行之前，首先检查CMakePresets.json文件中的ASCEND_COMPUTE_UNIT和ASCEND_CANN_PACKAGE_PATH是否正确，如下\n&quot;ASCEND_COMPUTE_UNIT&quot;: &#123;    &quot;type&quot;: &quot;STRING&quot;,    &quot;value&quot;: &quot;ascend310b;ascend910b&quot;&#125;,&quot;ASCEND_CANN_PACKAGE_PATH&quot;: &#123;    &quot;type&quot;: &quot;PATH&quot;,    &quot;value&quot;: &quot;/home/ma-user/Ascend/ascend-toolkit/latest&quot;&#125;,\n然后检查SigmoidCustom中的AICore是否设置正确，如下\nthis-&gt;AICore().AddConfig(&quot;ascend910b&quot;)              .AddConfig(&quot;ascend310b&quot;);\n如果上述设置没有问题，就可以进行编译测试了\n运行编译\nbash build.sh\n编译之后会得到build_out目录，运行其中的安装包\ncd build_out./custom_opp_ubuntu_aarch64.run\n最后到AclNNInvocation中运行测试\nbash run.sh\n检验脚本会调用py脚本，分别用numpy和我们写的算子计算答案，然后对比误差，如果代码没有问题会给出测试成功的提示。由于华为云提供的这个环境属实有点贵，因此我就不再开机测试并截图了，大家自行操作\n随后按照认证要求将SigmoidCustom打包提交即可，测试通过后会获得认证证书，如下\n\n","categories":["华为算子挑战赛"],"tags":["Ascend C","算子开发"]},{"title":"关于Simulink中参数传递的解决方案","url":"/posts/fcf42186/","content":"介绍\n本文主要对之前的Simulink工作进行优化，前面通过S Function一共实现了三个模块，分别为参数交互模块、调用求解模块和数据展示模块。但后续两个模块的代码中都采用了硬编码的方式来指定文件夹的路径，事实上后续两个模块的文件夹路径与第一个模块选中的文件夹是同一个路径，因此为了减少因为硬编码而导致的路径错误，我们将修改代码，把第一个模块选中的文件夹传递给后续的模块，这里将会使用Simulink的封装功能\n如何传递模块参数\n核心问题：传递文件夹路径\n目前，sfun_callXXX.m 和 sfun_callXXXProcess.m 中的文件路径是硬编码的，这降低了灵活性。\n% sfun_callXXX.mparamPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;% sfun_callXXXProcess.mdir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;\n最佳的解决方案是利用 Simulink 的 Mask Parameters (模块参数) 来接收路径，然后由第一个 S-Function (sfun_callInterface) 在用户确认路径后，通过编程方式设置这些参数。\n\n在 Simulink 模型中，右键点击 sfun_callXXX 模块，选择 Mask &gt; Create Mask。\n在 Mask Editor 窗口中，进入 Parameters &amp; Dialog 选项卡。\n在左侧面板添加一个 Edit 参数。\n在右侧的 Parameter Properties 中，设置:\n\nPrompt: 求解器参数路径\nName: paramPath\nEvaluate：取消勾选\n\n\n点击 OK 或 Apply 保存 Mask。\n对 sfun_callXXXProcess 模块重复以上步骤，但将参数 Name 设置为 dataDir。\n再次右键点击该模块，选择 Block Parameters (S-function)。\n在打开的对话框中，找到一个名为 S-function parameters 的输入框。\n在这个输入框里，填入你的 变量名 (paramPath 或 dataDir)。\n点击 OK 或 Apply。\n为另一个 S-Function 模块重复上述步骤。\n\n\n这个操作的目的是建立 Mask 和 S-Function 代码之间的连接。当你在 Mask 界面输入路径时，该路径字符串会存入名为 paramPath 的变量中。然后，通过将 paramPath填入 “S-function parameters” 字段，这个变量的值就被传递给了 S-Function 内部，代码 block.DialogPrm(1).Data 才能成功地接收到这个路径。\n现在，修改这两个 S-Function，让它们从刚刚创建的 Mask Parameter 中读取路径，而不是使用硬编码的字符串。\n修改 sfun_callXXX.m:\n\n\n在 setup 函数中，声明该模块有一个 Mask Parameter。\nfunction setup(block)    % ... (I/O 配置)    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    % ... (SampleTime 等其他配置)end\n\n\n在 Outputs 函数中，用 block.DialogPrm(1).Data 替换硬编码的路径。\nfunction Outputs(block)    % ...    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行    paramPath = block.DialogPrm(1).Data;    % &lt;--- 添加这一行    % ...end\n\n\n修改 sfun_callXXXProcess.m:\n\n\n同样，在 setup 函数中声明 Mask Parameter。\nfunction setup(block)    % ...    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    block.SampleTimes        = [0.5 0];    % ...end\n\n\n在 Outputs 函数中，替换硬编码的路径。\nfunction Outputs(block)    % ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行        dir = block.DialogPrm(1).Data;    % &lt;--- 添加这一行        % ...    end    % ...end\n\n\n最后，修改第一个 S-Function 的 GUI 确认回调函数 (confirm_action)，让它在用户点击“确认”时，自动将选定的文件夹路径写入另外两个模块的 Mask Parameter。\n为此，需要在 Simulink 模型中为 sfun_callXXX 和 sfun_callXXXProcess 模块指定一个清晰的、可编程访问的名称。例如，将它们分别命名为 XXX_Launcher 和 XXX_Processor。如图所示\n\n修改 sfun_callInterface.m 中的 confirm_action 函数:\n% sfun_callInterface.mfunction confirm_action(fig)    % ... (前面的代码保持不变)    % --- 新增代码：获取模型名称和设置其他模块的参数 ---    try        blockHandle = fig.UserData.blockHandle;        modelName = bdroot(blockHandle); % 获取顶层模型的名称                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);    catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % 释放处理器并返回，防止在出错时继续执行        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        return;    end    % --- 新增代码结束 ---    % ... (释放处理器、设置 confirmationFlag 和关闭 GUI 的代码保持不变)        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end\n小结: 通过以上三步，完成了下述工作：\n\nsfun_callInterface 的 GUI 捕获用户选择的路径。\n当用户点击“确认”时，该模块通过 set_param 函数，将路径动态地写入 XXX_Launcher 和 XXX_Processor 模块的 Mask 中。\n这两个模块在运行时，从自己的 Mask Parameter 中读取路径，从而实现了动态配置，完全避免了硬编码。\n\n\n注意：上述代码仍会出现问题，具体来说是modelName无法被识别，后续我将附上全部修改代码，这里不做展示\n\n\n加载/卸载Dll的优化\n此时多个模块正在加载和卸载同一个DLL (BWIBridgeDLL.dll)。这种做法效率低下，并且可以被简化。最佳实践是在整个仿真生命周期内将DLL作为共享资源进行管理：在仿真开始时加载一次，在仿真终止时卸载一次。\n1. 修改 sfun_callInterface.m\n该模块应负责加载DLL，并确保它在仿真期间保持加载状态。\n在 close_gui 函数中，删除卸载DLL的那一行代码。GUI不再需要管理DLL的卸载，这个任务将交给仿真的终止阶段来处理。\n原始代码 (sfun_callInterface.m):\nfunction close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\n建议修改:\nfunction close_gui(fig)    % DLL 不再在这里卸载。它将由仿真流程中最后一个S-Function模块的    % Terminate 函数来处理。    delete(fig);end\n2. 修改 sfun_callXXXProcess.m\n该模块应负责在仿真结束时卸载DLL。其 Outputs 函数也应简化，直接使用已加载的库。\na. 在 Outputs 函数中:\n移除 loadlibrary 和 unloadlibrary 调用。现在代码应该假设DLL已经被第一个模块加载了。为保险起见，可以添加一个 libisloaded 检查。\n原始代码 (sfun_callXXXProcess.m):\nfunction Outputs(block)    % ... (前面的代码) ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        dir = block.DialogPrm(1).Data;        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        % ... (调用库的逻辑) ...                % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % ... (剩余的代码) ...end\n建议修改:\nfunction Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        % ... (其余逻辑保持不变) ...        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary 调用已从此函数中移除。    end    block.Dwork(1).Data = u;end\nb. 在 Terminate 函数中:\n此函数在仿真停止时会执行一次。这是卸载DLL的理想位置。\n原始代码 (sfun_callXXXProcess.m):\nfunction Terminate(~)end\n建议修改:\nfunction Terminate(~)    fprintf(&#x27;[XXX] Simulation terminated. Unloading BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n经过修改之后，我们的代码理论上只会在仿真开始时加载Dll，在仿真结束后卸载Dll，避免中间过程对Dll的反复调用\n隐含问题\n在sfun_callXXX.m的代码中，还存在着一个潜在的重要问题，我们使用了如下代码\n%— 持久变量：进程句柄 —————————————persistent procObj\n这是一个持久变量，用来检测进程的状态，当我们使用了不止于一个sfun_callXXX模块时，所有模块将共享这个变量，如果我们在第一个模块中启动一个.exe进程，并将其句柄存入 procObj。紧接着，第二个模块启动另一个.exe进程，并将其句柄覆盖到同一个 procObj 变量中。此时，第一个进程的句柄就丢失了。系统将无法再轮询或终止第一个进程，从而导致逻辑错误和进程失控。简单来说，当前的设计只适用于模型中只有一个XXX_Launcher模块的情况。一旦需要多个，就会立即出错。\n目前这个问题还没有解决，后续如果遇到了，会在该系列文章中提供解决方案\n最后附上全部代码\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);         % 这里的双击回调函数并不能正常使用，如要使用，可能要把start_import_gui及相关代码作为独立的文件和函数end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0                % --- 确保 modelName 永远是字符串 ---        rootSystem = bdroot(block.BlockHandle); % 获取顶层模型，结果可能是句柄或名称                modelName = &#x27;&#x27;; % 初始化        if isnumeric(rootSystem) &amp;&amp; ishandle(rootSystem)            % 如果返回的是数字句柄，则通过句柄获取名称            modelName = get_param(rootSystem, &#x27;Name&#x27;);        elseif ischar(rootSystem)            % 如果返回的是字符串名称，则直接使用            modelName = rootSystem;        end        % 添加一个安全检查，如果获取名称失败则报错并停止        if isempty(modelName)            errordlg(&#x27;无法获取 Simulink 模型名称，GUI 无法启动。&#x27;, &#x27;严重错误&#x27;);            % 在这种严重错误下，停止仿真可能更安全            set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);            return; % 提前退出函数        end        % --- 修复结束 ---                start_import_gui(modelName);        block.Dwork(1).Data = 1;    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(modelName)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.modelName  = modelName;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;    try        % 从 UserData 获取模型名称字符串        modelName = fig.UserData.modelName; % &lt;--- 修改点                % 检查 modelName 是否有效 (例如，不是空的)        if isempty(modelName) || ~ischar(modelName)            error(&#x27;未能获取有效的模型名称。&#x27;); % 抛出一个错误        end                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);            catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % ... (释放处理器并返回)        return;    end        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    % if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)    %     unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    % end    % 清理其他资源如果需要    delete(fig);end\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    block.NumDialogPrms  = 1;     %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;    paramPath = block.DialogPrm(1).Data;     %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            fprintf(&#x27;[XXX] PID=%d 已退出\\n&#x27;, block.Dwork(3).Data)            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.NumDialogPrms  = 1;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        % --- 读取数据并绘图 ---        % dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        % hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt);        if ~result            fprintf(&#x27;读取失败&#x27;)            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);            unloadlibrary(&#x27;BWIBridgeDLL&#x27;)        end;        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)    fprintf(&#x27;[XXX] Simulation 终止. 卸载 BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]}]