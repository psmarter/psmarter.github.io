[{"title":"AI Infra学习之旅-PagedAttention详解","url":"/posts/fbab2bc4/","content":"PagedAttention：大语言模型推理的内存管理革命\n\n借鉴操作系统虚拟内存思想，实现LLM推理的高效KV Cache管理\n\n\n引言\n在大语言模型(LLM)快速发展的今天，如何高效地进行模型推理成为了一个关键问题。随着模型规模的不断扩大，内存管理成为制约推理性能的重要瓶颈。本文将深入介绍PagedAttention技术——一种受操作系统虚拟内存管理启发的创新性内存管理方法，它极大地提升了LLM推理的效率和throughput。\n一、背景：LLM推理中的内存挑战\n1.1 KV Cache的作用\n在Transformer架构的自回归生成过程中，每个token的生成都需要用到之前所有token的Key和Value向量。为了避免重复计算，这些K、V向量会被缓存起来，这就是KV Cache。\n输入序列: &quot;今天天气&quot;生成过程:- 生成&quot;很&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;的KV- 生成&quot;好&quot;: 需要&quot;今&quot;、&quot;天&quot;、&quot;天&quot;、&quot;气&quot;、&quot;很&quot;的KV- ...依次类推\n1.2 传统方法的问题\n传统的KV Cache管理方法存在严重的内存浪费问题：\n\n\n\n外部碎片化（External Fragmentation）\n\n必须为每个请求预先分配一个连续的内存块\n由于无法预知生成序列的最终长度，通常按最大序列长度分配\n实际使用长度远小于分配长度时，造成大量浪费\n\n\n\n内部碎片化（Internal Fragmentation）\n\n批处理中不同请求的序列长度不同\n必须按批次中最长序列分配内存\n短序列的剩余空间无法被其他请求使用\n\n\n\n研究表明，传统方法的内存浪费率高达60%-80%，这严重限制了批处理大小和系统吞吐量。\ngraph LR\n    subgraph 传统方法\n        A[请求1] --&gt; B[预分配大块连续内存]\n        A2[请求2] --&gt; B2[预分配大块连续内存]\n        B --&gt; C[大量浪费:60-80%]\n        B2 --&gt; C\n    end\n    \n    subgraph PagedAttention\n        D[请求1] --&gt; E[按需分配小块]\n        D2[请求2] --&gt; E2[按需分配小块]\n        E --&gt; F[极少浪费:&lt;4%]\n        E2 --&gt; F\n    end\n    \n    style C fill:#FFB6C1\n    style F fill:#90EE90\n\n二、PagedAttention核心原理\n2.1 操作系统的启发\nPagedAttention的设计灵感来源于操作系统中的虚拟内存分页机制：\n\n\n\n操作系统虚拟内存\nPagedAttention\n\n\n\n\n虚拟内存页\n逻辑KV块\n\n\n物理内存页\n物理KV块\n\n\n页表\n块表(Block Table)\n\n\n按需分页\n动态块分配\n\n\n写时复制\nKV块共享\n\n\n\n\n2.2 核心设计\n2.2.1 块状存储\nPagedAttention将KV Cache划分为固定大小的块(Block)：\n\n每个块存储固定数量token的KV向量（通常16-128个token）\n块可以在物理内存中非连续存储\n每个序列的KV Cache由多个块组成\n\n逻辑序列: [Token1, Token2, ..., Token100]         ↓物理存储: [Block0: Token1-16] → 物理地址 0x1000         [Block1: Token17-32] → 物理地址 0x3000         [Block2: Token33-48] → 物理地址 0x2000         ...\n\n2.2.2 块表映射\n每个序列维护一个块表(Block Table)，记录逻辑块到物理块的映射：\n# 伪代码示例class BlockTable:    def __init__(self):        self.logical_to_physical = &#123;&#125;  # 逻辑块号 -&gt; 物理块地址        def get_physical_block(self, logical_block_id):        return self.logical_to_physical[logical_block_id]\n\n2.2.3 动态分配\n\n按需分配：只在需要时分配新块\n精细粒度：以块为单位分配，而非整个序列\n即时回收：序列完成后立即释放所有块\n\n2.3 Attention计算的适配\n在PagedAttention中，Attention计算需要根据块表来访问KV Cache：\n# 传统Attention（伪代码）def traditional_attention(Q, K_cache, V_cache):    scores = Q @ K_cache.T  # 直接访问连续内存    attention_weights = softmax(scores)    output = attention_weights @ V_cache    return output# PagedAttention（伪代码）def paged_attention(Q, block_table, physical_blocks):    output = 0    for logical_block_id in block_table:        # 通过块表查找物理块        physical_block = physical_blocks[block_table[logical_block_id]]        K_block, V_block = physical_block                # 在每个块上计算Attention        scores = Q @ K_block.T        attention_weights = softmax(scores)        output += attention_weights @ V_block        return output\n三、PagedAttention的关键优势\n3.1 近乎零的内存浪费\n通过块状动态分配，PagedAttention实现了：\n\n外部碎片 ≈ 0：无需预分配最大长度\n内部碎片 &lt; 4%：只有最后一个未满的块存在浪费\n\n这将内存利用率从传统的20-40%提升到96%以上！\n3.2 高吞吐量提升\n更高的内存利用率意味着：\n\n可以容纳更大的批处理大小\nGPU利用率显著提升\n系统吞吐量提升2-24倍\n\n\n\n\n对比系统\n吞吐量提升\n\n\n\n\nHuggingFace Transformers\n24x\n\n\nFasterTransformer\n3.5x\n\n\nOrca\n2-4x\n\n\n\n3.3 高效的内存共享\nPagedAttention支持多种场景下的KV Cache共享：\n3.3.1 并行采样（Parallel Sampling）\n当需要为同一个prompt生成多个不同的响应时：\n请求: &quot;写一首关于春天的诗&quot;     ↓共享Prompt的KV Cache     ↓生成多个不同版本：版本1、版本2、版本3...\n通过**写时复制(Copy-on-Write)**机制，多个生成序列可以共享相同prompt的KV块。\n\n3.3.2 Beam Search\n在Beam Search中，多个候选序列共享大部分前缀KV Cache：\nBeam 1: &quot;春天来了&quot; → &quot;万物复苏&quot;Beam 2: &quot;春天来了&quot; → &quot;花开满园&quot;  ← 共享&quot;春天来了&quot;的KVBeam 3: &quot;春天来了&quot; → &quot;鸟语花香&quot;\n\n3.3.3 共享系统Prompt\n多个用户请求可能共享相同的系统提示词：\nSystem Prompt: &quot;你是一个helpful的AI助手...&quot;              ↓ (多个请求共享)User1: &quot;今天天气怎么样？&quot;User2: &quot;帮我写个代码&quot;User3: &quot;翻译这段文字&quot;\n\n3.4 支持长上下文\n\n无需预分配连续大内存块\n可以处理远超单次分配限制的超长序列\n动态扩展，按需增长\n\n四、vLLM：PagedAttention的工程实现\n4.1 vLLM架构概述\nvLLM是首个基于PagedAttention的开源LLM推理引擎，实现了：\n┌─────────────────────────────────────┐│        Request Manager              ││   (调度、批处理、优先级管理)          │└──────────────┬──────────────────────┘               │┌──────────────▼──────────────────────┐│     KV Cache Manager                ││  - 块池管理                          ││  - 块表维护                          ││  - 自动前缀缓存(Automatic Prefix Cache)│└──────────────┬──────────────────────┘               │┌──────────────▼──────────────────────┐│    Model Executor                   ││  (PagedAttention Kernel)            │└─────────────────────────────────────┘\n4.2 KV Cache Manager\n核心功能：\n\n块池管理：维护可用物理块的池\n块分配：为新token分配块\n块回收：释放完成请求的块\n引用计数：支持块共享的引用计数机制\n\n# vLLM块管理器简化示例class BlockManager:    def __init__(self, block_size, num_blocks):        self.block_size = block_size        self.free_blocks = set(range(num_blocks))        self.ref_counts = defaultdict(int)        def allocate_block(self):        if not self.free_blocks:            return None  # 内存不足        block_id = self.free_blocks.pop()        self.ref_counts[block_id] = 1        return block_id        def share_block(self, block_id):        # 写时复制：增加引用计数        self.ref_counts[block_id] += 1        def free_block(self, block_id):        self.ref_counts[block_id] -= 1        if self.ref_counts[block_id] == 0:            self.free_blocks.add(block_id)            del self.ref_counts[block_id]\n4.3 自动前缀缓存\nvLLM实现了**自动前缀缓存(Automatic Prefix Caching)**功能：\n\n使用哈希表管理KV块\n自动检测和复用相同的前缀\n无需用户手动指定\n\n# 自动前缀缓存原理class PrefixCache:    def __init__(self):        self.hash_table = &#123;&#125;  # token_hash -&gt; block_id        def lookup(self, token_sequence):        token_hash = hash(tuple(token_sequence))        return self.hash_table.get(token_hash)        def insert(self, token_sequence, block_id):        token_hash = hash(tuple(token_sequence))        self.hash_table[token_hash] = block_id\n4.4 调度策略\nvLLM支持多种调度策略：\n\nFCFS（First-Come-First-Serve）：先到先服务\n优先级调度：根据请求优先级\n抢占和交换：内存不足时可以将部分请求的KV Cache交换到CPU\n\n五、技术细节与实现要点\n5.1 块大小的选择\n块大小的权衡：\n\n\n较小块（如16 tokens）：\n\n✅ 内存碎片更少\n❌ 块表开销大，查找次数多\n\n\n\n较大块（如128 tokens）：\n\n✅ 块表开销小\n❌ 最后一块可能浪费较多\n\n\n\n实践中通常选择16-64之间\n5.2 CUDA Kernel优化\nPagedAttention需要高效的CUDA kernel来处理非连续内存访问：\n// PagedAttention CUDA Kernel简化示例__global__ void paged_attention_kernel(    const float* Q,          // Query    const float* K_blocks,   // 所有K块    const float* V_blocks,   // 所有V块    const int* block_table,  // 块表    float* output,    int num_blocks) &#123;    // 1. 遍历块表中的每个块    for (int i = 0; i &lt; num_blocks; i++) &#123;        int physical_block_id = block_table[i];                // 2. 从物理块加载KV        const float* K_block = &amp;K_blocks[physical_block_id * BLOCK_SIZE];        const float* V_block = &amp;V_blocks[physical_block_id * BLOCK_SIZE];                // 3. 计算attention score        float score = compute_attention(Q, K_block, V_block);                // 4. 累加到输出        accumulate_output(output, score);    &#125;&#125;\n5.3 内存预算与OOM处理\n# 内存管理策略class MemoryManager:    def can_allocate(self, num_blocks_needed):        return len(self.free_blocks) &gt;= num_blocks_needed        def evict_if_needed(self, num_blocks_needed):        &quot;&quot;&quot;内存不足时的驱逐策略&quot;&quot;&quot;        if not self.can_allocate(num_blocks_needed):            # 将低优先级请求的KV Cache迁移到CPU            self.swap_to_cpu(num_blocks_needed)        def swap_to_cpu(self, num_blocks):        &quot;&quot;&quot;将GPU块交换到CPU内存&quot;&quot;&quot;        # 选择要交换的请求（如最久未使用）        victims = self.select_victims(num_blocks)        for victim in victims:            self.move_blocks_to_cpu(victim)            self.free_blocks.extend(victim.blocks)\n六、与其他优化技术的对比\n6.1 Flash Attention\n\n\n\n特性\nFlash Attention\nPagedAttention\n\n\n\n\n优化目标\n计算效率（减少HBM访问）\n内存管理效率\n\n\n主要技术\nTiling + 重计算\n块状内存分配\n\n\n加速场景\n训练 &amp; 推理\n主要用于推理\n\n\n是否兼容\n✅ 可结合使用\n✅ 可结合使用\n\n\n\n两者可以结合：vLLM可以同时使用Flash Attention和PagedAttention！\n6.2 量化技术（INT8/INT4）\n\n\n\n特性\n量化\nPagedAttention\n\n\n\n\n优化维度\n减少每个参数的存储位数\n优化内存分配方式\n\n\n内存节省\n模型权重和激活\nKV Cache\n\n\n是否互补\n✅ 高度互补\n✅ 高度互补\n\n\n\n6.3 推测解码（Speculative Decoding）\nPagedAttention与推测解码也可结合：\n\n推测解码：通过小模型加速生成\nPagedAttention：提升内存利用率和吞吐量\n\n七、总结\nPagedAttention是大语言模型推理领域的一项重要创新：\n核心贡献\n\n✅ 近乎零浪费的内存管理：将浪费率从60-80%降低到&lt;4%\n✅ 显著的吞吐量提升：2-24倍的性能提升\n✅ 灵活的KV共享机制：支持并行采样、Beam Search等复杂场景\n✅ 工程化落地：vLLM已成为业界主流推理引擎\n\n参考资料\n\n原始论文：“Efficient Memory Management for Large Language Model Serving with PagedAttention” (2023)\nvLLM GitHub: https://github.com/vllm-project/vllm\nvLLM官方文档: https://docs.vllm.ai/\nPagedAttention博客系列（多个技术博客）\n\n","categories":["AI Infra"],"tags":["vLLM","LLM","PagedAttention","KV Cache","AI系统","AI Infrastructure","内存管理"]},{"title":"AI Infra学习之旅-Transformer知识地图","url":"/posts/4854dc00/","content":"AI Infra学习路线\n\n写给刚入门AI Infrastructure的同学：你真的需要搞懂Transformer的每个细节吗？\n\n写在前面\n最近跟几个刚开始学AI Infra的朋友聊天，大家都有个共同的困惑：明明是搞基础设施的，为什么老有人让我们先把Transformer学透？\n说实话，我刚开始也纠结过。看了一堆Transformer的论文和教程，什么Attention机制、位置编码、残差连接…感觉自己要变成算法工程师了。后来跑了几个月的vLLM、搞了一些推理优化，才慢慢想明白：\nAI Infra工程师确实要懂Transformer，但不是全懂，而是要懂对地方。\n今天这篇文章，我想跟你聊聊：作为AI Infra的学习者，到底应该重点关注Transformer的哪些部分，哪些可以暂时放一放，以及不同方向（推理优化、模型部署、系统架构）的学习侧重点。\n一、为什么AI Infra一定要学Transformer？\n在回答&quot;学什么&quot;之前，先说说&quot;为什么要学&quot;。\n1.1 现代AI系统的核心就是Transformer\n看看你做AI Infra会接触的东西：\n\n推理框架：vLLM、TensorRT-LLM、TGI、…\n优化技术：Flash Attention、PagedAttention、KV量化、…\n部署工具：Triton Inference Server、Ray Serve、…\n\n这些东西，100%都是围绕Transformer模型设计的。\n如果你不了解Transformer的工作原理，就像是开飞机但不知道飞机怎么飞的——能起飞，但出了问题根本不知道从哪查。\n1.2 &quot;搞硬件&quot;也要懂模型\n有人会说：“我是做基础设施的，GPU、内存、网络这些才是我该关心的吧？”\n没错，但问题是：\n\n内存优化：为什么要优化？因为KV Cache太大了。KV Cache是啥？Transformer推理过程中产生的。\n计算优化：为什么要Flash Attention？因为原生Attention太慢了。为什么慢？要看Transformer的计算流程。\n并行策略：为什么要张量并行？因为单卡放不下大模型。为什么放不下？要看Transformer的参数分布。\n\n你优化的对象就是Transformer模型，不懂它怎么优化？\n1.3 一个真实的例子\n给你讲个我自己的例子。\n前阵子我在用vLLM跑一个模型，发现GPU内存占用特别高，batch size稍微大一点就OOM了。当时我只会调参数，试了半天没用。\n后来静下心来看了Transformer的KV Cache机制，才明白：\n\n每个token都要生成K和V向量\n这些向量要一直存在GPU显存里\n序列越长，batch越大，KV Cache占用呈指数级增长\n\n理解了这个，我才知道为什么PagedAttention能省内存（块状分配减少碎片），为什么要用Multi-Query Attention（减少KV头数）。\n不懂原理，就只能瞎调参。\n二、AI Infra视角下的Transformer知识地图\n好了，既然要学，那到底学什么？\n我把Transformer的知识点分成三个层级，告诉你哪些必须学、哪些重要、哪些了解就行。\n核心必学\n这部分不学，你做AI Infra基本寸步难行。\n2.1 KV Cache机制\n为什么必学？\nKV Cache是AI Infra优化的头号目标。不夸张地说，现代LLM推理优化的一半技术都在优化KV Cache。\n必须理解的点：\n\nKV Cache是怎么产生的？\n\n在Transformer的自回归生成过程中（比如GPT生成文本），每生成一个新token，都需要用到之前所有token的Key和Value向量。\n生成第1个词: 需要prompt的KV生成第2个词: 需要prompt + 第1个词的KV生成第3个词: 需要prompt + 第1个词 + 第2个词的KV...\n为了避免重复计算，这些KV向量会被缓存起来——这就是KV Cache。\n\nKV Cache有多占内存？\n\n假设一个7B参数的模型，hidden size是4096，有32层：\n\n每个token的KV向量：2 × 4096 × 32 × 2字节(FP16) ≈ 512KB\n生成1000个token：512KB × 1000 ≈ 512MB\nBatch size = 32：512MB × 32 = 16GB\n\n16GB！这还只是KV Cache，不包括模型权重和其他激活值。所以你会看到大batch推理很容易OOM。\n\n怎么优化KV Cache？\n\n\nPagedAttention：像操作系统的虚拟内存一样，分块管理KV Cache，减少内存碎片（这就是vLLM的核心技术）\nMulti-Query Attention (MQA)：让所有Query头共享一组KV，大幅减少KV Cache大小\nKV量化：把KV向量从FP16量化到INT8甚至INT4\nPrefix Caching：多个请求共享相同的系统prompt对应的KV\n\n实践建议：\n去看vLLM的源码，重点看CacheEngine和BlockManager这两个模块。跑一个模型，用nvidia-smi监控显存占用，你会对KV Cache有直观的感受。\n2.2 Attention计算流程\n为什么必学？\nAttention计算是Transformer的性能瓶颈。你做推理优化，90%的时间都在优化Attention。\n必须理解的点：\n\nAttention的四步计算\n\n# 伪代码scores = Q @ K.T  / sqrt(d_k)     # 1. 点积 + 缩放attention_weights = softmax(scores)  # 2. Softmax归一化  output = attention_weights @ V       # 3. 加权求和\n\n为什么Attention慢？\n\n\n内存瓶颈：Q、K、V都是大矩阵，频繁在HBM（显存）和SRAM（缓存）之间搬运数据\n计算复杂度：O(n²)，序列越长越慢\n\n\n优化方向\n\n\nFlash Attention：重新组织计算顺序，减少HBM访问次数（vLLM已经集成）\n稀疏Attention：不是所有token都需要关注所有其他token\nKernel融合：把多个小算子融合成一个大kernel，减少数据搬运\n\n实践建议：\n对比一下开启和关闭Flash Attention的性能差异。在vLLM里很简单：\n# 开启Flash Attention（默认）llm = LLM(model=&quot;facebook/opt-125m&quot;)# 关闭Flash Attentionllm = LLM(model=&quot;facebook/opt-125m&quot;, disable_flash_attn=True)\n跑个benchmark，你会发现差距很明显。\n2.3 Batch处理与序列并行\n为什么必学？\n提升推理系统吞吐量的核心手段。\n必须理解的点：\n\n静态Batching vs 动态Batching\n\n传统方法：等凑够32个请求再一起推理。问题是：第1个请求可能要等很久。\nContinuous Batching（vLLM用的）：来一个处理一个，动态调整batch。\n\n为什么Transformer适合Batching？\n\n因为Attention是独立的！处理batch中的第1个序列和第2个序列，计算是并行的。\n实践建议：\n用vLLM跑两个实验：\n\n单请求推理：测latency（延迟）\n批量请求推理：测throughput（吞吐量）\n\n你会发现throughput可以提升10倍+，但latency只增加了一点点。\n\n重要理解\n这部分不是立刻就用，但理解了能帮你少走弯路。\n2.4 位置编码（Positional Encoding）\n为什么要关注？\n影响模型处理长上下文的能力。\nTransformer的Self-Attention本身不感知位置，&quot;我爱你&quot;和&quot;你爱我&quot;对它来说是一样的。所以需要位置编码来告诉模型词的顺序。\nAI Infra关心什么？\n\n原始位置编码（Sinusoidal）：有长度限制，不适合超长上下文\nRoPE（Rotary Position Embedding）：很多新模型（LLaMA等）用这个，支持外推到更长序列\nALiBi：另一种方案，不需要额外参数\n\n如果你要部署一个支持32K上下文的模型，位置编码方案会直接影响性能和效果。\n2.5 Multi-Head Attention\n为什么要关注？\n影响模型并行策略。\n多头注意力意味着计算可以并行。如果一个模型有32个头，你可以把它们分到多个GPU上（张量并行）。\nAI Infra关心什么？\n\n头数是2的幂次（8、16、32）方便切分\nMQA/GQA（Multi-Query/Grouped-Query Attention）用更少的头，更省内存\n\n2.6 Encoder vs Decoder 架构\n为什么要关注？\n不同架构的推理特性完全不同。\n\n\nEncoder-only (BERT类)：\n\n输入一段文本，输出一段表示\n没有自回归生成，不需要KV Cache\n推理很快，适合分类、检索任务\n\n\n\nDecoder-only (GPT类)：\n\n自回归生成，每个词依赖前面所有词\n需要大量KV Cache\n推理慢，但生成能力强\n\n\n\nAI Infra关心什么？\n你部署BERT和GPT，优化策略完全不同：\n\nBERT：重点优化计算（算子融合、量化）\nGPT：重点优化内存（KV Cache管理、Paged Attention）\n\n\n了解即可\n这部分主要是训练相关，推理时影响不大。\n2.7 Masked Attention\n训练时用来防止模型&quot;偷看&quot;未来的词。推理时生成本来就是一个词一个词来的，不存在这个问题。\n了解就行，不用深究。\n2.8 残差连接 &amp; Layer Norm\n这些是为了稳定训练过程。推理时它们就是网络的一部分，你优化时treat it as a black box就行。\n如果做算子优化，可能会关注Layer Norm的实现。\n三、不同AI Infra方向的学习侧重\n根据你的具体方向，学习重点不太一样。\n推理优化工程师\n你的日常工作：\n让模型跑得更快、用更少资源、支持更大batch。\nTransformer知识优先级：\n\n\nKV Cache管理：必须吃透\n\nKV的产生、存储、读取全流程\nPagedAttention原理和实现\nPrefix Caching、KV量化\n\n\n\nAttention计算优化：核心战场\n\nFlash Attention的原理（至少懂为什么快）\nMulti-Query Attention的效果\nSparse Attention的适用场景\n\n\n\n量化对Transformer的影响：必备技能\n\n哪些部分可以量化（权重、激活、KV Cache）\n量化后的精度损失\n量化算子的实现\n\n\n\n学习路线：\n第1周：搞透KV Cache\n\n看vLLM的CacheEngine源码\n画出KV Cache的生命周期图\n跑实验：监控不同batch下的KV占用\n\n第2-3周：实践优化技术\n\n开启/关闭Flash Attention对比\n尝试不同的block size（PagedAttention参数）\n实现一个简单的KV Cache管理器（Python即可）\n\n第4周+：深入一个方向\n\n如果做kernel优化：学CUDA，看Flash Attention源码\n如果做系统优化：学调度策略，看vLLM的scheduler\n如果做量化：学INT8/INT4 kernel实现\n\n模型部署工程师\n你的日常工作：\n让模型在生产环境稳定运行，支持高并发请求。\nTransformer知识优先级：\n\n\n模型架构与框架对应：必须清楚\n\nEncoder-only vs Decoder-only的部署差异\n不同框架对Transformer的支持（TensorRT-LLM、vLLM、TGI）\n模型格式转换（PyTorch → ONNX → TensorRT）\n\n\n\nBatch处理机制：影响吞吐量\n\nDynamic Batching的实现\nContinuous Batching（vLLM的核心）\nBatch size与latency的trade-off\n\n\n\n长上下文支持：客户常问的问题\n\n位置编码方案（RoPE、ALiBi）\n长上下文下的内存管理\nSliding Window Attention\n\n\n\n学习路线：\n第1周：熟悉部署流程\n\n在vLLM上部署一个模型\n尝试不同的推理框架（TGI、TensorRT-LLM）\n对比它们的API和性能\n\n第2周：理解架构差异\n\n部署一个BERT模型（如果做任务推理）\n部署一个GPT模型\n总结两者的部署要点差异\n\n第3周：优化并发性能\n\n测试不同max_batch_size的影响\n配置动态batching参数\n监控GPU利用率\n\n第4周+：生产化\n\n加入监控（Prometheus + Grafana）\n实现自动扩缩容\n做故障演练\n\nAI系统架构师\n你的日常工作：\n设计支持千亿参数模型的分布式推理系统。\nTransformer知识优先级：\n\n\n模型并行策略：核心技能\n\n张量并行（Tensor Parallelism）在Transformer中的应用\n流水线并行（Pipeline Parallelism）的切分点\n序列并行（Sequence Parallelism）的适用场景\n\n\n\n内存墙与计算墙：系统瓶颈\n\nTransformer哪些操作是compute-bound，哪些是memory-bound\n不同硬件（A100 vs H100）的特性\n通信开销的计算\n\n\n\n端到端推理流程：全局视角\n\n从接收请求到返回结果的完整路径\n各阶段的瓶颈和优化点\nSLA保证策略\n\n\n\n学习路线：\n第1-2周：理解并行策略\n\n阅读Megatron-LM、DeepSpeed论文\n理解Transformer各层如何切分\n画出并行策略的拓扑图\n\n第3周：分析瓶颈\n\n用Nsight分析Transformer的kernel性能\n区分compute-bound和memory-bound操作\n计算不同配置下的理论性能上限\n\n第4周+：设计系统\n\n设计一个支持千亿参数模型的推理集群\n考虑成本、延迟、吞吐量的trade-off\n写技术方案文档\n\n四、学习建议与避坑指南\n推荐做法\n1. 从实践入手\n不要上来就啃论文。先跑起来一个vLLM程序，看看KV Cache在哪，占了多少内存。有了直观感受，再看原理会轻松很多。\n2. 关注&quot;为什么影响性能&quot;\n学每个概念，都问自己：这个东西为什么会影响推理性能？是影响内存、计算还是通信？\n比如学位置编码，AI Infra关心的不是数学公式，而是：\n\nRoPE为什么比Sinusoidal支持更长上下文？\n这对内存有什么影响？\n\n3. 动手实验\n理论只是理论，跑个实验印象深刻一百倍。\n推荐实验：\n\n监控KV Cache占用随序列长度的变化\n对比Flash Attention开启前后的速度\n测试不同batch size对吞吐量的影响\n\n4. 看开源代码\nvLLM、TensorRT-LLM、TGI的代码都开源的。看不懂C++/CUDA没关系，先看Python部分的逻辑。\n重点看：\n\nKV Cache的管理逻辑\nBatch调度策略\n内存分配器\n\n写在最后\n回到开头的问题：AI Infra工程师要不要学Transformer？\n要学，但要聪明地学。\n不要试图把Transformer的每个细节都搞懂，那是算法工程师的事。你要做的是：\n\n抓住核心：KV Cache、Attention计算、Batch处理\n理解影响：每个设计为什么影响性能\n动手实践：跑起来，监控起来，优化起来\n\n记住，AI Infra的价值不是&quot;我懂Transformer&quot;，而是&quot;我能让Transformer跑得又快又稳&quot;。\n\n参考资料\n\n\n我的其他文章：\n\n《Transformer详解》 - Transformer基础原理\n《PagedAttention解析》 - KV Cache优化的核心技术\n《第一个vLLM程序》 - 实践入门\n\n\n\n推荐阅读：\n\nAttention Is All You Need - Transformer原论文\nThe Illustrated Transformer - 最好的可视化教程\nvLLM: Easy, Fast, and Cheap LLM Serving with PagedAttention - vLLM原论文\nFlash Attention - Attention优化技术\n\n\n\n开源项目：\n\nvLLM\nTensorRT-LLM\nText Generation Inference (TGI)\n\n\n\n","categories":["AI Infra"],"tags":["KV Cache","AI Infrastructure","Transformer","推理优化","模型部署","学习路线"]},{"title":"AI Infra学习之旅-Transformer详解","url":"/posts/db1cf321/","content":"Transformer深度解析：从零开始理解&quot;注意力就是你所需要的一切&quot;\n\n如果你关注AI领域，ChatGPT、BERT、GPT这些名字应该不陌生。它们背后有个共同的&quot;老祖宗&quot;——Transformer。我最初看到这个架构时，觉得有点复杂，但当我真正理解了它的设计思想后，突然发现一切都说得通了。今天我想用最直白的方式，和你聊聊这个改变了整个深度学习游戏规则的架构。\n\n写在前面\n2017年，Google的研究团队发了一篇论文，标题叫《Attention Is All You Need》。第一次看到这个标题时我就觉得，这帮人可真敢说——“注意力就是你所需要的一切”，口气未免太大了吧？但几年过去了，事实证明他们是对的。这篇论文提出的Transformer架构，不仅彻底改写了NLP的规则，还渗透到了CV、语音、甚至生物信息学等各个领域。\n在扎进技术细节之前，我想先说说Transformer为什么会出现。毕竟，任何技术的诞生都是为了解决某个实际问题。\n一、RNN的困境：我们为什么需要新架构？\n在Transformer横空出世之前，处理序列数据（比如文本、语音）的主流方案是RNN（循环神经网络）以及它的改进版LSTM、GRU。\nRNN怎么工作的？\n你可以把RNN想象成这样一个场景：你在读一本侦探小说。RNN的处理方式就是一个字一个字地往下读，每读一个字都会更新对剧情的理解。\n输入: &quot;我 爱 北京 天安门&quot;处理: 我 → 我爱 → 我爱北京 → 我爱北京天安门\n听起来挺合理的，对吧？但这里有个致命的问题：必须按顺序处理，没法跳着来。\nRNN的两大硬伤\n1. 没法并行计算\n要处理第3个词，你必须先把第1、2个词处理完。这就像高速公路只有一条车道，不管你有多少辆车（GPU核心），也只能排队一辆一辆过。对于动辄几百万、上亿参数的模型来说，这种串行处理简直是灾难。训练一个大模型可能要好几周，谁受得了？\n2. 长距离依赖问题\n来看这个句子：\n\n“那只猫，它在花园里追蝴蝶的时候不小心撞到了树，后来躺在沙发上休息了一下午，最后终于恢复了精神，它开心地喵喵叫。”\n\n你肯定一眼就能看出最后的&quot;它&quot;指的是开头的&quot;猫&quot;。但对RNN来说，这可太难了。&quot;猫&quot;这个信息得像接力赛一样，一站一站地传到&quot;它&quot;那里。传递链越长，信息损失越严重——就像小时候玩传话游戏，传到最后往往都变味了。\n理论上LSTM通过门控机制缓解了这个问题，但也只是&quot;缓解&quot;，并没有根治。\nTransformer的出现，就是为了一刀切掉这两个问题。\n二、注意力机制：Transformer的核心武器\n在正式拆解Transformer之前，得先搞懂它最核心的部分——自注意力机制（Self-Attention）。这东西听起来玄乎，其实思想很直观。\n先来个直观的例子\n假设有这么一句话：\n\n“那只动物没能过马路，因为它太累了。”\n\n当你读到&quot;它&quot;的时候，你的大脑会做什么？会自动&quot;回看&quot;前面的内容，判断&quot;它&quot;指的是啥。你会把更多注意力分配给&quot;动物&quot;，而不是&quot;马路&quot;或&quot;因为&quot;。\n自注意力机制做的就是这件事：在处理每个词的时候，让模型能&quot;看到&quot;句子里所有其他词，并自动决定该给每个词分配多少注意力。\nQuery、Key、Value：三个关键角色\n自注意力的实现靠三个向量：Query（查询）、Key（键）、Value（值）。\n我第一次看到这三个概念时也很懵，后来发现用图书馆来比喻特别好理解：\n\nQuery：你想找的书的描述，比如&quot;关于深度学习的入门书&quot;\nKey：每本书的标签/索引，比如&quot;深度学习&quot;、“CV”、“烹饪”\nValue：书的实际内容\n\n找书的过程是这样的：\n\n拿着你的Query（需求描述），去和书架上每本书的Key（标签）对比\n标签越匹配，说明这本书越相关\n根据相关性高低，从对应的Value（书的内容）中提取信息\n最后你得到的是一个&quot;混合信息&quot;——相关性高的书提供更多内容，相关性低的书提供较少内容\n\n在Transformer里，每个词都会生成自己的Q、K、V向量。这些向量怎么来的？很简单，就是把词向量和三个可学习的权重矩阵相乘：\nQ = 词向量 × WqK = 词向量 × Wk  V = 词向量 × Wv\n这三个矩阵Wq、Wk、Wv是模型训练过程中学习出来的。\n注意力分数怎么算？\n有了Q、K、V，注意力的计算就是四步走：\n第一步：计算相关性分数\n用当前词的Query和所有词（包括自己）的Key做点积。点积值越大，说明两个词越相关。\n分数 = Q · K^T\n这里为什么用点积？因为点积本质上衡量的是两个向量的相似度。方向越接近，点积越大。\n第二步：缩放（Scaling）\n直接用点积会有个问题：如果向量维度很大（比如512维），点积的结果也会很大。这些大数值经过softmax后，会导致梯度极小（想象一下softmax把一个很大的数映射成接近1，其他数映射成接近0，梯度基本就没了）。\n所以论文里做了个简单粗暴的处理：除以√dk（Key向量维度的平方根）。\n缩放后的分数 = Q·K^T / √dk\n为什么是平方根？论文附录里有数学推导，简单说就是：假设Q和K的每个元素均值为0、方差为1，那么d维向量点积的方差就是d。除以√d可以把方差拉回到1，保持数值稳定。\n第三步：Softmax归一化\n把分数转成概率分布，让所有注意力权重加起来等于1。\n注意力权重 = softmax(缩放后的分数)\n经过softmax后，相关性高的词得到更大的权重，相关性低的词权重接近0。\n第四步：加权求和\n用注意力权重对所有Value向量进行加权求和。\n输出 = 注意力权重 × V\n整个过程可以用一个公式搞定：\nAttention(Q, K, V) = softmax(QK^T / √dk) × V\n来个具体例子\n假设我们有三个词：“我”、“爱”、“你”，每个词的向量是2维（实际中通常是512维或更高，这里为了方便演示用2维）。\n假设&quot;爱&quot;这个词的Query是[1, 0]，三个词的Key分别是：\n\n“我”：[0.8, 0.2]\n“爱”：[1.0, 0.0]\n“你”：[0.6, 0.5]\n\n计算&quot;爱&quot;对三个词的注意力：\n\n\n计算点积：\n\n爱→我：1×0.8 + 0×0.2 = 0.8\n爱→爱：1×1.0 + 0×0.0 = 1.0\n爱→你：1×0.6 + 0×0.5 = 0.6\n\n\n\n缩放（√2 ≈ 1.41）：\n\n爱→我：0.8/1.41 ≈ 0.57\n爱→爱：1.0/1.41 ≈ 0.71\n爱→你：0.6/1.41 ≈ 0.42\n\n\n\nSoftmax后大约是：\n\n爱→我：0.31\n爱→爱：0.38\n爱→你：0.31\n\n\n\n用这些权重对Value向量加权求和，得到&quot;爱&quot;的新表示\n\n\n这个例子说明，“爱&quot;这个词对自己的注意力最高（0.38），但也会关注&quot;我&quot;和&quot;你”（各0.31左右）。这很合理，因为动词往往需要同时关注主语和宾语。\n\n多头注意力：从多个视角看问题\n单个注意力机制就像从一个角度看东西。但理解一句话，可能需要同时考虑语法结构、语义关系、指代关系等多个维度。\n多头注意力（Multi-Head Attention） 就是这个思路：\n\n把Q、K、V分别切成多个&quot;头&quot;（原论文用了8个头）\n每个头独立计算注意力\n把所有头的结果拼起来，再做一次线性变换\n\nMultiHead(Q,K,V) = Concat(head₁, head₂, ..., head₈) × Wo其中 headᵢ = Attention(QWᵢq, KWᵢk, VWᵢv)\n每个头有自己独立的Wq、Wk、Wv权重矩阵，所以能学到不同类型的关系。\n举个例子，在翻译句子时：\n\n第1个头可能专注于主谓关系\n第2个头可能专注于修饰关系（形容词和名词）\n第3个头可能专注于位置关系（前后词的相对位置）\n…\n\n把这些不同视角的信息综合起来，模型对句子的理解就更全面了。\n\n三、Transformer架构全貌\n搞懂了注意力机制，就理解了Transformer的核心。现在我们把整个架构拼起来。\nTransformer采用经典的编码器-解码器（Encoder-Decoder） 结构，左边是Encoder，右边是Decoder。\n\n原论文中的Transformer由6层Encoder和6层Decoder堆叠而成。\n编码器（Encoder）\n每一层Encoder包含两个子层：\n\n多头自注意力层：让每个词都能&quot;看到&quot;输入序列中的所有其他词\n前馈神经网络（FFN）：其实就是两层全连接网络，对每个位置的表示做进一步变换\n\n关键的是，每个子层都包了两个&quot;保护壳&quot;：\n\n残差连接（Residual Connection）：把输入直接加到输出上，这样梯度可以&quot;直通&quot;回去，缓解深层网络的梯度消失问题\n层归一化（Layer Normalization）：把每一层的输出归一化，稳定训练过程\n\n整个流程可以写成：\n输出 = LayerNorm(x + SubLayer(x))\n先对x做变换（MultiHead Attention或FFN），然后和原来的x相加（残差连接），最后归一化。\n6层Encoder叠在一起，就像是对输入做了6次&quot;提炼&quot;，每一层都在之前的基础上提取更抽象的特征。\n解码器（Decoder）\n解码器比编码器多一个子层，总共三个：\n\n带掩码的多头自注意力层（Masked Multi-Head Attention）\n编码器-解码器注意力层（Cross-Attention）：让解码器能够&quot;查阅&quot;编码器的输出\n前馈神经网络\n\n为什么需要掩码（Mask）？\n这是个关键问题。在训练翻译模型时，我们已经有了完整的目标句子。比如把&quot;我爱中国&quot;翻译成&quot;I love China&quot;，训练时我们知道完整的目标是&quot;I love China&quot;。\n但我们希望模型学会的是：根据已生成的词，预测下一个词。如果模型在预测&quot;love&quot;的时候能&quot;偷看&quot;到后面的&quot;China&quot;，那就作弊了——测试时哪有未来的词给你看啊？\n掩码的作用就是在自注意力计算时，遮住未来位置的信息。具体做法是：在softmax之前，把未来位置的分数设为负无穷（-∞）。这样经过softmax后，那些位置的注意力权重就变成0了。\n比如在生成&quot;love&quot;时：\n\n可以看到&lt;start&gt;和&quot;I&quot;\n看不到&quot;love&quot;后面的&quot;China&quot;\n\n\n编码器-解码器注意力\n这是Decoder特有的第二个子层。它让解码器在生成每个词时，可以&quot;查阅&quot;编码器的输出。\n这里的Query来自解码器，Key和Value来自编码器。这样解码器就能根据自己当前的状态（Query），去编码后的源句子里找相关信息（Key），并提取相应内容（Value）。\n比如翻译&quot;我爱中国&quot;→&quot;I love China&quot;时：\n\n生成&quot;I&quot;时，主要关注&quot;我&quot;\n生成&quot;love&quot;时，主要关注&quot;爱&quot;\n生成&quot;China&quot;时，主要关注&quot;中国&quot;\n\n当然，实际情况会更复杂，因为不是所有语言都是一一对应的词序。\n位置编码：告诉模型词的顺序\n自注意力有个&quot;缺陷&quot;：它是位置无关的。\n什么意思？对于自注意力来说，&quot;我爱你&quot;和&quot;你爱我&quot;如果只看词本身，处理方式是一样的——因为它只计算词与词之间的关系，不管它们的位置。\n但词的位置显然很重要啊！&quot;狗咬人&quot;和&quot;人咬狗&quot;完全是两码事。\n怎么办？把位置信息&quot;编码&quot;进输入向量里。\n位置编码（Positional Encoding） 用正弦和余弦函数生成：\nPE(pos, 2i)   = sin(pos / 10000^(2i/d))PE(pos, 2i+1) = cos(pos / 10000^(2i/d))\n其中：\n\npos是词在句子中的位置（0, 1, 2, …）\ni是维度索引（0到d/2）\nd是向量维度（比如512）\n\n为什么用正弦/余弦函数？主要是因为它们有几个好性质：\n\n值域有界：始终在[-1, 1]之间，不会因为位置太大而爆炸\n每个位置唯一：不同位置的编码不会重复\n能表示相对位置：利用三角函数的性质，PE(pos+k)可以表示为PE(pos)的线性组合，这让模型更容易学到&quot;相对位置关系&quot;（比如&quot;前面第2个词&quot;）\n可以泛化到更长序列：训练时见过100个词的句子，测试时来了150个词，位置编码依然能算出来\n\n位置编码会直接加到词嵌入向量上，作为模型的最终输入。\n\n四、实际应用：机器翻译的完整流程\n理论说了一堆，我们来看个具体例子。假设要把&quot;我爱中国&quot;翻译成&quot;I love China&quot;。\n编码阶段\n第一步：输入表示\n\n把&quot;我&quot;、“爱”、&quot;中国&quot;转成词向量（比如用Word2Vec或直接学习Embedding）\n给每个词向量加上位置编码（&quot;我&quot;是位置0，&quot;爱&quot;是位置1，&quot;中国&quot;是位置2）\n\n第二步：经过6层Encoder\n\n第1层：通过自注意力，“爱&quot;这个词能看到&quot;我&quot;和&quot;中国”，理解到这是个主谓宾结构\n第2层：在第1层的基础上进一步提炼，可能学到&quot;我爱X&quot;这种情感表达模式\n…\n第6层：得到包含丰富上下文信息的最终编码\n\n每经过一层，词的表示就更&quot;丰富&quot;一些，包含的上下文信息就更多一些。\n解码阶段\n第一步：开始标记\n输入&lt;start&gt;标记，告诉模型&quot;该生成句子了&quot;。\n第二步：生成&quot;I&quot;\n\n解码器接收&lt;start&gt;\n通过掩码自注意力处理&lt;start&gt;（虽然只有一个词，也要走这个流程）\n通过编码器-解码器注意力，关注编码后的源句子，发现&quot;我&quot;最相关\n经过FFN，输出一个概率分布\n概率最高的词是&quot;I&quot;\n\n第三步：生成&quot;love&quot;\n\n解码器接收&lt;start&gt; I\n掩码确保&quot;I&quot;只能看到自己和&lt;start&gt;，看不到未来\n再次查阅编码器输出，这次主要关注&quot;爱&quot;\n预测下一个词：“love”\n\n第四步：生成&quot;China&quot;\n\n解码器接收&lt;start&gt; I love\n关注编码器中的&quot;中国&quot;\n预测：“China”\n\n第五步：结束\n\n解码器接收&lt;start&gt; I love China\n预测下一个词是&lt;end&gt;，翻译结束\n\n实际使用中，我们不一定每次都选概率最高的词（这叫Greedy Decoding），更常用Beam Search：保留top-k个候选序列，最后选总概率最高的那个。\n\n五、为什么Transformer这么成功？\n回顾一下，Transformer为什么能在短短几年内席卷整个AI领域？\n1. 真·并行计算\n这是最直接的优势。RNN必须一个词一个词地算，Transformer可以一次性算完整个句子。\n假设一个句子有100个词，RNN需要100步串行计算；Transformer可以一步算完所有词的self-attention（当然内部还是有矩阵运算，但这些可以完美并行）。\n在GPU上，这个优势太明显了。GPU有成千上万个核心，就是为并行计算设计的。Transformer充分发挥了硬件优势，训练速度比RNN快了几个数量级。\n2. 长距离依赖不再是问题\n在Transformer里，任意两个词之间的&quot;距离&quot;都是1——一次注意力计算就能直接建立联系。\n不像RNN，信息要一站一站传递。句子开头的词，要传100步才能影响结尾的词；Transformer里，开头直接看到结尾。\n这让模型能轻松捕捉长距离依赖，比如指代消解、长篇文档的主题理解等。\n3. 可解释性更好\n注意力权重可以可视化。你可以画个热力图，看到模型在翻译&quot;China&quot;时，把80%的注意力放在了源句子的&quot;中国&quot;上。\n这比RNN的隐状态好理解多了。RNN的隐状态是一堆数字，你根本不知道它记住了啥、忘了啥。\n4. 极强的可扩展性\nTransformer的架构非常&quot;scalable&quot;。想要更强的模型？简单：\n\n加深：6层→12层→24层→96层\n加宽：512维→1024维→2048维\n加头：8 heads→16 heads→32 heads\n\n从BERT-base（110M参数）到GPT-3（175B参数），再到最新的模型（千亿级），都是Transformer架构。只是层数、维度不同而已。\n而且有个神奇的现象：参数越大，效果往往越好（当然数据也要跟上）。这就是大模型时代的基石。\n六、Transformer的后代们\nTransformer提出后，基于它的各种变体和改进模型层出不穷。这里介绍几个最有影响力的：\n\n\n\n模型\n架构\n特点\n典型应用\n\n\n\n\nBERT\n只用Encoder\n双向编码，擅长理解文本\n搜索引擎、问答系统、文本分类\n\n\nGPT系列\n只用Decoder\n自回归生成，擅长创造文本\nChatGPT、代码生成、创意写作\n\n\nT5\n完整Encoder-Decoder\n把所有NLP任务都转成&quot;文本到文本&quot;\n翻译、摘要、QA统一框架\n\n\nVision Transformer (ViT)\nEncoder-only\n把图像切成patch当词处理\n图像分类、目标检测\n\n\nDALL-E / Stable Diffusion\n改进的Transformer\n文生图、多模态\nAI绘画、图像编辑\n\n\n\nBERT vs GPT：一个理解，一个生成\n\n\nBERT：只用Encoder，训练时随机遮住一些词让模型猜（Masked Language Modeling）。因为能同时看到上下文，所以擅长&quot;理解&quot;任务——给它一篇文章，它能告诉你情感是正面还是负面，能回答文章相关问题。\n\n\nGPT：只用Decoder，训练时根据前面的词预测下一个词。因为只能看到之前的内容，所以擅长&quot;生成&quot;任务——给它一个开头，它能续写出连贯的文章。\n\n\n这也解释了为什么ChatGPT用的是GPT架构，而不是BERT——因为聊天需要生成回复嘛。\n可以说，现代AI的大部分突破，都直接或间接站在Transformer的肩膀上。\n写在最后\n回头看看我们都聊了些啥：\n\n为什么需要Transformer：RNN的并行化困难和长距离依赖问题\n核心机制：Self-Attention通过Query、Key、Value实现对上下文的灵活建模\n多头注意力：从多个角度理解输入\n整体架构：Encoder-Decoder结构，加上位置编码、残差连接、层归一化等关键组件\n实际应用：翻译、生成、理解，无所不能的基础架构\n\nTransformer的影响已经远超当初的机器翻译。从ChatGPT到Stable Diffusion，从AlphaFold到代码补全工具GitHub Copilot，Transformer无处不在。\n说实话，当初读论文时，我没想到这个架构能火成现在这样。它并不完美——比如注意力的O(n²)复杂度在处理超长序列时还是个问题——但它的设计思想实在太优雅了。用注意力机制让模型自己决定关注什么，这个想法简单却强大。\n如果你想深入学习AI，Transformer绝对是绕不过去的一关。理解了它，你就掌握了现代AI的基石。\n希望这篇文章能帮你建立起对Transformer的直观理解。如果有任何疑问，欢迎留言讨论！\n\n参考资料\n\nVaswani, A., et al. (2017). “Attention is all you need.” Advances in Neural Information Processing Systems. 原论文链接\nThe Illustrated Transformer - Jay Alammar 的可视化教程，强烈推荐：http://jalammar.github.io/illustrated-transformer/\nAnnotated Transformer - Harvard NLP的带注释实现，适合动手实践：https://nlp.seas.harvard.edu/annotated-transformer/\nBERT论文: Devlin, J., et al. (2018). “BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding.”\nGPT-3论文: Brown, T., et al. (2020). “Language Models are Few-Shot Learners.”\n\n","categories":["AI Infra"],"tags":["Transformer","注意力机制","深度学习","NLP","人工智能"]},{"title":"AI Infra学习之旅-服务器环境配置","url":"/posts/a8ee689e/","content":"前言\n在上一篇博客中，我在 Kaggle 上成功运行了第一个 vLLM 程序。但 Kaggle 毕竟有时长限制（每周 30 小时），而且每次都要重新配置环境。这次，我有机会使用一台配备双 RTX 4090 的 Ubuntu 服务器，这是一次从云端到本地服务器的重要升级！\n这篇文章将详细记录我从零开始配置这台服务器的完整过程，包括：\n\nSSH 免密登录配置\nVSCode Remote SSH 开发环境搭建\n远程桌面访问（GNOME Remote Desktop）\nPython + vLLM 环境安装\n实际踩过的坑与解决方案\n\n希望这篇文章能帮助到同样需要配置 AI 开发服务器的朋友们。\n\n服务器配置信息\n硬件配置\nGPU型号: 2 × NVIDIA GeForce RTX 4090显存: 24GB × 2 = 48GB 总显存CUDA版本: 12.2驱动版本: 535.274.02\n系统信息\n操作系统: Ubuntu 24.04 LTS用户名: Smarter主机名: 330B内网IP: 服务器ip \n与 Kaggle 对比\n\n\n\n维度\n我的服务器 (RTX 4090×2)\nKaggle/Colab\n\n\n\n\nGPU型号\nRTX 4090 (旗舰)\n⚠️ P100/T4 (中低端)\n\n\n显存\n48GB\n⚠️ 16GB\n\n\nGPU时长\n无限制\n⚠️ 30h/周\n\n\n环境持久化\n永久保存\n❌ 每次重装\n\n\n性能\n独享双卡\n⚠️ 共享单卡\n\n\n适合长实验\n\n❌\n\n\n\n结论: 服务器配置远超 Kaggle，应该优先使用服务器进行学习和开发。\n\n第一阶段：SSH 连接配置\nStep 1: 首次 SSH 连接测试\n在 Windows PowerShell 中执行：\n# 首次连接（替换为你的用户名@服务器IP）ssh Smarter@服务器ip# 首次连接会提示：# The authenticity of host &#x27;192.168.50.58&#x27; can&#x27;t be established.# Are you sure you want to continue connecting (yes/no)?# 输入：yes# 然后输入密码\n成功标志：看到以下提示符说明连接成功\nSmarter@330B:~$\nStep 2: 验证 GPU 状态\n连接成功后，立即验证 GPU：\nnvidia-smi\n我的实际输出：\n\n看到两张 RTX 4090，CUDA 12.2，驱动正常，说明环境 OK！\nStep 3: 配置 SSH 密钥免密登录\n每次输入密码很麻烦，配置公钥登录可以一劳永逸。\n在 Windows 本地生成 SSH 密钥\n打开 PowerShell：\n# 生成 SSH 密钥对（如果还没有）ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# 提示：Enter file in which to save the key# 直接回车（使用默认路径 C:\\Users\\pc\\.ssh\\id_rsa）# 提示：Enter passphrase# 直接回车（不设置密码，方便使用）\n将公钥复制到服务器\n# 读取公钥内容$pub = Get-Content C:\\Users\\pc\\.ssh\\id_rsa.pub# 将公钥追加到服务器的 authorized_keysssh Smarter@服务器ip &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;$pub&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;\n\n💡 这一步会要求输入最后一次服务器密码，之后就可以免密登录了。\n\n测试免密登录\nssh Smarter@服务器ip\n如果直接登录不再要求密码，说明配置成功！\n\n第二阶段：VSCode Remote SSH 配置\nVSCode Remote SSH 是最重要的开发工具，可以让我在 Windows 上直接编辑服务器上的代码。\nStep 1: 安装 VSCode 插件\n在 VSCode 中安装以下插件：\n\nRemote - SSH  (必装)\nRemote - SSH: Editing Configuration Files\nPython\nJupyter\n\nStep 2: 配置 SSH Config 文件\n\n按 F1，输入 Remote-SSH: Open SSH Configuration File\n选择 C:\\Users\\pc\\.ssh\\config\n添加以下配置：\n\n# Ubuntu AI Infra服务器 (RTX 4090×2)Host ai-server    HostName 服务器ip    User Smarter    Port 22    IdentityFile C:\\Users\\pc\\.ssh\\id_rsa    IdentitiesOnly yes    PreferredAuthentications publickey    ForwardAgent yes\n配置说明：\n\nIdentitiesOnly yes: 只使用指定的密钥\nPreferredAuthentications publickey: 优先使用公钥认证\nForwardAgent yes: 允许 SSH Agent 转发\n\nStep 3: 连接到服务器\n\n按 F1，输入 Remote-SSH: Connect to Host\n选择 ai-server\n等待连接（首次会安装 VSCode Server，约 1 分钟）\n成功标志：左下角显示 SSH: ai-server\n\nStep 4: 在 VSCode 中打开服务器文件夹\n连接成功后：\n\n点击 File → Open Folder\n选择 /home/Smarter 或你的项目目录\n现在可以直接在 VSCode 中编辑服务器上的文件了！\n\n\n第三阶段：远程桌面配置\n有时候需要图形界面，我配置了 GNOME Remote Desktop。\n为什么选择 GNOME Remote Desktop？\n\nUbuntu 24.04 自带，无需额外安装\n支持无显示器远程登录\nWindows 自带 mstsc 即可连接\n比 XRDP 更稳定\n\nStep 1: 安装和启用 GNOME Remote Desktop\n在服务器上执行（需要管理员权限）：\n# 1. 安装组件（Ubuntu 24.04 通常已安装）sudo apt updatesudo apt install -y gnome-remote-desktop# 2. 生成 TLS 证书（必需）sudo -u gnome-remote-desktop mkdir -p ~gnome-remote-desktop/.local/share/gnome-remote-desktopsudo openssl req -x509 -newkey rsa:4096 -nodes -days 3650 -sha256 \\  -keyout ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \\  -out ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt \\  -subj &quot;/CN=服务器ip&quot;# 3. 设置文件权限sudo chown gnome-remote-desktop:gnome-remote-desktop \\  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.key \\  ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crtsudo chmod 600 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.keysudo chmod 644 ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt\nStep 2: 配置 RDP 认证\n# 禁用 RDP（如果之前启用过）sudo grdctl --system rdp disable 2&gt;/dev/null || true# 设置 TLS 证书sudo grdctl --system rdp set-tls-key ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.keysudo grdctl --system rdp set-tls-cert ~gnome-remote-desktop/.local/share/gnome-remote-desktop/tls.crt# 设置 RDP 入口账号密码（这不是 Linux 用户密码）sudo grdctl --system rdp set-credentials rdpuser &#x27;你的强密码&#x27;# 启用 RDPsudo grdctl --system rdp enable\nStep 3: 启动服务并验证\n# 启动并设置开机自启sudo systemctl enable --now gnome-remote-desktop.service# 重启服务sudo systemctl restart gnome-remote-desktop.service# 验证 3389 端口是否监听sudo ss -lnptu | grep 3389# 查看状态sudo grdctl --system status\nStep 4: Windows 端连接\n\n按 Win + R，输入 mstsc\n计算机填写：服务器ip\n首次认证输入：\n\n用户名：rdpuser\n密码：你设置的密码\n\n\n进入 GNOME 登录界面后，使用 Linux 用户 Smarter 的系统密码登录\n\n\n⚠️ 重要：确保 Smarter 用户设置了系统密码：\nsudo passwd Smarter\n\nStep 5: 保存 RDP 凭据（避免每次输入）\n在 Windows 中：\n\n搜索并打开 凭据管理器\n进入 Windows 凭据\n点击 添加 Windows 凭据\n地址填：TERMSRV/服务器ip\n用户名填：rdpuser\n密码填你的密码 → 保存\n\n\n第四阶段：Python 环境配置\nStep 1: 检查 Conda 是否已安装\n在 VSCode 终端（或 SSH 连接）中：\nconda --version\n\n如果显示版本号 → 已安装\n如果报错 command not found → 需要安装\n\nStep 2A: 如果已有 Conda\n# 1. 检查 CUDA 版本nvidia-smi | grep &quot;CUDA Version&quot;# 输出: CUDA Version: 12.2# 2. 检查现有环境conda env list# 3. 创建 AI Infra 环境（如果不存在）conda create -n ai-infra python=3.10 -y# 4. 激活环境conda activate ai-infra# 5. 安装 PyTorch（CUDA 12.2 使用 cu121）pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121# 6. 验证 GPU 可用性python -c &quot;import torch; print(f&#x27;PyTorch: &#123;torch.__version__&#125;&#x27;); print(f&#x27;CUDA可用: &#123;torch.cuda.is_available()&#125;&#x27;); print(f&#x27;GPU数量: &#123;torch.cuda.device_count()&#125;&#x27;)&quot;\n期望输出：\nPyTorch: 2.1.2+cu121CUDA可用: TrueGPU数量: 2\nStep 2B: 如果需要安装 Conda\n# 1. 下载 Miniconda（比 Anaconda 更轻量）wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh# 2. 安装bash Miniconda3-latest-Linux-x86_64.sh# 提示: Do you accept the license terms? → yes# 提示: installation location → 回车（使用默认）# 提示: Do you wish to update your shell profile → yes# 3. 重新加载 shellsource ~/.bashrc# 4. 验证安装conda --version# 5. 然后回到 Step 2A 的步骤 3 继续\nStep 3: 安装基础科学计算包\n# 确保在 ai-infra 环境中conda activate ai-infra# 安装基础包（指定版本避免冲突）pip install numpy==1.24.3 pandas matplotlib jupyterlabpip install transformers==4.36.2 accelerate==0.25.0# 验证安装python -c &quot;import transformers; print(f&#x27;Transformers: &#123;transformers.__version__&#125;&#x27;)&quot;\n\n第五阶段：vLLM 安装与测试\n版本兼容性说明\n\n⚠️ 重要：不要随意升级版本，容易导致 CUDA 不兼容！\n\n推荐版本组合（2026年1月验证）：- PyTorch 2.1.2 (cu121)- vLLM 0.2.7 (稳定版)- Triton 2.1.0 (vLLM依赖)- Flash-Attention 2.3.6 (可选，编译困难，不推荐)\n保守安装方案（推荐）\n# 1. 激活环境conda activate ai-infra# 2. 安装 vLLM（会自动安装 Triton 等依赖）pip install vllm==0.2.7# 3. 验证 vLLMpython -c &quot;import vllm; print(f&#x27;vLLM版本: &#123;vllm.__version__&#125;&#x27;)&quot;# 输出: vLLM版本: 0.2.7# 4. 验证 Triton（vLLM 会自动安装）python -c &quot;import triton; print(f&#x27;Triton版本: &#123;triton.__version__&#125;&#x27;)&quot;# 5. 测试 vLLM 是否可用python -c &quot;from vllm import LLM; print(&#x27;vLLM导入成功 &#x27;)&quot;\n最终环境验证\n运行完整验证脚本：\npython &lt;&lt;EOFimport torchimport vllmimport tritonprint(&quot;=&quot; * 50)print(&quot;环境验证&quot;)print(&quot;=&quot; * 50)print(f&quot;PyTorch版本: &#123;torch.__version__&#125;&quot;)print(f&quot;CUDA可用: &#123;torch.cuda.is_available()&#125;&quot;)print(f&quot;CUDA版本: &#123;torch.version.cuda&#125;&quot;)print(f&quot;GPU数量: &#123;torch.cuda.device_count()&#125;&quot;)if torch.cuda.is_available():    print(f&quot;GPU 0: &#123;torch.cuda.get_device_name(0)&#125;&quot;)    print(f&quot;GPU 1: &#123;torch.cuda.get_device_name(1)&#125;&quot;)print(f&quot;\\nvLLM版本: &#123;vllm.__version__&#125;&quot;)print(f&quot;Triton版本: &#123;triton.__version__&#125;&quot;)print(&quot;\\n 所有核心组件安装成功！&quot;)EOF\n期望输出：\n==================================================环境验证==================================================PyTorch版本: 2.1.2+cu121CUDA可用: TrueCUDA版本: 12.1GPU数量: 2GPU 0: NVIDIA GeForce RTX 4090GPU 1: NVIDIA GeForce RTX 4090vLLM版本: 0.2.7Triton版本: 2.1.0 所有核心组件安装成功！\n\n第六阶段：运行第一个 vLLM 程序\n创建测试文件\n在 VSCode 中创建 ~/test_vllm.py：\nfrom vllm import LLM, SamplingParamsimport torchimport time# 显示 GPU 信息print(&quot;=&quot; * 80)print(&quot;GPU 配置信息&quot;)print(&quot;=&quot; * 80)print(f&quot;可用GPU数量: &#123;torch.cuda.device_count()&#125;&quot;)print(f&quot;GPU 0: &#123;torch.cuda.get_device_name(0)&#125;&quot;)print(f&quot;GPU 1: &#123;torch.cuda.get_device_name(1)&#125;&quot;)print(&quot;=&quot; * 80)# 加载小模型测试（只有 125M 参数，几秒加载）print(&quot;\\n🔄 正在加载模型...&quot;)llm = LLM(    model=&quot;facebook/opt-125m&quot;,    trust_remote_code=True,    gpu_memory_utilization=0.5  # 只用 50% 显存，不影响其他人)print(&quot; 模型加载完成！\\n&quot;)# 准备输入prompts = [    &quot;Hello, my name is&quot;,    &quot;The capital of France is&quot;,    &quot;AI Infrastructure is&quot;]# 配置采样参数sampling_params = SamplingParams(    temperature=0.8,    top_p=0.95,    max_tokens=50)# 执行推理print(&quot;🚀 开始推理...\\n&quot;)outputs = llm.generate(prompts, sampling_params)# 查看结果print(&quot;=&quot; * 80)print(&quot;📊 推理结果&quot;)print(&quot;=&quot; * 80)for output in outputs:    print(f&quot;\\n提示词: &#123;output.prompt&#125;&quot;)    print(f&quot;生成结果: &#123;output.outputs[0].text&#125;&quot;)    print(&quot;-&quot; * 80)print(&quot;\\n 成功运行第一个 vLLM 程序！&quot;)# 性能测试print(&quot;\\n⏱️  性能测试开始...&quot;)test_prompts = [&quot;Explain AI in simple terms&quot;] * 10start = time.time()outputs = llm.generate(test_prompts, sampling_params)elapsed = time.time() - starttotal_tokens = sum(len(o.outputs[0].token_ids) for o in outputs)throughput = total_tokens / elapsedprint(&quot;\\n&quot; + &quot;=&quot; * 80)print(&quot;📈 服务器性能测试结果&quot;)print(&quot;=&quot; * 80)print(f&quot;模型:        OPT-125M&quot;)print(f&quot;GPU:         RTX 4090 (单卡)&quot;)print(f&quot;总耗时:      &#123;elapsed:.2f&#125; 秒&quot;)print(f&quot;总 Token 数: &#123;total_tokens&#125;&quot;)print(f&quot;吞吐量:      &#123;throughput:.2f&#125; tokens/秒&quot;)print(&quot;=&quot; * 80)\n运行测试\n# 指定使用 GPU 0（避免占用他人 GPU）CUDA_VISIBLE_DEVICES=0 python ~/test_vllm.py\n我的运行结果\n\n\n💡 性能对比：\n\nKaggle P100: ~1539 tokens/秒\n我的 RTX 4090: ~5818 tokens/秒\n提升约 278%！ 🚀\n\n\n\n踩过的坑与解决方案\n问题 1: VSCode Remote SSH 每次要输密码\n现象: VSCode 连接服务器时总是弹窗要求输入密码\n解决方案: 配置 SSH 公钥免密登录（见&quot;第一阶段 Step 3&quot;）\n关键步骤：\n# Windows 本地$pub = Get-Content C:\\Users\\pc\\.ssh\\id_rsa.pubssh Smarter@服务器ip &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;$pub&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;\n并在 SSH config 中添加：\nIdentitiesOnly yesPreferredAuthentications publickey\n问题 2: GNOME Remote Desktop 无法连接\n现象: Windows 端 mstsc 连接 3389 端口无响应\n原因:\n\n没有生成 TLS 证书\n没有设置 RDP 认证凭据\nXRDP 占用了 3389 端口\n\n解决方案:\n# 1. 停止并卸载 XRDP（如果有）sudo systemctl disable --now xrdp xrdp-sesmansudo apt purge -y xrdp xorgxrdp# 2. 生成 TLS 证书（见&quot;第三阶段 Step 1&quot;）# 3. 设置 RDP 凭据sudo grdctl --system rdp set-credentials rdpuser &#x27;强密码&#x27;sudo grdctl --system rdp enable# 4. 重启服务sudo systemctl restart gnome-remote-desktop.service# 5. 验证端口监听sudo ss -lnptu | grep 3389\n问题 3: 远程桌面提示&quot;已有会话运行&quot;\n现象: 尝试远程登录时提示&quot;该用户已有会话&quot;\n原因: 之前的远程会话没有正常退出，系统认为仍在运行\n解决方案:\n# 1. 查看当前会话loginctl list-sessionsloginctl user-status Smarter# 2. 终止该用户所有会话sudo loginctl terminate-user Smarter# 3. 重启远程桌面服务sudo systemctl restart gnome-remote-desktop.servicesudo systemctl restart gdm3# 4. 再尝试连接\n问题 4: vLLM 导入报错 CUDA 版本不匹配\n现象: import vllm 报错 “CUDA version mismatch”\n原因: PyTorch 的 CUDA 版本与系统 CUDA 不匹配\n解决方案:\n# 1. 卸载 PyTorchpip uninstall torch torchvision -y# 2. 重新安装匹配的版本（CUDA 12.2 使用 cu121）pip install torch==2.1.2 torchvision==0.16.2 --index-url https://download.pytorch.org/whl/cu121# 3. 验证python -c &quot;import torch; print(torch.version.cuda)&quot;# 应该输出: 12.1 (PyTorch 对 CUDA 12.x 通用)\n问题 5: Conda 命令找不到\n现象: conda: command not found\n解决方案:\n# 重新加载 bashrcsource ~/.bashrc# 如果还是不行，手动添加到 PATHexport PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;# 或者添加到 ~/.bashrcecho &#x27;export PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc\n问题 6: Clash 代理端口被占用\n现象: 想重启 Clash 但提示端口 7890 被占用\n解决方案:\n# 1. 查看占用端口的进程sudo lsof -iTCP:7890 -sTCP:LISTEN# 输出示例:# COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME# clash   3528110  Smarter    9u  IPv4 xxx      0t0  TCP localhost:7890 (LISTEN)# 2. 终止该进程sudo kill 3528110# 3. 重新启动 Clash\n\n开发工作流程\n配置完成后，我的日常开发流程是这样的：\n方案：VSCode Remote SSH\n┌─────────────────┐         SSH        ┌─────────────────┐│  Windows笔记本   │ ◄────────────────► │ Ubuntu服务器    ││                 │                    │                 ││  VSCode界面     │                    │  实际执行代码    ││  编辑器         │                    │  双GPU计算      ││  浏览器         │                    │  永久存储       │└─────────────────┘                    └─────────────────┘       本地                                   云端\n日常步骤:\n\n\n打开 VSCode 连接服务器\nVSCode → F1 → Remote-SSH: Connect to Host → ai-server\n\n\n编辑代码（和本地一样）\n\n在服务器上直接编辑项目文件\nVSCode 体验和本地完全一样\n代码保存在服务器上，永久保存\n\n\n\n运行实验（服务器 GPU）\n# VSCode 集成终端conda activate ai-infra# 检查 GPU 状态nvidia-smi# 指定使用 GPU 0CUDA_VISIBLE_DEVICES=0 python train.py# GPU 计算，无时长限制 \n\n\n查看结果\n\n结果保存在服务器\n可以通过 VSCode 直接查看图片/日志\n或者下载到本地\n\n\n\n\nGPU 资源管理\n查看 GPU 使用情况\n# 实时监控watch -n 1 nvidia-smi# 或者安装 nvitop（更友好的界面）pip install nvitopnvitop\n指定 GPU 运行代码\n# 使用 GPU 0CUDA_VISIBLE_DEVICES=0 python train.py# 使用 GPU 1CUDA_VISIBLE_DEVICES=1 python train.py# 同时使用两张 GPUCUDA_VISIBLE_DEVICES=0,1 python train.py\nPython 代码中指定\nimport osos.environ[&#x27;CUDA_VISIBLE_DEVICES&#x27;] = &#x27;0&#x27;  # 只用第一张 GPU# 或者import torchdevice = torch.device(&#x27;cuda:0&#x27;)  # GPU 0# device = torch.device(&#x27;cuda:1&#x27;)  # GPU 1\n多人共享礼仪\n如果服务器是多人共享的：\n# 每次使用前检查 GPU 状态nvidia-smi# 看 Processes 列：# - GPU 0 空闲 → CUDA_VISIBLE_DEVICES=0# - GPU 1 空闲 → CUDA_VISIBLE_DEVICES=1# - 都在用 → 等待或协调\n\n长时间任务：使用 screen\n服务器的优势之一就是可以运行长时间任务，即使关闭本地电脑也不影响。\n安装 screen\nsudo apt install screen\n使用方法\n# 1. 创建 sessionscreen -S my_experiment# 2. 运行长时间任务conda activate ai-infrapython long_training.py# 3. 断开（任务继续运行）# 按 Ctrl+A，然后按 D# 4. 重新连接screen -r my_experiment# 5. 列出所有 sessionscreen -ls# 6. 终止 session（在 session 内部）exit\n优势：关闭 Windows 电脑，SSH 断开，任务照样运行！\n\n总结与收获\n完成的配置\n\n[x]  SSH 免密登录配置\n[x]  VSCode Remote SSH 环境\n[x]  GNOME Remote Desktop 远程桌面\n[x]  Conda 环境创建 (ai-infra)\n[x]  PyTorch 2.1.2 + CUDA 12.1 安装\n[x]  vLLM 0.2.7 安装与测试\n[x]  第一个 vLLM 程序运行成功\n[x]  性能测试：2276 tokens/秒\n\n性能对比\n\n\n\n平台\nGPU\n吞吐量 (tokens/s)\n成本\n\n\n\n\nKaggle\nP100\n~1539\n免费（30h/周）\n\n\n我的服务器\nRTX 4090\n~5818\n内网服务器（无限）\n\n\n性能提升\n-\n+278%\n-\n\n\n\n\n写在最后\n如果你也有机会使用服务器进行 AI 学习，我的建议是：\n\n优先配置好 SSH 免密登录 - 这是一切的基础\nVSCode Remote SSH 是最佳开发环境 - 比本地+rsync 方便太多\n认真做版本管理 - 不要随意升级，稳定的版本组合很重要\n做好 GPU 资源管理 - 尤其是共享服务器，要有礼貌\n使用 screen 管理长任务 - 充分利用服务器优势\n\n\n参考资料\n\nUbuntu GNOME Remote Desktop 官方文档\nVSCode Remote SSH 文档\nvLLM 官方文档\nPyTorch 官方安装指南\n\n\n如果这篇文章对你有帮助，欢迎点赞和分享！有任何问题也欢迎在评论区交流。 🎉\n","categories":["AI Infra"],"tags":["vLLM","AI Infrastructure","Ubuntu Server","RTX 4090","SSH","VSCode Remote"]},{"title":"AI Infra学习之旅-第一个vLLM程序","url":"/posts/b21cbc80/","content":"前言\n今天是我正式开始学习 AI Infrastructure 的第一天。作为一个对大模型推理充满好奇的初学者，我决定从实战开始——在免费的 Kaggle GPU 上运行 vLLM。这篇文章记录了我从零开始的完整过程，希望能帮助到和我一样的新手。\n核心目标: 今天就跑通第一个 vLLM 程序！\n\n为什么选择 Kaggle + vLLM？\n在开始之前，我做了一些调研：\n为什么选择 Kaggle？\n\n✅ 完全免费: 每周 30 小时 GPU 时间\n✅ 无需配置: 预装了常用的深度学习库\n✅ P100 GPU: 16GB 显存，足够运行中小型模型\n✅ 入门友好: 无需本地 GPU，浏览器即可使用\n\n为什么选择 vLLM？\n\n✅ 高性能: 比 HuggingFace Transformers 快数倍\n✅ 易用性: API 设计简洁，上手快\n✅ 工业级: 被多个公司用于生产环境\n✅ 学习价值: 涉及 PagedAttention 等前沿技术\n\n\n实战步骤\nStep 1: 注册 Kaggle 账号\n这一步非常简单：\n\n访问 Kaggle 官网\n使用 Google 账号快速注册\n重要: 验证手机号（这是使用 GPU 的必要条件，也可以使用Persona进行验证）\n\n\n\nStep 2: 创建 GPU Notebook\n创建 Notebook 的步骤：\n\n点击右上角 “Create” → “New Notebook”\n在右侧设置面板中：\n\nAccelerator → 选择 GPU P100 ✅\nInternet → 打开 On ✅\n\n\n等待环境启动（大约 30 秒）\n\n启动后，在第一个 cell 中运行以下命令验证 GPU：\n!nvidia-smi\n如果看到类似以下输出，说明 GPU 环境已就绪：\n+-----------------------------------------------------------------------------+| NVIDIA-SMI 525.xx.xx    Driver Version: 525.xx.xx    CUDA Version: 12.0     ||-------------------------------+----------------------+----------------------+| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. ||                               |                      |               MIG M. ||===============================+======================+======================||   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 || N/A   37C    P0    26W / 250W |      0MiB / 16280MiB |      0%      Default |\n\n\nStep 3: 安装 vLLM\n在新的 cell 中运行：\n# 安装 vLLM!pip install vllm -q# 验证安装import vllmprint(f&quot;✅ vLLM 安装成功！版本: &#123;vllm.__version__&#125;&quot;)\n安装可能需要 10-15 分钟，请耐心等待。安装完成后，你应该看到类似的输出：\n✅ vLLM 安装成功！版本: 0.x.x\n\nStep 4: 运行第一个推理程序\n这是今天的重头戏！我使用 facebook/opt-125m 这个小模型进行测试（只有 125M 参数，加载速度快）。\n完整代码如下：\nfrom vllm import LLM, SamplingParams# 【核心代码块1】加载模型llm = LLM(    model=&quot;facebook/opt-125m&quot;,  # 小模型,快速测试    trust_remote_code=True)# 【核心代码块2】准备输入prompts = [    &quot;Hello, my name is&quot;,    &quot;The capital of France is&quot;,    &quot;The meaning of life is&quot;]# 【核心代码块3】配置采样参数sampling_params = SamplingParams(    temperature=0.8,    top_p=0.95,    max_tokens=100)# 【核心代码块4】执行推理outputs = llm.generate(prompts, sampling_params)# 【核心代码块5】查看结果for output in outputs:    prompt = output.prompt    generated_text = output.outputs[0].text    print(f&quot;Prompt: &#123;prompt!r&#125;&quot;)    print(f&quot;Generated: &#123;generated_text!r&#125;&quot;)    print(&quot;-&quot; * 80)\n我的运行结果:\n\n\nPrompt: &#x27;Hello, my name is&#x27;Generated: &#x27; Joel, my dad is my friend and we are in a relationship...-------------------------------------------------Prompt: &#x27;The capital of France is&#x27;Generated: &#x27; at an impasse with the French government over its future as the euro zone’s biggest economy...-------------------------------------------------Prompt: &#x27;The meaning of life is&#x27;Generated: &quot; measured in the things that are accomplished in it.\\nMost of the time...\n\n\nStep 5: 性能测试\n为了了解 vLLM 的性能，我运行了一个简单的吞吐量测试：\nimport time# 准备 10 个相同请求test_prompts = [&quot;Explain AI in simple terms&quot;] * 10# 测试吞吐量print(&quot;⏱️  性能测试开始...&quot;)start = time.time()outputs = llm.generate(test_prompts, sampling_params)elapsed = time.time() - start# 计算指标total_tokens = sum(len(o.outputs[0].token_ids) for o in outputs)throughput = total_tokens / elapsed# 打印结果print(&quot;\\n&quot; + &quot;=&quot;*80)print(&quot;📈 我的第一次 vLLM 运行记录&quot;)print(&quot;=&quot;*80)print(f&quot;模型:        OPT-125M&quot;)print(f&quot;GPU:         Kaggle P100&quot;)print(f&quot;总耗时:      &#123;elapsed:.2f&#125; 秒&quot;)print(f&quot;总 Token 数: &#123;total_tokens&#125;&quot;)print(f&quot;吞吐量:      &#123;throughput:.2f&#125; tokens/秒&quot;)print(f&quot;日期:        &#123;time.strftime(&#x27;%Y-%m-%d&#x27;)&#125;&quot;)print(&quot;=&quot;*80)\n我的性能数据:\n\n\n\n\n\n指标\n数值\n\n\n\n\n模型\nOPT-125M\n\n\nGPU\nKaggle P100\n\n\n总耗时\n0.58 秒\n\n\n总 Token 数\n892\n\n\n吞吐量\n1539.24 tokens/秒\n\n\n\n\n\n踩过的坑与解决方案\n问题 1: Kaggle GPU 不可用\n现象: 设置中看不到 GPU 选项\n原因: 没有验证手机号\n解决: 在账号设置中完成手机验证\n问题 2: vLLM 安装超时\n现象: pip install vllm 一直卡住\n解决: 重启 Notebook，或者切换到 Google Colab\n问题 3: 模型下载速度慢\n现象: 加载模型时长时间无响应\n解决: 使用 HuggingFace 镜像站\nimport osos.environ[&#x27;HF_ENDPOINT&#x27;] = &#x27;https://hf-mirror.com&#x27;\n\n写在最后\n第一天的学习让我深刻体会到：AI Infrastructure 并不遥远，动手实践才是最好的老师。\n如果你也想开始学习 AI Infra，我的建议是：\n\n不要被理论吓倒 - 先跑起来，再慢慢理解\n选择免费资源 - Kaggle/Colab 足够初学者使用\n从小模型开始 - 125M 参数的模型几秒就能加载\n记录每一步 - 写博客是最好的复习方式\n\n记住: 慢一点没关系，停下来才可惜。💪\n\n参考资料\n\nvLLM 官方文档\nKaggle GPU 使用指南\n\n","categories":["AI Infra"],"tags":["vLLM","AI Infrastructure","Kaggle","GPU","大模型推理"]},{"title":"Effective Modern C++","url":"/posts/162e86b7/","content":"Effective Modern C++：42条改善C++11和C++14代码的建议\n\n深入理解 Effective Modern C++ 的核心思想，掌握现代C++最佳实践\n\n引言\n《Effective Modern C++》是 Scott Meyers 的经典著作，提供了 42 条改善 C++11 和 C++14 代码的具体建议。本文总结这些核心要点，帮助你写出更现代、更高效的 C++ 代码。\n核心主题：\n\n类型推导的陷阱与最佳实践\nauto 的正确使用\n移动语义和完美转发\n智能指针的选择\nLambda 表达式的优化\n并发编程\n\n\n第一章：类型推导\nItem 1: 理解模板类型推导\n模板类型推导有三种情况，取决于 ParamType 的形式。\n规则总结：\ngraph TD\n    A[模板推导] --&gt; B&#123;ParamType类型&#125;\n    B --&gt;|指针/引用| C[保留const]\n    B --&gt;|万能引用| D[左值/右值分别推导]\n    B --&gt;|按值传递| E[丢弃const和引用]\n关键要点：\n\n引用和指针不同时，const 被保留\n万能引用（T&amp;&amp;）区分左值和右值\n按值传递会忽略 const 和引用\n\nItem 2: 理解 auto 类型推导\nauto 与模板推导几乎完全相同，唯一例外是花括号初始化。\nauto x1 = 27;     // intauto x2(27);      // int  auto x3 = &#123;27&#125;;   // std::initializer_list&lt;int&gt; ❌陷阱！auto x4&#123;27&#125;;      // C++17: int, C++14: std::initializer_list&lt;int&gt;\n要记住的事：\n\nauto 推导通常与模板推导相同\nauto 假定花括号初始化代表 std::initializer_list\n函数返回值或 lambda 参数中的 auto 使用模板推导规则\n\nItem 3: 理解 decltype\ndecltype 总是返回表达式的确切类型，不会丢失 const 或引用。\nconst int i = 0;auto a = i;           // intdecltype(i) d = i;    // const int// C++14 的 decltype(auto)template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];  // 完美转发返回类型&#125;\n括号陷阱：\nint x = 10;decltype(x)   t1;   // intdecltype((x)) t2;   // int&amp; ⚠️ 危险！\nItem 4: 学会查看类型推导结果\n三种方法：\n\nIDE 编辑器：快速但可能不准\n编译器诊断：利用编译错误\n运行时输出：typeid 和 Boost.TypeIndex\n\n// 最可靠的方法：故意制造编译错误template&lt;typename T&gt;class TD;  // Type DisplayerTD&lt;decltype(x)&gt; xType;  // 编译器会显示类型\n\n第二章：auto\nItem 5: 优先使用 auto 而非显式类型声明\n优点：\n// 1. 避免未初始化变量int x;        // 未初始化auto x = 0;   // 必须初始化// 2. 避免类型不匹配std::unordered_map&lt;std::string, int&gt; m;// ❌ 错误：每次迭代都拷贝for (const std::pair&lt;std::string, int&gt;&amp; p : m) &#123; &#125;// ✓ 正确：零拷贝for (const auto&amp; p : m) &#123; &#125;// 3. 简化复杂类型std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;,                    const std::unique_ptr&lt;Widget&gt;&amp;)&gt; func;// 简化为auto func = [](const auto&amp; lhs, const auto&amp; rhs) &#123;    return *lhs &lt; *rhs;&#125;;\n性能优势：\n\n\n\n场景\n显式类型\nauto\n性能\n\n\n\n\nLambda\nstd::function\nauto\nauto 快 2-10倍\n\n\n容器遍历\n可能类型错误\n总是正确\n避免拷贝\n\n\n闭包\n无法表达\n完美捕获\n零开销\n\n\n\nItem 6: 当 auto 推导出非预期类型时使用显式类型初始化\n代理类陷阱：\nstd::vector&lt;bool&gt; features(const Widget&amp; w);auto highPriority = features(w)[5];  // ❌ 返回代理对象// highPriority 不是 bool，而是临时的代理类bool highPriority = features(w)[5];  // ✓ 正确\n解决方案：显式类型转换\nauto highPriority = static_cast&lt;bool&gt;(features(w)[5]);\n其他代理类场景：\n\nstd::vector&lt;bool&gt;::reference\nMatrix 表达式模板\n智能指针的代理\n\n\n第三章：转向现代C++\nItem 7: 创建对象时区分 () 和 {}\n三种初始化语法：\nint x(0);     // 圆括号int y = 0;    // 等号int z&#123;0&#125;;     // 花括号（统一初始化）\n花括号优点：\n// 1. 可用于任何初始化场景struct Widget &#123;    int x&#123;0&#125;;      // ✓ 成员初始化    int y = 0;     // ✓ 也可以    int z(0);      // ❌ 不行&#125;;// 2. 禁止隐式窄化转换double x = 3.14;int y&#123;x&#125;;      // ❌ 编译错误，禁止窄化int z(x);      // ⚠️ 允许，但丢失精度// 3. 免疫最令人烦恼的解析Widget w1(10);  // 调用构造函数Widget w2();    // ❌ 函数声明！Widget w3&#123;&#125;;    // ✓ 调用默认构造函数\n陷阱：std::initializer_list 构造函数\nstd::vector&lt;int&gt; v1(10, 20);  // 10个元素，每个值为20std::vector&lt;int&gt; v2&#123;10, 20&#125;;  // 2个元素：10和20\nItem 8: 优先使用 nullptr 而非 0 或 NULL\nvoid f(int);void f(bool);void f(void*);f(0);        // 调用 f(int)f(NULL);     // 可能不编译，或调用 f(int)f(nullptr);  // 调用 f(void*)// 模板中的优势template&lt;typename FuncType, typename PtrType&gt;decltype(auto) call(FuncType func, PtrType ptr) &#123;    return func(ptr);&#125;auto result1 = call(f, 0);        // 错误：推导为 intauto result2 = call(f, nullptr);  // ✓ 正确\nItem 9: 优先使用别名声明而非 typedef\n// typedeftypedef std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;    UPtrMapSS;// using (更清晰)using UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;// 模板别名 - typedef 无法做到template&lt;typename T&gt;using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;MyAllocList&lt;Widget&gt; lw;  // ✓ 简洁// typedef 需要template&lt;typename T&gt;struct MyAllocList &#123;    typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;&#125;;MyAllocList&lt;Widget&gt;::type lw;  // ❌ 繁琐\nItem 10-11: 优先使用限域 enum 和 deleted 函数\n限域枚举：\n// C++98 enum：不限域enum Color &#123; black, white, red &#125;;auto white = false;  // ❌ 错误！white 已被定义// C++11 enum class：限域enum class Color &#123; black, white, red &#125;;auto white = false;           // ✓ OKColor c = Color::white;       // 必须限定auto c = Color::white;        // 也可以\ndeleted 函数：\n// 防止隐式转换bool isLucky(int number);bool isLucky(char) = delete;   // 拒绝 charbool isLucky(bool) = delete;   // 拒绝 boolbool isLucky(double) = delete; // 拒绝 double// 禁止模板实例化template&lt;typename T&gt;void processPointer(T* ptr);template&lt;&gt;void processPointer&lt;void&gt;(void*) = delete;template&lt;&gt;void processPointer&lt;char&gt;(char*) = delete;  // const char* 也被拒绝\nItem 12-15: 特殊成员函数和优化\nnoexcept 的重要性：\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs) noexcept  // ✓ 推荐        : name(std::move(rhs.name)) &#123;&#125;        Widget&amp; operator=(Widget&amp;&amp; rhs) noexcept &#123;        name = std::move(rhs.name);        return *this;    &#125;    private:    std::string name;&#125;;// noexcept 让 std::vector 使用移动而非拷贝std::vector&lt;Widget&gt; vw;vw.push_back(Widget());  // 如果没有 noexcept，会拷贝而非移动\n\n第四章：智能指针\nItem 18: 使用 std::unique_ptr 管理独占所有权资源\nclass Investment &#123; &#125;;class Stock : public Investment &#123; &#125;;// 工厂函数auto makeInvestment() &#123;    return std::make_unique&lt;Stock&gt;();  // C++14&#125;// 自定义删除器auto delInvmt = [](Investment* pInvestment) &#123;    makeLogEntry(pInvestment);    delete pInvestment;&#125;;template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;makeInvestment(Ts&amp;&amp;... params) &#123;    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;        pInv(nullptr, delInvmt);        if (/* 创建 Stock */)        pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...));        return pInv;&#125;\n特点：\n\n零开销（与裸指针相同大小）\n独占所有权\n可转换为 shared_ptr\n\nItem 19: 使用 std::shared_ptr 管理共享所有权资源\nauto loggingDel = [](Widget *pw) &#123;    makeLogEntry(pw);    delete pw;&#125;;std::unique_ptr&lt;Widget, decltype(loggingDel)&gt;    upw(new Widget, loggingDel);  // 删除器是类型的一部分std::shared_ptr&lt;Widget&gt;    spw(new Widget, loggingDel);  // 删除器不是类型的一部分\n引用计数机制：\ngraph LR\n    A[shared_ptr 1] --&gt; C[控制块]\n    B[shared_ptr 2] --&gt; C\n    C --&gt; D[对象]\n    C --&gt; E[引用计数: 2]\n    C --&gt; F[弱引用计数]\n    C --&gt; G[删除器]\n性能开销：\n\n控制块动态分配\n引用计数原子操作\n虚函数调用（删除器）\n\nItem 20: 使用 std::weak_ptr 解决悬空指针\nauto spw = std::make_shared&lt;Widget&gt;();std::weak_ptr&lt;Widget&gt; wpw(spw);  // wpw 指向 Widgetspw = nullptr;  // Widget 被销毁，wpw 悬空if (spw == nullptr) &#123;  // ✓ 检测共享指针&#125;if (wpw.expired()) &#123;   // ✓ 检测弱指针&#125;// 原子检查并访问std::shared_ptr&lt;Widget&gt; spw2 = wpw.lock();  // 如果 wpw 过期则返回 nullauto spw3 = wpw.lock();\n应用场景：\n\n缓存：\n\nstd::shared_ptr&lt;const Widget&gt; fastLoadWidget(WidgetID id) &#123;    static std::unordered_map&lt;WidgetID, std::weak_ptr&lt;const Widget&gt;&gt; cache;        auto objPtr = cache[id].lock();  // 尝试从缓存获取        if (!objPtr) &#123;                   // 不在缓存中        objPtr = loadWidget(id);        cache[id] = objPtr;    &#125;    return objPtr;&#125;\n\n观察者模式：\n\nclass Subject &#123;    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers;public:    void notify() &#123;        for (auto&amp; wo : observers) &#123;            if (auto o = wo.lock()) &#123;  // 检查观察者是否存活                o-&gt;update();            &#125;        &#125;    &#125;&#125;;\nItem 21: 优先使用 std::make_unique 和 std::make_shared\n// ❌ 不推荐std::shared_ptr&lt;Widget&gt; spw(new Widget);// ✓ 推荐auto spw = std::make_shared&lt;Widget&gt;();// 优点1: 异常安全processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority());// ⚠️ 可能泄漏：new Widget 可能在 computePriority() 抛异常后完成processWidget(std::make_shared&lt;Widget&gt;(), computePriority());// ✓ 安全// 优点2: 性能更好auto spw1 = std::shared_ptr&lt;Widget&gt;(new Widget);  // 2次分配auto spw2 = std::make_shared&lt;Widget&gt;();            // 1次分配\n不能使用 make 函数的情况：\n// 1. 自定义删除器auto deleter = [](Widget* pw) &#123; delete pw; &#125;;std::unique_ptr&lt;Widget decltype(deleter)&gt; upw(new Widget, deleter);// 2. 花括号初始化auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(10, 20);  // 10个20// 想要&#123;10, 20&#125;只能：auto initList = &#123;10, 20&#125;;auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(initList);\n\n第五章：右值引用、移动语义和完美转发\nItem 23: 理解 std::move 和 std::forward\nstd::move 无条件转换为右值：\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs)        : name(std::move(rhs.name)),          p(std::move(rhs.p)) &#123;&#125;    private:    std::string name;    std::shared_ptr&lt;int&gt; p;&#125;;// move 的实现（简化）template&lt;typename T&gt;decltype(auto) move(T&amp;&amp; param) &#123;    using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param);&#125;\nstd::forward 条件转换：\nvoid process(const Widget&amp; lvalArg);   // 处理左值void process(Widget&amp;&amp; rvalArg);        // 处理右值template&lt;typename T&gt;void logAndProcess(T&amp;&amp; param) &#123;    auto now = std::chrono::system_clock::now();    makeLogEntry(&quot;Calling &#x27;process&#x27;&quot;, now);    process(std::forward&lt;T&gt;(param));  // 完美转发&#125;\n对比：\n\n\n\n特性\nstd::move\nstd::forward\n\n\n\n\n用途\n无条件转右值\n条件转发\n\n\n参数\n通用引用\n通用引用\n\n\n使用场景\n移动构造/赋值\n完美转发\n\n\n\nItem 24: 区分万能引用和右值引用\n万能引用的判断标准：\ntemplate&lt;typename T&gt;void f(T&amp;&amp; param);  // 万能引用（有类型推导）auto&amp;&amp; var2 = var1;  // 万能引用void f(Widget&amp;&amp; param);  // 右值引用（无类型推导）template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param);  // 右值引用（不是 T&amp;&amp;）\nItem 25: 对右值引用使用 std::move，对万能引用使用 std::forward\nclass Widget &#123;public:    Widget(Widget&amp;&amp; rhs)        : name(std::move(rhs.name)) &#123;&#125;  // rhs 是右值引用    template&lt;typename T&gt;    void setName(T&amp;&amp; newName) &#123;        name = std::forward&lt;T&gt;(newName);  // newName 是万能引用    &#125;    private:    std::string name;&#125;;\n错误示例：\n// ❌ 不要对右值引用使用 forwardWidget(Widget&amp;&amp; rhs)    : name(std::forward&lt;Widget&gt;(rhs).name) &#123;&#125;  // 错误// ❌ 不要对万能引用使用 movetemplate&lt;typename T&gt;void setName(T&amp;&amp; newName) &#123;    name = std::move(newName);  // 可能移动左值！&#125;\nItem 26: 避免重载万能引用\n// ❌ 问题代码std::multiset&lt;std::string&gt; names;template&lt;typename T&gt;void logAndAdd(T&amp;&amp; name) &#123;    auto now = std::chrono::system_clock::now();    log(now, &quot;logAndAdd&quot;);    names.emplace(std::forward&lt;T&gt;(name));&#125;logAndAdd(std::string(&quot;Persephone&quot;));  // ✓logAndAdd(&quot;Patty Dog&quot;);                 // ✓std::string petName(&quot;Darla&quot;);logAndAdd(petName);  // ✓ 拷贝左值short nameIdx = 22;logAndAdd(nameIdx);  // ❌ 问题：T 推导为 short&amp;，不会转换为 string\nItem 27-30: 熟悉完美转发失败的情况\n完美转发失败的情况：\n\n花括号初始化：\n\nvoid f(const std::vector&lt;int&gt;&amp; v);f(&#123;1, 2, 3&#125;);  // ✓ OKtemplate&lt;typename T&gt;void fwd(T&amp;&amp; param) &#123;    f(std::forward&lt;T&gt;(param));&#125;fwd(&#123;1, 2, 3&#125;);  // ❌ 错误：无法推导// 解决方案auto il = &#123;1, 2, 3&#125;;fwd(il);  // ✓\n\n0 或 NULL 作为空指针：\n\nfwd(NULL);  // ❌ 推导为整数fwd(0);     // ❌ 推导为整数fwd(nullptr);  // ✓\n\n仅声明的 static const 成员变量：\n\nclass Widget &#123;public:    static const std::size_t MinVals = 28;  // 声明&#125;;std::vector&lt;int&gt; widgetData;widgetData.reserve(Widget::MinVals);  // ✓fwd(Widget::MinVals);  // ❌ 链接错误\n\n重载函数名和模板名\n位域\n\n\n第六章：Lambda表达式\nItem 31: 避免默认捕获模式\n按值捕获的问题：\nusing FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters;void addDivisorFilter() &#123;    auto calc1 = computeSomeValue1();    auto calc2 = computeSomeValue2();    auto divisor = computeDivisor(calc1, calc2);        filters.emplace_back(        [=](int value) &#123; return value % divisor == 0; &#125;  // ❌ 悬空引用    );&#125;\n指针捕获的问题：\nclass Widget &#123;public:    void addFilter() const &#123;        filters.emplace_back(            [=](int value) &#123; return value % divisor == 0; &#125;            // ❌ 捕获的是 this 指针，不是 divisor        );    &#125;private:    int divisor;&#125;;\n正确做法：\nclass Widget &#123;public:    void addFilter() const &#123;        auto divisorCopy = divisor;  // 拷贝数据成员                filters.emplace_back(            [divisorCopy](int value) &#123;  // ✓ 显式捕获副本                return value % divisorCopy == 0;            &#125;        );    &#125;&#125;;\nItem 32: 使用初始化捕获将对象移入闭包\n// C++14: 初始化捕获auto pw = std::make_unique&lt;Widget&gt;();auto func = [pw = std::move(pw)] &#123;  // 移动进闭包    return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();&#125;;// C++11: 使用 bind 模拟auto func = std::bind(    [](const std::unique_ptr&lt;Widget&gt;&amp; pw) &#123;        return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();    &#125;,    std::make_unique&lt;Widget&gt;());\nItem 33-34: Lambda 与 std::function\n优先使用 auto 而非 std::function：\n// std::functionstd::function&lt;bool(int)&gt; func1 = [](int x) &#123; return x &gt; 0; &#125;;// autoauto func2 = [](int x) &#123; return x &gt; 0; &#125;;\n性能对比：\n\n\n\n特性\nstd::function\nauto\n\n\n\n\n内存\n固定大小，可能堆分配\n闭包大小\n\n\n内联\n几乎不可能\n容易内联\n\n\n性能\n慢\n快\n\n\n\n\n第七章：并发API\nItem 35: 优先使用基于任务而非基于线程的编程\n// 基于线程int doAsyncWork();std::thread t(doAsyncWork);  // ❌ 无法获取返回值// 基于任务auto fut = std::async(doAsyncWork);  // ✓ 可以获取返回值auto result = fut.get();\nstd::async 的优势：\n\n自动管理线程\n可以获取返回值\n可以传播异常\n避免过度订阅\n\nItem 36-40: 并发编程最佳实践\n使用 std::atomic 而非 volatile：\n// ❌ volatile 不提供原子性volatile int counter = 0;void increment() &#123;    ++counter;  // 不是原子的！&#125;// ✓ atomic 提供原子性std::atomic&lt;int&gt; counter(0);void increment() &#123;    ++counter;  // 原子操作&#125;\n避免在 std::atomic 上使用复制操作：\nstd::atomic&lt;int&gt; x(0);auto y = x;  // ❌ 错误：deletedauto y = x.load();  // ✓ 显式读取std::atomic&lt;int&gt; z(0);z = x; // ❌ 错误：deletedz.store(x.load());  // ✓ 显式存储\n\n第八章：微调\nItem 41: 对于可拷贝的形参，当移动成本低且总会被拷贝时，考虑按值传递\nclass Widget &#123;public:    // 方案1: 重载左值和右值    void setName(const std::string&amp; newName) &#123;        name = newName;    &#125;    void setName(std::string&amp;&amp; newName) &#123;        name = std::move(newName);    &#125;        // 方案2: 万能引用    template&lt;typename T&gt;    void setName(T&amp;&amp; newName) &#123;        name = std::forward&lt;T&gt;(newName);    &#125;        // 方案3: 按值传递（在某些情况下最优）    void setName(std::string newName) &#123;        name = std::move(newName);    &#125;    private:    std::string name;&#125;;\n性能对比：\n\n\n\n调用方式\n重载\n万能引用\n按值传递\n\n\n\n\n左值\n1次拷贝\n1次拷贝\n1次拷贝+1次移动\n\n\n右值\n1次移动\n1次移动\n1次移动+1次移动\n\n\n\nItem 42: 考虑使用置入而非插入\nstd::vector&lt;std::string&gt; vs;// 插入vs.push_back(&quot;xyzzy&quot;);  // 创建临时对象，然后移动// 置入vs.emplace_back(&quot;xyzzy&quot;);  // 直接在容器中构造，避免临时对象// 性能对比vs.push_back(std::string(50, &#x27;x&#x27;));  // 1个临时对象vs.emplace_back(50, &#x27;x&#x27;);             // 无临时对象，直接构造\n何时使用置入：\n\n值被构造进容器，而非赋值\n传递的参数类型与容器元素类型不同\n容器不太可能拒绝新值（如 set）\n\n\n总结\n核心要点总结\ngraph TD\n    A[Effective Modern C++] --&gt; B[类型推导]\n    A --&gt; C[auto]\n    A --&gt; D[移动语义]\n    A --&gt; E[智能指针]\n    A --&gt; F[Lambda]\n    A --&gt; G[并发]\n    \n    B --&gt; B1[模板推导3种情况]\n    B --&gt; B2[decltype陷阱]\n    \n    C --&gt; C1[优先使用auto]\n    C --&gt; C2[注意代理类]\n    \n    D --&gt; D1[move无条件转右值]\n    D --&gt; D2[forward条件转发]\n    D --&gt; D3[完美转发失败情况]\n    \n    E --&gt; E1[unique_ptr独占]\n    E --&gt; E2[shared_ptr共享]\n    E --&gt; E3[weak_ptr观察]\n    \n    F --&gt; F1[避免默认捕获]\n    F --&gt; F2[初始化捕获]\n    F --&gt; F3[优先auto]\n    \n    G --&gt; G1[基于任务]\n    G --&gt; G2[atomic不是volatile]\n","categories":["知识分享"],"tags":["C++","Effective Modern C++","C++11","C++14","现代C++"]},{"title":"LeetCode热题100(25.09.29)","url":"/posts/8c812416/","content":"一：两数之和\n\n1. 暴力\n不写\n2. 哈希表\n哈希表通过用空间换时间，使用哈希函数将任意长度的键转换为一个固定范围的数组下标，时间复杂度为O(1)O(1)O(1)\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; hashMap;        for(int i = 0; i &lt; nums.size(); ++i)        &#123;            auto it = hashMap.find(target - nums[i]);       // 返回迭代器            if(it != hashMap.end())             // 和尾后迭代器比对            &#123;                return &#123;it-&gt;second, i&#125;;         // 找到就返回下标            &#125;            hashMap[nums[i]] = i;               // 没找到就把数据添加进hash表        &#125;        return &#123;&#125;;    &#125;&#125;;\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashMap = dict()        for i, num in enumerate(nums):          # 遍历            if target - nums[i] in hashMap:     # 是否存在，可把nums[i]改为num                return [hashMap[target - num], i]            hashMap[nums[i]] = i        return []        \nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;();         // 初始化一个哈希表        for( int i = 0; i &lt; nums.length; ++i)        &#123;            if(hashMap.containsKey(target - nums[i]))           // 这里的K大写            &#123;                return new int[]&#123;hashMap.get(target - nums[i]), i&#125;;            &#125;            hashMap.put(nums[i], i);        &#125;        return new int[0];              // 返回为空    &#125;&#125;\n\n二：移动零\n\n1. 双指针\n题目要求不能复制，同时保证原有序列的顺序不变，因此只能交换非零值和零值的位置。\n\n思路一：处理零值，将零和右边非零值进行交换\n思路二：处理非零值，将非零值和左边零值进行交换\n\n方式一需要不断寻找非零值，性能稍差，因此采用方式二\nclass Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int Left = 0, Right = 0;                // Left的左边均为非零值，其指向第一个零值。Right的右边为未处理的序列，当前指向用于判断零值和非零值        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            if (nums[i])            &#123;                swap(nums[Left], nums[Right]);              // 交换位置                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;;\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        Left = Right = 0        for num in nums:            if num:                nums[Left], nums[Right] = nums[Right], nums[Left]                Left += 1            Right += 1\nclass Solution &#123;    public void moveZeroes(int[] nums) &#123;        int Left = 0;        int Right = 0;        int temp;        for (int i = 0; i &lt; nums.length; ++i)        &#123;            if (nums[i] != 0)            &#123;                temp = nums[Left];                nums[Left] = nums[Right];                nums[Right] = temp;                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;\n\n三：相交链表\n1. Hash表\n将其中一个链表的数据放入哈希表，第二个链表依次判断是否包含即可\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode *&gt; hashTalble;        while (headA)        &#123;            hashTalble.insert(headA);            headA = headA-&gt;next;        &#125;        while (headB)        &#123;            if (hashTalble.count(headB))            &#123;                return headB;            &#125;            headB = headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        hashTable = set()        while headA:            hashTable.add(headA)            headA = headA.next              # 使用.运算符不是-&gt;，非指针                while headB:            if headB in hashTable:                return headB            headB = headB.next        return None             # 空为None        \npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (headA != null)               // 不能直接判断headA        &#123;            hashTable.add(headA);            headA = headA.next;             // 使用.        &#125;        while (headB != null)        &#123;            if (hashTable.contains(headB))            &#123;                return headB;            &#125;            headB = headB.next;        &#125;        return null;            // 使用null    &#125;&#125;\n\n2. 双指针\n使用两个指针指向两个链表的头结点，判断两个指针是否相等，走到末尾如果两者不相同则将指针赋值为另一个链表的头结点继续遍历，如果有相交结点，在不超过第二次遍历一定会在相交结点使两个指针相等\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *pA = headA;        ListNode *pB = headB;        if (!pA || !pB)        &#123;            return nullptr;        &#125;        while (pA != pB)        &#123;            if (pA == nullptr) pA = headB;          // 可用三元运算符替代            else pA = pA-&gt;next;            if (pB == nullptr) pB = headA;            else pB = pB-&gt;next;        &#125;        return pA;    &#125;&#125;;\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        pA = headA        pB = headB        while pA != pB:             # 也可以用is not            if not pA:              # 或if pA is None:                pA = headB            else:                pA = pA.next            if not pB:                pB = headA            else:                pB = pB.next        return pA\npublic class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if (headA == null || headB == null)            return null;        ListNode pA = headA, pB = headB;        while (pA != pB)        &#123;            pA = (pA == null) ? headB : pA.next;            pB = pB == null ? headA : pB.next;        &#125;        return pA;    &#125;&#125;\n\n四：反转链表\n\n\n1. 迭代反转\n根据头结点可获取到下一个结点，头结点的先前结点为空，可依次遍历将当前结点的指向进行反转，题目要求输出的结果也是反转的，因此需要返回最后一个结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre\n\n2. 递归反转\n依次传入下一个结点，并返回最后一个结点，与上一个解法的区别在于由后向前反转，此时不需要前继结点\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (!head || !head-&gt;next)            // 链表为空或只有单结点        &#123;            return head;        &#125;        ListNode *Last = reverseList(head-&gt;next);           // 最后一个结点在这里        head-&gt;next-&gt;next = head;        // 这里不能用Last，因为Last不动，而head一直向前        head-&gt;next = nullptr;\t\t\t// 必须设为空，否则第一个结点和第二个结点将互指        return Last;            // 一直返回最后一个结点    &#125;&#125;;\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null)        &#123;            return head;        &#125;        ListNode Last = reverseList(head.next);        head.next.next = head;        head.next = null;        return Last;    &#125;&#125;\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head or not head.next:            return head        Last = self.reverseList(head.next)\t\t\t// 这里要用self        head.next.next = head        head.next = None        return Last\n\n五：回文链表\n\n1. 数组\n将链表中的数据复制到数组中，然后将数组反转或遍历第一个和最后一个数据进行比较\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        while (head)        &#123;            vals.emplace_back(head-&gt;val);            head = head-&gt;next;        &#125;        for (int i = 0, j = static_cast&lt;int&gt;(vals.size() - 1); i &lt; j; ++i, --j)        &#123;            if (vals[i] != vals[j]) return false;        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();        while (head != null)        &#123;            vals.add(head.val);            head = head.next;        &#125;        for (int i = 0, j = vals.size() - 1; i &lt; j; ++i, --j)        &#123;            if (vals.get(i) != vals.get(j)) return false;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        vals = []        while head:            vals.append(head.val)            head = head.next        return vals == vals[::-1]\t\t\t# 可直接利用反转列表来比对\n\n2. 递归\n递归可以从后往前遍历，但是也需要从前往后的一个结点来进行对比\nclass Solution &#123;private:    ListNode *frontIteration = nullptr;\t\t\t// 从前往后public:    bool isPalindrome(ListNode* head) &#123;        frontIteration = head;        return recursion(frontIteration);    &#125;    bool recursion(ListNode* head)    &#123;        if (head)        &#123;            if (!recursion(head-&gt;next))\t\t// false继续返回false                &#123;                    return false;                &#125;            if (head-&gt;val != frontIteration-&gt;val) return false;\t\t// true则进行比对            frontIteration = frontIteration-&gt;next;\t\t\t// 每一层向后遍历        &#125;        return true;\t\t// 末尾返回true    &#125;&#125;;\nclass Solution &#123;    private ListNode frontIteration = null;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        frontIteration = head;        return recursion(head);    &#125;    public boolean recursion(ListNode head)    &#123;        if (head != null)        &#123;            if (!recursion(head.next))            &#123;                return false;            &#125;            if (head.val != frontIteration.val) return false;            frontIteration = frontIteration.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        self.frontIteration = head              # 成员变量的初始化，如果不在这里需要在__init__中        return self._recursion(head)    def _recursion(self, head: Optional[ListNode]) -&gt; bool:         # _表明内部使用，Optional表示可能的类型，-&gt; bool返回类型        if head:            if not self._recursion(head.next):                return False            if head.val != self.frontIteration.val:                return False            self.frontIteration = self.frontIteration.next        return True\n\n3.快慢指针\n该方法主要是寻找到链表的中间结点，然后将前半部分或者后半部分反转，对两部分进行比较，由于中间需要修改链表，并发处理下需要锁定其他线程或进程对链表的访问。快慢的意思则是通过两个指针，一个步长为2，另一个为1，当快指针到达尾节点时，慢指针到达中间结点，从而减少重复遍历的时间。反转可以使用之前的代码\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if (!head) return true;        ListNode *lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != nullptr)        &#123;            if (head-&gt;val != lastNode-&gt;val) return false;            head = head-&gt;next;            lastNode = lastNode-&gt;next;        &#125;        return true;    &#125;    // 寻找中间节点，    ListNode* interMediateNode(ListNode* head)    &#123;        ListNode *fastNode = head;        ListNode *slowNode = head;        while (fastNode != nullptr &amp;&amp; fastNode-&gt;next-&gt;next != nullptr)        &#123;            fastNode = fastNode-&gt;next-&gt;next;            slowNode = slowNode-&gt;next;        &#125;        return slowNode;    &#125;    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;\t\t\t\t// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;\nclass Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        if (head == null) return true;        ListNode lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != null)        &#123;            if (head.val != lastNode.val) return false;            head = head.next;            lastNode = lastNode.next;        &#125;        return true;    &#125;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;    public ListNode interMediateNode(ListNode head)    &#123;        ListNode fastNode = head;        ListNode slowNode = head;        while (fastNode != null &amp;&amp; fastNode.next.next != null)        &#123;            fastNode = fastNode.next.next;            slowNode = slowNode.next;        &#125;        return slowNode;    &#125;&#125;\nclass Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        if (not head):            return True        lastNode = self.reverseList(self.interMediateNode(head))        while (head != lastNode and head):            if head.val != lastNode.val:                return False            head = head.next            lastNode = lastNode.next        return True    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre        def interMediateNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fastNode = head        slowNode = head        while fastNode and fastNode.next.next:            fastNode = fastNode.next.next            slowNode = slowNode.next        return slowNode\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.09.30)","url":"/posts/5c81f568/","content":"一：环形链表\n\n1. 哈希表\n遍历节点并将节点存入哈希表，判断表中是否存在之前的节点即可\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return true;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return false;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return true;\t\t\t// 或if (!hashTable.add(head)) return true;            hashTable.add(head);            head = head.next;        &#125;        return false;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        hashTable = set()        while head:            if head in hashTable:                return True            hashTable.add(head)            head = head.next        return False\n\n2. 快慢指针\n通过两个不同的指针来表示行进速度，差值为1，从初始到最后相遇相当于快指针多走了一个环\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return false;        ListNode* fastNode = head-&gt;next;        // 相差一个起始位置，从而进入循环        ListNode* slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return false;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;        &#125;        return true;    &#125;&#125;;\npublic class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        ListNode fastNode = head.next;        // 相差一个起始位置，从而进入循环        ListNode slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == null || fastNode.next == null) return false;            slowNode = slowNode.next;            fastNode = fastNode.next.next;        &#125;        return true;    &#125;&#125;\nclass Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        if head is None or head.next is None:            return False        fastNode = head.next;        # 相差一个起始位置，从而进入循环        slowNode = head        while slowNode != fastNode:            if fastNode is None or fastNode.next is None:                return false            slowNode = slowNode.next            fastNode = fastNode.next.next        return True\n\n二：合并两个有序链表\n\n1. 迭代\n依次比较两个链表中的值，较小值放在较大值的前面\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 递归\n根据最小值按照相反方向逐一返回\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (!list1) return list2;        if (!list2) return list1;        if (list1-&gt;val &lt; list2-&gt;val)        &#123;            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);            return list1;        &#125; else        &#123;            list2-&gt;next = mergeTwoLists(list2-&gt;next, list1);            return list2;        &#125;    &#125;&#125;;\nclass Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        if (list1 == null) return list2;        if (list2 == null) return list1;        if (list1.val &lt; list2.val)        &#123;            list1.next = mergeTwoLists(list1.next, list2);            return list1;        &#125; else        &#123;            list2.next = mergeTwoLists(list2.next, list1);            return list2;        &#125;    &#125;&#125;\nclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if list1 == None:            return list2        if list2 == None:            return list1        if list1.val &lt; list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list2.next, list1)            return list2\n\n三：二叉树的中序遍历\n\n1. 递归\n先逐层访问左节点，然后保存当前值，再访问右节点\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        recursion(root);        return nodes;    &#125;    void recursion(TreeNode* root)    &#123;        if (!root) return;        recursion(root-&gt;left);        nodes.emplace_back(root-&gt;val);        recursion(root-&gt;right);    &#125;&#125;;\nclass Solution &#123;    private List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();\t\t// 需要new    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        recursion(root);        return nodes;    &#125;    public void recursion(TreeNode root)    &#123;        if (root == null) return;        recursion(root.left);        nodes.add(root.val);        recursion(root.right);    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        self.nodes = []        self._recursion(root)        return self.nodes    def _recursion(self, root: Optional[TreeNode]):        if not root:            return        self._recursion(root.left)        self.nodes.append(root.val)\t\t\t\t# 这里使用append        self._recursion(root.right)\n\n2. 迭代\n这里需要一个栈来维护树的层次\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            nodes.emplace_back(root-&gt;val);            treeStack.pop();                    // 拿到数据出栈            root = root-&gt;right;       &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            nodes.add(root.val);            root = root.right;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            nodes.append(root.val)            root = root.right        return nodes\n\n3. Morris 中序遍历\n查找第一个左节点，然后遍历该结点的右节点，将最后一个右节点指向根节点，依次循环，访问时向右遍历即可\nclass Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        TreeNode* cur = nullptr;        while (root)        &#123;            if (root-&gt;left)            &#123;                cur = root-&gt;left;                while (cur-&gt;right != nullptr &amp;&amp; cur-&gt;right != root )                &#123;                    cur = cur-&gt;right;                &#125;                if (cur-&gt;right == nullptr)                &#123;                    cur-&gt;right = root;                    root = root-&gt;left;                &#125; else                &#123;                    nodes.emplace_back(root-&gt;val);                    cur-&gt;right = nullptr;           // 要赋空，否则死循环                    root = root-&gt;right;                &#125;            &#125; else             &#123;                nodes.emplace_back(root-&gt;val);                root = root-&gt;right;            &#125;        &#125;        return nodes;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        TreeNode cur = null;        while (root != null)        &#123;            if (root.left != null)            &#123;                cur = root.left;                while (cur.right != null &amp;&amp; cur.right != root)     // cur.right != root必须有                &#123;                    cur = cur.right;                &#125;                if (cur.right == null)                &#123;                    cur.right = root;                    root = root.left;                &#125; else                &#123;                    nodes.add(root.val);                    cur.right = null;           // 要赋空，否则死循环                    root = root.right;                &#125;            &#125; else             &#123;                nodes.add(root.val);                root = root.right;            &#125;        &#125;        return nodes;    &#125;&#125;\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        cur = None        while root is not None:            if root.left is not None:                cur = root.left                while cur.right is not None and cur.right is not root:     # cur.right is not root必须有                    cur = cur.right                if cur.right == None:                    cur.right = root                    root = root.left                else:                    nodes.append(root.val)                    cur.right = None           # 要赋空，否则死循环                    root = root.right            else:                nodes.append(root.val)                root = root.right          return nodes\n\n四：二叉树的最大深度\n\n1. 深度优先搜索\n利用递归依次遍历左右节点，取其中的较大值\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; // 使用Math.max    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\t\t# 加self\n\n2. 广度优先搜索\n用队列维护\nclass Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(root);        int depth = 0;        while (!treeQueue.empty())        &#123;            int size = treeQueue.size();            while (size &gt; 00)            &#123;                TreeNode* root = treeQueue.front();                treeQueue.pop();                if (root-&gt;left) treeQueue.push(root-&gt;left);                if (root-&gt;right) treeQueue.push(root-&gt;right);                --size;            &#125;            ++depth;        &#125;        return depth    &#125;&#125;;\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;();        treeQueue.offer(root);      // 使用offer        int depth = 0;        while (treeQueue.isEmpty() == false)        &#123;            int size = treeQueue.size();            while (size &gt; 0)            &#123;                TreeNode newroot = treeQueue.poll();       // 使用poll                if (newroot.left != null) treeQueue.offer(newroot.left);                if (newroot.right != null) treeQueue.offer(newroot.right);                --size;            &#125;            ++depth;        &#125;        return depth;    &#125;&#125;\nclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        treeQueue = deque([root])         # 使用deque            depth = 0        while treeQueue:            size = len(treeQueue)            while size &gt; 0:                newroot = treeQueue.popleft()       # 使用popleft                if newroot.left:                    treeQueue.append(newroot.left)      # 使用append                if newroot.right:                    treeQueue.append(newroot.right)                size -= 1            depth += 1        return depth\n\n五：翻转二叉树\n\n1. 递归\n左右节点依次递归，找到叶子节点，然后交换左右位置\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        TreeNode* temp = root-&gt;left;        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = invertTree(temp);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        TreeNode temp = root.left;        root.left = invertTree(root.right);        root.right = invertTree(temp);        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        temp = root.left\t\t# 或平行赋值        root.left = self.invertTree(root.right)        root.right = self.invertTree(temp)        return root\n\n2. 迭代\n用队列维护\nclass Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        stack&lt;TreeNode*&gt; treeStack;        TreeNode* cur = nullptr;        TreeNode* temp = nullptr;        treeStack.push(root);        while (!treeStack.empty())        &#123;            cur = treeStack.top();            treeStack.pop();            if (cur-&gt;left != nullptr) treeStack.push(cur-&gt;left);            if (cur-&gt;right != nullptr) treeStack.push(cur-&gt;right);            temp = cur-&gt;left;            cur-&gt;left = cur-&gt;right;            cur-&gt;right = temp;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        Stack&lt;TreeNode&gt; treeStack = new Stack&lt;&gt;();        treeStack.add(root);        TreeNode cur = null;        TreeNode temp = null;        while (!treeStack.isEmpty())        &#123;            cur = treeStack.pop();            if (cur.left != null) treeStack.add(cur.left);            if (cur.right != null) treeStack.add(cur.right);            temp = cur.left;            cur.left = cur.right;            cur.right = temp;        &#125;        return root;    &#125;&#125;\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        treeStack = []        treeStack.append(root)        while treeStack:            cur = treeStack.pop()            if cur.left != None: treeStack.append(cur.left)            if cur.right != None: treeStack.append(cur.right)            cur.left, cur.right = cur.right, cur.left        return root\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.1)","url":"/posts/2bc0b0cc/","content":"一：对称二叉树\n1. 递归\n每次访问左右两个节点，不相同则为false\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return recursion(root-&gt;left, root-&gt;right);    &#125;    bool recursion(TreeNode* left, TreeNode* right)    &#123;        if (left == nullptr &amp;&amp; right == nullptr) return true;       // 都为空        if (left == nullptr || right == nullptr) return false;      // 其中一个为空        return left-&gt;val == right-&gt;val &amp;&amp; recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left);   // 左节点的左节点与右节点的右节点，左节点的右节点与右节点的左节点    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return recursion(root.left, root.right);    &#125;    public boolean recursion(TreeNode left, TreeNode right)    &#123;        if (left == null &amp;&amp; right == null) return true;              if (left == null || right == null) return false;             return left.val == right.val &amp;&amp; recursion(left.left, right.right) &amp;&amp; recursion(left.right, right.left);       &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._recursion(root.left, root.right)    def _recursion(self, left: Optional[TreeNode], right: Optional[TreeNode]) -&gt; bool:        if left == None and right == None: return True              if (left == None or right == None): return False             return left.val == right.val and self._recursion(left.left, right.right) and self._recursion(left.right, right.left)  \n\n2. 迭代\n使用队列管理左右节点\nclass Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return iteration(root, root);    &#125;    bool iteration(TreeNode* left, TreeNode* right)    &#123;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(left);        treeQueue.push(right);        while (!treeQueue.empty())        &#123;            left = treeQueue.front();       // 先进先出            treeQueue.pop();            right = treeQueue.front();            treeQueue.pop();            if (left == nullptr &amp;&amp; right == nullptr) continue;            if (left == nullptr || right == nullptr || left-&gt;val != right-&gt;val) return false;            treeQueue.push(left-&gt;left);            treeQueue.push(right-&gt;right);            treeQueue.push(left-&gt;right);            treeQueue.push(right-&gt;left);        &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return iteration(root, root);    &#125;    public boolean iteration(TreeNode left, TreeNode right)    &#123;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        treeQueue.offer(left);        treeQueue.offer(right);        while (!treeQueue.isEmpty())        &#123;            left = treeQueue.poll();       // 先进先出            right = treeQueue.poll();            if (left == null &amp;&amp; right == null) continue;            if (left == null || right == null || left.val != right.val) return false;            treeQueue.offer(left.left);            treeQueue.offer(right.right);            treeQueue.offer(left.right);            treeQueue.offer(right.left);        &#125;        return true;    &#125;&#125;\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._iteration(root, root)    def _iteration(self, left, right) -&gt; bool:        treeQueue = []        treeQueue.append(left)        treeQueue.append(right)        while (treeQueue):            left = treeQueue.pop()                  right = treeQueue.pop()            if (left == None and right == None): continue            if (left == None or right == None or left.val != right.val): return False            treeQueue.append(left.left)            treeQueue.append(right.right)            treeQueue.append(left.right)            treeQueue.append(right.left)        return True    \n\n二：二叉树的直径\n\n1. 深度优先\n长度为节点数减1，通过递归可获得左右子树的深度，左右子树的深度+1则为经过的节点数\nclass Solution &#123;public:    int diameterOfBinaryTree(TreeNode* root) &#123;        int nodeNum = 1;    // 初始节点为1，也可设为0表示长度        recursion(nodeNum, root);        return  nodeNum - 1;    // 返回长度    &#125;    int recursion(int&amp; nodeNum, TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftNum = recursion(nodeNum, node-&gt;left);        int rightNum = recursion(nodeNum, node-&gt;right);        nodeNum = max(nodeNum, leftNum + rightNum + 1);     // 拿到最大节点        return max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;;\nclass Solution &#123;    public int nodeNum = 0; // 初始长度为0    public int diameterOfBinaryTree(TreeNode root) &#123;        recursion(root);        return  nodeNum;    // 返回长度    &#125;    public int recursion(TreeNode node)    &#123;        if (node == null) return 0;        int leftNum = recursion(node.left);        int rightNum = recursion(node.right);        nodeNum = Math.max(nodeNum, leftNum + rightNum);     // 拿到最大长度        return Math.max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;\nclass Solution:    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:        self.nodeNum = 0        self._recursion(root)        return  self.nodeNum        def _recursion(self, node) -&gt; int:        if (node == None): return 0        leftNum = self._recursion(node.left)        rightNum = self._recursion(node.right)        self.nodeNum = max(self.nodeNum, leftNum + rightNum)             return max(leftNum, rightNum) + 1      \n\n三：将有序数组转换为二叉搜索树\n\n1. 左边中序遍历\n给定升序数组，对于二叉搜索树则是中序遍历，可将数组的中间数据或偏左作为根节点，左右两段分别为左右子树\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);\t\t// 使用length    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n2. 中间中序遍历\n这里是用中间位置或偏右作为中间结点\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + 1) / 2;       // 这里加1        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right + 1) / 2;              TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + 1) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n3. 右边中序遍历\nclass Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + rand() % 2) / 2;       // 随机，rand返回一个伪随机的整数        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        Random rand = new Random();         // 随机对象        int mid = (left + right + rand.nextInt(2)) / 2;       // 返回这个范围(2)内的随机整数        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + randint(0, 1)) // 2       # 随机整数的范围，包括起点和终点        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root\n\n四：搜索插入位置\n\n1. 二分\n根据二分查找的思想，依次比较中间点\nclass Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2; // 避免溢出的写法，也可使用java的方法            if (nums[mid] == target) &#123;                return mid;             &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;             &#125; else &#123;                right = mid - 1;             &#125;        &#125;        // 循环结束后，left 指针就是目标应该插入的位置        return left;    &#125;&#125;;\nclass Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target &lt;= nums[mid])            &#123;                cur = mid;                right = mid - 1;            &#125; else            &#123;                left = mid + 1;            &#125;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1         cur = right + 1        while (left &lt;= right):            mid = ((right - left) // 2) + left                  if (target &lt;= nums[mid]):                cur = mid                right = mid - 1            else:                left = mid + 1        return cur\n\n五：有效的括号\n\n1. 栈\n先把左括号放入栈中，遇到右括号则弹出栈顶，判断是否相同\nclass Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 != 0) return false;        unordered_map&lt;char, char&gt; unMap = &#123;            &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,            &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;,             &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;&#125;;        // 遇到右括号寻找左括号        stack&lt;char&gt; chStk;        for (auto ch : s)        &#123;            if (unMap.count(ch))            &#123;                if (chStk.empty()) return false;                char top = chStk.top();                chStk.pop();                if (unMap[ch] != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.empty();    &#125;&#125;;\nclass Solution &#123;    public boolean isValid(String s) &#123;        if (s.length() % 2 != 0) return false;        Map&lt;Character, Character&gt; unMap = new HashMap&lt;&gt;();          // 使用Character而非char        unMap.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);        unMap.put(&#x27;]&#x27;, &#x27;[&#x27;);        unMap.put(&#x27;)&#x27;, &#x27;(&#x27;);        Deque&lt;Character&gt; chStk = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; s.length(); ++i)        &#123;            char ch = s.charAt(i);            if (unMap.containsKey(ch))            &#123;                if (chStk.isEmpty()) return false;                char top = chStk.peek();                chStk.pop();                if (unMap.get(ch) != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.isEmpty();    &#125;&#125;\nclass Solution:    def isValid(self, s: str) -&gt; bool:        if (len(s) % 2 != 0): return False        unMap = &#123;            &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,            &#x27;]&#x27;: &#x27;[&#x27;,            &#x27;)&#x27;: &#x27;(&#x27;,        &#125;              chStk =[]        for ch in s:            if (ch in unMap):                if (not chStk): return False                top = chStk[-1]     # 最后一个值                chStk.pop()         # 弹出                if (unMap[ch] != top): return False            else:                chStk.append(ch)        return not chStk\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.10)","url":"/posts/994990d2/","content":"一：实现Trie（前缀树）\n\n1. 字典树\n这是一种用边表示数据的图，节点主要包含两部分，一个是子节点指针，另一部分是用数组模拟的字符数据\nclass Trie &#123;public:    vector&lt;Trie*&gt; sub;    bool endFlag;    Trie() :sub(26), endFlag(false) &#123;&#125;        void insert(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr)        // 不存在子节点，创建新的                root-&gt;sub[ch - &#x27;a&#x27;] = new Trie();            root = root-&gt;sub[ch - &#x27;a&#x27;];       // 移动到子节点        &#125;        root-&gt;endFlag = true;       // 单词结尾标识    &#125;        bool search(string word) &#123;        Trie* root = this;        for (auto&amp; ch : word)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return root-&gt;endFlag;    &#125;        bool startsWith(string prefix) &#123;        Trie* root = this;        for (auto&amp; ch : prefix)         &#123;            if (root-&gt;sub[ch - &#x27;a&#x27;] == nullptr) return false;            root = root-&gt;sub[ch - &#x27;a&#x27;];        &#125;        return true;    &#125;&#125;;\n\n二：全排列\n\n1. 回溯\n其本质很像递归和深度优先搜索，类似于走迷宫，先选择一条路，直到达到目标或者发现无法走通进行回退，主要分为三部分：选择、探索、恢复选择\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        recursion(nums, 0, nums.size());        return result;    &#125;    void recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right)        &#123;            result.emplace_back(nums);            return;        &#125;        for (int i = left; i &lt; right; ++i)        &#123;            swap(nums[i], nums[left]);            recursion(nums, left + 1, right);            swap(nums[left], nums[i]);        &#125;    &#125;&#125;;\n\n三：子集\n\n1. 二进制迭代\n假如数组包含n个元素，子集的所有可能为2n2^n2n，因此可以使用一个数值来表示该二进制，然后求出对应的子集\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; (1 &lt;&lt; len); ++i)\t\t\t// 2^n        &#123;            vector&lt;int&gt; temp;            for (int j = 0; j &lt; len; ++j)            &#123;                if (i &amp; (1 &lt;&lt; j)) temp.emplace_back(nums[j]);\t\t\t// 判断第j位的值            &#125;            ans.emplace_back(temp);        &#125;        return ans;    &#125;&#125;;\n\n2. 递归枚举\n逐字符处理，需要考虑每个字符的两种状态\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        recursion(0, nums);        return ans;    &#125;    void recursion(int cur, vector&lt;int&gt;&amp; nums)    &#123;        if (cur == nums.size())        &#123;            ans.emplace_back(temp);            return;        &#125;        temp.emplace_back(nums[cur]);       // 添加字符，存在的情况        recursion(cur + 1, nums);       // 下一个        temp.pop_back();            // 该字符不存在的情况        recursion(cur + 1, nums);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.11)","url":"/posts/8052a193/","content":"一：电话号码的字母组合\n\n1. 回溯\n这道题的思路和子集很相似，不过需要使用哈希表处理映射关系\nclass Solution &#123;public:    vector&lt;string&gt; ans;    string sub;    unordered_map&lt;char, string&gt; map&#123;            &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;,            &#123;&#x27;3&#x27;, &quot;def&quot;&#125;,            &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;,            &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;,            &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,            &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;,            &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;,            &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;        &#125;;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if (digits.empty()) return ans;        recursion(digits, 0);        return ans;    &#125;    void recursion(string&amp; digits, int cur)    &#123;        if (cur == digits.size())        &#123;            ans.emplace_back(sub);            return;        &#125;        char ch = digits[cur];        auto&amp; subLetter = map.at(ch);        for (auto&amp; ch : subLetter)        &#123;            sub.push_back(ch);            recursion(digits, cur + 1);            sub.pop_back();        &#125;    &#125;&#125;;\n\n二：组合总和\n\n1. 搜索回溯\n这道题的思路也和子集很相似，区别在于子集只有选和不选，必须进入下一层，而当前题目可以包含重复值，可以一直选择一个元素\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; temp;        recursion(candidates, target - 0, ans, temp, 0);        return ans;    &#125;    void recursion(vector&lt;int&gt;&amp; candidates, int&amp;&amp; target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; temp, int cur)    &#123;        if (cur == candidates.size()) return;        if (target == 0)        &#123;            ans.emplace_back(temp);            return;        &#125;        recursion(candidates, target - 0, ans, temp, cur + 1);      // 跳过        if (target - candidates[cur] &gt;= 0)        &#123;            temp.emplace_back(candidates[cur]);     // 选择            recursion(candidates, target - candidates[cur], ans, temp, cur);      // 下一层            temp.pop_back();        &#125;    &#125;&#125;;\n\n三：括号生成\n\n1. 暴力\n使用暴力将所有组合生成并检测是否是有效字符串\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            if (isValid(cur)) ans.emplace_back(cur);            return;        &#125;        cur.push_back(&#x27;(&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();        cur.push_back(&#x27;)&#x27;);        gengerateAll(ans, cur, n);        cur.pop_back();    &#125;    bool isValid(string&amp; str)    &#123;        int index = 0;        for (auto&amp; ch : str)        &#123;            if (ch == &#x27;(&#x27;) ++index;     // 左括号加一，右括号减一            else --index;            if (index &lt; 0) return false;        // 说明前面的字符串右括号多于左括号，肯定不是有效字符串        &#125;        return index == 0;    &#125;&#125;;\n\n2. 回溯\n暴力充斥了很多无效的字符串直到最后才做判断，可以在递归过程中就对字符串进行检查\nclass Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; ans;        string cur;        gengerateAll(ans, cur, n * 2, 0, 0);       // 有double的字符        return ans;    &#125;    void gengerateAll(vector&lt;string&gt;&amp; ans, string&amp; cur, int n, int left, int right)    &#123;        if (cur.size() == n)        // 一个完整的字符串        &#123;            ans.emplace_back(cur);            return;        &#125;        if (left &lt; n / 2)        &#123;            cur.push_back(&#x27;(&#x27;);            gengerateAll(ans, cur, n, left + 1, right);            cur.pop_back();        &#125;        if (right &lt; left)        &#123;               cur.push_back(&#x27;)&#x27;);            gengerateAll(ans, cur, n, left, right + 1);            cur.pop_back();        &#125;    &#125;&#125;;\n\n3. 按括号序列的长度递归\n每个有效字符串必是’(‘开头，某个’)'结尾，其组成为“(A)B”，A的可能性为i对，则B为n-i-1对\nclass Solution &#123;public:    shared_ptr&lt;vector&lt;string&gt;&gt; cache[10] = &#123;nullptr&#125;;    vector&lt;string&gt; generateParenthesis(int n) &#123;        return *generate(n);    &#125;    shared_ptr&lt;vector&lt;string&gt;&gt; generate(int n) &#123;        if (cache[n] != nullptr)            return cache[n];        if (n == 0) &#123;            cache[0] = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;&#123;&quot;&quot;&#125;);        &#125; else &#123;            auto result = shared_ptr&lt;vector&lt;string&gt;&gt;(new vector&lt;string&gt;);            for (int i = 0; i != n; ++i) &#123;                auto lefts = generate(i);                auto rights = generate(n - i - 1);                for (const string&amp; left : *lefts)                    for (const string&amp; right : *rights)                        result -&gt; push_back(&quot;(&quot; + left + &quot;)&quot; + right);            &#125;            cache[n] = result;        &#125;        return cache[n];    &#125;&#125;;\n\n四：单词搜索\n\n1. 回溯\n使用dfs来逐个访问节点，已访问的需要标记，并在访问后恢复，因为后续还会访问\nclass Solution &#123;public:    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;        int row = board.size();        int col = board[0].size();        vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col));        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (recursion(board, visited, i, j, word, 0)) return true;        return false;    &#125;    bool recursion(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; word, int cur)    &#123;        if (board[i][j] != word[cur]) return false;        else if (cur == word.size() - 1) return true;\t\t// 应当减少size的调用        visited[i][j] = 1;\t\t // 原地标记更快，不需要额外内存        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\t\t// 这里可使用static提高运行速度        for (auto&amp; dir : directions)        &#123;            int newi = i + dir.first;            int newj = j + dir.second;            if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size())                if (!visited[newi][newj])                    if (recursion(board, visited, newi, newj, word, cur + 1)) return true;        &#125;        visited[i][j] = 0;        return false;    &#125;&#125;;\n\n五：分割回文串\n\n1. 回溯+动态规划\n本题的难点在于状态转移方程\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len, true));        for (int i = len - 1; i &gt;= 0; --i)            for (int j = i + 1; j &lt; len; ++j)                flag[i][j] = (s[i] == s[j]) &amp;&amp; flag[i + 1][j - 1];        // i需要减，j需要加，形成上三角矩阵，这是本题的关键        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (flag[i][j])            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;&#125;;\n\n2. 回溯+记忆化搜索\n这里不使用数组来表示子字符串的状态，而是在递归时不断更新\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; flag;    vector&lt;string&gt; cur;    int len;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        len = s.size();        flag.assign(len, vector&lt;int&gt;(len));        recursion(s, 0);        return result;    &#125;    void recursion(string&amp; s, int i)    &#123;        if (i == len)         &#123;            result.emplace_back(cur);            return;        &#125;        for (int j = i; j &lt; len; ++j)        &#123;            if (IsPalindrome(s, i, j) == 1)            &#123;                cur.emplace_back(s.substr(i, j + 1 - i));                recursion(s, j + 1);                cur.pop_back();            &#125;        &#125;    &#125;    int IsPalindrome(string&amp; s, int i, int j)      // 0 、1、-1    &#123;        if (flag[i][j]) return flag[i][j];        if (i &gt;= j) return flag[i][j] = 1;        return flag[i][j] = (s[i] == s[j] ? IsPalindrome(s, i + 1, j - 1) : -1);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.12)","url":"/posts/ab7ff250/","content":"一：搜索二维矩阵\n\n1. 两次查找\n第一次在每行的第一个元素查找，然后在该行中查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        auto row = upper_bound(matrix.begin(), matrix.end(), target, [](int target, vector&lt;int&gt;&amp; row)&#123;return target &lt; row[0];&#125;);  // 需要自定义比较函数，因为一个值无法与数组比较        if (row == matrix.begin()) return false;        --row;        return binary_search(row-&gt;begin(), row-&gt;end(), target);    &#125;&#125;;\n\n2. 一次查找\n将二位矩阵展开为一维，然后把索引转换为二维去处理\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int row = matrix.size();        int col = matrix[0].size();        int left = 0, right = row * col - 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;            int cur = matrix[mid / col][mid % col];     // 对列处理            if (cur &gt; target) right = mid - 1;            else if (cur &lt; target) left = mid + 1;            else return true;        &#125;        return false;    &#125;&#125;;\n\n二：在排序数组中查找元素的第一个和最后一个位置\n\n1. 二分查找\n先查找左边界，然后寻找右边界，最后验证\nclass Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = BinarySearch(nums, target, true);        int right = BinarySearch(nums, target, false) - 1;        if (left &gt;= 0 &amp;&amp; left &lt;= right &amp;&amp; right &lt; nums.size() &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)            return vector&lt;int&gt;&#123;left, right&#125;;        return vector&lt;int&gt;&#123;-1, -1&#125;;    &#125;    int BinarySearch(vector&lt;int&gt;&amp; nums, int target, int lowFlag)    &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        int ans = nums.size();        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &gt; target || (nums[mid] &gt;= target &amp;&amp; lowFlag))            &#123;                right = mid - 1;                ans = mid;            &#125;            else                left = mid + 1;        &#125;        return ans;    &#125;&#125;;\n\n三：搜索旋转排序数组\n\n1. 二分查找\n这题比普通的二分稍微复杂一些，主要在于取中间点后，中间点可能大于也可能小于起始元素，但有一边一定是有序的\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int len = nums.size();        if (len == 0) return false;        if (len == 1) return target == nums[0] ? 0 : -1;        int left = 0, right = len - 1;        int mid = 0;        while (left &lt;= right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] == target) return mid;            if (nums[0] &lt;= nums[mid])            &#123;                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid])                    right = mid - 1;                else                    left = mid + 1;            &#125; else            &#123;                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[len - 1])                    left = mid + 1;                else                       right = right -1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n四：寻找旋转排序数组中的最小值\n\n1. 二分查找\n这题和上题类似，主要利用划分后最小值可能存在的位置，左边或者右边\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left = 0;        int right = nums.size() - 1;        int mid = 0;        while (left &lt; right)        &#123;            mid = (right - left) / 2 + left;            if (nums[mid] &lt; nums[right])                right = mid;            else                left = mid + 1;        &#125;        return nums[left];    &#125;&#125;;\n\n五：最小栈\n\n1. 辅助栈\n栈的实现可以直接使用stack，但这里需要记录最小值，并且常数查找，因此使用辅助栈来记录每一个元素对应的最小值\nclass MinStack &#123;    stack&lt;int&gt; value;    stack&lt;int&gt; min;public:    MinStack() &#123;        min.push(INT_MAX);    &#125;        void push(int val) &#123;        value.push(val);        min.push(std::min(val, min.top()));    &#125;        void pop() &#123;        value.pop();        min.pop();    &#125;        int top() &#123;        return value.top();    &#125;        int getMin() &#123;        return min.top();    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.13)","url":"/posts/b264c311/","content":"一：字符串解码\n\n1. 栈操作\n将数字和左括号入栈，遇到右括号对数据进行处理\nclass Solution &#123;public:    string decodeString(string s) &#123;        vector&lt;string&gt; stk;        int cur = 0;        string digits;        while (cur &lt; s.size())        &#123;            char ch = s[cur];            if (isdigit(ch))            &#123;                digits = GetDigits(s, cur, digits);                stk.push_back(digits);            &#125; else if (isalpha(ch) || ch == &#x27;[&#x27;)                stk.push_back(string(1, s[cur++]));            else            &#123;                ++cur;      // ]直接略过                string sub;                string temp;                while (stk.back() != &quot;[&quot;)                &#123;                    sub = stk.back() + sub;                    stk.pop_back();                &#125;                //reverse(sub.begin(), sub.end());                stk.pop_back();     // 左括号略过                int count = stoi(stk.back());                stk.pop_back();                 while (count--) temp += sub;                stk.push_back(temp);            &#125;        &#125;        string result;        for (auto&amp; s : stk) result += s;        return result;    &#125;    string&amp; GetDigits(string&amp; s, int&amp; cur, string&amp; digits)    &#123;        digits.clear();        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return digits;    &#125;&#125;;\n\n2. 递归\n对数字仍做上述处理，左括号过滤，然后递归处理字符，右括号也过滤\nclass Solution &#123;public:    string s;    int cur = 0;    string decodeString(string s) &#123;        this-&gt;s = s;        return GetString();    &#125;    int GetDigits()    &#123;        string digits;        while (isdigit(s[cur])) digits.push_back(s[cur++]);        return stoi(digits);    &#125;    string GetString()    &#123;        if (cur == s.size() || s[cur] == &#x27;]&#x27;) return &quot;&quot;;        char ch = s[cur];        string sub;        if (isdigit(ch))        &#123;            int repeatTime = GetDigits();            ++cur;            string str = GetString();            ++cur;            while (repeatTime--) sub += str;        &#125; else if(isalpha(ch))        &#123;            sub = string(1, ch);            ++cur;        &#125;        return sub + GetString();    &#125;&#125;;\n\n二：每日温度\n\n1. 暴力\n该题通过使用一个温度数组来记录当前温度的索引，其中温度为下标，值为数组中的索引，通过向前遍历来记录温度的情况\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        vector&lt;int&gt; record(101, INT_MAX);        for (int i = len - 1; i &gt;= 0; --i)        &#123;            int index = INT_MAX;            for (int j = temperatures[i] + 1; j &lt;= 100; ++j)                index = min(index, record[j]);            if (index != INT_MAX)                result[i] = (index - i);            record[temperatures[i]] = i;        &#125;        return result;    &#125;&#125;;\n\n2. 单调栈\n使用一个栈来维护温度，使温度递减，如果温度大于栈顶，则把栈顶弹出，并更新天数，因为此时为栈顶索引遇到的第一个升温天气\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len = temperatures.size();        vector&lt;int&gt; result(len);        stack&lt;int&gt; stk;        int temp;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()])            &#123;                temp = stk.top();                stk.pop();                result[temp] = i - temp;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n三：数组中的第K个最大元素\n\n1. 基于快速排序的选择方法\n寻找第K大的元素意味着寻找第n - k小的元素，利用快速排序分治的思想不断递归，可以找到元素所在的位置\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        return QuickChoose(nums, len - k, 0, len - 1);    &#125;    int QuickChoose(vector&lt;int&gt;&amp; nums, int index, int left, int right)    &#123;        if (left == right) return nums[left];        int i = left - 1;        int j = right + 1;        int numFlag = nums[left];        while (i &lt; j)        &#123;            do ++i; while (nums[i] &lt; numFlag);            do --j; while (nums[j] &gt; numFlag);            if (i &lt; j) swap(nums[i], nums[j]);        &#125;        if ( index &lt;= j) return QuickChoose(nums, index, left, j);        else return QuickChoose(nums, index, j + 1, right);    &#125;&#125;;\n\n2. 基于堆排序的选择方法\n选择当前数组作为最大堆，然后将其从第一个非叶子节点重新构建，之后逐个删除顶端元素\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size(), size = len;        BuildHeap(nums, len);        for (int i = len - 1; i &gt; len - k; --i)        &#123;            swap(nums[0], nums[i]);            --size;            Heapify(nums, size, 0);        &#125;        return nums[0];    &#125;    void BuildHeap(vector&lt;int&gt;&amp; nums, int size)    &#123;        for (int i = size / 2 - 1; i &gt;= 0; --i)            Heapify(nums, size, i);    &#125;    void Heapify(vector&lt;int&gt;&amp; nums, int size, int cur)    &#123;        int leftNode = cur * 2 + 1;        int rightNode = cur * 2 + 2;        int largest = cur;        if (leftNode &lt; size &amp;&amp; nums[leftNode] &gt; nums[largest]) largest = leftNode;         if (rightNode &lt; size &amp;&amp; nums[rightNode] &gt; nums[largest]) largest = rightNode;         if (cur != largest)        &#123;            swap(nums[largest], nums[cur]);            Heapify(nums, size, largest);        &#125;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.14)","url":"/posts/fd2555d6/","content":"一：前K个高频元素\n\n1. 堆\n可以使用哈希表将元素出现的次数记录下来，然后对出现次数排序，复杂度为O(nlog⁡(n))O(n\\log(n))O(nlog(n))。但题目要求优于O(nlog⁡(n))O(n\\log(n))O(nlog(n))，需要使用其他方案。这里的时间主要花在了排序上，可以使用堆或快排来对元素进行不完全排序，从而降低时间复杂度。该方法使用最小堆将出现次数小的元素放在栈顶\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        auto commpare = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;return a.second &gt; b.second;&#125;;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(commpare)&gt; pq(commpare);        for (auto&amp; [num, count] : occour)        &#123;            if (pq.size() &lt; k) pq.emplace(num, count);            else if (pq.top().second &lt; count)             &#123;                pq.pop();                pq.emplace(num, count);            &#125;        &#125;        while (!pq.empty())        &#123;            result.emplace_back(pq.top().first);            pq.pop();        &#125;        return result;    &#125;&#125;;\n\n2. 基于快速排序\n其核心思想在于快排的一次循环过后能够将数据按照选定的某个值分为≥和≤两部分，通过比较左右长度便可判断前k最大值所在位置\nclass Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        result.reserve(k);        int len = nums.size();        unordered_map&lt;int, int&gt; occour;        occour.reserve(len);        for (auto&amp; num : nums) ++occour[num];        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; value : occour) values.emplace_back(value);        QuickChoose(values, k, 0, values.size() - 1, result);        return result;    &#125;    void QuickChoose(vector&lt;pair&lt;int, int&gt;&gt;&amp; values, int k, int left, int right, vector&lt;int&gt;&amp; result)    &#123;        if (left &gt; right) return;        if (left == right) &#123;                 // 基本情形            result.push_back(values[left].first);            return;        &#125;        int picked = rand() % (right - left + 1) + left;        swap(values[picked], values[left]);        int pivot = values[left].second;        int i = left - 1;        int j = right + 1;        while (i &lt; j)        &#123;            do ++i; while (values[i].second &gt; pivot);            do --j; while (values[j].second &lt; pivot);            if (i &lt; j) swap(values[i], values[j]);        &#125;        int leftCount = j - left + 1;          if (k &lt;= leftCount) QuickChoose(values, k, left, j, result);        else         &#123;            for (int i = left; i &lt;= j; ++i)                result.emplace_back(values[i].first);            QuickChoose(values, k - leftCount, j + 1, right, result);        &#125;    &#125;&#125;;\n\n二：跳跃游戏\n\n1. 贪心\n假设当前位于x，那么x+nums[x]范围内的元素都是可达的，因此我们只需要维护一个最大的可达范围即可，如果该范围能够覆盖终点，则意味着终点可达\nclass Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int maxSkip = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if ( i &lt;= maxSkip) maxSkip = max(maxSkip, i + nums[i]);            if (maxSkip &gt;= len - 1) return true;        &#125;        return false;    &#125;&#125;;\n\n三：跳跃游戏Ⅱ\n\n1. 反向查找出发位置\n我们从最后一个点出发，先找出最后一步到达终点的前面所有点，取最远位置，然后循环直到出发点即可。为什么可行？我们假设终点为n - 1，其最远距离为x，那么x~n - 1区间内的所有位置都是可达的，假设区间中存在一个点的第二步的上一个位置为y，那么y~该点的距离一定包含x，所以x的第二步一定大于等于y，所以求解出来的步数最优\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int cur = len;        int step = 0;        while (cur &gt; 0)        &#123;            for (int i = 0; i &lt;= cur; ++i)            &#123;                if (i + nums[i] &gt;= cur)                &#123;                    cur = i;                    ++step;                    break;                &#125;            &#125;        &#125;        return step;    &#125;&#125;;\n\n2. 正向查找可到达的最大位置\n这里假设第一步的距离为x，由题意知一定会到达终点，那么第二步应该选择0~x之间能够跳出最远的位置，理论和上一个方法相同，最远位置一定包含其中的点，步骤只会小于等于其他元素\nclass Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;        int step = 0, maxStep = 0, end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt;= maxStep)                maxStep = max(maxStep, i + nums[i]);            if (i == end)            &#123;                end = maxStep;                ++step;            &#125;        &#125;        return step;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.15)","url":"/posts/e43e6497/","content":"一：划分字母区间\n\n1. 贪心\n该题的思路为通过遍历字符串，得到每一个字符最后出现的位置，然后维护一个起始指针，再次遍历字符串更新结束位置，如果达到end则意味着这个子字符串可划分\nclass Solution &#123;public:    vector&lt;int&gt; partitionLabels(string s) &#123;        int array[26];        int len = s.size();        vector&lt;int&gt; result;        for (int i = 0; i &lt; len; ++i)            array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)] = i;        int start = 0, end = 0;        int size = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            size = max(size, array[static_cast&lt;int&gt;(s[i] - &#x27;a&#x27;)]);            end = size;            if (i == end)            &#123;                result.emplace_back(end - start + 1);                start = end + 1;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：颜色分类\n\n1. 单指针\n使用该方式需要两次遍历，一次用于交换0，一次用于交换1，交换其他数据也可以\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur]);                ++cur;            &#125;        &#125;    &#125;&#125;;\n\n2. 双指针\n使用双指针可以同时交换两个数据，比如同时交换0和1，但需要注意交换顺序和对后续交换的影响\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur1 = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 1)             &#123;                swap(nums[i], nums[cur1]);                ++cur1;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                if (cur0 &lt; cur1)                     swap(nums[i], nums[cur1]);                ++cur0;                ++cur1;            &#125;        &#125;    &#125;&#125;;\n\n3. 双指针\n这里我们使用两端用于交换，但是交换之后的数据可能仍然需要交换，因此需要额外处理，知道它不需要交换\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int cur0 = 0, cur2 = len - 1;        for (int i = 0; i &lt;= cur2; ++i)        &#123;            while (i &lt;= cur2 &amp;&amp; nums[i] == 2)            &#123;                swap(nums[i], nums[cur2]);                --cur2;            &#125;            if (nums[i] == 0)             &#123;                swap(nums[i], nums[cur0]);                ++cur0;            &#125;        &#125;    &#125;&#125;;\n\n4. 直接遍历\n该题最简单的方式是将数组遍历得到每个元素的数量然后修改原来的数组即可\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int red = 0, white = 0, blue = 0;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)        &#123;            if (nums[i] == 0) ++red;            if (nums[i] == 1) ++white;            if (nums[i] == 2) ++blue;        &#125;        for (int i = 0; i &lt; len; ++i)        &#123;            if (i &lt; red) nums[i] = 0;            if (i &gt;= red&amp;&amp; i &lt; red + white) nums[i] = 1;            if (i &gt;= red + white &amp;&amp; i &lt; red + white + blue) nums[i] = 2;        &#125;    &#125;&#125;;\n\n三：下一个排列\n\n1. 两遍扫描\n该题需要从后向前找到第一个升序的位置，然后将其与该位置之后的最后一个大于自己的数据进行交换，同时需要对该位置之后的数据重排为升序\n\nclass Solution &#123;public:    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int start = len - 2;        while (start &gt;= 0 &amp;&amp; nums[start] &gt;= nums[start + 1])            --start;        if (start &gt;= 0)        &#123;            int j = len - 1;            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[start])                --j;            swap(nums[start], nums[j]);        &#125;        reverse(nums.begin() + start + 1, nums.end());    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.16)","url":"/posts/cf133754/","content":"一：寻找重复数\n\n1. 二分查找\n最简单的方式应该直接对其排序，然后遍历一遍找出重复值，但是题目要求不能修改原数组且使用常量空间，因此不能应用。这里我们可以注意到值的范围，如果我们把该范围的中间值作为一个临界值，那么数组应该被分为大致相等的两部分，存在重复值的一部分会稍大\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int left = 1, right = len - 1;        int mid = 0;        int ans = -1;        while (left &lt;= right)        &#123;            int count = 0;            mid = ((right - left) &gt;&gt; 1) + left;            for (int i = 0; i &lt; len; ++i)                if (nums[i] &lt;= mid) ++count;            if (count &lt;= mid) left = mid + 1;            else             &#123;                ans = mid;                right = mid - 1;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2. 二进制\n该方法使用二进制位来记录数组中不同元素的二进制位并与值域的二进制位比较\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int ans = 0;        int bitCnt = 0;        int temp = len - 1;        while (temp &gt;&gt;= 1) ++bitCnt;        for (int i = 0; i &lt;= bitCnt; ++i)        &#123;            int x = 0, y = 0;            for (int j = 0; j &lt; len; ++j)            &#123;                if (nums[j] &amp; (1 &lt;&lt; i)) ++x;                if (j &gt; 0 &amp;&amp; (j &amp; (1 &lt;&lt; i))) ++y;            &#125;            if (x &gt; y) ans |= (1 &lt;&lt; i);        &#125;        return ans;    &#125;&#125;;\n\n3. 快慢指针\n数组的索引为0~n-1，值域为1~n-1，那么每个索引都会对应一个值域，至少存在一个值域被两个索引指向，此时构建从索引到值的环，环的入口就是重复节点\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int slow = 0, fast = 0;        do         &#123;            slow = nums[slow];            fast = nums[nums[fast]];        &#125; while (slow != fast);        slow = 0;        while (slow != fast)        &#123;            slow = nums[slow];            fast = nums[fast];        &#125;        return slow;    &#125;&#125;;\n\n二：打家劫舍\n\n1. 动态规划\n由题目可知，一间房子和两间房子的情况是确定的，也就是我们的边界条件，对于房间k，我们有偷和不偷两个选项，但要取其中的较大值\nclass Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        vector&lt;int&gt; sum(len, 0);        sum[0] = nums[0];        sum[1] = max(nums[0], nums[1]);        for (int i = 2; i &lt; len; ++i)        &#123;            sum[i] = max(sum[i - 1], nums[i] + sum[i - 2]);        &#125;        return sum.back();    &#125;&#125;;// 滚动数组优化空间class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len == 0) return 0;        if (len == 1) return nums[0];        int pre = nums[0], next = max(nums[1], nums[0]);        int temp = 0;        for (int i = 2; i &lt; len; ++i)        &#123;            temp = next;            next = max(next, nums[i] + pre);            pre = temp;        &#125;        return next;    &#125;&#125;;\n\n三：完全平方数\n\n1. 动态规划\n该题需要寻找一个索引使得n - j * j的平方和的数量最小\nclass Solution &#123;public:    int numSquares(int n) &#123;        vector&lt;int&gt; step(n + 1);\t\t// 索引0作为辅助        for (int i = 1; i &lt;= n; ++i)        &#123;            int minStep = INT_MAX;            for (int j = 1; j * j &lt;= i; ++j)            &#123;                minStep = min(minStep, step[i - j * j]);            &#125;            step[i] = minStep + 1;         &#125;        return step[n];    &#125;&#125;;\n\n2. 数学\n四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。\n同时四平方和定理包含了一个更强的结论：当且仅当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，nnn 可以被表示为至多三个正整数的平方和。\n因此，当 n=4k×(8m+7)n = 4^k \\times (8m+7)n=4k×(8m+7) 时，(n) 只能被表示为四个正整数的平方和。此时我们可以直接返回 4。\n当 n≠4k×(8m+7)n \\ne 4^k \\times (8m+7)n=4k×(8m+7) 时，我们需要判断到底多少个完全平方数能够表示 nnn。我们知道答案只会是 (1,2,3) 中的一个\nclass Solution &#123;public:    int numSquares(int n) &#123;        if (static_cast&lt;int&gt;(sqrt(n)) * static_cast&lt;int&gt;(sqrt(n)) == n) return 1;        if (IsFormat(n)) return 4;        for (int i = 1; i * i &lt;= n; ++i)        &#123;            int j = n - i * i;            if (static_cast&lt;int&gt;(sqrt(j)) * static_cast&lt;int&gt;(sqrt(j)) == j) return 2;        &#125;        return 3;    &#125;    bool IsFormat(int x)    &#123;        while (x % 4 == 0) x /= 4;        return x % 8 == 7;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.17)","url":"/posts/d6080615/","content":"一：零钱兑换\n\n1. 记忆化搜索\n本质上属于迭代，找出子目标数据的最小值，自顶向下\nclass Solution &#123;public:    vector&lt;int&gt; count;    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        count.resize(amount);        return recursion(coins, amount);    &#125;    int recursion(vector&lt;int&gt;&amp; coins, int amount)    &#123;        if (amount == 0) return 0;        if (amount &lt; 0) return -1;        if (count[amount - 1] != 0) return count[amount - 1];        int minNum = INT_MAX;        for (auto&amp; coin : coins)        &#123;            int temp = recursion(coins, amount - coin);            if (temp &gt;= 0 &amp;&amp; temp &lt; minNum)                minNum = temp + 1;        &#125;        count[amount - 1] = minNum == INT_MAX ? -1 : minNum;        return count[amount - 1];    &#125;&#125;;\n\n2. 动态规划\n使用动态规划的关键点在于找出状态转移方程，该题目可求出当前硬币对应的上一个目标值的最小硬币数量\nclass Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int max = amount + 1;      // 不能使用INT_MAX，见下        vector&lt;int&gt; count(amount + 1, max);     // 这里使用+1把0也算入        count[0] = 0;        for (int i = 1; i &lt;= amount; ++i)        &#123;            for (auto&amp; coin : coins)            &#123;                if (coin &lt;= i)                &#123;                    count[i] = min(count[i], count[i - coin] + 1);      // INT_MAX这里会超出范围                &#125;            &#125;        &#125;        return count[amount] = count[amount] == amount + 1 ? -1 : count[amount];    &#125;&#125;;\n\n二：单词拆分\n\n1. 动态规划\n假设当前位于x，对于0 ~ x的子串需要寻找一个位置 j，使0 ~ j位于给定数组中，然后再判断j + 1 ~ x是否位于数组中\nclass Solution &#123;public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        unordered_set&lt;string&gt; hashWord;        int len = s.size();        for (auto&amp; word : wordDict) hashWord.insert(word);        vector&lt;bool&gt; dp(len + 1);        dp[0] = true;        for (int i = 1; i &lt;= len; ++i)            for (int j = 0; j &lt; i; ++j)                if (dp[j] &amp;&amp; hashWord.find(s.substr(j, i - j)) != hashWord.end())                &#123;                    dp[i] = true;                    break;                &#125;        return dp[len];    &#125;&#125;;\n\n三：最长递增子序列\n\n1. 动态规划\n使用一个数组来记录以给定数组的每个元素结尾的子序列的长度，如果当前值大于某个最长子序列的最后一个值，则把它加入\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        vector&lt;int&gt; dp(len, 1);        for (int i = 0; i &lt; len; ++i)            for (int j = 0; j &lt; i; ++j)                if (nums[i] &gt; nums[j])                    dp[i] = max(dp[i], dp[j] + 1);        return *max_element(dp.begin(), dp.end());    &#125;&#125;;\n\n2. 贪心+二分查找\n使用一个数组来维护最长子序列的最后一个值，如果下个值大于最后一个值则加入，如果不大于则替换数组中首个大于该元素的值\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int size = 1;        vector&lt;int&gt; dp(len + 1, 0);        dp[size] = nums[0];        for (int i = 1; i &lt; len; ++i)        &#123;            if (nums[i] &gt; dp[size])                dp[++size] = nums[i];            else            &#123;                int left = 1, right = size;                int pos = 0;                while (left &lt;= right)                &#123;                    int mid = (left + right) &gt;&gt; 1;                    if (dp[mid] &lt; nums[i])                    &#123;                        pos = mid;                        left = mid + 1;                    &#125; else                        right = mid - 1;                &#125;                dp[pos + 1] = nums[i];            &#125;        &#125;        return size;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.18)","url":"/posts/51901ada/","content":"一：乘积最大子数组\n\n1. 动态规划\n该题的难点在于需要同时处理正值和负值，以x结尾的子串乘上下一个元素有可能继续增大，也有可能变得很小，但如果一个负数乘一个负数可能得出一个很大的结果，因此我们同时维护以x结尾的子串的最大值和最小值\nclass Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;long long&gt; maxM(nums.begin(), nums.end());        vector&lt;long long&gt; minM(nums.begin(), nums.end());        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxM[i] = max(maxM[i - 1] * nums[i], max(minM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM[i] = min(minM[i - 1] * nums[i], min(maxM[i - 1] * nums[i], static_cast&lt;long long&gt;(nums[i])));        &#125;        return *max_element(maxM.begin(), maxM.end());    &#125;&#125;;// 滚动数组空间优化class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        long long maxM = nums[0];        long long maxT = nums[0];        long long minM = nums[0];        long long minT = nums[0];        long long ans = nums[0];        for (int i = 1; i &lt; nums.size(); ++i)        &#123;            maxT = maxM, minT = minM;            maxM = max(maxT * nums[i], max(minT * nums[i], static_cast&lt;long long&gt;(nums[i])));            minM = min(minT * nums[i], min(maxT * nums[i], static_cast&lt;long long&gt;(nums[i])));            ans = max(maxM, ans);        &#125;        return static_cast&lt;int&gt;(ans);    &#125;&#125;;\n\n二：分割等和子集\n\n1. 动态规划\n该题使用二维数组来存储子序列能否目标值，除了前置条件，后一个的判断需要根据先前的结果来判断\nclass Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(target + 1, 0));        for (int i = 0; i &lt; len; ++i)            dp[i][0] = true;        dp[0][nums[0]] = true;        for (int i = 1; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = 1; j &lt;= target; ++j)                if (temp &lt;= j)                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - temp];                else                    dp[i][j] = dp[i - 1][j];        &#125;        return dp[len - 1][target];    &#125;&#125;;// 空间优化class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        if (len &lt; 2) return false;        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        int target = sum / 2;        int maxElement = *max_element(nums.begin(), nums.end());        if (maxElement &gt; target) return false;        vector&lt;int&gt; dp(target + 1, 0);        dp[0] = true;        for (int i = 0; i &lt; len; ++i)        &#123;            int temp = nums[i];            for (int j = target; j &gt;= temp; --j)                dp[j] = dp[j] | dp[j - temp];        &#125;        return dp[target];    &#125;&#125;;\n\n三：不同路径\n\n1. 动态规划\n使用二维数组来存储每个位置的步数，当前位置的步数等于上一行和左边位置的和\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        for (int i = 0; i &lt; m; ++i) dp[i][0] = 1;        for (int i = 0; i &lt; n; ++i) dp[0][i] = 1;        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        return dp[m - 1][n - 1];    &#125;&#125;;// 空间优化class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;int&gt; dp(n);        dp[0] = 1;        for (int i = 0; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[j] = dp[j] + dp[j - 1];        return dp[n - 1];    &#125;&#125;;\n\n2. 组合数学\n对于一个m∗nm*nm∗n的二维数组，本质上有m−1m-1m−1次向下移动和n−1n-1n−1次向右移动，因此属于排列组合\nclass Solution &#123;public:    int uniquePaths(int m, int n) &#123;        long long result = 1;        for (int x = n, y = 1; y &lt; m; ++x, ++y)            result = result * x / y;        return static_cast&lt;int&gt;(result);    &#125;&#125;;\n\n四：最小路径和\n\n1. 动态规划\n该题与上题类似，不过每个元素的值可能不相等，但当前点只能由上和左两个位置得到，选用其中一个最小值和自身值相加即可得到当前点的最小值\nclass Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m = grid.size();        int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i - 1][0] + grid[i][0];        for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i - 1] + grid[0][i];        for (int i = 1; i &lt; m; ++i)            for (int j = 1; j &lt; n; ++j)                dp[i][j] = min(dp[i - 1][j] , dp[i][j - 1]) + grid[i][j];        return dp[m - 1][n - 1];    &#125;&#125;;\n\n五：最长回文子串\n\n1. 动态规划\n假设每个字符都为一个回文，对于一个从x到y的字符串，其是否为回文依赖于x+1x+1x+1和y−1y-1y−1是否为字符串，同时需要处理长度为2和为3的情况如“aa”，“bab”\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int len = s.size();        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));        if (len &lt; 2) return s;        for (int i = 0; i &lt; len; ++i) dp[i][i] = true;        int maxLen = 1;        int begin = 0;        for (int l = 2; l &lt;= len; ++l)        &#123;            for (int i = 0; i &lt; len; ++i)            &#123;                int right = l + i - 1;                if (right &gt;= len) break;                if (s[i] != s[right]) dp[i][right] = false;                else                &#123;                    if (right - i &lt; 3) dp[i][right] = true;                    else                    &#123;                        dp[i][right] = dp[i + 1][right - 1];                    &#125;                 &#125;                if (dp[i][right] &amp;&amp; right - i + 1 &gt; maxLen)                &#123;                    maxLen = right - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;\n\n2. 中心扩展算法\n我们以每个字符或者每两个字符为中心然后左右不断扩展，同时用起始位置来维护最大的长度\nclass Solution &#123;public:    int len;    string longestPalindrome(string s) &#123;        len = s.size();        int begin = 0;        int end = 0;        for (int i = 0; i &lt; len; ++i)        &#123;            auto [left1, right1] = Expand(s, i, i);            auto [left2, right2] = Expand(s, i, i + 1);            if (right1 - left1 &gt; end - begin)            &#123;                begin = left1;                end = right1;            &#125;            if (right2 - left2 &gt; end - begin)            &#123;                begin = left2;                end = right2;            &#125;        &#125;        return s.substr(begin, end - begin + 1);    &#125;    pair&lt;int, int&gt; Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return &#123;left + 1, right - 1&#125;;    &#125;&#125;;\n\n3. Manacher算法\n这个题非常巧妙，利用了回文的对称性，从而大量降低了重复的计算\nclass Solution &#123;public:    string longestPalindrome(string s) &#123;        int begin = 0;        int end = -1;       // 取-1为了下面正确的判断，从而使单个字符能够满足条件        string temp = &quot;#&quot;;        for (auto&amp; ch : s)        &#123;            temp += ch;            temp += &#x27;#&#x27;;        &#125;        s = temp;        int len = s.size();        vector&lt;int&gt; arm;        int right = -1, cur = -1;        for (int i = 0; i &lt; len; ++i)        &#123;            int curArm;            if (right &gt;= i)            &#123;                int isysm = 2 * cur - i;                int minArm = min(arm[isysm], right - i);                curArm = Expand(s, i - minArm, i + minArm);             &#125; else            &#123;                curArm = Expand(s, i, i);            &#125;            arm.emplace_back(curArm);            if (i + curArm &gt; right)            &#123;                cur = i;                right = i + curArm;            &#125;            if (curArm * 2 + 1 &gt; end - begin)            &#123;                begin = i - curArm;                end = i + curArm;            &#125;        &#125;        string result;        for (int i = begin; i &lt;= end; ++i)            if (s[i] != &#x27;#&#x27;) result += s[i];        return result;    &#125;    int Expand(string&amp; s, int left, int right)    &#123;        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])        &#123;            --left;            ++right;        &#125;        return (right - left - 2)  &gt;&gt; 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.19)","url":"/posts/488b2b9b/","content":"一：最长公共子序列\n\n1. 动态规划\n使用一个二维数组来记录以x和y长度的两个字符串的最大子串\nclass Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        int m = text1.size();        int n = text2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 1; i &lt;= m; ++i)        &#123;            for (int j = 1; j &lt;= n; ++j)                if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;        return dp[m][n];    &#125;&#125;;\n\n二：编辑距离\n\n1. 动态规划\n一共有三种替换方式，对于增加和删除是相对于原数据加1，替换有可能不增加，需要对三种方式取最小值，这里主要使用距离来表示两个字符串的差异\nclass Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m = word1.size();        int n = word2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        for (int i = 0; i &lt;= m; ++i)            dp[i][0] = i;        for (int i = 0; i &lt;= n; ++i)            dp[0][i] = i;        for (int i = 1; i &lt;= m; ++i)            for (int j = 1; j &lt;= n; ++j)            &#123;                int add = dp[i - 1][j] + 1;                int del = dp[i][j - 1] + 1;                int tak = dp[i - 1][j -1];                if (word1[i - 1] != word2[j - 1]) ++tak;                dp[i][j] = min(add, min(del, tak));            &#125;        return dp[m][n];    &#125;&#125;;\n\n三：最长有效括号\n\n1. 动态规划\n使用一个数组来表示以右括号结尾的子串的长度，那么左括号必为0，此时右括号有两种情况\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        vector&lt;int&gt; dp(len, 0);        int result = 0;        for (int i = 1; i &lt; len; ++i)         &#123;            if (s[i] == &#x27;)&#x27;)                if (s[i - 1] == &#x27;(&#x27; &amp;&amp; i &gt;= 2)                    dp[i] = dp[i - 2] + 2;                else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;)                &#123;                    dp[i] = dp[i - 1] + 2;                    int pre = i - dp[i - 1] - 2;                    if (pre &gt;= 0) dp[i] += dp[pre];                &#125;                result = max(result, dp[i]);        &#125;        return result;    &#125;&#125;;\n\n2. 栈\n这个方法相对容易但也需要一些技巧，我们使用索引放入堆栈作为未匹配字符，遇到右括号表明存在匹配从而弹出栈顶数据，使用当前位置减去栈顶未匹配索引即为所求字符串的长度\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        stack&lt;int&gt; stk;        int result = 0;        stk.push(-1);        for (int i = 0; i &lt; len; ++i)            if (s[i] == &#x27;(&#x27;) stk.push(i);            else            &#123;                stk.pop();                if (stk.empty()) stk.push(i);        // 保证有数据作为未匹配字符                else result = max(result, i - stk.top());            &#125;        return result;    &#125;&#125;;\n\n3. 不需要额外的空间\n对于一个有效的字符串一定满足两个条件，一：左右括号数量相等，二：前缀子串的左括号数不小于右括号、后缀子串右括号不小于左括号\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        int result = 0;        int left = 0, right = 0;        for (int i = 0; i &lt; len; ++i)\t\t// 无法处理左括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (right &gt; left) left = right = 0;         // 不合法，重置        &#125;        left = right = 0;        for (int i = len - 1; i &gt;= 0; --i)\t\t\t// 无法处理右括号过多的情况        &#123;            if (s[i] == &#x27;(&#x27;) ++left;            else ++right;            if (left == right) result = max(result, 2 * left);            if (left &gt; right) left = right = 0;         // 不合法，重置        &#125;        return result;    &#125;&#125;;\n\n四：数据流的中位数\n\n1. 优先队列\n使用大顶堆和小顶堆来维护有序数组，同时保证大顶堆的长度不小于小顶堆\nclass MedianFinder &#123;public:    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; priLess;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; priGreater;    MedianFinder() &#123;&#125;        void addNum(int num) &#123;        if (priLess.empty() || num &lt;= priLess.top())        &#123;            priLess.push(num);            if (priLess.size() &gt; priGreater.size() + 1)            &#123;                priGreater.push(priLess.top());                priLess.pop();            &#125;        &#125; else        &#123;            priGreater.push(num);            if (priGreater.size() &gt; priLess.size())            &#123;                priLess.push(priGreater.top());                priGreater.pop();            &#125;        &#125;    &#125;    double findMedian() &#123;        if (priLess.size() &gt; priGreater.size()) return priLess.top();        return (static_cast&lt;long long&gt;(priLess.top()) + static_cast&lt;long long&gt;(priGreater.top())) / 2.0;\t// 这里提升精度，否则有可能报错    &#125;&#125;;\n\n2. 有序集合+双指针\n使用multiset来维护一个有序数组，使用两个指针维护中位数，需要对双指针进行较多判断\nclass MedianFinder &#123;public:    multiset&lt;int&gt; nums;    multiset&lt;int&gt;::iterator left, right;    MedianFinder() &#123;left = nums.end(); right = nums.end();&#125;    void addNum(int num) &#123;        int len = nums.size();        nums.insert(num);        if (len == 0) left = right = nums.begin();        else if (len &amp; 1)             if (num &lt; *left) --left;            else ++right;        else            if (num &gt;= *right) ++left;            else if (num &gt;= *left &amp;&amp; num &lt; *right)             &#123;                ++left;                --right;            &#125;            else                --right;    &#125;    double findMedian() &#123;        return (static_cast&lt;long long&gt;(*left) + static_cast&lt;long long&gt;(*right)) / 2.0;    &#125;&#125;;\n\n五：柱状图中最大的矩形\n\n1. 单调栈\n使用两个数组来存储当前元素左右两边高度比自己小的索引，该方法需要维护一个单调栈，剔除比自己大的元素，从而方便查找比自己小的值\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len), right(len);        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            left[i] = stk.empty() ? -1 : stk.top();            stk.push(i);        &#125;        stk = std::stack&lt;int&gt;();        for (int i = len - 1; i &gt;= 0; --i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])                stk.pop();            right[i] = stk.empty() ? len : stk.top();            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n2. 单调栈+常数优化\n上个方法使用了两个循环，考虑第一个循环是否发现栈顶值被弹出说明它此时已经找到了比它小的右边界，但此时需要对存储右边界的数组的初始值进行限制\nclass Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int len = heights.size();        stack&lt;int&gt; stk;        vector&lt;int&gt; left(len, -1), right(len, len);\t\t// 从前到后只能正确处理左边界，右边界需要限定        for (int i = 0; i &lt; len; ++i)        &#123;            while (stk.empty() != true &amp;&amp; heights[stk.top()] &gt;= heights[i])\t\t// 考虑递增的数组，此时无法找到元素的右边界            &#123;                right[stk.top()] = i;                stk.pop();            &#125;            left[i] = stk.empty() ? -1 : stk.top();\t\t// 只能处理左边界            stk.push(i);        &#125;        int result = 0;        for (int i = 0; i &lt; len; ++i)            result = max(result, (right[i] - left[i] - 1) * heights[i]);        return result;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.2)","url":"/posts/ede30f/","content":"一：买卖股票的最佳时机\n\n1. 暴力\n不写\n2. 一次遍历\n记录最低值和利润最高值\nclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int maxP = 0;           // 后面的最大利润        int minP = 1e9;         // 之前的最低值        for (auto price : prices)        &#123;            maxP = max(maxP, price - minP);            minP = min(minP, price);        &#125;        return maxP;    &#125;&#125;;\nclass Solution &#123;    public int maxProfit(int[] prices) &#123;        int maxP = 0;                   int minP = Integer.MAX_VALUE;                 for (int i =  0; i &lt; prices.length; ++i)        &#123;            int price = prices[i];            maxP = Math.max(maxP, price - minP);            minP = Math.min(minP, price);        &#125;        return maxP;    &#125;&#125;\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        maxP = 0                   minP = 1e9                 for price in prices:            maxP = max(maxP, price - minP)            minP = min(minP, price)        return maxP\n\n二：爬楼梯\n\n1. 动态规划\nf(x)=f(x−1)+f(x−2)f(x)=f(x−1)+f(x−2)\nf(x)=f(x−1)+f(x−2)\n爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和，f(0)=1f(0)=1f(0)=1，f(1)=1f(1)=1f(1)=1，对空间的优化使用滚动数组\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;\t\t// 赋值顺序不能反            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sPre, pre, cur = 0, 0, 1        # 赋值        for _ in range(n):      # 遍历，_不使用            sPre = pre            pre = cur            cur = sPre + pre        return cur\n\n2. 矩阵快速幂\n[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix} = \\begin{bmatrix} f(n)+f(n-1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix}\n[11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]\n[f(n+1)f(n)]=[1110]n[f(1)f(0)]\\begin{bmatrix} f(n+1) \\\\ f(n) \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n} \\begin{bmatrix} f(1) \\\\ f(0) \\end{bmatrix}\n[f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]\nM=[1110]M = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\nM=[11​10​]\n常规计算M的n次方时间复杂度同上，这里使用快速幂\n**快速幂是一种用于在 O(log⁡n)O(\\log n)O(logn) 时间内计算 ana^nan 的高效算法。它利用了指数的二进制表示来减少乘法运算的次数，通常用于解决指数非常大时可能导致超时的问题。\n基本思想\n传统方法计算 ana^nan 需要进行 n−1n-1n−1 次乘法（即 a×a×⋯×aa \\times a \\times \\dots \\times aa×a×⋯×a）。快速幂则利用以下数学性质：\n\n如果 nnn 是偶数，an=an/2×an/2a^n = a^{n/2} \\times a^{n/2}an=an/2×an/2。\n如果 nnn 是奇数，an=a(n−1)/2×a(n−1)/2×aa^n = a^{(n-1)/2} \\times a^{(n-1)/2} \\times aan=a(n−1)/2×a(n−1)/2×a。\n\n这个思想的核心是将指数 nnn 不断折半。通过将 nnn 转换为二进制形式，我们可以将 ana^nan 的计算分解为一系列乘法和平方操作。例如，要计算 a13a^{13}a13，因为 131313 的二进制是 110111011101，即 13=8+4+113 = 8 + 4 + 113=8+4+1，所以：\na13=a8+4+1=a8×a4×a1a^{13} = a^{8+4+1} = a^8 \\times a^4 \\times a^1a13=a8+4+1=a8×a4×a1\n我们只需要计算 a1,a2,a4,a8a^1, a^2, a^4, a^8a1,a2,a4,a8（通过不断平方得到），然后将这些项相乘即可。这比直接进行 12 次乘法要快得多。\n算法步骤\n\n初始化结果 res = 1。\n将底数 base 设为 aaa。\n当指数 n&gt;0n &gt; 0n&gt;0 时循环：\n\n如果 nnn 的二进制最后一位是 1（即 nnn 为奇数），将 res 乘以 base。\n将 base 自身相乘（base = base * base）。\n将 nnn 右移一位（n = n &gt;&gt; 1），相当于 n=n/2n = n / 2n=n/2。\n\n\n返回 res。\n\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;vector&lt;long long&gt;&gt; init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        vector&lt;vector&lt;long long&gt;&gt; result = matrixPow(init, n);        return result[0][0];    &#125;    vector&lt;vector&lt;long long&gt;&gt; multiplication(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b)      // 二阶矩阵乘法    &#123;         vector&lt;vector&lt;long long&gt;&gt; c(2, vector&lt;long long&gt;(2));        for (int i = 0; i &lt; a.size(); ++i)        &#123;            for (int j = 0; j &lt; b[0].size(); ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    vector&lt;vector&lt;long long&gt;&gt; matrixPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int n)    &#123;        vector&lt;vector&lt;long long&gt;&gt; unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        int[][] init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        // 使用int[][]或long        int[][] result = matrixPow(init, n);        return result[0][0];    &#125;    public int[][] multiplication(int[][] a, int[][] b)      // 二阶矩阵乘法    &#123;         int[][] c = new int[2][2];         // 基本数据类型        for (int i = 0; i &lt; a.length; ++i)        &#123;            for (int j = 0; j &lt; b[0].length; ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    public int[][] matrixPow(int[][] a, int n)    &#123;        int[][] unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        init = [[1, 1], [1, 0]]                result = self._matrixPow(init, n)        return result[0][0]    def multiplication(self, a, b):            c = [[1, 1], [1, 0]]              for i in range(2):            for j in range(2):                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]        return c    def _matrixPow(self, a, n):        unit = [[1, 0], [0, 1]]          while n &gt; 0:            if ((n &amp; 1) == 1): unit = self.multiplication(unit, a)            a = self.multiplication(a, a)            n &gt;&gt;= 1        return unit\n\n3. 通项公式\n\nclass Solution &#123;public:    int climbStairs(int n) &#123;        double sqrt5 = sqrt(5);        return static_cast&lt;int&gt;(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;;\nclass Solution &#123;    public int climbStairs(int n) &#123;        double sqrt5 = Math.sqrt(5);        return (int)(Math.round((Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        sqrt5 = sqrt(5)        return (int)(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5))\n\n三：杨辉三角\n\n1. 数学分析\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; result(numRows);        for (int i= 0; i &lt; numRows; ++i)        &#123;            result[i].resize(i + 1);            result[i][0] = result[i][i] = 1;            for (int j = 1; j &lt; i; ++j)            &#123;                result[i][j] = result[i - 1][j] + result[i - 1][j - 1];            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        for (int i= 0; i &lt; numRows; ++i)        &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            for (int j = 0; j &lt;= i; ++j)            &#123;                if (j == 0 || j == i) row.add(1);                else row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));            &#125;            result.add(row);        &#125;        return result;    &#125;&#125;\nclass Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        result = []        for i in range(numRows):            row = []            for j in range(0, i + 1):       # 0-i                if j == 0 or j == i: row.append(1)                else: row.append(result[i - 1][j] + result[i - 1][j - 1])            result.append(row)        return result\n\n四：只出现一次的数字\n\n1. 位运算\n题目要求使用空间复杂度为常量，因此常规解法不可用。这里采用异或，性质如下\n\nclass Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result = 0;        for (auto num : nums)            result ^=num;        return result;    &#125;&#125;;\nclass Solution &#123;    public int singleNumber(int[] nums) &#123;        int result = 0;        for (int num : nums)        // 没有auto            result ^=num;        return result;    &#125;&#125;\nclass Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        result = 0        for num in nums:                   result ^=num        return result\t\t# return reduce(lambda x, y: x ^ y, nums) 使用lambda，reduce从可迭代对象中取出第一个和第二个元素，用指定的函数进行计算，将计算结果与第三个元素再次进行计算，直到所有元素处理完毕\n\n五：多数元素\n\n1. 哈希表\n数组的值作为键，出现的次数作为值\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; hashMap;        int count = 0, numberous = 0;        for (auto num : nums)        &#123;            ++hashMap[num];            if (hashMap[num] &gt; count)\t\t// 通过该方式无需再次遍历哈希表            &#123;                count = hashMap[num];                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        int count = 0, numberous = 0;        for (int num : nums)        &#123;            if (hashMap.containsKey(num)) hashMap.put(num, hashMap.get(num) + 1);            else hashMap.put(num, 1);                        if (hashMap.get(num) &gt; count)            &#123;                count = hashMap.get(num) ;                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)\t\t# 统计每个元素的个数，保存为字典        return max(counts.keys(), key = counts.get)\t\t\t# 根据键取出对应的值的最大值\n\n2. 排序\n由于多数总是超过元素总和的二分之一，那么排序后中间的元素一定是多数（奇偶均可）\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)        return max(counts.keys(), key = counts.get)\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Arrays.sort(nums);      // 使用Arrays        return nums[nums.length / 2];    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // 2]\n\n3. 随机化\n随机挑选一个元素作为多数，然后统计\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        while (true)        &#123;            int count = 0;            int right = nums[rand() % nums.size()];\t\t// 也可以假设第一个为多数，依次尝试，比随机时间稍低，因为不会重复            for (auto num : nums)                if (num == right) ++count;            if (count &gt; nums.size() / 2) return right;        &#125;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        Random rand = new Random();        while (true)        &#123;            int right = nums[rand.nextInt(nums.length)];            int count = 0;            for (int num : nums)                if (num == right) ++count;            if (count &gt; nums.length / 2) return right;        &#125;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        while True:            right = random.choice(nums)            count = 0            for num in nums:\t\t# 或if sum(1 for elem in nums if elem == candidate) &gt; majority_count:                if num == right: count += 1            if count &gt; len(nums) // 2: return right\n\n4. 分治\n将数据分为两组，多数一定会存在其中一组\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    int recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);\t\t// 两者相等可以直接返回了leftNum == rightNum        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(vector&lt;int&gt;&amp; nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    public int recursion(int[] nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(int[] nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1)    def recursion(self, nums, left, right):        if (left == right): return nums[left]        mid = ((right - left) // 2) + left        leftNum = self.recursion(nums, left, mid)        rightNum = self.recursion(nums, mid + 1, right)        if (self.countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2): return leftNum        if (self.countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2): return rightNum        return -1    def countNum(self, nums, target, lo, hi):        count = 0        for num in nums:            if (num == target):                count +=1        return count    # 官方写法class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        def majority_elem在·ent_rec(lo, hi) -&gt; int:            if lo == hi:                return nums[lo]                        mid = (hi - lo) // 2 + lo            left = majority_element_rec(lo, mid)            right = majority_element_rec(mid + 1, hi)            if left == right:                return left            left_count = sum(1 for i in range(lo, hi + 1) if nums[i] == left)            right_count = sum(1 for i in range(lo, hi + 1) if nums[i] == right)            return left if left_count &gt; right_count else right        return majority_element_rec(0, len(nums) - 1)\n\n5. Boyer-Moore 投票算法\n\n利用多数大于二分之一的性质，所有元素加减之后一定大于零，最后一个零出现的位置意味着之后的第一个元素一定是多数，因为如果不是多数，后面还会出现零\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int right = -1;    int count = 0;    for (auto num : nums)    &#123;        if (count == 0) right = num;        if (num == right) ++count;        else --count;    &#125;    return right;    &#125;&#125;;\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int right = -1;        int count = 0;        for (int num : nums)        &#123;            if (count == 0) right = num;            if (num == right) ++count;            else --count;        &#125;        return right;    &#125;&#125;\nclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        right = -1        count = 0        for num in nums:            if (count == 0): right = num            if (num == right): count += 1            else: count -= 1        return right\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.20)","url":"/posts/9b0f2e8b/","content":"一：寻找两个正序数组的中位数\n\n1. 二分查找\n寻找两个数组的中位数即是寻找第 k 小的数，那么对于每一个数组求k / 2 - 1，小的一个元素的左边值应当被排除，更新K值和索引\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        int total = m + n;        if (total &amp; 1) return GetKvalue(nums1, nums2, (total + 1) / 2);        else return ((GetKvalue(nums1, nums2, total / 2) + GetKvalue(nums1, nums2, total / 2 + 1)) / 2.0);    &#125;    int GetKvalue(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)    &#123;        int m = nums1.size();        int n = nums2.size();        int index1 = 0;        int index2 = 0;        while (true)        &#123;            if (index1 == m) return nums2[index2 + k - 1];            if (index2 == n) return nums1[index1 + k - 1];            if (k == 1) return min(nums1[index1], nums2[index2]);            int newIndex1 = min(index1 + k / 2 - 1, m - 1);            int newIndex2 = min(index2 + k / 2 - 1, n - 1);            int pre1 = nums1[newIndex1];            int pre2 = nums2[newIndex2];            if (pre1 &lt;= pre2)            &#123;                k = k - (newIndex1 - index1 + 1);                index1 = newIndex1 + 1;            &#125; else            &#123;                k = k - (newIndex2 - index2 + 1);                index2 = newIndex2 + 1;            &#125;        &#125;    &#125;&#125;;\n\n2. 划分数组\n这个题有点难，将两个数组进行划分，通常左边的最大值如果小于右边的最小值，那么中位数即可判断\nclass Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        if (m &gt; n) return findMedianSortedArrays(nums2, nums1);     // 保证第一个数组小        int left = 0, right = m;        // 二分范围        int median1 = 0;        int median2 = 0;        while (left &lt;= right)        &#123;            int i = (left + right) &gt;&gt; 1;        // 第一个数组的中间值            int j = ((m + n + 1) &gt;&gt; 1) - i;       // 第二个数组的中间值            int i_1 = i == 0 ? INT_MIN : nums1[i - 1];            int iNew = i == m ? INT_MAX : nums1[i];            int j_1 = j == 0 ? INT_MIN : nums2[j - 1];            int jNew = j == n ? INT_MAX : nums2[j];            if (i_1 &lt;= jNew)            &#123;                median1 = max(i_1, j_1);                median2 = min(iNew, jNew);                left = i + 1;            &#125; else                right = i - 1;        &#125;        return (m + n) &amp; 1 ? median1 : (median1 + median2) / 2.0;    &#125;&#125;;\n\n二：N 皇后\n\n1. 基于集合的回溯\n使用回溯需要三步，选择、递归、撤销选择，在选择时需要避免行、列以及两个斜线不能冲突\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    unordered_set&lt;int&gt; col;    unordered_set&lt;int&gt; diaR;    unordered_set&lt;int&gt; diaL;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, board);        return result;    &#125;    void recursion(int row, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);     // 全部填充            return;        &#125;         for (int i = 0; i &lt; len; ++i)       // 对当前行遍历可行的列        &#123;            if (col.count(i) || diaR.count(row - i) || diaL.count(row + i)) continue;       // 冲突则下一列            board[row][i] = &#x27;Q&#x27;;        // 选择            col.insert(i);            diaR.insert(row - i);            diaL.insert(row + i);            recursion(row + 1, board);      // 递归            board[row][i] = &#x27;.&#x27;;        // 撤销            col.erase(i);            diaR.erase(row - i);            diaL.erase(row + i);        &#125;    &#125;&#125;;\n\n2. 基于位运算的回溯\n这里使用二进制来表示每一列和斜边的位置情况\nclass Solution &#123;public:    int len;    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        len = n;        vector&lt;string&gt; board(len, string(n, &#x27;.&#x27;));        recursion(0, 0, 0, 0, board);        return result;    &#125;    void recursion(int row, int col, int digR, int digL, vector&lt;string&gt; &amp;board)    &#123;        if (row == len)        &#123;            result.emplace_back(board);                return;        &#125;         int avail = ((1 &lt;&lt; len) - 1) &amp; (~(col | digR | digL));\t\t// 可用位置        while (avail != 0)        &#123;            int p = avail &amp; (-avail);\t\t// 最低位的可用位置            int colT = 0;            int temp = p;            while ((temp &gt;&gt;= 1) &gt; 0) ++colT;\t\t// 对应列            board[row][colT] = &#x27;Q&#x27;;            int next_col = col | p;\t\t// 新的二进制            int next_digR = (digR | p) &gt;&gt; 1;            int next_digL = (digL | p) &lt;&lt; 1;            recursion(row + 1, next_col, next_digR, next_digL, board);            board[row][colT] = &#x27;.&#x27;;            avail &amp;= (~p);\t\t// 取消可用位置        &#125;    &#125;&#125;;\n\n三：二叉树中的最大路径和\n\n1. 递归\n这里主要需要使用一个常数来记录最大值，因为不能回溯，而返回值不能叠加\nclass Solution &#123;public:    int result = INT_MIN;    int maxPathSum(TreeNode* root) &#123;        recursion(root);        return result;    &#125;    int recursion(TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftVal = max(recursion(node-&gt;left), 0);        int rightVal = max(recursion(node-&gt;right), 0);        result = max(result, node-&gt;val + leftVal + rightVal);        return node-&gt;val + max(leftVal, rightVal);    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.21)","url":"/posts/82141fca/","content":"一：合并 K 个升序链表\n\n1. 顺序合并\n按照链表合并的逻辑将数组中的链表逐个合并\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        int len = lists.size();        ListNode* retuslt = nullptr;        for (int i = 0; i &lt; len; ++i) retuslt = Merge(retuslt, lists[i]);        return retuslt;    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n2. 分治合并\n将数组中的链表两两配对，依次递归\nclass Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        return recursion(lists, 0, lists.size() - 1);    &#125;    ListNode* recursion(vector&lt;ListNode*&gt;&amp; lists, int left, int right)    &#123;        if (left == right) return lists[left];        if (left &gt; right) return nullptr;        int mid = (left + right) &gt;&gt; 1;        return Merge(recursion(lists, left, mid), recursion(lists, mid + 1, right));    &#125;    ListNode* Merge(ListNode* a, ListNode* b)    &#123;        if (!a || !b) return a ? a : b;        ListNode head, *tail = &amp;head;        while (a &amp;&amp; b)        &#123;            if (a-&gt;val &lt; b-&gt;val)            &#123;                tail-&gt;next = a;                a = a-&gt;next;            &#125;            else            &#123;                tail-&gt;next = b;                b = b-&gt;next;            &#125;            tail = tail-&gt;next;        &#125;        tail-&gt;next = a ? a : b;        return head.next;    &#125;&#125;;\n\n3. 使用优先队列合并\n根据节点的值将其放入优先队列中，依次取出队列顶端的值，可得到最小的节点\nclass Solution &#123;public:    struct Node    &#123;        int val;        ListNode* p;        bool operator &lt; (const Node &amp;com) const        &#123;            return val &gt; com.val;        &#125;    &#125;;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode head, *cur = &amp;head;        priority_queue&lt;Node&gt; pq;        for (auto &amp;list : lists)             if (list) pq.push(&#123;list-&gt;val, list&#125;);        while (!pq.empty())        &#123;            auto temp = pq.top();            pq.pop();            cur-&gt;next = temp.p;            cur = cur-&gt;next;            if (temp.p-&gt;next) pq.push(&#123;temp.p-&gt;next-&gt;val, temp.p-&gt;next&#125;);        &#125;        return head.next;    &#125;&#125;;\n\n二：K 个一组翻转链表\n\n1. 模拟\n翻转链表的实现很容易，但反转之后需要它的前置和后置节点，以便更新在链表中的结构，所以需要提前保留需要交换的头和尾节点\nclass Solution &#123;public:    ListNode* reverseKGroup(ListNode* head, int k) &#123;        ListNode* result = new ListNode(0);        result-&gt;next = head;        ListNode* pre = result;        while (head)        &#123;            ListNode* tail = pre;            for (int i = 0; i &lt; k; ++i)            &#123;                tail = tail-&gt;next;                if (tail == nullptr) return result-&gt;next;            &#125;            ListNode* next = tail-&gt;next;            tie(head, tail) = Reverse(head, tail);            pre-&gt;next = head;            tail-&gt;next = next;            head = tail-&gt;next;            pre = tail;        &#125;        return result-&gt;next;    &#125;    pair&lt;ListNode*, ListNode*&gt; Reverse(ListNode* head, ListNode* tail)    &#123;        ListNode* pre = nullptr;        ListNode* cur = head;        while (pre != tail)        &#123;            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return &#123;tail, head&#125;;    &#125;&#125;;\n\n三：缺失的第一个正数\n\n1. 哈希表\n想要记录没有出现的数据，通常使用哈希表，这里无法使用额外空间，我们可以对数组进行原地操作\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (auto&amp; num: nums)            if (num &lt;= 0) num = INT_MAX;        for (auto&amp; num: nums)        &#123;            int temp = abs(num);            if (temp &lt;= len) nums[temp - 1] = -abs(nums[temp - 1]);     // 这里可能修改后面的数据，所以取负值        &#125;        for (int i = 0; i &lt; len; ++i)            if (nums[i] &gt; 0) return i + 1;        return len + 1;    &#125;&#125;;\n\n2. 置换\n我们可以尝试把元素的值与数组索引对应\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        for (int i = 0; i &lt; len; ++i)            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - 1])                 swap(nums[i], nums[nums[i] - 1]);        for (int i = 0; i &lt; len; ++i)            if (nums[i] != i + 1) return i + 1;        return len + 1;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.22)","url":"/posts/a9394c09/","content":"一：接雨水\n\n1. 动态规划\n使用两个数组维护其左右最大高度，其当前位置的雨水即为左右高度的最小值减去当前值\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        vector&lt;int&gt; LeftH(len);        vector&lt;int&gt; rightH(len);        LeftH[0] = height[0];        rightH[len - 1] = height[len - 1];        for (int i = 1; i &lt; len; ++i)            LeftH[i] = max(LeftH[i - 1], height[i]);        for (int i = len - 2; i &gt;= 0; --i)            rightH[i] = max(rightH[i + 1], height[i]);        for (int i = 0; i &lt; len; ++i)            result += min(LeftH[i], rightH[i]) - height[i];        return result;    &#125;&#125;;\n\n2. 单调栈\n按照递减的顺序将数据放入栈中，如果有数据大于栈顶，则计算其包含的雨水量\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        stack&lt;int&gt; stk;        for (int i = 0; i &lt; len; ++i)        &#123;            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()])            &#123;                int cur = stk.top();                stk.pop();                if (stk.empty()) break;                int left = stk.top();                int width = i - left - 1;                int hei = min(height[left], height[i]) - height[cur];                result += width * hei;            &#125;            stk.push(i);        &#125;        return result;    &#125;&#125;;\n\n3. 双指针\n使用两个指针维护左右的最大值，哪个指针的值小便进行移动\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int len = height.size();        int result = 0;        int left = 0, right = len - 1;        int leftM = 0, rightM = 0;        while (left &lt; right)        &#123;            leftM = max(leftM, height[left]);            rightM = max(rightM, height[right]);            if (leftM &lt; rightM)            &#123;                result += leftM - height[left];                ++left;            &#125; else            &#123;                result += rightM - height[right];                --right;            &#125;        &#125;        return result;    &#125;&#125;;\n\n二：滑动窗口最大值\n\n1. 优先队列\n维护一个当前窗口的优先队列，每次从里面选中一个最大值作为当前窗口的最大值，然后移动窗口并剔除超出边界的队顶元素\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;        for (int i = 0; i &lt; k; ++i) pq.push(&#123;nums[i], i&#125;);        result.emplace_back(pq.top().first);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            pq.push(&#123;nums[i], i&#125;);            while (pq.top().second &lt;= i - k) pq.pop();            result.emplace_back(pq.top().first);        &#125;        return result;    &#125;&#125;;\n\n2. 单调队列\n将优先队列改为双端队列，同时维护有序状态，可将原来操作插入的log⁡(n)\\log(n)log(n)复杂度降低为(n)(n)(n)\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; result;        deque&lt;int&gt; dq;        for (int i = 0; i &lt; k; ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);        &#125;        result.emplace_back(nums[dq.front()]);        for (int i = k; i &lt; nums.size(); ++i)        &#123;            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) dq.pop_back();            dq.push_back(i);            while (dq.front() &lt;= i - k) dq.pop_front();            result.emplace_back(nums[dq.front()]);        &#125;        return result;    &#125;&#125;;\n\n3. 分块+预处理\n首先将元素分块，并计算出当前元素在该块的前缀最大值和后缀最大值，随后遍历元素取其中的最大值即可\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int len = nums.size();        vector&lt;int&gt; result;        vector&lt;int&gt; pre(len);        vector&lt;int&gt; suf(len);        for (int i = 0; i &lt; len; ++i)            if (i % k == 0)                pre[i] = nums[i];            else                pre[i] = max(pre[i - 1], nums[i]);        for (int i = len - 1; i &gt;= 0; --i)            if (i == len - 1 || (i + 1) % k == 0)                suf[i] = nums[i];            else                suf[i] = max(suf[i + 1], nums[i]);        for (int i = 0; i &lt;= len - k; ++i)            result.emplace_back(max(pre[i + k - 1], suf[i]));        return result;    &#125;&#125;;\n\n三：最小覆盖子串\n\n1. 滑动窗口\n使用一个窗口来表示当前子串的范围，并在包含所有元素之后尝试缩短长度\nclass Solution &#123;public:    unordered_map &lt;char, int&gt; ori, cnt;    string minWindow(string s, string t) &#123;        for (const auto &amp;c: t)            ++ori[c];        int l = 0, r = -1;        int len = INT_MAX, ansL = -1;        while (r &lt; int(s.size())) &#123;            if (ori.find(s[++r]) != ori.end())                 ++cnt[s[r]];            while (check() &amp;&amp; l &lt;= r) &#123;                if (r - l + 1 &lt; len) &#123;                    len = r - l + 1;                    ansL = l; // 记录最短子串的起始位置                &#125;                if (ori.find(s[l]) != ori.end())                     --cnt[s[l]];                ++l;            &#125;        &#125;        return ansL == -1 ? string() : s.substr(ansL, len);    &#125;    bool check()     &#123;        for (const auto &amp;p: ori)             if (cnt[p.first] &lt; p.second)                 return false;        return true;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.3)","url":"/posts/19f6d24e/","content":"一：字母异位词分组\n\n1. 排序\n字母异位词排序之后相同，可使用哈希表\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str : strs)        &#123;            string key = str;            sort(key.begin(), key.end());            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)        &#123;            result.emplace_back(row.second);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            char[] arrayStr = str.toCharArray();            Arrays.sort(arrayStr);            String key = new String(arrayStr);            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            // getOrDefault 它的作用是：如果 map 中存在 key，则返回 key 对应的值；            // 如果不存在，则返回 new ArrayList&lt;String&gt;() 并添加到 map 中            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            # sorted(st) 返回一个按字母排序的列表 [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;t&#x27;]            # &quot;&quot;.join(...) 将列表中的字符连接成字符串 &quot;aet&quot;            key = &quot;&quot;.join(sorted(str))            hashMap[key].append(str)        return list(hashMap.values())\n\n2. 计数\n跟排序道理相同，只不过增加了字符的次数\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str: strs) &#123;            array&lt;int, 26&gt; counts&#123;&#125;;            for (char ch : str)                 counts[ch - &#x27;a&#x27;] ++;            string key;            for (auto count : counts)                 key += to_string(count) + &quot;#&quot;;            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)            result.emplace_back(row.second);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            int[] counts = new int[26];            for (int i = 0; i &lt; str.length(); i++)                counts[str.charAt(i) - &#x27;a&#x27;]++;            StringBuffer sb = new StringBuffer();            for (int i = 0; i &lt; 26; i++)                if (counts[i] != 0)\t\t\t// 这里也可以使用python的方式，但是必须在字符之间添加分界符，原因是出现次数超过10的字母会导致键不唯一                &#123;                    sb.append((char)(&#x27;a&#x27; + i));                    sb.append(counts[i]);                &#125;            String key = sb.toString();            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            counts = [0] * 26            for ch in str:                counts[ord(ch) - ord(&quot;a&quot;)] += 1            hashMap[tuple(counts)].append(str)\t\t# 直接使用计数数组，注意这里保留了顺序，因为生成的是元组        return list(hashMap.values())\n\n二：最长连续序列\n\n1. 哈希表\n将数据放入哈希表，然后不断寻找它的下一位，时间大概为线性，但有些数据没必要再次寻找，如已经找过的数据\nclass Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; hashSet;        int maxCount = 0;        for (auto num : nums) hashSet.insert(num);        for (auto num : hashSet)        &#123;            if (!hashSet.count(num - 1))            &#123;                int count = 1;                  while (hashSet.count(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = max(maxCount, count);            &#125;        &#125;         return maxCount;                                       &#125;&#125;;\nclass Solution &#123;    public int longestConsecutive(int[] nums) &#123;        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        int maxCount = 0;        for (int num : nums) hashSet.add(num);        for (int num : hashSet)        &#123;            if (!hashSet.contains(num - 1))            &#123;                int count = 1;                  while (hashSet.contains(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = Math.max(maxCount, count);            &#125;        &#125;         return maxCount;        &#125;&#125;\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        hashSet = set(nums)        maxCount = 0        for num in hashSet:            if num - 1 not in hashSet:                count = 1                  while (num + 1) in hashSet:                    count += 1                    num += 1                maxCount = max(maxCount, count)        return maxCount   \n\n三：盛水最多的容器\n\n1. 双指针\n从两端开始，移动小的向中间靠近\nclass Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int left = 0, right = height.size() - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;;\nclass Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0, right = height.length - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = Math.min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = Math.max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, maxA = 0, 0        right = len(height) - 1        while left &lt; right:            curArea = min(height[left], height[right]) * (right - left)            if (height[left] &lt; height[right]): left += 1            else: right -= 1            maxA = max(maxA, curArea)        return maxA\n\n四：三数之和\n\n1. 排序 + 双指针\n首先对数组进行排序，外层循环从左往右，内层从右往左，题目要求三元组不重复意味着相同的值无需处理跳过即可\n当我们想要枚举数组中的两个元素时，如果发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N2)O(N^2)O(N2) 减少至 O(N)O(N)O(N)。为什么是 O(N)O(N)O(N) 呢？这是因为在枚举的过程中，每一步中，“左指针”会向右移动一个位置，而“右指针”会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)O(N)。均摊下来，每次也只向右移动一个位置，因此时间复杂度为 O(N)O(N)O(N)。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0) result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);            &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        int length = nums.length;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0)                &#123;                    List&lt;Integer&gt; row = new ArrayList&lt;&gt;();                    row.add(nums[i]);                    row.add(nums[j]);                    row.add(nums[k]);                    result.add(row);                &#125;            &#125;        &#125;        return result;    &#125;&#125;\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        length = len(nums)        result = list()        nums.sort()        for i in range(length):            if i &gt; 0 and nums[i] == nums[i - 1]: continue            k = length - 1            for j in range(i + 1, length):                if j &gt; i + 1 and nums[j] == nums[j - 1]: continue                while nums[i] + nums[j] + nums[k] &gt; 0 and j &lt; k: k -= 1                if j == k: break                if nums[i] + nums[j] + nums[k] == 0:                    result.append([nums[i], nums[j], nums[k]])        return result\n\n五：无重复字符的最长子串\n\n1. 滑动窗口\n通过哈希表维护窗口，两个指针指向字符串，若右指针元素不在哈希表则添加并右移，若包含则左指针右移并剔除当前指向元素\nclass Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        unordered_set&lt;char&gt; hashSet;        int right = 0;        int length = s.size();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.count(s[right]))            &#123;                hashSet.insert(s[right]);                ++right;            &#125;            hashSet.erase(s[i]);            result = max(result, right - i);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();        int right = 0;        int length = s.length();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.contains(s.charAt(right)))            &#123;                hashSet.add(s.charAt(right));                ++right;            &#125;            hashSet.remove(s.charAt(i));            result = Math.max(result, right - i);        &#125;        return result;    &#125;&#125;\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        hashSet = set()        right = 0        length = len(s)        result = 0        for i in range(length):            while (right &lt; length and s[right] not in hashSet):                hashSet.add(s[right])                right += 1            hashSet.remove(s[i])            result = max(result, right - i)        return result\n\n六：找到字符串中所有字母异位词\n\n1. 滑动窗口\np的长度固定，在s中寻找p可使用p的长度的作为窗口宽度，利用当前宽度两个字符串出现的次数即可作为判定\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; pCharCount(26);        vector&lt;int&gt; sCharCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p[i] - &#x27;a&#x27;];            ++sCharCount[s[i] - &#x27;a&#x27;];        &#125;        if (sCharCount == pCharCount) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s[i] - &#x27;a&#x27;];            ++sCharCount[s[i + pL] - &#x27;a&#x27;];            if (sCharCount == pCharCount) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] pCharCount = new int[26];        int[] sCharCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        if (Arrays.equals(pCharCount, sCharCount)) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (Arrays.equals(pCharCount, sCharCount)) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        pCharCount = [0] * 26        sCharCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            pCharCount[ord(p[i]) - 97] += 1            sCharCount[ord(s[i]) - 97] += 1        if (sCharCount == pCharCount): result.append(0)        for i in range(sL - pL):               sCharCount[ord(s[i]) - 97] -= 1            sCharCount[ord(s[i + pL]) - 97] += 1            if (sCharCount == pCharCount): result.append(i + 1)        return result\n\n2. 优化\n不比较两个字符串在窗口的位置，直接比较差值\nclass Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; charCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p[i] - &#x27;a&#x27;];            ++charCount[s[i] - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s[i] - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s[i] - &#x27;a&#x27;] == 0) ++dif;            --charCount[s[i] - &#x27;a&#x27;];            if (charCount[s[i + pL] - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s[i + pL] - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s[i + pL] - &#x27;a&#x27;];            if (dif == 0) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] charCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p.charAt(i) - &#x27;a&#x27;];            ++charCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s.charAt(i) - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s.charAt(i) - &#x27;a&#x27;] == 0) ++dif;            --charCount[s.charAt(i) - &#x27;a&#x27;];            if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (dif == 0) result.add(i + 1);        &#125;        return result;    &#125;&#125;\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        charCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            charCount[ord(p[i]) - 97] -= 1            charCount[ord(s[i]) - 97] += 1        differ = [c != 0 for c in charCount].count(True)        if (differ == 0): result.append(0)        for i in range(sL - pL):               if charCount[ord(s[i]) - 97] == 1: differ -= 1            elif charCount[ord(s[i]) - 97] == 0: differ += 1            charCount[ord(s[i]) - 97] -= 1            if charCount[ord(s[i + pL]) - 97] == -1: differ -= 1            elif charCount[ord(s[i + pL]) - 97] == 0: differ += 1            charCount[ord(s[i + pL]) - 97] += 1            if (differ == 0): result.append(i + 1)        return result\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.4)","url":"/posts/56b74489/","content":"一：和为K的子数组\n\n1. 枚举\n其实就是暴力，两层循环，python可能会超时\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        int length = nums.length;        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        length = len(nums)        count = 0        for i in range(length):            sum = 0            for j in range(i, length):                sum += nums[j]                if (sum == k): count += 1        return count\n\n2. 哈希表\n遍历时记录所有和并放入哈希表，寻找子串时只寻找当前值与目标值的差，相同值通过哈希表的值来记录\nclass Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; hashMap;        hashMap[0] = 1;         // 相同值需要        int sum = 0;        int count = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            if (hashMap.count(sum - k)) count += hashMap[sum - k];            ++hashMap[sum];        &#125;        return count;    &#125;&#125;;\nclass Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(0, 1);        int sum = 0;        int count = 0;        for (int num : nums)        &#123;            sum += num;            if (hashMap.containsKey(sum - k)) count += hashMap.get(sum - k);            hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);        &#125;        return count;    &#125;&#125;\nclass Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        hashMap = &#123;0 : 1&#125;        sum = 0        count = 0        for num in nums:            sum += num            if (sum - k in hashMap): count += hashMap[sum - k]            hashMap[sum] = hashMap.get(sum, 0) + 1        return count\n\n二：最大子数组和\n\n1. 动态规划\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int next = 0;        int result = nums[0];        for (auto&amp; num : nums)        &#123;            next = max(next + num, num);            // 局部最优            result = max(result, next);        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int next = 0;        int result = nums[0];        for (int num : nums)        &#123;            next = Math.max(next + num, num);            // 局部最优            result = Math.max(result, next);        &#125;        return result;    &#125;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        next = 0        result = nums[0]        for num in nums:            next = max(next + num, num)                      result = max(result, next)        return result\n\n2. 分治\nclass Solution &#123;public:    struct Status &#123;        int left, right, media, sum;    &#125;;    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1).media;    &#125;    Status recursion(vector&lt;int&gt; &amp;a, int l, int r) &#123;        if (l == r) &#123;            return (Status) &#123;a[l], a[l], a[l], a[l]&#125;;        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;        Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = max(l.left, l.sum + r.left);        int rSum = max(r.right, r.sum + l.right);        int mSum = max(max(l.media, r.media), l.right + r.left);        return (Status) &#123;lSum, rSum, mSum, iSum&#125;;    &#125;;&#125;;\nclass Solution &#123;    public class Status &#123;        public int left, right, media, sum;        public Status(int lSum, int rSum, int mSum, int iSum) &#123;            this.left = lSum;            this.right = rSum;            this.media = mSum;            this.sum = iSum;        &#125;    &#125;    public int maxSubArray(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1).media;    &#125;    public Status recursion(int[] a, int l, int r) &#123;        if (l == r) &#123;            return new Status (a[l], a[l], a[l], a[l]);        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;    public Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = Math.max(l.left, l.sum + r.left);        int rSum = Math.max(r.right, r.sum + l.right);        int mSum = Math.max(Math.max(l.media, r.media), l.right + r.left);        return new Status (lSum, rSum, mSum, iSum);    &#125;;&#125;\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1).media    def recursion(self, a, l, r):        if l == r:            val = a[l]            return (val, val, val, val)                m = (r + l) // 2        l_sub = self.recursion(a, l, m)        r_sub = self.recursion(a, m + 1, r)          return self.pushUp(l_sub, r_sub)    def pushUp(self, l, r):        l_left, l_right, l_media, l_sum = l        r_left, r_right, r_media, r_sum = r                i_sum = l_sum + r_sum        l_sum_new = max(l_left, l_sum + r_left)        r_sum_new = max(r_right, r_sum + l_right)        m_sum_new = max(max(l_media, r_media), l_right + r_left)                return (l_sum_new, r_sum_new, m_sum_new, i_sum)\n\n3. 前缀法\n参考第一题的第二中解法，时间和空间同动态规划方法\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int minV = 0, maxV = -1e9;        int sum = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            maxV = max(maxV, sum - minV);            minV = min(minV , sum);        &#125;        return maxV;    &#125;&#125;;\n三：合并区间\n\n1. 排序\n对首元素排序，然后判断每个区间的首尾大小即可\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(), intervals.end());        vector&lt;vector&lt;int&gt;&gt; reruslt;        for (int i = 0; i &lt; intervals.size(); ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.back()[1] &lt; left) reruslt.emplace_back(intervals[i]);            else reruslt.back()[1] = max(reruslt.back()[1], right);        &#125;         return reruslt;    &#125;&#125;;\nclass Solution &#123;    public int[][] merge(int[][] intervals) &#123;        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] interval1, int[] interval2) &#123;                return interval1[0] - interval2[0];            &#125;        &#125;);        List&lt;int[]&gt; reruslt = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; intervals.length; ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.get(reruslt.size() - 1)[1] &lt; left) reruslt.add(new int[]&#123;left, right&#125;);            else reruslt.get(reruslt.size() - 1)[1] = Math.max(reruslt.get(reruslt.size() - 1)[1], right);        &#125;         return reruslt.toArray(new int[reruslt.size()][]);    &#125;&#125;\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        result = []        for interval in intervals:            if not result or result[-1][1] &lt; interval[0]: result.append(interval)            else: result[-1][1] = max(result[-1][1], interval[1])        return result\n\n四：轮转数组\n\n1. 额外数组\n使用一个额外数组来存储移动后的元素\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; newNums(nums.size());        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            newNums[(i + k) % nums.size()] = nums[i];        &#125;        return nums.assign(newNums.begin(), newNums.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[] nums, int k) &#123;        int[] newNums = new int[nums.length];        for (int i = 0; i &lt; nums.length; ++i)        &#123;            newNums[(i + k) % nums.length] = nums[i];        &#125;        System.arraycopy(newNums, 0, nums, 0, nums.length);    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        newNums = [0] * len(nums)        for i in range(len(nums)):            newNums[(i + k) % len(nums)] = nums[i]        nums[:] = newNums\n\n2. 环状替换\n以环为单位在数组元素中跳动反转，跳转几次后会回到原点，使用临时值来作为其中一个交换对象，如果遍历交换，则需要多个值来存储交换对象，效率变低\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                swap(nums[cur], curV);            &#125; while(i != cur);        &#125;    &#125;&#125;;\nclass Solution &#123;    public int gcd(int x, int y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;    public void rotate(int[] nums, int k) &#123;        int length = nums.length;        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                int temp = nums[cur];                nums[cur] = curV;                curV = temp;            &#125; while(i != cur);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        length = len(nums)        k = k % length        step = math.gcd(k, length)               for i in range(step):            cur = i            curV = nums[i]            while True:                cur = (cur + k) % length                nums[cur], curV = curV, nums[cur]                if i == cur: break\n\n3. 数组反转\n先将数组反转，然后反转前k个值，最后反转剩余值就得到换位后的数组\nclass Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        k = k % nums.size();        reverse(nums, 0, nums.size() - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.size() - 1);    &#125;    void reverse(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j) swap(nums[i], nums[j]);    &#125;&#125;;\nclass Solution &#123;   public void rotate(int[] nums, int k) &#123;        k = k % nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    &#125;    public void reverse(int[] nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j)        &#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        k = k % len(nums)        self.reverse(nums, 0, len(nums) - 1)        self.reverse(nums, 0, k - 1)        self.reverse(nums, k, len(nums) - 1)    def reverse(self, nums, left, right):        while left &lt; right:            nums[left], nums[right] = nums[right], nums[left]            left += 1            right -= 1\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.5)","url":"/posts/4fac75c8/","content":"一：除自身以外数组的乘积\n\n1. 左右乘积列表\n用两个数组分别记录左右两端的乘积\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; left(length);        vector&lt;int&gt; right(length);        vector&lt;int&gt; result(length);        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] left = new int[length] ;        int[] right = new int[length] ;        int[] result = new int[length] ;        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        left = [0] * length        right = [0] * length        result = [0] * length        left[0] = 1        right[length -  1] = 1        for i in range(1, length):            left[i] = nums[i - 1] * left[i - 1]        for j in reversed(range(length - 1)):            right[j] = nums[j + 1] * right[j + 1]        for i in range(length):            result[i] = left[i] * right[i]        return result\n\n2. 空间复杂度O(1)O(1)O(1)的方法\n用结果数组先作为左乘积列表，然后使用临时变量记录每个右乘积并更新数组\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; result(length);        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] result = new int[length] ;        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        result = [0] * length        result[0] = 1        for i in range(1, length):            result[i] = nums[i - 1] * result[i - 1]        rightMul = 1        for j in reversed(range(length)):            result[j] = result[j] * rightMul            rightMul *= nums[j]        return result\n\n二：矩阵置零\n\n1. 使用标记数组\n通过两个数组来记录二维数组中某行或这某列是否包含零\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        vector&lt;int&gt; vRow(nRow);        vector&lt;int&gt; vCol(nCol);        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        int[] vRow = new int[nRow];        int[] vCol = new int[nCol];        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        vRow = [0] * nRow        vCol = [0] * nCol        for i in range(nRow):            for j in range(nCol):                if (matrix[i][j] == 0): vRow[i] = vCol[j] = 1        for i in range(nRow):            for j in range(nCol):                if (vRow[i] == 1 or vCol[j] == 1): matrix[i][j] = 0\n\n2. 使用两个标记变量\n使用第一行和第一列来记录其余位置的零，再使用两个标记变量来记录第一行和第一列的情况\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstRow = false;        bool firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstRow = false;        boolean firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        firstRow = False        firstCol = False        for i in range(nRow):            if (matrix[i][0] == 0): firstCol = True        for i in range(nCol):            if (matrix[0][i] == 0): firstRow = True        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0        if (firstCol == True):            for i in range(nRow):                matrix[i][0] = 0        if (firstRow == True):            for i in range(nCol):                matrix[0][i] = 0\n\n3. 使用一个标记变量\n用左上角的元素作为标记变量\nclass Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;\nclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        flag = False        for i in range(nRow):            if (matrix[i][0] == 0): flag = True            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in reversed(range(nRow)):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0            if flag == True:                matrix[i][0] = 0\n\n三：螺旋矩阵\n\n1. 模拟\n定义一个旋转方向，当遇到边界和访问过的节点进行旋转（属于暴力）\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowCnt = matrix.size();        int colCnt = matrix[0].size();        enum Rule &#123;leftToright, upTodow, rightToleft, downToup&#125;;        Rule myRule = Rule::leftToright;        vector&lt;int&gt; results;        vector&lt;vector&lt;int&gt;&gt; visited(rowCnt, vector&lt;int&gt;(colCnt));        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            int nextRow = row, nextCol = col;            results.emplace_back(matrix[row][col]);            visited[row][col] = 1;            if (myRule == 0) nextCol = col + 1;            if (myRule == 1) nextRow = row + 1;            if (myRule == 2) nextCol = col - 1;            if (myRule == 3) nextRow = row - 1;            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                myRule = static_cast&lt;Rule&gt;((myRule + 1) % 4);            if (myRule == 0) ++col;            if (myRule == 1) ++row;            if (myRule == 2) --col;            if (myRule == 3) --row;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int rowCnt = matrix.length;        int colCnt = matrix[0].length;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int[][] visited = new int[rowCnt][colCnt];        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;        int directionIndex = 0;        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            results.add(matrix[row][col]);            visited[row][col] = 1;            int nextRow = row + directions[directionIndex][0];            int nextCol = col + directions[directionIndex][1];            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                directionIndex = (directionIndex + 1) % 4;            row += directions[directionIndex][0];            col += directions[directionIndex][1];        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        rowCnt, colCnt = len(matrix), len(matrix[0])        results = []        visited = [[0] * colCnt for _ in range(rowCnt)]        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]        direction_index = 0          row, col = 0, 0        for _ in range(rowCnt * colCnt):            results.append(matrix[row][col])            visited[row][col] = True            next_row = row + directions[direction_index][0]            next_col = col + directions[direction_index][1]            if not (0 &lt;= next_row &lt; rowCnt and 0 &lt;= next_col &lt; colCnt and not visited[next_row][next_col]):                direction_index = (direction_index + 1) % 4            row += directions[direction_index][0]            col += directions[direction_index][1]        return results\n\n2. 按层模拟\n每一圈相当于将最外围的数据输出，需要四个循环将四个边界输出，然后通过大的循环来遍历每一圈，注意圈的截止条件\nclass Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;;        int bottom = matrix.size() - 1;        int right = matrix[0].size() - 1;        vector&lt;int&gt; results;        int left = 0, top = 0;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.emplace_back(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.emplace_back(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom) \t\t\t// 到这里可能剩余不足围成圈，如1*n或n*1，此时前两个循环已经足够处理，如果不加以限制，那么在n大于1的情况下，下述的循环将会有一个进入导致最后结尾出现多余的数据            &#123;                for (int i = right - 1; i &gt; left; --i) results.emplace_back(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.emplace_back(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int bottom = matrix.length - 1;        int right = matrix[0].length - 1;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int left = 0, top = 0;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return results;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.add(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.add(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom)             &#123;                for (int i = right - 1; i &gt; left; --i) results.add(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.add(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        bottom, right = len(matrix) - 1, len(matrix[0]) - 1        results = list()         left, top = 0, 0        while left &lt;= right and top &lt;= bottom:            for i in range(left, right + 1): results.append(matrix[top][i])            for i in range(top + 1, bottom + 1): results.append(matrix[i][right])            if left &lt; right and top &lt; bottom:                for i in range(right - 1, left, -1): results.append(matrix[bottom][i])                for i in range(bottom, top, -1): results.append(matrix[i][left])            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1        return results\n\n四：旋转图像\n\n1. 辅助数组\n将旋转后的元素放入新的数组\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        auto result = matrix;        int m = matrix.size();        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        matrix.assign(result.begin(), result.end());    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        int[][] result = new int[m][m];        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        for (int i = 0; i &lt; m; i++) &#123;            System.arraycopy(result[i], 0, matrix[i], 0, m);        &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        n = len(matrix)        result = [[0] * n for _ in range(n)]        for i in range(n):            for j in range(n):                result[j][n - 1 - i] = matrix[i][j]        matrix[:] = result\n\n2. 原地旋转\n参考移动数组的解决方案，这里旋转四次会回到原地，一圈会移动四个数据，那么也就是只需要旋转约四分之一的元素，n的奇的情况下，中间不需要管\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range((m + 1) // 2):                temp = matrix[i][j]                matrix[i][j] = matrix[m - 1 - j][i]                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1]                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1]                matrix[j][m - 1 - i] = temp\n\n3. 翻转\n先水平后主对角线，也可以先竖直\nclass Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)                swap(matrix[i][j], matrix[m - i - 1][j]);        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)                swap(matrix[i][j], matrix[j][i]);    &#125;&#125;;\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - i - 1][j];                matrix[m - i - 1][j] = temp;            &#125;        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;    &#125;&#125;\nclass Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range(m):                matrix[i][j], matrix[m - i - 1][j] = matrix[m - i - 1][j], matrix[i][j]        for i in range(m):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n五：搜索二维矩阵\n\n1. 暴力\n不写\n\n2. 二分\n由于数组左右有序，对每一行使用二分从中间查找\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        for (auto&amp; row : matrix)        &#123;            auto it = lower_bound(row.begin(), row.end(), target);\t\t\t// 返回不小于目标值的第一个元素的迭代器            if (it != row.end() &amp;&amp; *it == target) return true;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        for (int[] row : matrix)        &#123;            int index = searchInsert(row, target);            if (index != -1) return true;        &#125;        return false;    &#125;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target == nums[mid]) return mid;            else if (target &lt; nums[mid])                     right = mid - 1;            else                left = mid + 1;        &#125;        return -1;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        for row in matrix:            it = bisect.bisect_left(row, target)\t\t\t            if it &lt; len(row) and row[it] == target: return True        return False\n\n3. Z 字形查找\n充分运用题目要求，第二种方法只有了一个条件，但数据从上往下也是递增，从右上角开始，横竖作为边界，也就是说如果某个位置的值小于目标值，行数可以加一，如果大于目标值，则列数应该减一\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m = matrix.size();        int n = matrix[0].size();        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;;\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length;        int n = matrix[0].length;        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;\nclass Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        m = len(matrix)        n = len(matrix[0])        i = 0        j = n - 1        while i &lt; m and j &gt;= 0:            if (matrix[i][j] == target): return True            elif (matrix[i][j] &gt; target): j -= 1            elif(matrix[i][j] &lt; target): i += 1        return False\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.6)","url":"/posts/6481260b/","content":"一：环形链表2️⃣\n\n1. 哈希表\n这道题的思路和环形链表的方法一相同\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return head;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return head;\t\t\t            hashTable.add(head);            head = head.next;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        hashTable = set()        while head:            if head in hashTable:                return head            hashTable.add(head)            head = head.next        return None\n\n2. 快慢指针\n这道题的思路和环形链表的方法二相同，如果有环相遇点一定在环中，且快指针比慢指针多n圈，进入环之后快指针比慢指针多一圈\n\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return nullptr;        ListNode* fastNode = head;               ListNode* slowNode = head;        while (fastNode != nullptr)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return nullptr;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;            if (fastNode == slowNode)            &#123;                ListNode* cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur-&gt;next;                    slowNode = slowNode-&gt;next;                &#125;                return cur;            &#125;        &#125;        return nullptr;    &#125;&#125;;\npublic class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        if (head == null || head.next == null) return null;        ListNode fastNode = head;               ListNode slowNode = head;        while (fastNode != null)        &#123;            if (fastNode == null || fastNode.next == null) return null;            slowNode = slowNode.next;            fastNode = fastNode.next.next;            if (fastNode == slowNode)            &#123;                ListNode cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur.next;                    slowNode = slowNode.next;                &#125;                return cur;            &#125;        &#125;        return null;    &#125;&#125;\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return None        fastNode = head               slowNode = head        while (fastNode != None):            if (fastNode == None or fastNode.next == None): return None            slowNode = slowNode.next            fastNode = fastNode.next.next            if (fastNode == slowNode):                cur = head                while ( cur != slowNode):                     cur = cur.next                    slowNode = slowNode.next                return cur        return None\n\n二：两数相加\n\n1. 模拟\n直接对对应节点的数字进行相加，难点在于处理进位和非对齐的场景\nclass Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        int carry = 0;        ListNode* head = nullptr;        ListNode* cur = nullptr;        while (l1 != nullptr || l2 != nullptr)        &#123;            int num1= l1 ? l1-&gt;val : 0;            int num2= l2 ? l2-&gt;val : 0;            int sum= num1 + num2 + carry;            if (head == nullptr)                cur = head = new ListNode(sum % 10);            else                cur = cur-&gt;next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != nullptr) l1 = l1-&gt;next;            if (l2 != nullptr) l2 = l2-&gt;next;        &#125;        if (carry != 0) cur-&gt;next = new ListNode(carry);        return head;    &#125;&#125;;\nclass Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int carry = 0;        ListNode head = null;        ListNode cur = null;        while (l1 != null || l2 != null)        &#123;            int num1= l1 != null ? l1.val : 0;            int num2= l2 != null ? l2.val : 0;            int sum= num1 + num2 + carry;            if (head == null)                cur = head = new ListNode(sum % 10);            else                cur = cur.next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        if (carry != 0) cur.next = new ListNode(carry);        return head;    &#125;&#125;\nclass Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        carry = 0        head = None        cur = None        while (l1 != None or l2 != None):            num1 = l1.val if l1 else 0            num2 = l2.val if l2 else 0            sum= num1 + num2 + carry            if (head == None):                head = ListNode(sum % 10)                cur = head            else:                cur.next = ListNode(sum % 10)                cur = cur.next            carry = sum // 10            if (l1 != None): l1 = l1.next            if (l2 != None): l2 = l2.next        if (carry != 0): cur.next = ListNode(carry)        return head\n\n三：删除链表的倒数第 N 个结点\n\n1. 计算链表长度\n需要一个虚拟头结点，这样可以删除任意的节点，否则如果只有一个节点并删除自己，则需要单独处理\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        int length = GetLength(head);        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur-&gt;next;        &#125;        cur-&gt;next = cur-&gt;next-&gt;next;        ListNode* ans = dummy-&gt;next;        return ans;    &#125;    int GetLength(ListNode* head)    &#123;        int length = 0;        while (head)        &#123;            head = head-&gt;next;            ++length;        &#125;         return length;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        int length = GetLength(head);        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur.next;        &#125;        cur.next = cur.next.next;        ListNode ans = dummy.next;        return ans;    &#125;    public int GetLength(ListNode head)    &#123;        int length = 0;        while (head != null)        &#123;            head = head.next;            ++length;        &#125;         return length;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        def GetLength(head : Optional[ListNode]) -&gt; Optional[int]:            length = 0            while (head != None):                head = head.next                length += 1            return length        length = GetLength(head)        cur = ListNode(0, head)        dummy = cur        for i in range(1, length + 1 -n):            cur = cur.next        cur.next = cur.next.next        ans = dummy.next        return ans\n\n2. 栈\n用一个栈去存储节点，之后弹出的第n个节点就是需要删除的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        stack&lt;ListNode*&gt; stk;        while (cur != nullptr)         &#123;            stk.push(cur);            cur = cur-&gt;next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.top();        head-&gt;next = head-&gt;next-&gt;next;        return dummy-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        Deque&lt;ListNode&gt; stk = new LinkedList&lt;&gt;();        while (cur != null)         &#123;            stk.push(cur);            cur = cur.next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.peek();        head.next = head.next.next;        return dummy.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        cur = ListNode(0, head)        dummy = cur        stk = list()        while (cur != None):             stk.append(cur)            cur = cur.next        for i in range(n): stk.pop()        head = stk[-1]        head.next = head.next.next        return dummy.next\n\n3. 双指针\n使用两个指针，快指针比慢指针多n个节点，快指针到达末尾则慢指针位置就是需要处理的地方\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* slow = pre;           // 不从head开始的原因在于，可以刚好到达倒数第n节点的前继结点        ListNode* fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast-&gt;next;        while (fast != nullptr)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        slow-&gt;next = slow-&gt;next-&gt;next;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode pre = new ListNode(0, head);        ListNode slow = pre;                 ListNode fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast.next;        while (fast != null)        &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return pre.next;    &#125;&#125;\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        slow = pre                 fast = head        for i in range(n): fast = fast.next        while (fast != None):            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return pre.next\n\n四：两两交换链表中的节点\n\n1. 递归\n终止条件为末尾只有单个节点或没有节点，一个递归需要处理两个节点\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return head;        ListNode* n1 = head-&gt;next;        head-&gt;next = swapPairs(n1-&gt;next);        n1-&gt;next = head;        return n1;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) return head;        ListNode n1 = head.next;        head.next = swapPairs(n1.next);        n1.next = head;        return n1;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return head        n1 = head.next        head.next = self.swapPairs(n1.next)        n1.next = head        return n1\n\n2. 迭代\n我们定义一个前继结点，依次交换后面的两个节点，然后前继结点向前移动两个位置\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* cur = pre;        while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)        &#123;            ListNode* n1 = cur-&gt;next;            ListNode* n2 = cur-&gt;next-&gt;next;            cur-&gt;next = n2;            n1-&gt;next = n2-&gt;next;            n2-&gt;next = n1;            cur = n1;        &#125;        return pre-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0, head);        ListNode cur = pre;        while (cur.next != null &amp;&amp; cur.next.next != null)        &#123;            ListNode n1 = cur.next;            ListNode n2 = cur.next.next;            cur.next = n2;            n1.next = n2.next;            n2.next = n1;            cur = n1;        &#125;        return pre.next;    &#125;&#125;\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        cur = pre        while (cur.next != None and cur.next.next != None):            n1 = cur.next            n2 = cur.next.next            cur.next = n2            n1.next = n2.next            n2.next = n1            cur = n1        return pre.next\n\n五：随机链表的复制\n\n1. 回溯+哈希表\n该题的难度在于随机指针的处理，因为拷贝节点时，随机指针指向的节点可能还未创建，一种方法是先不拷贝随机指针，在第二次循环中再拷贝，或者利用递归的思想反向处理\nclass Solution &#123;public:    unordered_map&lt;Node*, Node*&gt; hashMap;    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return head;        if (!hashMap.count(head))        &#123;            Node* newNode = new Node(head-&gt;val);            hashMap[head] = newNode;            newNode-&gt;next = copyRandomList(head-&gt;next);     // 到这里完成了除随机指针的拷贝            newNode-&gt;random = copyRandomList(head-&gt;random);\t\t// 等效于第二次遍历，此时节点已完成创建        &#125;        return hashMap[head];    &#125;&#125;;\nclass Solution &#123;    public Map&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();    public Node copyRandomList(Node head) &#123;        if (head == null) return head;        if (hashMap.containsKey(head) == false)        &#123;            Node newNode = new Node(head.val);            hashMap.put(head, newNode);            newNode.next = copyRandomList(head.next);                 newNode.random = copyRandomList(head.random);             &#125;        return hashMap.get(head);    &#125;&#125;\nclass Solution:    def __init__(self):        self.hashMap = &#123;&#125;\t\t# 这里初始化    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return head        if (head not in self.hashMap):            newNode= Node(head.val)            self.hashMap[head] = newNode            newNode.next = self.copyRandomList(head.next)                 newNode.random = self.copyRandomList(head.random)             return self.hashMap[head]\n\n2. 迭代+拆分\n将每一个拷贝后的节点作为原节点的后继结点，随机指针则为原指针的随机指针节点的后继位置，空除外\nclass Solution &#123;public:    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return nullptr;        Node* newHead = nullptr;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 建立复制链表        &#123;            Node* newNode = new Node(start-&gt;val);            newNode-&gt;next = start-&gt;next;            start-&gt;next = newNode;        &#125;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)\t\t// 对随机指针赋值        &#123;            if (start-&gt;random != nullptr) start-&gt;next-&gt;random = start-&gt;random-&gt;next;            else start-&gt;next-&gt;random =nullptr;        &#125;        newHead = head-&gt;next;        for (Node* start = head; start != nullptr; start = start-&gt;next)\t\t\t// 恢复原链表，连接新链表        &#123;            Node* newNode = start-&gt;next;            start-&gt;next = start-&gt;next-&gt;next;            newNode-&gt;next = (newNode-&gt;next != nullptr) ? newNode-&gt;next-&gt;next : nullptr;        &#125;        return newHead;    &#125;&#125;;\nclass Solution &#123;    public Node copyRandomList(Node head) &#123;        if (head == null) return null;        Node newHead = null;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            Node newNode = new Node(start.val);            newNode.next = start.next;            start.next = newNode;        &#125;        for (Node start = head; start != null; start = start.next.next)\t\t        &#123;            if (start.random != null) start.next.random = start.random.next;            else start.next.random =null;        &#125;        newHead = head.next;        for (Node start = head; start != null; start = start.next)\t\t\t        &#123;            Node newNode = start.next;            start.next = start.next.next;            newNode.next = (newNode.next != null) ? newNode.next.next : null;        &#125;        return newHead;    &#125;&#125;\nclass Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return None        start = head        while start:\t            newNode = Node(start.val)            newNode.next = start.next            start.next = newNode            start = newNode.next        start = head        while start:\t            if (start.random != None): start.next.random = start.random.next            else: start.next.random = None            start = start.next.next        newHead = head.next        start = head        while start:\t\t            newNode = start.next            start.next = start.next.next            if newNode.next:                newNode.next = newNode.next.next            start = start.next        return newHead\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.7)","url":"/posts/7d9a174a/","content":"一：排序链表\n\n1. 自顶向下归并排序\n对链表不断切分，然后使用合并两个有序链表的方式合并\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        return recursion(head, nullptr);    &#125;    ListNode* recursion(ListNode* left, ListNode* right)    &#123;        if (left == nullptr || left-&gt;next == nullptr) return left;        if (left-&gt;next == right)        &#123;            left-&gt;next = nullptr;            return left;        &#125;        ListNode* slow = left, *fast = left;        while (fast != right)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;            if (fast != right) fast = fast-&gt;next;        &#125;        ListNode* mid = slow;        ListNode* leftNew = recursion(left, mid);        ListNode* rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        return recursion(head, null);    &#125;    public ListNode recursion(ListNode left, ListNode right)    &#123;        if (left == null || left.next == null) return left;        if (left.next == right)        &#123;            left.next = null;            return left;        &#125;        ListNode slow = left, fast = left;        while (fast != right)        &#123;            slow = slow.next;            fast = fast.next;            if (fast != right) fast = fast.next;        &#125;        ListNode mid = slow;        ListNode leftNew = recursion(left, mid);        ListNode rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.recursion(head, None)    def recursion(self, left, right):        if (left == None or left.next == None): return left        if (left.next == right):            left.next = None            return left        slow, fast = left, left        while (fast != right):            slow = slow.next            fast = fast.next            if (fast != right): fast = fast.next        mid = slow        leftNew = self.recursion(left, mid)        rightNew = self.recursion(mid, right)        return self.MergeTwoLists(leftNew, rightNew)     def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n2. 自底向上归并排序\n第一层处理两个节点，将它们断开并排序，第二层结束处理四个节点，其中的两两已经处理好，是有序链表，因此可直接排序，依次迭代\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (head == nullptr) return head;        int length = 0;        ListNode* temp = head;        ListNode* pre = new ListNode(0, head);        while (temp != nullptr)        &#123;            ++length;            temp = temp-&gt;next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode* preCur = pre;            ListNode* cur = pre-&gt;next;            while (cur != nullptr)            &#123;                ListNode* node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur-&gt;next != nullptr; ++i) cur = cur-&gt;next;                ListNode* node2 = cur-&gt;next;                cur-&gt;next = nullptr;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != nullptr &amp;&amp; cur-&gt;next !=nullptr; ++i) cur = cur-&gt;next;                ListNode* next = nullptr;                if (cur != nullptr)                &#123;                    next = cur-&gt;next;                    cur-&gt;next = nullptr;                    cur = next;                &#125;                preCur-&gt;next = MergeTwoLists(node1, node2);                while (preCur-&gt;next != nullptr) preCur = preCur-&gt;next;            &#125;        &#125;        return pre-&gt;next;    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);\t\t\t// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        if (head == null) return head;        int length = 0;        ListNode temp = head;        ListNode pre = new ListNode(0, head);        while (temp != null)        &#123;            ++length;            temp = temp.next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode preCur = pre;            ListNode cur = pre.next;            while (cur != null)            &#123;                ListNode node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur.next != null; ++i) cur = cur.next;                ListNode node2 = cur.next;                cur.next = null;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != null &amp;&amp; cur.next !=null; ++i) cur = cur.next;                ListNode next = null;                if (cur != null)                &#123;                    next = cur.next;                    cur.next = null;                    cur = next;                &#125;                preCur.next = MergeTwoLists(node1, node2);                while (preCur.next != null) preCur = preCur.next;            &#125;        &#125;        return pre.next;    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;\nclass Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None): return head        length = 0        temp = head        pre = ListNode(0, head)        while (temp != None):            length += 1            temp = temp.next        sub = 1        while (sub &lt; length):            preCur = pre            cur = pre.next            while (cur != None):                node1 = cur                for i in range(1, sub):                    if cur.next:                        cur = cur.next                    else:                        break                node2 = cur.next                cur.next = None                cur = node2                for i in range(1, sub):                    if cur and cur.next:                        cur = cur.next                    else:                        break                next = None                if (cur != None):                    next = cur.next                    cur.next = None                    cur = next                preCur.next = self.MergeTwoLists(node1, node2)                while (preCur.next != None): preCur = preCur.next            sub *= 2        return pre.next    def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)\t\t\t# 没有new        cur = preNode        if not list1:\t\t\t# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next\n\n二：LRU缓存\n\n1. 哈希表+双向链表\n使用哈希表保存键和双向链表的节点，节点保存键值和前后指针，这样每个操作都为常数\nclass LRUCache &#123;private:struct DoubleList&#123;    int key;    int value;    DoubleList* pre;    DoubleList* next;    DoubleList() : key(0), value(0), pre(nullptr), next(nullptr) &#123;&#125;    DoubleList(int _key, int _value) : key(_key), value(_value), pre(nullptr), next(nullptr) &#123;&#125;&#125;;public:    unordered_map&lt;int, DoubleList*&gt; hashMap;    DoubleList* head;    DoubleList* tail;    int capacity = 0;    int size = 0;    LRUCache(int capacity) &#123;        this-&gt;capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head-&gt;next = tail;        tail-&gt;pre = head;    &#125;        int get(int key) &#123;        if (hashMap.count(key) == false) return -1;        else        &#123;            DoubleList* cur = hashMap[key];            AddToHead(DeleteNode(cur));            return cur-&gt;value;        &#125;    &#125;        void put(int key, int value) &#123;        if (hashMap.count(key) == false)        &#123;            DoubleList* newNode = new DoubleList(key, value);            hashMap[key] = newNode;            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList* deleteNode = DeleteNode(tail-&gt;pre);                hashMap.erase(deleteNode-&gt;key);                delete deleteNode;                --size;            &#125;        &#125; else        &#123;            DoubleList* cur = hashMap[key];            cur-&gt;value = value;            AddToHead(DeleteNode(cur));        &#125;    &#125;    DoubleList* DeleteNode(DoubleList* node)    &#123;        node-&gt;next-&gt;pre = node-&gt;pre;        node-&gt;pre-&gt;next = node-&gt;next;        return node;    &#125;    void AddToHead(DoubleList* node)    &#123;        node-&gt;pre = head;        node-&gt;next = head-&gt;next;        head-&gt;next = node;        node-&gt;next-&gt;pre = node;    &#125;&#125;;\nclass LRUCache &#123;    class DoubleList    &#123;        int key;        int value;        DoubleList pre;        DoubleList next;        public DoubleList() &#123;&#125;        public DoubleList(int _key, int _value) &#123;key = _key; value = _value;&#125;    &#125;    Map&lt;Integer, DoubleList&gt; hashMap = new HashMap&lt;&gt;();    DoubleList head;    DoubleList tail;    int capacity = 0;    int size = 0;    public LRUCache(int capacity) &#123;        this.capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head.next = tail;        tail.pre = head;    &#125;        public int get(int key) &#123;        if (hashMap.containsKey(key) == false) return -1;        else        &#123;            DoubleList cur = hashMap.get(key);            AddToHead(DeleteNode(cur));            return cur.value;        &#125;    &#125;        public void put(int key, int value) &#123;        if (hashMap.containsKey(key) == false)        &#123;            DoubleList newNode = new DoubleList(key, value);            hashMap.put(key, newNode);            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList deleteNode = DeleteNode(tail.pre);                hashMap.remove(deleteNode.key);                --size;            &#125;        &#125; else        &#123;            DoubleList cur = hashMap.get(key);            cur.value = value;            AddToHead(DeleteNode(cur));        &#125;     &#125;    public DoubleList DeleteNode(DoubleList node)    &#123;        node.next.pre = node.pre;        node.pre.next = node.next;        return node;    &#125;    public void AddToHead(DoubleList node)    &#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;&#125;\nclass LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.size = 0        self.hashMap = dict()        self.head = DoubleList()        self.tail = DoubleList()        self.head.next = self.tail        self.tail.prev = self.head    def get(self, key: int) -&gt; int:        if (key not in self.hashMap): return -1        else:            cur = self.hashMap[key]            self.AddToHead(self.DeleteNode(cur))            return cur.value    def put(self, key: int, value: int) -&gt; None:        if (key not in self.hashMap):            newNode = DoubleList(key, value)            self.hashMap[key] = newNode            self.AddToHead(newNode)            self.size += 1            if (self.size &gt; self.capacity):                   deleteNode = self.DeleteNode(self.tail.pre)                self.hashMap.pop(deleteNode.key)                self.size -= 1        else:            cur = self.hashMap[key]            cur.value = value            self.AddToHead(self.DeleteNode(cur))    def DeleteNode(self, node):        node.next.pre = node.pre        node.pre.next = node.next        return node    def AddToHead(self, node):        node.pre = self.head        node.next = self.head.next        self.head.next = node        node.next.pre = nodeclass DoubleList:    def __init__(self, key = 0, value = 0):        self.key = key        self.value = value        self.prev = None        self.next = None\n\n三：二叉树的层序遍历\n\n1. 广度优先搜索\n用队列表示每一层，逐层遍历\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if (root == nullptr) return result;        queue&lt;TreeNode*&gt; queueTree;        queueTree.push(root);        while (queueTree.empty() == false)        &#123;            int size = queueTree.size();            result.emplace_back(vector&lt;int&gt;());            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode* newNode = queueTree.front();                queueTree.pop();                result.back().emplace_back(newNode-&gt;val);                if (newNode-&gt;left) queueTree.push(newNode-&gt;left);                if (newNode-&gt;right) queueTree.push(newNode-&gt;right);              &#125;        &#125;        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if (root == null) return result;        Queue&lt;TreeNode&gt; queueTree = new LinkedList&lt;&gt;();        queueTree.offer(root);        while (queueTree.isEmpty() == false)        &#123;            int size = queueTree.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode newNode = queueTree.poll();                level.add(newNode.val);                if (newNode.left != null) queueTree.offer(newNode.left);                if (newNode.right != null) queueTree.offer(newNode.right);              &#125;            result.add(level);        &#125;        return result;    &#125;&#125;\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        result = []        if (root == None): return result        queueTree = deque([root])        while (queueTree):            size = len(queueTree)            level = []            for _ in range(size):                newNode = queueTree.popleft()                level.append(newNode.val)                if (newNode.left != None): queueTree.append(newNode.left)                if (newNode.right != None): queueTree.append(newNode.right)              result.append(level)        return result\n\n四：验证二叉搜索树\n\n1. 递归\n参考二叉树的中序遍历的递归写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        return recursion(root, LONG_MIN, LONG_MAX);    &#125;    bool recursion(TreeNode* node, long long min, long long max)    &#123;        if (node == nullptr) return true;        if (node-&gt;val &lt;= min || node-&gt;val &gt;= max) return false;        bool flagLeft = recursion(node-&gt;left, min, node-&gt;val);        bool flagRight = recursion(node-&gt;right, node-&gt;val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public boolean recursion(TreeNode node, long min, long max)    &#123;        if (node == null) return true;        if (node.val &lt;= min || node.val &gt;= max) return false;        boolean flagLeft = recursion(node.left, min, node.val);        boolean flagRight = recursion(node.right, node.val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def recursion(node, min, max):            if (node == None): return True            if (node.val &lt;= min or node.val &gt;= max): return False            flagLeft = recursion(node.left, min, node.val)            flagRight = recursion(node.right, node.val, max)            return flagLeft and flagRight        return recursion(root, float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;))\n\n2. 中序遍历\n参考二叉树的中序遍历的迭代写法，这里多了对数据大小的判断\nclass Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        long long min = (long long)INT_MIN - 1;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            treeStack.pop();                    // 拿到数据出栈            if (root -&gt; val &lt;= min) return false;            min = root -&gt; val;            root = root-&gt;right;       &#125;        return true;    &#125;&#125;;\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            if (root.val &lt;= min) return false;            min = root.val;            root = root.right;        &#125;        return true;    &#125;&#125;\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        treeStack = []        min = float(&#x27;-inf&#x27;)        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            if (root.val &lt;= min): return False            min = root.val            root = root.right        return True\n\n五：二叉搜索树中第 K 小的元素\n\n1. 中序遍历\n利用中序遍历得到有序数组，找到数组中的第K个元素即可。迭代用栈管理，栈弹出的顺序就是有序列表，因此第K个就是需要的值\nclass Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())              &#123;            while (root != nullptr)            &#123;                treeStack.push(root);                       root = root-&gt;left;            &#125;            root = treeStack.top();                   treeStack.pop();                    // 第一个出栈的为最小元素，出栈k次即可得到结果            --k;            if (k == 0) break;             root = root-&gt;right;       &#125;        return root-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            --k;            if (k == 0) break;            root = root.right;        &#125;        return root.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            k -= 1            if (k == 0): break            root = root.right        return root.val\n\n2. 记录子树的节点\n把每个节点的左右子树的节点数量记录，此时只需要判断k与子树节点数量的大小，因为左子树一定小于当前节点，右子树大于当前节点。适用于频繁寻找k值\nclass Solution &#123;public:    unordered_map&lt;TreeNode*, int&gt; hashMap;    TreeNode* root;    int kthSmallest(TreeNode* root, int k) &#123;        this-&gt;root = root;        CountNum(root);        return SearchTarget(k);    &#125;    int CountNum(TreeNode* node)    &#123;        if (node == nullptr) return 0;        hashMap[node] = 1 + CountNum(node-&gt;left) + CountNum(node-&gt;right);        return hashMap[node];    &#125;    int GetNum(TreeNode* node)    &#123;        if (node != nullptr &amp;&amp; hashMap.count(node)) return hashMap[node];        else return 0;    &#125;    int SearchTarget(int k)    &#123;        TreeNode* node = root;        while (node != nullptr)        &#123;            int leftNum = GetNum(node-&gt;left);            if (leftNum &lt; k - 1)            &#123;                node = node-&gt;right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node-&gt;left;            else break;        &#125;        return node-&gt;val;    &#125;&#125;;\nclass Solution &#123;    public Map&lt;TreeNode, Integer&gt; hashMap = new HashMap&lt;&gt;();    public TreeNode root;    public int kthSmallest(TreeNode root, int k) &#123;        this.root = root;        CountNum(root);        return SearchTarget(k);    &#125;    public int CountNum(TreeNode node)    &#123;        if (node == null) return 0;        hashMap.put(node, 1 + CountNum(node.left) + CountNum(node.right));        return hashMap.get(node);    &#125;    public int GetNum(TreeNode node)    &#123;        if (node != null &amp;&amp; hashMap.containsKey(node)) return hashMap.get(node);        else return 0;    &#125;    public int SearchTarget(int k)    &#123;        TreeNode node = root;        while (node != null)        &#123;            int leftNum = GetNum(node.left);            if (leftNum &lt; k - 1)            &#123;                node = node.right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node.left;            else break;        &#125;        return node.val;    &#125;&#125;\nclass Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        self.hashMap = &#123;&#125;        self.root = root        self.CountNum(self.root)        return self.SearchTarget(k)    def CountNum(self, node):        if (node == None): return 0        self.hashMap[node] = 1 + self.CountNum(node.left) + self.CountNum(node.right)        return self.hashMap[node]    def GetNum(self, node):        if (node != None and node in self.hashMap): return self.hashMap[node]        else: return 0    def SearchTarget(self, k):        node = self.root        while (node != None):            leftNum = self.GetNum(node.left)            if (leftNum &lt; k - 1):                node = node.right                k -= leftNum + 1            elif (leftNum &gt; k - 1): node = node.left            else: break        return node.val\n\n3. 平衡二叉搜索树\n官方给的题解太长了，使用了经典的AVL树数据结构，并添加了一些常用的操作，没必要，简化一下吧\nstruct Node &#123;    int val;    Node * parent;    Node * left;    Node * right;    int size;    int height;    Node(int val, Node * parent) &#123;        this-&gt;val = val;        this-&gt;parent = parent;        this-&gt;left = nullptr;        this-&gt;right = nullptr;        this-&gt;height = 0;         this-&gt;size = 1;     &#125;&#125;;class AVL &#123;public:    Node * root;    AVL(vector&lt;int&gt; &amp; vals) &#123;        if (!vals.empty()) &#123;            root = build(vals, 0, vals.size() - 1, nullptr);        &#125;    &#125;    Node * build(vector&lt;int&gt; &amp; vals, int l, int r, Node * parent) &#123;        int m = (l + r) &gt;&gt; 1;        Node * node = new Node(vals[m], parent);        if (l &lt;= m - 1) &#123;            node-&gt;left = build(vals, l, m - 1, node);        &#125;        if (m + 1 &lt;= r) &#123;            node-&gt;right = build(vals, m + 1, r, node);        &#125;        recompute(node);        return node;    &#125;    void recompute(Node * node) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));        node-&gt;size = 1 + getSize(node-&gt;left) + getSize(node-&gt;right);    &#125;    static int getHeight(Node * node) &#123;        return node != nullptr ? node-&gt;height : 0;    &#125;    static int getSize(Node * node) &#123;        return node != nullptr ? node-&gt;size : 0;    &#125;    int kthSmallest(int k) &#123;        Node * node = root;        while (node != nullptr) &#123;            int left = getSize(node-&gt;left);            if (left &lt; k - 1) &#123;                node = node-&gt;right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node-&gt;left;            &#125;        &#125;        return node-&gt;val;    &#125;&#125;;class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        vector&lt;int&gt; inorderList;        inorder(root, inorderList);        AVL avl(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode * node, vector&lt;int&gt; &amp; inorderList) &#123;        if (node-&gt;left != nullptr) &#123;            inorder(node-&gt;left, inorderList);        &#125;        inorderList.push_back(node-&gt;val);        if (node-&gt;right != nullptr) &#123;            inorder(node-&gt;right, inorderList);        &#125;    &#125;&#125;;\nclass Node &#123;    int val;    Node parent;    Node left;    Node right;    int size;    int height;    Node(int val, Node parent) &#123;        this.val = val;        this.parent = parent;        this.left = null;        this.right = null;        this.height = 0;         this.size = 1;     &#125;&#125;class AVL &#123;    Node root;    AVL(List&lt;Integer&gt; vals) &#123;        if (!vals.isEmpty()) &#123;            root = build(vals, 0, vals.size() - 1, null);        &#125;    &#125;    Node build(List&lt;Integer&gt; vals, int l, int r, Node parent) &#123;        if (l &gt; r) &#123;            return null;        &#125;        int m = l + (r - l) / 2;        Node node = new Node(vals.get(m), parent);        node.left = build(vals, l, m - 1, node);        node.right = build(vals, m + 1, r, node);                recompute(node);        return node;    &#125;    void recompute(Node node) &#123;        if (node == null) return;        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));        node.size = 1 + getSize(node.left) + getSize(node.right);    &#125;    static int getHeight(Node node) &#123;        return node != null ? node.height : 0;    &#125;    static int getSize(Node node) &#123;        return node != null ? node.size : 0;    &#125;    int kthSmallest(int k) &#123;        Node node = root;        while (node != null) &#123;            int left = getSize(node.left);            if (left &lt; k - 1) &#123;                node = node.right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node.left;            &#125;        &#125;        return node.val;    &#125;&#125;class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        List&lt;Integer&gt; inorderList = new ArrayList&lt;&gt;();        inorder(root, inorderList);                if (inorderList.isEmpty() || k &lt;= 0 || k &gt; inorderList.size()) &#123;            return -1;        &#125;        AVL avl = new AVL(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode node, List&lt;Integer&gt; inorderList) &#123;        if (node == null) &#123;            return;        &#125;        inorder(node.left, inorderList);        inorderList.add(node.val);        inorder(node.right, inorderList);    &#125;&#125;\nclass Node:    def __init__(self, val: int, parent: Optional[&#x27;Node&#x27;] = None):        self.val = val        self.parent = parent        self.left = None        self.right = None        self.height = 0        self.size = 1class AVL:    def __init__(self, vals: List[int]):        self.root: Optional[Node] = None        if vals:            self.root = self.build(vals, 0, len(vals) - 1, None)    def build(self, vals: List[int], l: int, r: int, parent: Optional[Node]) -&gt; Optional[Node]:        if l &gt; r:            return None                m = (l + r) // 2        node = Node(vals[m], parent)                node.left = self.build(vals, l, m - 1, node)        node.right = self.build(vals, m + 1, r, node)                self.recompute(node)        return node    def recompute(self, node: Node):        if node is None:            return                    left_height = AVL.get_height(node.left)        right_height = AVL.get_height(node.right)                node.height = 1 + max(left_height, right_height)        node.size = 1 + AVL.get_size(node.left) + AVL.get_size(node.right)    @staticmethod    def get_height(node: Optional[Node]) -&gt; int:        return node.height if node else 0    @staticmethod    def get_size(node: Optional[Node]) -&gt; int:        return node.size if node else 0    def kthSmallest(self, k: int) -&gt; int:        node = self.root        while node:            left_size = AVL.get_size(node.left)                        if left_size &lt; k - 1:                k -= left_size + 1                node = node.right            elif left_size == k - 1:                return node.val            else:                node = node.left                return -1class Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        inorder_list: List[int] = []        self._inorder(root, inorder_list)                if not inorder_list or k &lt;= 0 or k &gt; len(inorder_list):            return -1                    avl = AVL(inorder_list)        return avl.kthSmallest(k)    def _inorder(self, node: Optional[TreeNode], inorder_list: List[int]):        if node is None:            return                    self._inorder(node.left, inorder_list)        inorder_list.append(node.val)        self._inorder(node.right, inorder_list)\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.8)","url":"/posts/fa020b85/","content":"一：二叉树的右视图\n\n1. 深度优先搜索\n通过另一个深度栈来维护每一层唯一的可见值，这个值为后添加的右节点\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        stack&lt;TreeNode*&gt; stk;        stack&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.top();            stk.pop();            int depth = stkDepth.top(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                if (hashMap.count(depth) == false) hashMap[depth] = node-&gt;val;                stk.push(node-&gt;left);                stk.push(node-&gt;right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Deque&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.pop();            int depth = stkDepth.pop();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                if (hashMap.containsKey(depth) == false) hashMap.put(depth, node.val);                stk.push(node.left);                stk.push(node.right);      // 优先弹出右节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        stack = [(root, 1)]        while stack:            node, depth = stack.pop()            if (node != None):                maxDepth = max(maxDepth, depth)                if (depth not in hashMap): hashMap[depth] = node.val                    stack.append((node.left, depth + 1))                stack.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n2. 广度优先搜索\n类似于深度，这里使用队列执行先进先出，因此从左节点开始向右遍历\nclass Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        unordered_map&lt;int, int&gt; hashMap;        queue&lt;TreeNode*&gt; stk;        queue&lt;int&gt; stkDepth;        int maxDepth = 0;        stk.push(root);        stkDepth.push(1);        while (stk.empty() == false)        &#123;            TreeNode* node = stk.front();            stk.pop();            int depth = stkDepth.front(); stkDepth.pop();            if (node != nullptr)            &#123;                maxDepth = max(maxDepth, depth);                hashMap[depth] = node-&gt;val;\t\t\t// 最后一个节点为可见节点                stk.push(node-&gt;left);                stk.push(node-&gt;right);      \t\t// 先弹出左节点                stkDepth.push(depth + 1);                stkDepth.push(depth + 1);            &#125;        &#125;        vector&lt;int&gt; result;        for (int i = 1; i &lt;= maxDepth; ++i) result.emplace_back(hashMap[i]);        return result;    &#125;&#125;;\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        Queue&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; stkDepth = new LinkedList&lt;&gt;();        int maxDepth = 0;        stk.add(root);        stkDepth.add(1);        while (stk.isEmpty() == false)        &#123;            TreeNode node = stk.remove();            int depth = stkDepth.remove();            if (node != null)            &#123;                maxDepth = Math.max(maxDepth, depth);                hashMap.put(depth, node.val);                stk.add(node.left);                stk.add(node.right);      // 优先弹出右节点                stkDepth.add(depth + 1);                stkDepth.add(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= maxDepth; ++i) result.add(hashMap.get(i));        return result;    &#125;&#125;\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        hashMap = dict()        maxDepth = 0        queue = deque([(root, 1)])        while queue:            node, depth = queue.popleft()            if (node != None):                maxDepth = max(maxDepth, depth)                hashMap[depth] = node.val                    queue.append((node.left, depth + 1))                queue.append((node.right, depth + 1))        result = []        for i in range(1, maxDepth + 1): result.append(hashMap[i])        return result\n\n二：二叉树展开为链表\n\n1. 前序遍历\n前序遍历得到所有节点的数组，然后逐一构建\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        vector&lt;TreeNode*&gt; listTree;        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode* pre = listTree[i - 1];            TreeNode* cur = listTree[i];            pre-&gt;right = cur;            pre-&gt;left = nullptr;        &#125;    &#125;    void PreOrder(TreeNode* node, vector&lt;TreeNode*&gt;&amp; listTree)    &#123;        if (node != nullptr)         &#123;            listTree.emplace_back(node);            PreOrder(node-&gt;left, listTree);            PreOrder(node-&gt;right, listTree);        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        List&lt;TreeNode&gt; listTree = new ArrayList&lt;&gt;();        PreOrder(root, listTree);        for (int i = 1; i &lt; listTree.size(); ++i)        &#123;            TreeNode pre = listTree.get(i - 1);            TreeNode cur = listTree.get(i);            pre.right = cur;            pre.left = null;        &#125;    &#125;    public void PreOrder(TreeNode node, List&lt;TreeNode&gt; listTree)    &#123;        if (node != null)         &#123;            listTree.add(node);            PreOrder(node.left, listTree);            PreOrder(node.right, listTree);        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        listTree = list()        self.PreOrder(root, listTree)        for i in range(1, len(listTree)):            pre = listTree[i - 1]            cur = listTree[i]            pre.right = cur            pre.left = None    def PreOrder(self, node, listTree):        if (node != None):            listTree.append(node)            self.PreOrder(node.left, listTree)            self.PreOrder(node.right, listTree)\n\n2. 前序遍历和展开同步进行\n不使用额外数组，使用栈来使遍历和创建新链表同时进行\nclass Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        stack&lt;TreeNode*&gt; stk;        stk.push(root);        TreeNode* pre = nullptr;        while (stk.empty() == false)        &#123;            TreeNode* cur = stk.top();            stk.pop();            if (pre != nullptr)            &#123;                pre-&gt;left = nullptr;                pre-&gt;right = cur;            &#125;            if (cur-&gt;right != nullptr) stk.push(cur-&gt;right);     // 先进右节点出栈可以先处理左节点            if (cur-&gt;left != nullptr) stk.push(cur-&gt;left);            pre = cur;        &#125;    &#125;&#125;;\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();        stk.push(root);        TreeNode pre = null;        while (stk.isEmpty() == false)        &#123;            TreeNode cur = stk.pop();            if (pre != null)            &#123;                pre.left = null;                pre.right = cur;            &#125;            if (cur.right != null) stk.push(cur.right);     // 先进右节点出栈可以先处理左节点            if (cur.left != null) stk.push(cur.left);            pre = cur;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        stk = [root]        pre = None        while (stk):            cur = stk.pop()            if (pre != None):                pre.left = None                pre.right = cur            if (cur.right != None): stk.append(cur.right)                 if (cur.left != None): stk.append(cur.left)            pre = cur\n\n3. 寻找前驱节点\n这个方法有点类似于二叉树的中序遍历中的Morris方法，通过将左子树最后的右节点指向当前节点的右节点，从而建立连接关系，相当于更改了当前链表的结构\n */class Solution &#123;public:    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        auto cur = root;        while (cur != nullptr)        &#123;            if (cur-&gt;left != nullptr)            &#123;                auto node = cur-&gt;left;                auto next = node;                while (node-&gt;right != nullptr) node = node-&gt;right;      // 一直右移找到当前节点的前继结点                node-&gt;right = cur-&gt;right;                cur-&gt;left = nullptr;                cur-&gt;right = next;            &#125;            cur = cur-&gt;right;        &#125;    &#125;&#125;;\t\nclass Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) return;        TreeNode cur = root;        while (cur != null)        &#123;            if (cur.left != null)            &#123;                TreeNode node = cur.left;                TreeNode next = node;                while (node.right != null) node = node.right;      // 一直右移找到当前节点的前继结点                node.right = cur.right;                cur.left = null;                cur.right = next;            &#125;            cur = cur.right;        &#125;    &#125;&#125;\nclass Solution:    def flatten(self, root: Optional[TreeNode]) -&gt; None:        if (root == None): return        cur = root        while (cur != None):            if (cur.left != None):                node = cur.left                next = node                while (node.right != None): node = node.right                     node.right = cur.right                cur.left = None                cur.right = next            cur = cur.right\n\n三：从前序与中序遍历序列构造二叉树\n\n1. 递归\n通过前序遍历找到中序遍历的根节点，然后左右划分依次递归，需要先处理左边，因为先序遍历根节点之后是左子树\nclass Solution &#123;private:    unordered_map&lt;int, int&gt; index;public:    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return nullptr;        &#125;        int preorder_root = preorder_left;        int inorder_root = index[preorder[preorder_root]];        TreeNode* root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int n = preorder.size();        for (int i = 0; i &lt; n; ++i) &#123;            index[inorder[i]] = i;        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;\nclass Solution &#123;    private Map&lt;Integer, Integer&gt; indexMap;    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        if (preorder_left &gt; preorder_right) &#123;            return null;        &#125;        int preorder_root = preorder_left;        int inorder_root = indexMap.get(preorder[preorder_root]);        TreeNode root = new TreeNode(preorder[preorder_root]);        int size_left_subtree = inorder_root - inorder_left;        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n = preorder.length;        indexMap = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; n; i++) &#123;            indexMap.put(inorder[i], i);        &#125;        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):            if preorder_left &gt; preorder_right:                return None            preorder_root = preorder_left            inorder_root = index[preorder[preorder_root]]            root = TreeNode(preorder[preorder_root])            size_left_subtree = inorder_root - inorder_left            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)            return root        n = len(preorder)        index = &#123;element: i for i, element in enumerate(inorder)&#125;        return myBuildTree(0, n - 1, 0, n - 1)\n\n2. 迭代\n这个解法巧妙的利用了先序和中序的特点，先序从根节点先到达最后一个左节点，中序则从最后一个左节点开始，当先序的某个节点和中序的第一个相等意味着当前节点的左子树结束，此时用栈来维护没有处理右子树的节点即可\nclass Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if (!preorder.size()) &#123;            return nullptr;        &#125;        TreeNode* root = new TreeNode(preorder[0]);        stack&lt;TreeNode*&gt; stk;        stk.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.size(); ++i) &#123;            int preorderVal = preorder[i];            TreeNode* node = stk.top();            if (node-&gt;val != inorder[inorderIndex]) &#123;                node-&gt;left = new TreeNode(preorderVal);                stk.push(node-&gt;left);            &#125;            else &#123;                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;                    node = stk.top();                    stk.pop();                    ++inorderIndex;                &#125;                node-&gt;right = new TreeNode(preorderVal);                stk.push(node-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;;\nclass Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if (preorder == null || preorder.length == 0) &#123;            return null;        &#125;        TreeNode root = new TreeNode(preorder[0]);        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();        stack.push(root);        int inorderIndex = 0;        for (int i = 1; i &lt; preorder.length; i++) &#123;            int preorderVal = preorder[i];            TreeNode node = stack.peek();            if (node.val != inorder[inorderIndex]) &#123;                node.left = new TreeNode(preorderVal);                stack.push(node.left);            &#125; else &#123;                while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;                    node = stack.pop();                    inorderIndex++;                &#125;                node.right = new TreeNode(preorderVal);                stack.push(node.right);            &#125;        &#125;        return root;    &#125;&#125;\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None        root = TreeNode(preorder[0])        stack = [root]        inorderIndex = 0        for i in range(1, len(preorder)):            preorderVal = preorder[i]            node = stack[-1]            if node.val != inorder[inorderIndex]:                node.left = TreeNode(preorderVal)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[inorderIndex]:                    node = stack.pop()                    inorderIndex += 1                node.right = TreeNode(preorderVal)                stack.append(node.right)        return root\n\n四：路径总和 III\n\n1. 深度优先搜索\nclass Solution &#123;public:    int rootSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, long targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = rootSum(root, targetSum);        ret += pathSum(root.left, targetSum);        ret += pathSum(root.right, targetSum);        return ret;    &#125;    public int rootSum(TreeNode root, long targetSum) &#123;        int ret = 0;        if (root == null) &#123;            return 0;        &#125;        int val = root.val;        if (val == targetSum) &#123;            ret++;        &#125;         ret += rootSum(root.left, targetSum - val);        ret += rootSum(root.right, targetSum - val);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        def rootSum(root, targetSum):            if root is None:                return 0            ret = 0            if root.val == targetSum:                ret += 1            ret += rootSum(root.left, targetSum - root.val)            ret += rootSum(root.right, targetSum - root.val)            return ret                if root is None:            return 0                    ret = rootSum(root, targetSum)        ret += self.pathSum(root.left, targetSum)        ret += self.pathSum(root.right, targetSum)        return ret\n\n2. 前缀和\nclass Solution &#123;public:    unordered_map&lt;long long, int&gt; prefix;    int dfs(TreeNode *root, long long curr, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        curr += root-&gt;val;        if (prefix.count(curr - targetSum)) &#123;            ret = prefix[curr - targetSum];        &#125;        prefix[curr]++;        ret += dfs(root-&gt;left, curr, targetSum);        ret += dfs(root-&gt;right, curr, targetSum);        prefix[curr]--;        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        prefix[0] = 1;        return dfs(root, 0, targetSum);    &#125;&#125;;\nclass Solution &#123;    public int pathSum(TreeNode root, int targetSum) &#123;        Map&lt;Long, Integer&gt; prefix = new HashMap&lt;Long, Integer&gt;();        prefix.put(0L, 1);        return dfs(root, prefix, 0, targetSum);    &#125;    public int dfs(TreeNode root, Map&lt;Long, Integer&gt; prefix, long curr, int targetSum) &#123;        if (root == null) &#123;            return 0;        &#125;        int ret = 0;        curr += root.val;        ret = prefix.getOrDefault(curr - targetSum, 0);        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);        ret += dfs(root.left, prefix, curr, targetSum);        ret += dfs(root.right, prefix, curr, targetSum);        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);        return ret;    &#125;&#125;\nclass Solution:    def pathSum(self, root: TreeNode, targetSum: int) -&gt; int:        prefix = collections.defaultdict(int)        prefix[0] = 1        def dfs(root, curr):            if not root:                return 0            ret = 0            curr += root.val            ret += prefix[curr - targetSum]            prefix[curr] += 1            ret += dfs(root.left, curr)            ret += dfs(root.right, curr)            prefix[curr] -= 1            return ret        return dfs(root, 0)\n\n五：二叉树的最近公共祖先\n\n1. 递归\nclass Solution &#123;public:    TreeNode* ans;    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root == nullptr) return false;        bool lson = dfs(root-&gt;left, p, q);        bool rson = dfs(root-&gt;right, p, q);        if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        dfs(root, p, q);        return ans;    &#125;&#125;;\nclass Solution &#123;    private TreeNode ans;    public Solution() &#123;        this.ans = null;    &#125;    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) &#123;        if (root == null) return false;        boolean lson = dfs(root.left, p, q);        boolean rson = dfs(root.right, p, q);        if ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         return lson || rson || (root.val == p.val || root.val == q.val);    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        this.dfs(root, p, q);        return this.ans;    &#125;&#125;\nclass Solution:    def __init__(self):        self.ans = None    def dfs(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; bool:        if not root:            return False        lson = self.dfs(root.left, p, q)        rson = self.dfs(root.right, p, q)        if (lson and rson) or ((root.val == p.val or root.val == q.val) and (lson or rson)):            self.ans = root        return lson or rson or (root.val == p.val or root.val == q.val)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.dfs(root, p, q)        return self.ans\n\n2. 存储父节点\nclass Solution &#123;public:    unordered_map&lt;int, TreeNode*&gt; fa;    unordered_map&lt;int, bool&gt; vis;    void dfs(TreeNode* root)&#123;        if (root-&gt;left != nullptr) &#123;            fa[root-&gt;left-&gt;val] = root;            dfs(root-&gt;left);        &#125;        if (root-&gt;right != nullptr) &#123;            fa[root-&gt;right-&gt;val] = root;            dfs(root-&gt;right);        &#125;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        fa[root-&gt;val] = nullptr;        dfs(root);        while (p != nullptr) &#123;            vis[p-&gt;val] = true;            p = fa[p-&gt;val];        &#125;        while (q != nullptr) &#123;            if (vis[q-&gt;val]) return q;            q = fa[q-&gt;val];        &#125;        return nullptr;    &#125;&#125;;\nclass Solution &#123;    Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();    Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();    public void dfs(TreeNode root) &#123;        if (root.left != null) &#123;            parent.put(root.left.val, root);            dfs(root.left);        &#125;        if (root.right != null) &#123;            parent.put(root.right.val, root);            dfs(root.right);        &#125;    &#125;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        dfs(root);        while (p != null) &#123;            visited.add(p.val);            p = parent.get(p.val);        &#125;        while (q != null) &#123;            if (visited.contains(q.val)) &#123;                return q;            &#125;            q = parent.get(q.val);        &#125;        return null;    &#125;&#125;\nclass Solution:    def __init__(self):        self.fa = &#123;&#125;        self.visited = set()    def dfs(self, root: &#x27;TreeNode&#x27;):        if root.left:            self.fa[root.left.val] = root            self.dfs(root.left)        if root.right:            self.fa[root.right.val] = root            self.dfs(root.right)    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        self.fa[root.val] = None  # 根节点没有父节点        self.dfs(root)        while p:            self.visited.add(p.val)            p = self.fa.get(p.val) # 使用.get()避免键不存在时出错        while q:            if q.val in self.visited:                return q            q = self.fa.get(q.val)        return None\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"LeetCode热题100(25.10.9)","url":"/posts/e3193ac4/","content":"一：岛屿数量\n假期结束了，没有足够时间刷题了，因此往后只采用一种语言解题，方法还是向官方看齐\n\n1. 深度优先搜索\n遍历所有元素，然后将该元素的周围为1的元素设为0，依次递归，直到下一次循环\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    recursion(grid, i, j);      // 当前位置                &#125;            &#125;        return num;    &#125;    void recursion(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)    &#123;        grid[i][j] = 0;     // 访问过的点设为0        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;) recursion(grid, i - 1, j);     // 遍历上下左右四个点        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;) recursion(grid, i, j - 1);        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;) recursion(grid, i + 1, j);        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;) recursion(grid, i, j + 1);    &#125;&#125;;\n\n2. 广度优先搜索\n广度使用队列来维护节点，优先处理队列顶端的前后左右四个元素\nclass Solution &#123;public:    int row = 0;    int col = 0;    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        row = grid.size();        if (row == 0) return num;        col = grid[0].size();        if (col == 0) return num;        queue&lt;pair&lt;int, int&gt;&gt; queueNum;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    ++num;                    grid[i][j] = &#x27;0&#x27;;                    queueNum.push(pair(i, j));                    while (!queueNum.empty())                    &#123;                        auto cur = queueNum.front();                        queueNum.pop();                        int i = cur.first;                        int j = cur.second;                        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i - 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i - 1, j));                        &#125;                        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j - 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j - 1));                        &#125;                        if (i + 1 &lt; row &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;)                        &#123;                            grid[i + 1][j] = &#x27;0&#x27;;                            queueNum.push(pair(i + 1, j));                        &#125;                        if (j + 1 &lt; col &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;)                        &#123;                            grid[i][j + 1] = &#x27;0&#x27;;                            queueNum.push(pair(i, j + 1));                        &#125;                    &#125;                &#125;        return num;    &#125;&#125;;\n\n3. 并查集\n这个数据结构就是为了处理这种“查询两个元素是否属于同一集合”和“合并两个元素所在的集合”的操作而生的。parent.push_back(i * n + j)将每个元素的父节点保存\nclass UnionFind&#123;public:    vector&lt;int&gt; parent;     // 记录父节点    vector&lt;int&gt; depth;      // 记录节点深度    int count = 0;          // 记录独立森林数    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid)       // 初始化森林和父节点列表    &#123;        int row = grid.size();        int col = grid[0].size();        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == &#x27;1&#x27;)                &#123;                    parent.emplace_back(i * col + j);       // 父节点为自己                    ++count;            // 森林数量+1                &#125;                else parent.emplace_back(-1);        // 无父节点                depth.emplace_back(0);           // 深度为1            &#125;    &#125;    int Find(int i)          // 查找父节点    &#123;        if (parent[i] != i) parent[i] = Find(parent[i]);        // 父节点不是本身，向上查找        return parent[i];    &#125;    void Unite(int x, int y)            // 联合    &#123;        x = Find(x);                y = Find(y);        if (x != y)     // 两者父节点不相同，相同节点不必处理        &#123;            if (depth[x] &lt; depth[y]) parent[x] = y;           // 深度浅接到深度深的节点，方便查找            else if (depth[x] &gt; depth[y]) parent[y] = x;            else parent[x] = y;            --count;            x &gt; y ? ++depth[y] : ++depth[x];        &#125;    &#125;&#125;;class Solution &#123;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int nr = grid.size();        if (!nr) return 0;        int nc = grid[0].size();        UnionFind uf(grid);        for (int r = 0; r &lt; nr; ++r)             for (int c = 0; c &lt; nc; ++c)                 if (grid[r][c] == &#x27;1&#x27;) &#123;                    grid[r][c] = &#x27;0&#x27;;           // 不需要，只是为了减少重复访问的次数                    if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r-1) * nc + c);                    if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &#x27;1&#x27;) uf.Unite(r * nc + c, (r+1) * nc + c);                    if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c - 1);                    if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &#x27;1&#x27;) uf.Unite(r * nc + c, r * nc + c + 1);                &#125;        return uf.count;    &#125;&#125;;\n\n二：腐烂的橘子\n\n1. 多源广度优先搜索\n使用栈来维护每一层，然后依次判断该层每个节点的上下左右是否被感染，因为每分钟只能感染周围\nclass Solution &#123;public:    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int time = 0;        int numFre = 0;        int row = grid.size();         int col = grid[0].size();        queue&lt;pair&lt;int, int&gt;&gt; Q;        if (row == 0 || col == 0 ) return 0;        for (int i = 0; i &lt; row; ++i)            for (int j = 0; j &lt; col; ++j)            &#123;                if (grid[i][j] == 2)                    Q.push(pair&#123;i ,j&#125;);                if (grid[i][j] == 1)                    ++numFre;            &#125;        if (numFre == 0) return 0;        while (!Q.empty())        &#123;            int size = Q.size();            ++time;            for (int i = 0; i &lt; size; ++i)            &#123;                int x = Q.front().first;                int y = Q.front().second;                Q.pop();                if (x - 1 &gt;= 0 &amp;&amp; grid[x - 1][y] == 1)                &#123;                    grid[x - 1][y] = 2;                    Q.push(pair&#123;x - 1, y&#125;);                    --numFre;                &#125;                if (x + 1 &lt; row &amp;&amp; grid[x + 1][y] == 1)                &#123;                    grid[x + 1][y] = 2;                    Q.push(pair&#123;x + 1, y&#125;);                    --numFre;                &#125;                if (y - 1 &gt;= 0 &amp;&amp; grid[x][y - 1] == 1)                &#123;                    grid[x][y - 1] = 2;                    Q.push(pair&#123;x, y - 1&#125;);                    --numFre;                &#125;                if (y + 1 &lt; col &amp;&amp; grid[x][y + 1] == 1)                &#123;                    grid[x][y + 1] = 2;                    Q.push(pair&#123;x, y + 1&#125;);                    --numFre;                &#125;            &#125;        &#125;        if (numFre != 0) return -1;        return time - 1;    &#125;&#125;;\n\n三：课程表\n\n1. 深度优先搜索\n实际上是判断该结构是否为有向无环图，使用0、1、2来表示节点的状态，再次遇到1表示存在环\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; edge;    vector&lt;int&gt; visit;    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        edge.resize(numCourses);        visit.resize(numCourses);         for (auto&amp; it : prerequisites)            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边        for (int i = 0; i &lt; numCourses; ++i)            if (visit[i] == 0)              // 未访问的节点，每一个都判断防止森林的情况                &#123;                    if (!recursion(i)) return false;                &#125;        return true;            &#125;    bool recursion(int i)    &#123;        visit[i] = 1;               // 表示正在访问，还未完成        for (auto sub : edge[i])        // 寻找子节点        &#123;            if (visit[sub] == 0)                &#123;                    if (!recursion(sub)) return false;                &#125;         // 表明子节点存在环，直接返回无需设为已完成            else if(visit[sub] == 1)      // 访问到正在访问的节点，表明出现环                return false;        &#125;        visit[i] = 2;               // 完成访问        return true;    &#125;&#125;;\n\n2. 广度优先搜索\n用队列维护没有入度的节点，然后对每个子节点的入度减一，然后添加子节点到队列，记录的子节点数量和题目要求的值相同表明可以完成课程\nclass Solution &#123;public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;vector&lt;int&gt;&gt; edge;        vector&lt;int&gt; inEdge;        edge.resize(numCourses);        inEdge.resize(numCourses);         for (auto&amp; it : prerequisites)        &#123;            edge[it[1]].emplace_back(it[0]);            // 构造节点的有向边            ++inEdge[it[0]];                    // 入边的数量        &#125;        queue&lt;int&gt; q;        int allNum = 0;        for (int i = 0; i &lt; numCourses; ++i)        // 没有入度的节点            if (inEdge[i] == 0) q.push(i);        while (!q.empty())        &#123;            ++allNum;            int cur = q.front();            q.pop();            for (auto&amp; sub : edge[cur])            &#123;                --inEdge[sub];                if (inEdge[sub] == 0) q.push(sub);            &#125;        &#125;        return allNum == numCourses;    &#125;&#125;;\n\n","categories":["算法"],"tags":["C++","LeetCode","Python","Java"]},{"title":"Modelica之带迁移的掠食者猎物方程","url":"/posts/a129a992/","content":"一、经典 LV：单区域两物种\n目标：在经典的掠食-猎物（Lotka–Volterra, LV）两物种模型上，加入区域间迁移。\n做法：把每个区域都当作一个“本地 LV 子系统”，然后用“扩散式”迁移把同类物种在相邻区域之间耦合（从高密度流向低密度），并保证总量守恒。\n最小两区域（A、B）方程：\nx˙A=αxA−βxAyA+Dx(xB−xA),y˙A=δxAyA−γyA+Dy(yB−yA),x˙B=αxB−βxByB+Dx(xA−xB),y˙B=δxByB−γyB+Dy(yA−yB).\\begin{aligned}\n\\dot x_A &amp;= \\alpha x_A - \\beta x_A y_A + D_x (x_B - x_A),\\\\\n\\dot y_A &amp;= \\delta x_A y_A - \\gamma y_A + D_y (y_B - y_A),\\\\\n\\dot x_B &amp;= \\alpha x_B - \\beta x_B y_B + D_x (x_A - x_B),\\\\\n\\dot y_B &amp;= \\delta x_B y_B - \\gamma y_B + D_y (y_A - y_B).\n\\end{aligned}\nx˙A​y˙​A​x˙B​y˙​B​​=αxA​−βxA​yA​+Dx​(xB​−xA​),=δxA​yA​−γyA​+Dy​(yB​−yA​),=αxB​−βxB​yB​+Dx​(xA​−xB​),=δxB​yB​−γyB​+Dy​(yA​−yB​).​\n\n二、代码讲解\n\n⚠️：下述代码仅代表部分功能实现的示例，并不是完整代码，完整代码后续会考虑上传至GitHub\n\n1) 接口层：Interfaces.Species\n作用：一根线同时承载两个量：种群数量（population）和对它的“作用流”（rate，flow 变量）。\nconnector Species &quot;物种连接器：传递种群数量与通量&quot;  Real population &quot;种群数量&quot;;  flow Real rate &quot;作用于种群的通量（正为流入，负为流出）&quot;;  annotation(Icon(graphics=&#123;      Rectangle(extent=&#123;&#123;-80,60&#125;,&#123;80,-60&#125;&#125;, lineColor=&#123;0,0,0&#125;, fillColor=&#123;220,220,255&#125;),      Text(extent=&#123;&#123;-80,65&#125;,&#123;80,85&#125;&#125;, string=&quot;物种&quot;, fontSize=12)&#125;),            Documentation(info=&quot;&lt;html&gt;&lt;p&gt;用于在组件之间传递“种群数量（population）”与其变化通量（rate）。&lt;/p&gt;&lt;/html&gt;&quot;));end Species;\n\n2) 基础组件：繁殖/饥饿/捕食\n\n\nReproduction（繁殖）：对单一物种，增长与数量成正比\nmodel Reproduction &quot;繁殖：增长与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real alpha &quot;出生率比例系数 α&quot;;equation  growth = alpha * species.population &quot;增长 ~ α·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;繁殖&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;繁殖项：&lt;code&gt;growth = α·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Reproduction;\n\n\nStarvation（饥饿/自然死亡）：对单一物种，衰退与数量成正比\nmodel Starvation &quot;饥饿：衰退与种群数量成正比&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.SinkOrSource;  parameter Real gamma &quot;饥饿（死亡）系数 γ&quot;;equation  decline = gamma * species.population &quot;衰退 ~ γ·种群&quot;;  annotation(Icon(graphics=&#123;    Ellipse(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,220,220&#125;, lineColor=&#123;150,0,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;饥饿&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;饥饿/自然死亡项：&lt;code&gt;decline = γ·population&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end Starvation;\n\n\nPredation（捕食）：两物种相互作用（A=猎物，B=掠食者）\nmodel Predation &quot;捕食：A为猎物，B为捕食者&quot;  extends ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Interaction;  parameter Real beta  &quot;猎物被捕食系数 β&quot;;  parameter Real delta &quot;捕食者摄食增殖系数 δ&quot;;equation  b_growth = delta * a.population * b.population &quot;B增长 ~ δ·A·B&quot;;  a_decline = beta  * a.population * b.population &quot;A衰退 ~ β·A·B&quot;;  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,40&#125;,&#123;60,-40&#125;&#125;, fillColor=&#123;255,240,200&#125;, lineColor=&#123;120,60,0&#125;),    Text(extent=&#123;&#123;-60,45&#125;,&#123;60,65&#125;&#125;, string=&quot;捕食&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;经典 Lotka–Volterra 捕食项。&lt;/p&gt;&lt;/html&gt;&quot;));end Predation;\n\n\n\n3) 区域内状态持有者：RegionalPopulation\n作用：把连接器里的 rate 积分成状态 population；这是唯一持有微分方程的地方。\nmodel RegionalPopulation &quot;区域内的单物种种群（带初始化选项）&quot;  encapsulated type InitializationOptions = enumeration(    Free &quot;自由：不施加额外初值条件&quot;,    FixedPopulation &quot;固定初值：指定初始种群&quot;,    SteadyState &quot;稳态：初始导数为0&quot;);  parameter InitializationOptions init = InitializationOptions.Free     annotation(Dialog(group=&quot;初始化&quot;));  parameter Real initial_population = 10     annotation(Dialog(group=&quot;初始化&quot;, enable=init==InitializationOptions.FixedPopulation));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species species     annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  Real population(start=initial_population) &quot;内部状态 = 外部连接器的 population&quot;;initial equation  if init == InitializationOptions.FixedPopulation then    population = initial_population;  elseif init == InitializationOptions.SteadyState then    der(population) = 0;  end if;equation  der(population) = species.rate;  species.population = population;  assert(population &gt;= 0, &quot;种群数量必须非负&quot;);  annotation(Icon(graphics=&#123;    Circle(extent=&#123;&#123;-40,40&#125;,&#123;40,-40&#125;&#125;, fillColor=&#123;200,255,200&#125;, lineColor=&#123;0,100,0&#125;),    Text(extent=&#123;&#123;-50,45&#125;,&#123;50,65&#125;&#125;, string=&quot;区域种群&quot;, fontSize=11)&#125;),    Documentation(info=&quot;&lt;html&gt;&lt;p&gt;区域内的单物种状态持有者，&lt;code&gt;der(population) = rate&lt;/code&gt;。&lt;/p&gt;&lt;/html&gt;&quot;));end RegionalPopulation;\n\n4) 区域两物种子系统：TwoSpecies\n作用：组装“兔-狐”这对物种在单一区域内的 LV 过程。\nmodel TwoSpecies &quot;区域两物种（兔-狐）Lotka–Volterra 子系统&quot;  import RegionalPopulation = ModelicaByExample_CN.Components.LotkaVolterra.Components.RegionalPopulation;  import Reproduction      = ModelicaByExample_CN.Components.LotkaVolterra.Components.Reproduction;  import Starvation        = ModelicaByExample_CN.Components.LotkaVolterra.Components.Starvation;  import Predation         = ModelicaByExample_CN.Components.LotkaVolterra.Components.Predation;  parameter Real alpha = 0.1 &quot;兔出生率 α&quot;;  parameter Real gamma = 0.4 &quot;狐饥饿系数 γ&quot;;  parameter Real initial_rabbit_population = 10 &quot;兔初始数量&quot;;  parameter Real initial_fox_population    = 10 &quot;狐初始数量&quot;;  parameter Real beta  = 0.02 &quot;兔被捕食系数 β&quot;;  parameter Real delta = 0.02 &quot;狐摄食增殖系数 δ&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbits    &quot;本区域的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-10&#125;,&#123;-90,10&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species foxes    &quot;本区域的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-10&#125;,&#123;110,10&#125;&#125;)));protected  RegionalPopulation rabbit_population(    initial_population=initial_rabbit_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;-60,-10&#125;,&#123;-40,10&#125;&#125;)));  Reproduction reproduction(alpha=alpha)     annotation(Placement(transformation(extent=&#123;&#123;-80,30&#125;,&#123;-60,50&#125;&#125;)));  RegionalPopulation fox_population(    initial_population=initial_fox_population,    init = RegionalPopulation.InitializationOptions.FixedPopulation)     annotation(Placement(transformation(extent=&#123;&#123;40,-10&#125;,&#123;60,10&#125;&#125;)));  Starvation fox_starvation(gamma=gamma)     annotation(Placement(transformation(extent=&#123;&#123;60,30&#125;,&#123;80,50&#125;&#125;)));  Predation fox_predation(beta=beta, delta=delta)     annotation(Placement(transformation(extent=&#123;&#123;-10,-10&#125;,&#123;10,10&#125;&#125;)));equation  connect(reproduction.species,      rabbit_population.species);  connect(fox_predation.a,           rabbit_population.species);  connect(fox_starvation.species,    fox_population.species);  connect(fox_population.species,    fox_predation.b);  connect(rabbit_population.species, rabbits);  connect(fox_population.species,    foxes);  annotation(Icon(graphics=&#123;    Rectangle(extent=&#123;&#123;-60,60&#125;,&#123;60,-60&#125;&#125;, fillColor=&#123;255,255,200&#125;, lineColor=&#123;0,0,0&#125;),    Text(extent=&#123;&#123;-60,65&#125;,&#123;60,85&#125;&#125;, string=&quot;两物种区域&quot;, fontSize=12)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;该子系统组合了：兔（繁殖）+ 狐（饥饿）+ 捕食（A=兔,B=狐）。&lt;/p&gt;&lt;/html&gt;&quot;));end TwoSpecies;\n\n5) 迁移组件：Migration\n作用：把两个区域的同类物种通过“差驱动扩散 + 守恒约束”耦合。\nA端： rateA=k (XA−XB),守恒： rateA+rateB=0.\\text{A端：}\\ \\text{rate}_A = k\\,(X_A - X_B),\\qquad\n\\text{守恒：}\\ \\text{rate}_A + \\text{rate}_B = 0.\nA端： rateA​=k(XA​−XB​),守恒： rateA​+rateB​=0.\nmodel Migration &quot;迁移（扩散）模型：A↔B 两区域&quot;  parameter Real rabbit_migration = 0.001 &quot;兔迁移率&quot;;  parameter Real fox_migration    = 0.005 &quot;狐迁移率&quot;;  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_a    &quot;区域A的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,-40&#125;,&#123;-90,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species rabbit_b    &quot;区域B的兔&quot; annotation(Placement(transformation(extent=&#123;&#123;90,-40&#125;,&#123;110,-20&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_a    &quot;区域A的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;-110,20&#125;,&#123;-90,40&#125;&#125;)));  ModelicaByExample_CN.Components.LotkaVolterra.Interfaces.Species fox_b    &quot;区域B的狐&quot; annotation(Placement(transformation(extent=&#123;&#123;90,20&#125;,&#123;110,40&#125;&#125;)));equation  // 兔扩散：按两区数量差迁移 + 总量守恒  rabbit_a.rate = (rabbit_a.population - rabbit_b.population) * rabbit_migration;  rabbit_a.rate + rabbit_b.rate = 0 &quot;兔总量守恒&quot;;  // 狐扩散：按两区数量差迁移 + 总量守恒  fox_a.rate    = (fox_a.population    - fox_b.population)    * fox_migration;  fox_a.rate + fox_b.rate = 0 &quot;狐总量守恒&quot;;  annotation(Icon(graphics=&#123;    Line(points=&#123;&#123;-50,0&#125;,&#123;50,0&#125;&#125;, color=&#123;0,0,150&#125;),    Polygon(points=&#123;&#123;45,5&#125;,&#123;55,0&#125;,&#123;45,-5&#125;&#125;, fillPattern=FillPattern.Solid),    Text(extent=&#123;&#123;-60,10&#125;,&#123;60,30&#125;&#125;, string=&quot;迁移&quot;, fontSize=11)&#125;),  Documentation(info=&quot;&lt;html&gt;&lt;p&gt;扩散式迁移：通量与两区域人口差成正比，并通过方程 &lt;code&gt;a.rate + b.rate = 0&lt;/code&gt; 保证总量守恒。&lt;/p&gt;&lt;/html&gt;&quot;));end Migration;\n\n6) 顶层系统：WithMigration\n四个区域（A,B,C,D 都是 TwoSpecies），用三段 Migration 串联成 A↔B↔C↔D。\nmodel WithMigration &quot;四区域：相邻迁移耦合（A↔B↔C↔D）&quot;  extends InitiallyDifferent;  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_AB    &quot;A↔B 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-60,10&#125;,&#123;-20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_BC    &quot;B↔C 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;-20,10&#125;,&#123;20,30&#125;&#125;)));  ModelicaByExample_CN.Subsystems.LotkaVolterra.Components.Migration migrate_CD    &quot;C↔D 迁移&quot; annotation(Placement(transformation(extent=&#123;&#123;20,10&#125;,&#123;60,30&#125;&#125;)));equation  connect(migrate_AB.rabbit_a, A.rabbits);  connect(migrate_AB.rabbit_b, B.rabbits);  connect(migrate_AB.fox_a,    A.foxes);  connect(migrate_AB.fox_b,    B.foxes);  connect(migrate_BC.rabbit_a, B.rabbits);  connect(migrate_BC.rabbit_b, C.rabbits);  connect(migrate_BC.fox_a,    B.foxes);  connect(migrate_BC.fox_b,    C.foxes);  connect(migrate_CD.rabbit_a, C.rabbits);  connect(migrate_CD.rabbit_b, D.rabbits);  connect(migrate_CD.fox_a,    C.foxes);  connect(migrate_CD.fox_b,    D.foxes);end WithMigration;\n\n三、仿真运行\n在 OpenModelica / MWorks 中使用\nOpenModelica / OMEdit：\n\nFile → Open Model/Library… 选择 ModelicaByExample_CN/package.mo\n打开：ModelicaByExample_CN.Subsystems.LotkaVolterra.Examples.WithMigration\nStopTime = 200，点击 Simulate\nPlot：A.rabbits.population、A.foxes.population、…、D.*\n\nMWorks：\n若对 MSL 版本敏感，把顶层 package.mo 中的\nannotation(uses(Modelica(version=&quot;4.0.0&quot;)))\n改成 MWorks 支持的版本（如 4.1.3），然后直接打开package.mo即可。\n\n结果展示\n各个不同的颜色分别代表了不同区域兔子和狐狸的数量\n\n","categories":["Modelica"],"tags":["Modelica","仿真","综合仿真平台开发"]},{"title":"PMPP-大规模并行处理器程序设计：导读","url":"/posts/30730973/","content":"前言\n《Programming Massively Parallel Processors: A Hands-on Approach》（简称 PMPP）是 GPU 并行编程领域的经典教材，由 NVIDIA 首席科学家 David Kirk 和 Wen-mei Hwu 教授编写。第四版于 2022 年出版，涵盖了截至 Ampere 架构的最新技术。\n这本书不只是 CUDA API 手册，更是一部**并行计算思维（Parallel Computational Thinking）**的养成指南。从最基础的线程模型到高级的分布式计算，从简单的向量加法到复杂的深度学习优化，循序渐进地构建完整的并行编程知识体系。\n本系列博客完整覆盖了全书 22 章内容，每章一篇。这篇导读将帮助你：\n\n快速了解全书结构和各章核心内容\n找到每章博客的链接\n根据自身背景选择合适的学习路线\n\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n全书结构\nPMPP 第四版共 22 章，可以分为四大部分：\n┌─────────────────────────────────────────────────────────────┐│  第一部分：CUDA 基础（1-6章）                                 ││  建立 GPU 编程的基础概念和核心技能                             │├─────────────────────────────────────────────────────────────┤│  第二部分：并行模式（7-15章）                                  ││  学习 9 种核心并行算法模式                                     │├─────────────────────────────────────────────────────────────┤│  第三部分：实际应用（16-18章）                                 ││  在真实场景中应用并行技术                                      │├─────────────────────────────────────────────────────────────┤│  第四部分：高级主题（19-22章）                                 ││  计算思维、分布式计算、高级特性                                 │└─────────────────────────────────────────────────────────────┘\n\n第一部分：CUDA 基础（1-6章）\n这是入门必读部分，建立 GPU 编程的完整基础。\n📖 各章概要\n\n\n\n章节\n标题\n核心内容\n博客链接\n\n\n\n\n1\n引言\nCPU vs GPU 设计哲学、CUDA 生态、异构计算模型\n阅读\n\n\n2\n异构数据并行计算\nThread/Block/Grid 概念、向量加法、错误处理\n阅读\n\n\n3\n多维网格和数据\n2D/3D 索引计算、图像处理、边界检查\n阅读\n\n\n4\n计算架构和调度\nSM 结构、Warp 调度、资源限制、占用率\n阅读\n\n\n5\n内存架构和数据局部性\n内存层次、共享内存、Tiling 技术\n阅读\n\n\n6\n性能方面的考虑\n合并访问、Bank 冲突、分支发散、资源分配\n阅读\n\n\n\n🔑 关键知识点\n硬件架构：\n\nGPU 由多个流式多处理器（SM，Streaming Multiprocessor）组成\n每个 SM 有自己的寄存器、共享内存、L1 缓存\n线程以32个一组（线程束，Warp）在 SM 上执行\n\n编程模型：\n\n核函数（Kernel）是在 GPU 上执行的并行函数\n线程组织为块（Block），块组织为网格（Grid）\n线程通过 threadIdx、blockIdx、blockDim 确定自己的位置\n\n内存优化（最重要）：\n\n寄存器 → 共享内存 → L2 缓存 → 全局内存，速度差异可达100倍\n分块（Tiling）：将数据分块加载到共享内存，块内复用\n合并访问（Coalesced Access）：让线程束内的线程访问连续地址\n\n💡 学习建议\n\n第一遍快速浏览 1-3 章，理解基本概念\n重点学习 4-6 章，这是性能优化的基础\n第 5 章的 Tiled 矩阵乘法必须亲手实现\n\n\n第二部分：并行模式（7-15章）\n这是本书的核心部分，介绍 9 种可复用的并行算法模式。\n📖 各章概要\n\n\n\n章节\n标题\n核心模式\n博客链接\n\n\n\n\n7\n卷积\nTiling + Halo 处理、常量内存\n阅读\n\n\n8\n模板\n寄存器 Tiling、分块时间迭代\n阅读\n\n\n9\n并行直方图\n原子操作、私有化、聚合\n阅读\n\n\n10\n归约\n树形归约、Warp Shuffle、CUB 库\n阅读\n\n\n11\n前缀和\nKogge-Stone、Brent-Kung、分层 Scan\n阅读\n\n\n12\n归并\nCo-Rank 技术、并行归并路径\n阅读\n\n\n13\n排序\n基数排序、归并排序、Thrust 库\n阅读\n\n\n14\n稀疏矩阵\nCSR/ELL/COO/HYB 格式、SpMV\n阅读\n\n\n15\n图遍历\n并行 BFS、边界推进、层级同步\n阅读\n\n\n\n🔑 关键知识点\n数据并行模式：\n\n\n\n模式\n特点\n典型应用\n\n\n\n\nMap\n一对一变换\n向量运算、图像滤波\n\n\nReduce\n多对一归约\n求和、最大值\n\n\nScan\n前缀操作\n压缩、流分配\n\n\nGather/Scatter\n不规则访问\n稀疏矩阵、图计算\n\n\n\n输出冲突处理（第 9 章）：\n\n原子操作：正确但慢\n私有化：每线程/每 Block 私有副本\n聚合：相同地址只做一次原子操作\n\n树形并行（第 10-11 章）：\n\n归约：多个值 → 一个值\n扫描：多个值 → 多个前缀和\n都是 O(log N) 步，但 Scan 更复杂\n\n💡 学习建议\n\n第 7 章卷积是第 5 章 Tiling 的进阶应用\n第 10-11 章（归约和前缀和）是最重要的两章\n稀疏矩阵和图遍历展示了如何处理不规则数据\n\n\n第三部分：实际应用（16-18章）\n将前面学到的技术应用于真实的科学计算和工程问题。\n📖 各章概要\n\n\n\n章节\n标题\n应用领域\n博客链接\n\n\n\n\n16\n深度学习\n卷积神经网络、Im2col、Tensor Core\n阅读\n\n\n17\n迭代式 MRI 重建\nNUFFT、共轭梯度、医学成像\n阅读\n\n\n18\n静电势能图\nN-body 问题、空间分区、cutoff 优化\n阅读\n\n\n\n🔑 关键知识点\n深度学习（第 16 章）：\n\n卷积是 95%+ 的计算量\nIm2col 把卷积转为 GEMM\nWinograd 减少乘法次数\ncuDNN 自动选择最优算法\n\n科学计算：\n\n迭代算法需要多次 Kernel 启动\n非均匀网格需要特殊处理\n空间分区降低 O(N²) 到 O(N)\n\n💡 学习建议\n\n如果做深度学习，第 16 章必读\n第 17-18 章展示科学计算的完整流程\n理解如何组合多种技术解决复杂问题\n\n\n第四部分：高级主题（19-22章）\n计算思维方法论、分布式扩展和未来趋势。\n📖 各章概要\n\n\n\n章节\n标题\n核心内容\n博客链接\n\n\n\n\n19\n并行编程与计算思维\n问题分解、算法选择、性能推理\n阅读\n\n\n20\n异构计算集群编程\nMPI+CUDA、多 GPU、Halo 交换\n阅读\n\n\n21\nCUDA 动态并行性\n设备端启动、递归算法、自适应网格\n阅读\n\n\n22\n高级实践与未来演变\n性能方法论、代码可移植性、发展趋势\n阅读\n\n\n\n🔑 关键知识点\n计算思维（第 19 章）：\n\n识别并行性：数据并行 vs 任务并行\n算法选择：计算复杂度 vs 并行度\n性能推理：Roofline 模型\n\n分布式扩展（第 20 章）：\n\n多 GPU：CUDA-aware MPI、GPUDirect\n通信隐藏：重叠计算和传输\n弱扩展 vs 强扩展\n\n动态并行（第 21 章）：\n\n设备端可以启动子 Kernel\n适合递归和自适应算法\n有同步和开销限制\n\n💡 学习建议\n\n第 19 章提炼了全书的方法论精华\n如果需要多 GPU/多节点，重点学第 20 章\n第 22 章可作为持续学习的指南\n\n\n核心知识图谱\n内存优化技术\n                    ┌──────────────────────────────────────┐                    │         GPU 内存层次结构              │                    ├──────────────────────────────────────┤                    │  寄存器 (~TB/s) ◀── 最快，数量有限    │                    │     ↓                                │                    │  共享内存 (~10 TB/s) ◀── 可编程缓存   │                    │     ↓                                │                    │  L2 缓存 (~1 TB/s) ◀── 自动管理       │                    │     ↓                                │                    │  全局内存 (~500 GB/s) ◀── 容量大但慢  │                    └──────────────────────────────────────┘优化策略：├── Tiling（第5章）：数据分块，在共享内存中复用├── 合并访问（第6章）：连续地址，减少内存事务├── 寄存器Tiling（第8章）：数据保留在寄存器└── 私有化（第9章）：避免原子操作的竞争\n并行算法选择\n问题类型                    推荐算法───────────────────────────────────────────────逐元素运算                  Map（直接并行）全局聚合（求和/最大值）      树形归约（第10章）前缀依赖计算                Scan（第11章）有序数据合并                Co-rank归并（第12章）整数键排序                  基数排序（第13章）稀疏数据处理                CSR/ELL格式（第14章）图遍历                      边界推进BFS（第15章）\n性能调优方法论\n1. Profile 先行   └── 使用 Nsight Compute 定位瓶颈2. 判断瓶颈类型   ├── 内存受限：优化访问模式、增加数据复用   └── 计算受限：减少指令数、使用快速数学函数3. 层次化优化（从上到下收益递减）   ├── 算法选择   ├── 数据布局   ├── 并行策略   ├── 内存层次利用   └── 指令级优化4. 迭代验证   └── 保持正确性，逐步优化\n\n学习路线推荐\n🚀 快速入门路线（2周）\n适合：有编程基础，想快速上手 CUDA\nWeek 1: 1→2→3→5（基础概念 + Tiling）Week 2: 10→16（归约 + 深度学习应用）\n📚 系统学习路线（2月）\n适合：想深入掌握 GPU 编程\nMonth 1（基础+模式）:  Week 1-2: 1-6章（打牢基础）  Week 3-4: 7-11章（核心模式）Month 2（进阶+应用）:  Week 1-2: 12-16章（高级模式+应用）  Week 3-4: 19-22章（思维+扩展）\n🎯 专项提升路线\n深度学习方向：1→2→5→7→10→16\n科学计算方向：1→2→5→10→11→14→17→18\nHPC 方向：1→2→4→5→6→10→20\n\n学习资源\n配套代码\n\nGitHub 仓库：https://github.com/psmarter/PMPP-Learning\n包含所有章节练习题解答\n可直接编译运行的 CUDA 代码\n详细的中文注释\n\n官方资源\n\nCUDA C++ Programming Guide\nCUDA Best Practices Guide\nNsight Compute Documentation\n\n相关课程\n\nUIUC ECE 408（Coursera 可看）\n书籍作者的配套课程\n\n\n写在最后\nPMPP 不是一本可以一次读完的书。第一遍建立框架，第二遍深入细节，每次实战后再回来都会有新的理解。\n学习建议：\n\n动手实践：每章的练习题都需要实际编码，仅阅读难以真正掌握\n使用性能分析工具：Nsight Compute 和 Nsight Systems 是理解性能的最佳途径\n理解底层原理：API 会更新，但硬件原理和优化思想具有长期价值\n项目驱动：在真实项目中应用这些技术才能融会贯通\n\nGPU 并行编程的重要性日益凸显——深度学习、科学计算、图形渲染、高性能计算都离不开它。掌握 PMPP 的内容，就掌握了进入这些领域的核心技能。\n祝学习进步！\n\n参考资料：\n\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nNVIDIA CUDA 官方文档\nNVIDIA Developer Blog\n\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n系列总览：本文是 PMPP 全书 22 章博客系列的导读索引。\n\n","categories":["知识分享"],"tags":["学习路线","CUDA","GPU编程","并行计算","PMPP","全书导读"]},{"title":"PMPP-第一章：引言","url":"/posts/10d278b0/","content":"前言\n第一章虽然是引言，但信息量很大。系统梳理了并行计算的发展历程、CPU与GPU的架构差异、CUDA的诞生背景。理解这些历史和设计思想，对后续学习GPU编程很有帮助。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n性能提升的转折点：从频率到并行\n2004年之前：频率提升的黄金时代\n在这个阶段，提高 CPU 频率是提升程序性能的主要方式。摩尔定律非常直观：晶体管数量每18个月翻倍，频率提升，性能自然增长。程序员无需特别关注性能优化，等待硬件升级就能获得免费的性能提升。\n功耗墙的出现\n2004年前后，CPU 发展遇到了物理极限——功耗墙（Power Wall）：\n\n动态功耗正比于频率和电压的平方\n提高频率需要提高电压以保证稳定性\n功耗以超线性速度增长，散热成为瓶颈\n\n当时 Pentium 4 的热设计功耗（TDP）已达130W以上，继续提升频率将导致功耗达到数百瓦，在消费级产品中难以实现。\n转向多核\n既然单核频率无法继续提升，芯片厂商转向多核：\n\n单核保持较低频率（控制功耗）\n通过并行提升整体性能\n利用不断增长的晶体管数量\n\n但多核CPU受限于功耗和面积，通常只有几个到十几个核心，对于需要成千上万并发任务的应用（图形渲染、深度学习）还不够。\nCPU vs GPU：设计哲学的根本差异\nCPU：最小化延迟\n目标：让单个线程尽可能快地完成任务\n手段：\n\n复杂控制逻辑：分支预测、乱序执行、寄存器重命名、推测执行\n庞大缓存：L1(32-64KB) + L2(256KB-1MB) + L3(8-64MB)\n强大计算单元：完备的ALU/FPU，SIMD指令集\n\n代价：芯片上只有20-30%的晶体管用于计算，其余都是控制逻辑和缓存。单核成本高，核心数量有限。\n适合：复杂控制流、不规则内存访问、串行依赖强的任务\nGPU：最大化吞吐量\n目标：通过海量线程提升整体吞吐量\n手段：\n\n大量简单核心：数千个核心，每个都很简单（无复杂分支预测/乱序执行）\nSIMT模型：32个线程为一组(warp)，共享指令单元\n高带宽内存：500-1000 GB/s（CPU只有50-100 GB/s）\n专注浮点运算：晶体管主要用于计算单元\n\n特点：单核简单，但数量多。在数据并行任务上，浮点性能可达CPU的10倍以上。\n适合：数据并行、计算密集、规则内存访问的任务\n形象类比\n\nCPU：经验丰富的专家，处理复杂问题效率高，但一次只能专注一件事\nGPU：数千名新手组成的团队，单个能力有限，但通过大规模协作完成简单任务效率惊人\n\nCUDA的诞生\nCUDA之前的黑暗时代\n早期GPGPU必须通过图形API（OpenGL/Direct3D）实现：\n\n将数据编码成纹理（Texture）\n编写顶点着色器和片段着色器\n通过渲染到纹理获取结果\n读回主内存\n\n问题：\n\n需要深入理解图形管线\n数据表示受限（只能用颜色通道）\n调试几乎不可能\n只有图形学专家能用\n\nCUDA 的革新（2007）\n硬件改进：\n\n统一着色器架构\n支持任意内存读写（不局限于纹理）\n提供共享内存（Shared Memory）等可编程存储\n支持整数运算、位运算\n\n软件生态：\n\n基于 C/C++ 的扩展，学习成本低\n完整工具链（nvcc 编译器）\n丰富的数学库（cuBLAS、cuFFT）\n调试和性能分析工具\n\n示例代码：\n__global__ void vecAdd(float *A, float *B, float *C, int n) &#123;    int i = blockDim.x * blockIdx.x + threadIdx.x;    if (i &lt; n) &#123;        C[i] = A[i] + B[i];    &#125;&#125;\n相比之前需要编写复杂着色器，CUDA代码直观得多。这是GPU通用计算普及的关键转折点。\n异构计算：CPU 与 GPU 协作\nGPU 虽强大，但不适合所有任务：\n\n\n\n场景\nGPU 优势\nGPU 劣势\n\n\n\n\n计算类型\n大量浮点运算\n复杂控制流\n\n\n并行度\n数据并行\n线程数少的任务\n\n\n内存访问\n规则访问模式\n不规则/随机访问\n\n\n同步\n独立计算\n频繁同步\n\n\n\n如果程序只有几百个线程（Thread），在 GPU 上可能不如 CPU。GPU 需要数千甚至数百万线程才能充分利用硬件。\n典型 CUDA 程序流程\n1. 主机（Host）初始化   - 分配主机内存   - 初始化数据2. 数据传输到设备（Device）   cudaMemcpy(..., cudaMemcpyHostToDevice);3. 启动 GPU 核函数（Kernel）   kernel&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(args);4. GPU 并行执行5. 结果传回主机   cudaMemcpy(..., cudaMemcpyDeviceToHost);6. 主机端后续处理\n现代深度学习框架（PyTorch、TensorFlow）底层都是这个模式：\n\n模型构建在 CPU\n前向/反向传播在 GPU\n优化器更新回到 CPU\n\n并行编程的挑战\n1. 算法并行化\n不是所有算法都能直接并行化：\n\n递归算法（快速排序、树遍历）\n动态规划（许多DP问题有串行依赖）\n累积计算（前缀和、累积乘积）\n\n有时需要完全重新设计算法（如并行前缀和），而不是简单并行化串行版本。\n2. 内存带宽瓶颈\n假设GPU峰值10 TFLOPS，内存带宽500 GB/s。如果计算需要读2个float(8B)做1次加法：\n\n计算需求：10 TFLOPS\n内存支撑：500 GB/s ÷ 8B = 62.5 GFLOPS\n实际性能：只能达到峰值的0.6%\n\n这就是内存受限（Memory-Bound）问题。优化方向：\n\n使用Shared Memory减少全局内存访问\n优化访问模式实现合并访问（Coalesced Access）\n提高算术强度（每字节数据做更多计算）\n\n3. 性能不确定性\n并行程序性能高度依赖输入数据。例如数组过滤：\nif (data[i] &gt; threshold) &#123;    output[count++] = data[i];&#125;\n\n全部满足条件 → 负载均衡，性能好\n少数满足 → 大部分线程空闲\n分布不均 → warp分支发散\n\n同样的代码，不同输入可能有数倍性能差异。\n4. 调试复杂性\n并发错误在串行程序中根本不存在：\n\n竞态条件（Race Condition）：多线程同时访问同一内存\n死锁（Deadlock）：线程间相互等待\n非确定性错误：随机出现，难以重现\n\n性能优化也需要深入理解硬件细节：\n\nWarp（32线程一组）\nOccupancy（活跃线程比例）\nBank冲突、寄存器溢出等\n\n本书的学习目标\n1. 并行编程技术\n以CUDA为平台，学习：\n\n基本概念（线程、同步、内存模型）\nCUDA语法和API\n常见并行模式（Map、Reduce、Scan、Stencil）\nGPU硬件架构\n\n2. 并行计算思维\n更深层次的能力：\n\n识别问题中的并行性\n设计高效并行算法\n权衡并行度、负载均衡、通信开销\n针对硬件优化算法\n\n3. 正确性与性能\n实践技能：\n\n避免并发错误，测试并行程序\n使用profiling工具\n系统化性能调优\n编写可移植的代码\n\n这些方法论比单纯学API更有价值，能迁移到其他并行平台（OpenCL、SYCL、HIP）。\n小结\n第一章建立了并行计算的大框架：\n历史脉络：功耗墙导致从频率提升转向并行计算，这是必然趋势。\n架构差异：CPU追求低延迟（复杂核心、大缓存），GPU追求高吞吐（简单核心、高带宽）。理解这点，就明白为什么某些任务适合GPU，某些不适合。\nCUDA价值：不仅是技术，更是生态。虽然是专有平台，但完整的工具链和库让它成为GPU编程的事实标准。\n挑战认识：并行编程确实比串行复杂，但掌握的思维方式和优化方法具有通用性。\n下一章将进入 CUDA 编程实战，通过向量加法这个经典例子，学习 CUDA 程序的基本结构和核心概念。\n\n参考资料：\n\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nNVIDIA CUDA官方文档\n\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP"]},{"title":"PMPP-第七章：卷积","url":"/posts/1c778456/","content":"前言\n第六章讨论了性能优化的各个方面，现在开始学习具体的并行计算模式。第七章的主角是卷积（Convolution）——信号处理和深度学习的核心算子。卷积看似简单，但要高效实现却涉及多个内存层次的配合：常量内存存储卷积核、共享内存实现分块（Tiling）、全局内存处理输入输出。本章将展示如何组合这些技术，实现工业级的卷积核函数。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n卷积基础\n什么是卷积\n卷积是一种数学运算，使用一个小矩阵（卷积核/滤波器，Kernel/Filter）在输入数据上滑动，在每个位置计算加权和。\n1D 卷积：\n输入：  [1, 2, 3, 4, 5, 6, 7]卷积核：[1, 2, 1]输出：  [_, 8, 12, 16, 20, 24, _]计算 Output[3]：= Input[2]*Kernel[0] + Input[3]*Kernel[1] + Input[4]*Kernel[2]= 3*1 + 4*2 + 5*1 = 12\n2D 卷积（图像处理常用）：\n输入图像                    卷积核 (3×3)┌───────────────┐           ┌───────┐│ 1 2 3 4 5     │           │ 1 0 1 ││ 5 6 7 8 9     │     *     │ 0 1 0 ││ 9 0 1 2 3     │           │ 1 0 1 ││ 4 5 6 7 8     │           └───────┘└───────────────┘\n卷积的应用\n卷积无处不在：\n\n\n\n领域\n应用\n示例\n\n\n\n\n图像处理\n边缘检测、模糊、锐化\nSobel、Gaussian Blur\n\n\n音频处理\n回声、均衡器、降噪\nFIR 滤波器\n\n\n深度学习\n特征提取\nCNN 的核心操作\n\n\n物理仿真\n扩散方程、有限差分\n热传导、波动方程\n\n\n\n卷积的数学定义\n1D 离散卷积：\nOutput[i]=∑j=−rrInput[i+j]×Kernel[j+r]Output[i] = \\sum_{j=-r}^{r} Input[i+j] \\times Kernel[j+r]\nOutput[i]=j=−r∑r​Input[i+j]×Kernel[j+r]\n其中 r 是卷积核的&quot;半径&quot;，卷积核大小为 2r+1。\n2D 离散卷积：\nOutput[y][x]=∑dy=−rr∑dx=−rrInput[y+dy][x+dx]×Kernel[dy+r][dx+r]Output[y][x] = \\sum_{dy=-r}^{r} \\sum_{dx=-r}^{r} Input[y+dy][x+dx] \\times Kernel[dy+r][dx+r]\nOutput[y][x]=dy=−r∑r​dx=−r∑r​Input[y+dy][x+dx]×Kernel[dy+r][dx+r]\n边界处理\n当卷积窗口超出输入边界时，有几种处理策略：\n1. 零填充（Zero Padding）：边界外的元素视为 0\nPadding 前：[1, 2, 3, 4, 5]Padding 后：[0, 0, 1, 2, 3, 4, 5, 0, 0]\n2. 复制填充（Replicate Padding）：用边界值填充\nPadding 后：[1, 1, 1, 2, 3, 4, 5, 5, 5]\n3. 镜像填充（Reflect Padding）：镜像边界元素\nPadding 后：[3, 2, 1, 2, 3, 4, 5, 4, 3]\n在 CUDA 实现中，零填充最简单——只需在边界判断时返回 0。\n朴素 1D 卷积实现\n基本思路\n每个线程负责计算一个输出元素：\n__global__ void conv1d_basic(float *input, float *kernel, float *output,                              int n, int kernel_size) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    int r = kernel_size / 2;  // 卷积核半径        if (i &lt; n) &#123;        float sum = 0.0f;        for (int j = -r; j &lt;= r; j++) &#123;            int idx = i + j;            if (idx &gt;= 0 &amp;&amp; idx &lt; n) &#123;                sum += input[idx] * kernel[j + r];            &#125;            // 边界外隐式为 0（零填充）        &#125;        output[i] = sum;    &#125;&#125;\n性能问题\n这个朴素实现有两个瓶颈：\n1. 卷积核重复读取\n每个线程都要读取整个卷积核。如果有 10 万个线程，卷积核就被读取 10 万次。但卷积核对所有线程是相同的！\n2. 输入数据重复读取\n相邻线程的卷积窗口高度重叠：\n线程 i   读取：input[i-1], input[i], input[i+1]线程 i+1 读取：input[i], input[i+1], input[i+2]                ↑ 共享元素\n卷积核大小为 2r+1 时，每个输入元素平均被读取 2r+1 次。\n常量内存优化\n常量内存特性\n第五章提过常量内存，这里深入讲解：\n硬件结构：\n┌──────────────────────────────────────┐│           常量内存 (64 KB)            ││           Device DRAM                │└──────────────┬───────────────────────┘               │ 广播┌──────────────┴───────────────────────┐│        常量缓存 (每 SM ~8 KB)         ││           On-chip Cache              │└──────────────┬───────────────────────┘               │ 极低延迟               ↓         Warp 中的线程\n特点：\n\n只读：Kernel 执行期间不能修改\n缓存优化：有专用缓存，命中时延迟极低\n广播高效：同一 Warp 读相同地址时，只需一次访问\n\n为什么适合卷积核：\n\n卷积核对所有线程都是相同的常量\n每次卷积操作，所有线程都读相同的 kernel[j]\n完美匹配常量内存的&quot;广播&quot;特性\n\n使用常量内存\n声明（全局作用域）：\n#define MAX_KERNEL_SIZE 1025__constant__ float d_kernel[MAX_KERNEL_SIZE];\nHost 端初始化：\nfloat h_kernel[kernel_size];// ... 填充卷积核数据 ...cudaMemcpyToSymbol(d_kernel, h_kernel, kernel_size * sizeof(float));\nKernel 中使用：\n__global__ void conv1d_const(float *input, float *output,                               int n, int kernel_size) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    int r = kernel_size / 2;        if (i &lt; n) &#123;        float sum = 0.0f;        for (int j = -r; j &lt;= r; j++) &#123;            int idx = i + j;            if (idx &gt;= 0 &amp;&amp; idx &lt; n) &#123;                sum += input[idx] * d_kernel[j + r];  // 直接使用            &#125;        &#125;        output[i] = sum;    &#125;&#125;\n性能提升\n常量内存解决了卷积核重复读取的问题：\n\n\n\n版本\n卷积核读取\n带宽消耗\n\n\n\n\n朴素\nN×K 次\n高\n\n\n常量内存\nK 次 + 缓存\n极低（广播）\n\n\n\n其中 N 是输出元素数，K 是卷积核大小。\n但输入数据的重复读取问题还没解决——这需要 Tiling。\nTiled 卷积\n为什么需要 Tiling\n回顾输入数据访问模式：\nBlock 内的线程访问：线程 0:   input[0], input[1], ..., input[k-1]线程 1:   input[1], input[2], ..., input[k]...线程 255: input[255], input[256], ..., input[255+k-1]\nBlock 内的线程访问范围是连续的，有大量重叠。把这部分数据加载到共享内存，就能避免重复的全局内存访问。\n输入 Tile 设计\n关键问题：一个 Block 的线程需要多大的输入 Tile？\nBlock 大小：BLOCK_SIZE卷积核半径：r卷积核大小：2r + 1输出范围：[block_start, block_start + BLOCK_SIZE - 1]输入范围：[block_start - r, block_start + BLOCK_SIZE - 1 + r]         = block_start - r, block_start + BLOCK_SIZE + r - 1]输入 Tile 大小 = BLOCK_SIZE + 2r\n也就是说，要计算 BLOCK_SIZE 个输出，需要读取 BLOCK_SIZE + 2r 个输入元素。\nHalo 元素\n输入 Tile 比输出 Tile 大，多出来的部分叫做 Halo（光晕）元素：\n                    Halo                 主体                  Halo            ┌────────────────┬─────────────────────────┬────────────────┐输入 Tile:  │ r 个元素       │ BLOCK_SIZE 个元素        │ r 个元素       │            └────────────────┴─────────────────────────┴────────────────┘                    ↑                                           ↑                左 Halo                                      右 Halo\nHalo 元素是相邻 Block 边界的重叠部分，也叫 Ghost Cells。\n实现策略\n有两种加载方式：\n策略 1：统一加载\n所有元素由 BLOCK_SIZE 个线程分工加载，每线程可能加载多个元素：\n__shared__ float tile[BLOCK_SIZE + 2 * MAX_R];int tile_size = BLOCK_SIZE + 2 * r;int loads_per_thread = (tile_size + BLOCK_SIZE - 1) / BLOCK_SIZE;for (int i = 0; i &lt; loads_per_thread; i++) &#123;    int tile_idx = threadIdx.x + i * BLOCK_SIZE;    if (tile_idx &lt; tile_size) &#123;        int global_idx = block_start - r + tile_idx;        tile[tile_idx] = (global_idx &gt;= 0 &amp;&amp; global_idx &lt; n) ?                           input[global_idx] : 0.0f;    &#125;&#125;\n策略 2：分区加载（更高效）\n左 Halo、主体、右 Halo 分别由不同线程加载：\n__shared__ float tile[BLOCK_SIZE + 2 * MAX_R];int halo_left = r;int block_start = blockIdx.x * BLOCK_SIZE;// 左 Halo：前 r 个线程负责if (threadIdx.x &lt; r) &#123;    int idx = block_start - r + threadIdx.x;    tile[threadIdx.x] = (idx &gt;= 0) ? input[idx] : 0.0f;&#125;// 主体：所有线程各负责一个int main_idx = block_start + threadIdx.x;tile[r + threadIdx.x] = (main_idx &lt; n) ? input[main_idx] : 0.0f;// 右 Halo：前 r 个线程负责if (threadIdx.x &lt; r) &#123;    int idx = block_start + BLOCK_SIZE + threadIdx.x;    tile[BLOCK_SIZE + r + threadIdx.x] = (idx &lt; n) ? input[idx] : 0.0f;&#125;__syncthreads();\n完整的 Tiled 1D 卷积\n#define BLOCK_SIZE 256#define MAX_R 512__constant__ float d_kernel[2 * MAX_R + 1];__global__ void conv1d_tiled(float *input, float *output,                               int n, int r) &#123;    // 共享内存 Tile    __shared__ float tile[BLOCK_SIZE + 2 * MAX_R];        int block_start = blockIdx.x * BLOCK_SIZE;    int global_idx = block_start + threadIdx.x;        // ========== 协作加载 ==========        // 左 Halo    if (threadIdx.x &lt; r) &#123;        int idx = block_start - r + threadIdx.x;        tile[threadIdx.x] = (idx &gt;= 0) ? input[idx] : 0.0f;    &#125;        // 主体元素    tile[r + threadIdx.x] = (global_idx &lt; n) ? input[global_idx] : 0.0f;        // 右 Halo    if (threadIdx.x &lt; r) &#123;        int idx = block_start + BLOCK_SIZE + threadIdx.x;        tile[BLOCK_SIZE + r + threadIdx.x] = (idx &lt; n) ? input[idx] : 0.0f;    &#125;        __syncthreads();        // ========== 计算卷积 ==========        if (global_idx &lt; n) &#123;        float sum = 0.0f;        for (int j = 0; j &lt; 2 * r + 1; j++) &#123;            sum += tile[threadIdx.x + j] * d_kernel[j];        &#125;        output[global_idx] = sum;    &#125;&#125;\n性能分析\n全局内存访问：\n\n\n\n版本\n每元素读取次数\n总读取量\n\n\n\n\n朴素\n2r + 1\nN × (2r + 1)\n\n\nTiled\n1 + 2r/BLOCK_SIZE\nN × (1 + 2r/B)\n\n\n\n当 BLOCK_SIZE = 256, r = 5 时：\n\n朴素：每元素 11 次\nTiled：每元素 1.04 次\n\n全局内存访问减少约 10 倍！\n2D 卷积\n扩展到二维\n2D 卷积更常见，思路类似但更复杂：\n输入 Tile 大小：(BLOCK_Y + 2ry) × (BLOCK_X + 2rx)Halo 元素在四个边和四个角\n2D Tile 结构\n┌─────────────┬───────────────────────────┬─────────────┐│  左上角     │        上 Halo            │  右上角     ││  (ry×rx)    │      (ry×BLOCK_X)         │  (ry×rx)    │├─────────────┼───────────────────────────┼─────────────┤│             │                           │             ││  左 Halo    │       主体                │  右 Halo    ││ (BLOCK_Y×rx)│   (BLOCK_Y×BLOCK_X)       │(BLOCK_Y×rx) ││             │                           │             │├─────────────┼───────────────────────────┼─────────────┤│  左下角     │        下 Halo            │  右下角     ││  (ry×rx)    │      (ry×BLOCK_X)         │  (ry×rx)    │└─────────────┴───────────────────────────┴─────────────┘\n简化的 2D 实现\n#define TILE_X 16#define TILE_Y 16#define R 1  // 3×3 卷积核的半径__constant__ float d_kernel2d[(2*R+1) * (2*R+1)];__global__ void conv2d_tiled(float *input, float *output,                              int width, int height) &#123;    // 共享内存    __shared__ float tile[TILE_Y + 2*R][TILE_X + 2*R];        int tx = threadIdx.x, ty = threadIdx.y;    int bx = blockIdx.x * TILE_X, by = blockIdx.y * TILE_Y;    int gx = bx + tx, gy = by + ty;        // ========== 加载主体 ==========    int tile_x = tx + R, tile_y = ty + R;    tile[tile_y][tile_x] = (gx &lt; width &amp;&amp; gy &lt; height) ?                             input[gy * width + gx] : 0.0f;        // ========== 加载 Halo（边界线程负责）==========        // 上边界    if (ty &lt; R) &#123;        int src_y = gy - R;        tile[ty][tile_x] = (gx &lt; width &amp;&amp; src_y &gt;= 0) ?                             input[src_y * width + gx] : 0.0f;    &#125;    // 下边界    if (ty &gt;= TILE_Y - R) &#123;        int src_y = gy + R;        tile[tile_y + R][tile_x] = (gx &lt; width &amp;&amp; src_y &lt; height) ?                                     input[src_y * width + gx] : 0.0f;    &#125;    // 左边界    if (tx &lt; R) &#123;        int src_x = gx - R;        tile[tile_y][tx] = (src_x &gt;= 0 &amp;&amp; gy &lt; height) ?                             input[gy * width + src_x] : 0.0f;    &#125;    // 右边界    if (tx &gt;= TILE_X - R) &#123;        int src_x = gx + R;        tile[tile_y][tile_x + R] = (src_x &lt; width &amp;&amp; gy &lt; height) ?                                     input[gy * width + src_x] : 0.0f;    &#125;        // 四个角（角落线程负责）    if (tx &lt; R &amp;&amp; ty &lt; R) &#123;  // 左上        int sx = gx - R, sy = gy - R;        tile[ty][tx] = (sx &gt;= 0 &amp;&amp; sy &gt;= 0) ? input[sy * width + sx] : 0.0f;    &#125;    if (tx &gt;= TILE_X - R &amp;&amp; ty &lt; R) &#123;  // 右上        int sx = gx + R, sy = gy - R;        tile[ty][tile_x + R] = (sx &lt; width &amp;&amp; sy &gt;= 0) ?                                 input[sy * width + sx] : 0.0f;    &#125;    if (tx &lt; R &amp;&amp; ty &gt;= TILE_Y - R) &#123;  // 左下        int sx = gx - R, sy = gy + R;        tile[tile_y + R][tx] = (sx &gt;= 0 &amp;&amp; sy &lt; height) ?                                 input[sy * width + sx] : 0.0f;    &#125;    if (tx &gt;= TILE_X - R &amp;&amp; ty &gt;= TILE_Y - R) &#123;  // 右下        int sx = gx + R, sy = gy + R;        tile[tile_y + R][tile_x + R] = (sx &lt; width &amp;&amp; sy &lt; height) ?                                        input[sy * width + sx] : 0.0f;    &#125;        __syncthreads();        // ========== 计算卷积 ==========    if (gx &lt; width &amp;&amp; gy &lt; height) &#123;        float sum = 0.0f;        for (int dy = -R; dy &lt;= R; dy++) &#123;            for (int dx = -R; dx &lt;= R; dx++) &#123;                sum += tile[ty + R + dy][tx + R + dx] *                        d_kernel2d[(dy + R) * (2*R + 1) + (dx + R)];            &#125;        &#125;        output[gy * width + gx] = sum;    &#125;&#125;\n启动配置\ndim3 block(TILE_X, TILE_Y);  // 16×16 = 256 线程dim3 grid((width + TILE_X - 1) / TILE_X,           (height + TILE_Y - 1) / TILE_Y);conv2d_tiled&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_input, d_output, width, height);\n缓存机制\nL1/L2 缓存与 Tiling 的关系\n前面我们手动用共享内存实现了 Tiling。但 GPU 还有自动的缓存机制：\nL1 缓存（每 SM）：\n\nAmpere 架构：128 KB（可配置与共享内存分割）\n自动缓存全局内存访问\n对于小卷积核，可能&quot;免费&quot;获得数据复用\n\nL2 缓存（全局共享）：\n\n几 MB 容量\n所有 SM 共享\n跨 Block 的数据访问可能命中\n\n何时依赖缓存 vs 显式 Tiling\n\n\n\n场景\n推荐方式\n原因\n\n\n\n\n小卷积核（3×3）\n可能只用缓存\nL1 够用，代码简单\n\n\n大卷积核（11×11+）\n显式 Tiling\n数据量大，需精确控制\n\n\n大图像、小 kernel\n显式 Tiling\n最大化内存带宽利用\n\n\n调试/原型\n先用缓存\n快速验证正确性\n\n\n\n现代 GPU 的优化建议\n\n先写简单版本，依赖 L1/L2 缓存\n用 Nsight Compute 分析，看内存吞吐是否成为瓶颈\n如果受限于内存带宽，再添加共享内存 Tiling\n常量内存始终是好选择（对于卷积核）\n\n卷积优化总结\n优化手段层次\n┌─────────────────────────────────────────────────────────────────┐│ Level 4: 算法级优化                                              ││   - FFT 卷积（大卷积核）                                          ││   - Winograd 算法（特定尺寸）                                     ││   - Im2col + GEMM（cuDNN 方式）                                   │├─────────────────────────────────────────────────────────────────┤│ Level 3: 数据复用                                                 ││   - 共享内存 Tiling                                               ││   - 常量内存存储卷积核                                            ││   - 寄存器缓存局部结果                                            │├─────────────────────────────────────────────────────────────────┤│ Level 2: 内存访问模式                                             ││   - 合并访问全局内存                                              ││   - 避免 Bank 冲突                                                ││   - 预取和双缓冲                                                  │├─────────────────────────────────────────────────────────────────┤│ Level 1: 基础正确实现                                             ││   - 边界检查                                                      ││   - 正确的索引计算                                                 │└─────────────────────────────────────────────────────────────────┘\n选择策略\n\n\n\n卷积核大小\n推荐方法\n\n\n\n\n3×3\nTiled + 常量内存\n\n\n5×5 ~ 11×11\nTiled + 常量内存\n\n\n大于 11×11\n考虑 FFT 或 cuDNN\n\n\n\ncuDNN：工业级选择\n实际生产中，卷积通常用 cuDNN：\ncudnnConvolutionForward(handle,    &amp;alpha,    inputDesc, d_input,    filterDesc, d_filter,    convDesc,    algo,  // 自动选择最优算法    workspace, workspaceSize,    &amp;beta,    outputDesc, d_output);\ncuDNN 会根据输入尺寸、卷积核大小、GPU 架构，自动选择最优实现（直接卷积、FFT、Winograd、Im2col+GEMM 等）。\n但理解底层原理仍然重要——知道 cuDNN 在做什么，才能正确调用和调优。\n实战：图像锐化\n锐化卷积核\n┌─────┬─────┬─────┐│  0  │ -1  │  0  │├─────┼─────┼─────┤│ -1  │  5  │ -1  │├─────┼─────┼─────┤│  0  │ -1  │  0  │└─────┴─────┴─────┘\n完整示例\n#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;#define TILE_SIZE 16#define R 1__constant__ float d_sharpen_kernel[9] = &#123;    0, -1,  0,   -1,  5, -1,    0, -1,  0&#125;;__global__ void sharpen_image(unsigned char *input, unsigned char *output,                               int width, int height) &#123;    __shared__ float tile[TILE_SIZE + 2][TILE_SIZE + 2];        int tx = threadIdx.x, ty = threadIdx.y;    int gx = blockIdx.x * TILE_SIZE + tx;    int gy = blockIdx.y * TILE_SIZE + ty;        // 加载（简化版，假设边界内）    if (gx &lt; width &amp;&amp; gy &lt; height) &#123;        tile[ty + 1][tx + 1] = (float)input[gy * width + gx];    &#125; else &#123;        tile[ty + 1][tx + 1] = 0.0f;    &#125;        // 加载 Halo（简化，仅示意）    if (tx == 0 &amp;&amp; gx &gt; 0)         tile[ty + 1][0] = input[gy * width + gx - 1];    if (tx == TILE_SIZE - 1 &amp;&amp; gx &lt; width - 1)         tile[ty + 1][TILE_SIZE + 1] = input[gy * width + gx + 1];    if (ty == 0 &amp;&amp; gy &gt; 0)         tile[0][tx + 1] = input[(gy - 1) * width + gx];    if (ty == TILE_SIZE - 1 &amp;&amp; gy &lt; height - 1)         tile[TILE_SIZE + 1][tx + 1] = input[(gy + 1) * width + gx];        // 角落处理省略...        __syncthreads();        // 卷积计算    if (gx &lt; width &amp;&amp; gy &lt; height) &#123;        float sum = 0.0f;        for (int dy = -1; dy &lt;= 1; dy++) &#123;            for (int dx = -1; dx &lt;= 1; dx++) &#123;                sum += tile[ty + 1 + dy][tx + 1 + dx] *                        d_sharpen_kernel[(dy + 1) * 3 + (dx + 1)];            &#125;        &#125;        // 钳制到 [0, 255]        sum = fminf(fmaxf(sum, 0.0f), 255.0f);        output[gy * width + gx] = (unsigned char)sum;    &#125;&#125;\n1D vs 2D 卷积的可分离性\n可分离卷积\n有些 2D 卷积核可以分解为两个 1D 卷积核的外积：\n                       ┌───┐   ┌─────────────┐┌───────────┐          │ 1 │   │             ││ 1  4  6  4  1 │      │ 4 │ × │ 1 4 6 4 1   ││ 4 16 24 16 4 │  =    │ 6 │   │             ││ 6 24 36 24 6 │       │ 4 │   │             ││ 4 16 24 16 4 │       │ 1 │   │             ││ 1  4  6  4  1 │      └───┘   └─────────────┘└───────────┘        垂直 1D     水平 1D   5×5 高斯\n可分离卷积的优势\n原始 2D：每像素 5×5 = 25 次乘法\n可分离：每像素 5 + 5 = 10 次乘法\n计算量减少 60%！\nCUDA 实现思路\n// 第一步：水平卷积（每行）conv1d_horizontal&lt;&lt;&lt;gridH, blockH&gt;&gt;&gt;(input, temp, width, height, kernel_h);// 第二步：垂直卷积（每列）conv1d_vertical&lt;&lt;&lt;gridV, blockV&gt;&gt;&gt;(temp, output, width, height, kernel_v);\n常见的高斯模糊、盒状模糊都是可分离的，这是实际优化中的重要技巧。\n小结\n第七章围绕卷积，整合了多项内存优化技术：\n常量内存：卷积核对所有线程相同，放常量内存是自然选择。广播访问让带宽消耗趋近于零。\nTiled 共享内存：输入数据有大量重叠访问。用共享内存缓存 Tile，全局内存访问降低到接近 1 次/元素。\nHalo 处理：2D Tiling 的关键难点。边界、角落需要细心处理。建议分区加载——不同区域由不同线程负责。\n缓存利用：现代 GPU 的 L1/L2 缓存能自动覆盖部分数据复用。小卷积核、调试阶段可以依赖缓存，正式优化再加 Tiling。\n可分离卷积：高斯等可分离核，分解成两次 1D 卷积，计算量直接减半。\n卷积是深度学习和图像处理的核心算子，优化卷积的思路——常量内存、Tiling、Halo 处理——适用于很多相似的模板计算模式。下一章会学习另一个重要模式——Stencil（模板计算），思路类似但有自己的特点。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 07\n第七章：卷积\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","卷积","常量内存","Tiling"]},{"title":"PMPP-第三章：多维网格和数据","url":"/posts/6b7045b6/","content":"前言\n第二章的向量加法是一维数据，实际应用大多是多维的——图像是2D，矩阵是2D，深度学习张量是3D/4D。第三章讲解如何用CUDA的多维Grid/Block处理这些数据，核心案例是矩阵乘法和图像处理。虽然还是基础实现，但已经能看出GPU编程的思维和优化方向。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n多维线程组织\n从一维到二维\n第二章使用一维索引：\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n处理矩阵若用一维，需要转换：\nint idx = blockIdx.x * blockDim.x + threadIdx.x;int row = idx / width;  // 除法int col = idx % width;  // 取模\n除法和取模在 GPU 上有开销，可读性也差。使用二维更自然：\nint row = blockIdx.y * blockDim.y + threadIdx.y;int col = blockIdx.x * blockDim.x + threadIdx.x;\ndim3类型\ndim3 blockDim(16, 16);     // 256 threads: 16×16dim3 gridDim(64, 64);      // 4096 blockskernel&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(args);\n如果用整数会自动转为1D：\nkernel&lt;&lt;&lt;256, 128&gt;&gt;&gt;(args);  // 等价于 dim3(256,1,1), dim3(128,1,1)\n配置原则\n\n匹配数据维度：图像用2D，体数据用3D\n考虑内存访问：同一warp的线程最好访问连续内存\n硬件限制：\n\n每block最多1024 threads\nGrid的y/z维最多65535 blocks\n\n\n\n常见错误\n1. 参数顺序：&lt;&lt;&lt;grid, block&gt;&gt;&gt;不要反\n2. 向上取整：\n// 错误：size整除时会多一个blockint blocks = size / threads + 1;// 正确int blocks = (size + threads - 1) / threads;\n3. 超过限制：\ndim3 block(32, 32, 1);   // 32*32=1024，刚好dim3 block(32, 32, 2);   // 2048，超限！\n矩阵乘法\n问题定义\nP[i][j] = Σ(k=0→n-1) M[i][k] × N[k][j]\n\nM: m×n\nN: n×o\nP: m×o\n\n基础实现\n每个线程计算一个输出元素：\n__global__ void matMul(float *M, float *N, float *P,                        int m, int n, int o) &#123;    int row = blockIdx.y * blockDim.y + threadIdx.y;    int col = blockIdx.x * blockDim.x + threadIdx.x;        if (row &lt; m &amp;&amp; col &lt; o) &#123;        float sum = 0.0f;        for (int k = 0; k &lt; n; k++) &#123;            sum += M[row * n + k] * N[k * o + col];        &#125;        P[row * o + col] = sum;    &#125;&#125;\n索引公式（行主序）：\n\nM[i][j] → i * width + j\n第i行第j列在一维数组中的位置\n\n启动配置：\ndim3 block(16, 16);dim3 grid((o + 15) / 16, (m + 15) / 16);matMul&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_M, d_N, d_P, m, n, o);\n边界检查：if (row &lt; m &amp;&amp; col &lt; o) 两个条件都要（grid向上取整会多线程）\n性能瓶颈\n算术强度极低：\n每线程读取: 2n个float = 8n bytes每线程计算: 2n FLOP算术强度 = 2n / 8n = 0.25 FLOP/Byte\n对于峰值10 TFLOPS、带宽500 GB/s的GPU：\n达到峰值需要: 10T / 500G = 20 FLOP/Byte实际只有: 0.25利用率: 1.25%\nGPU大部分时间在等数据。更严重的是数据重复读取：M[i][k]被第i行的所有线程读，总共被读m×o次，但每次都从全局内存读，没有复用。\n优化方向（第4-5章）：用Shared Memory做Tiling，算术强度提升到10+ FLOP/Byte。\n变体对比\n每线程一行：\nint row = blockIdx.x * blockDim.x + threadIdx.x;for (int col = 0; col &lt; size; col++) &#123;    // 计算P[row][col]&#125;\n每线程一列：类似，外层循环改为row\n\n\n\n方案\n并行度\n适用场景\n\n\n\n\n每线程一元素\nm×o (最高)\n通用\n\n\n每线程一行\nm\nm &gt;&gt; o\n\n\n每线程一列\no\no &gt;&gt; m\n\n\n\n大多数情况下，每线程一元素的并行度最高。\n矩阵-向量乘法\nA[i] = Σ B[i][j] × C[j]\n__global__ void matVecMul(float *B, float *C, float *A,                           int m, int n) &#123;    int row = blockIdx.x * blockDim.x + threadIdx.x;    if (row &lt; m) &#123;        float sum = 0.0f;        for (int j = 0; j &lt; n; j++) &#123;            sum += B[row * n + j] * C[j];        &#125;        A[row] = sum;    &#125;&#125;\n只需一维，因为输出是向量。瓶颈是向量C被所有线程重复读取，可用Constant Memory或Shared Memory优化。\n图像处理\nRGB转灰度\n公式：Gray = 0.299R + 0.587G + 0.114B\n内存布局（RGB交错）：\n[R0 G0 B0][R1 G1 B1]...[R(w-1) G(w-1) B(w-1)][Rw Gw Bw]...\nKernel：\n__global__ void rgb2gray(unsigned char *rgb, unsigned char *gray,                         int width, int height) &#123;    int col = blockIdx.x * blockDim.x + threadIdx.x;    int row = blockIdx.y * blockDim.y + threadIdx.y;        if (row &lt; height &amp;&amp; col &lt; width) &#123;        int rgbIdx = (row * width + col) * 3;        int grayIdx = row * width + col;                unsigned char r = rgb[rgbIdx];        unsigned char g = rgb[rgbIdx + 1];        unsigned char b = rgb[rgbIdx + 2];                gray[grayIdx] = 0.299f*r + 0.587f*g + 0.114f*b;    &#125;&#125;\n性能：带宽受限（读3字节，写1字节，计算很少），但访问连续，coalescing效果好。\n高斯模糊\n模板计算（Stencil）：每个像素由邻域加权求和\n3×3高斯核：\n1/16 * [1 2 1]       [2 4 2]       [1 2 1]\nKernel：\n__global__ void gaussianBlur(unsigned char *in, unsigned char *out,                              int width, int height) &#123;    int col = blockIdx.x * blockDim.x + threadIdx.x;    int row = blockIdx.y * blockDim.y + threadIdx.y;        // 边界直接复制    if (row == 0 || row == height-1 ||         col == 0 || col == width-1) &#123;        if (row &lt; height &amp;&amp; col &lt; width)            out[row*width + col] = in[row*width + col];        return;    &#125;        if (row &lt; height &amp;&amp; col &lt; width) &#123;        float sum = 0;        // 3x3邻域        sum += in[(row-1)*width + col-1] * 1.0f;        sum += in[(row-1)*width + col  ] * 2.0f;        sum += in[(row-1)*width + col+1] * 1.0f;        sum += in[row*width + col-1] * 2.0f;        sum += in[row*width + col  ] * 4.0f;        sum += in[row*width + col+1] * 2.0f;        sum += in[(row+1)*width + col-1] * 1.0f;        sum += in[(row+1)*width + col  ] * 2.0f;        sum += in[(row+1)*width + col+1] * 1.0f;                out[row*width + col] = sum / 16.0f;    &#125;&#125;\n关键点：\n-边界处理：这里简化为复制，也可padding/镜像\n\n数据重用：相邻像素的邻域重叠，但此版本没复用\n优化：用Shared Memory让block协作加载tile+halo\n\n内存布局\n行主序（C/CUDA）\n元素[row][col]的索引：\nindex = row * width + col\n例：4×3矩阵元素[2][1]：2*3 + 1 = 7\n列主序（Fortran/MATLAB）\nindex = col * height + row\n同样元素[2][1]：1*4 + 2 = 6\n三维张量\n深度×高度×宽度，元素[z][y][x]：\nindex = z * (height * width) + y * width + x\n例：300×500×400 (D×H×W)，元素[5][20][10]：\n5*(500*400) + 20*400 + 10 = 1,008,010\n注意：深度学习框架维度顺序可能不同（PyTorch用NCHW，TensorFlow用NHWC）。\n执行配置示例\n书中习题3：\ndim3 bd(16, 32);                      // block: 16×32dim3 gd((300-1)/16+1, (150-1)/32+1); // grid// M=150, N=300\n\n每block：16×32 = 512 threads\nGrid：(19, 5) = 95 blocks\n总线程：95×512 = 48,640\n有效线程（row&lt;150 &amp;&amp; col&lt;300）：150×300 = 45,000\n浪费：3,640 (7.5%)，可接受\n\n性能分析思路\nRoofline模型\n实际性能 = min(计算峰值, 带宽 × 算术强度)\n要达到计算峰值需要：算术强度 ≥ 峰值FLOPS / 带宽\n例如GPU 10 TFLOPS, 500 GB/s：需要 ≥ 20 FLOP/Byte\n当前算法都远低于此，性能受内存限制。\n提升算术强度\n核心：数据重用\n\nTiling：数据加载到Shared Memory重复使用\n寄存器复用：每线程计算多个元素\nKernel融合：减少中间结果传输\n\n矩阵乘法优化版能达到10+ FLOP/Byte，性能提升10倍以上。\n小结\n第三章从一维扩展到多维，核心是Grid/Block的灵活组织：\n多维索引：row = blockIdx.y*blockDim.y + threadIdx.y 要熟练，二维、三维是自然扩展。\n内存布局：行主序决定索引公式 row*width + col，搞错会访问错误数据。\n性能认知：基础实现都是内存受限，算术强度0.1-0.25 FLOP/Byte，远低于需要的20。GPU计算能力强，但数据供应跟不上。\n优化方向：提升算术强度 = 增加数据重用。这是第4-5章的重点。\n代码习惯：\n\n二维/三维都要严格边界检查\n索引计算先row后col（行主序）\n性能分析要量化（算术强度、带宽利用率）\n\n理解了朴素实现的瓶颈，才能明白共享内存（Shared Memory）和分块（Tiling）的价值。第五章的优化技术会让同样的矩阵乘法性能提升10倍以上。\n\n参考资料：\n\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nCUDA C++ Programming Guide\n\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","矩阵乘法","图像处理"]},{"title":"PMPP-第九章：并行直方图","url":"/posts/d29973f1/","content":"前言\n前几章学的卷积、模板都是&quot;规则&quot;的并行模式——输出位置固定，每个线程知道自己写哪里。但很多实际问题不是这样的，比如直方图：每个输入元素决定更新哪个输出桶，多个线程可能同时更新同一个桶。这就是输出冲突问题。第九章讲解如何用原子操作和私有化技术解决这类问题。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n直方图基础\n什么是直方图\n直方图统计数据的分布。给定一组数据，计算每个值（或区间）出现的次数。\n例子：统计文本中每个字母的出现次数\n输入: &quot;hello world&quot;输出: h:1, e:1, l:3, o:2, w:1, r:1, d:1, 空格:1\n图像直方图：统计每个灰度值（0-255）的像素数量\n输入: 256×256 图像输出: histogram[256]，每个元素是该灰度值的像素计数\n串行实现\nvoid histogram_sequential(unsigned char *data, int *histogram, int n) &#123;    // 初始化    for (int i = 0; i &lt; 256; i++) &#123;        histogram[i] = 0;    &#125;    // 统计    for (int i = 0; i &lt; n; i++) &#123;        histogram[data[i]]++;    &#125;&#125;\n时间复杂度 O(n)，空间复杂度 O(桶数)。\n并行化的挑战\n尝试直接并行化：\n__global__ void histogram_naive(unsigned char *data, int *histogram, int n) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        histogram[data[i]]++;  // 危险！读-改-写竞争    &#125;&#125;\n问题：多个线程可能同时读取同一个 histogram[k]，各自加 1，然后写回。结果只加了 1 次而不是多次。\n线程 A: 读 histogram[5] = 10线程 B: 读 histogram[5] = 10线程 A: 写 histogram[5] = 11线程 B: 写 histogram[5] = 11  // 应该是 12！\n这就是竞态条件（Race Condition）。\n原子操作\n什么是原子操作\n原子操作：不可分割的操作。整个&quot;读-改-写&quot;过程要么全部完成，要么完全不执行，不会被其他线程打断。\nCUDA 提供的原子函数：\n\n\n\n函数\n操作\n返回值\n\n\n\n\natomicAdd\n*addr += val\n旧值\n\n\natomicSub\n*addr -= val\n旧值\n\n\natomicMax\n*addr = max()\n旧值\n\n\natomicMin\n*addr = min()\n旧值\n\n\natomicExch\n*addr = val\n旧值\n\n\natomicCAS\ncompare-and-swap\n旧值\n\n\natomicAnd/Or/Xor\n位操作\n旧值\n\n\n\n使用原子操作的直方图\n__global__ void histogram_atomic(unsigned char *data, int *histogram, int n) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        atomicAdd(&amp;histogram[data[i]], 1);  // 原子加    &#125;&#125;\n正确性保证：atomicAdd 确保每次增量都被正确计入。\n原子操作的开销\n原子操作比普通操作慢得多：\n普通写入：~4 周期原子操作：~数百周期（取决于争用程度）\n原因：\n\n串行化：同一地址的原子操作必须排队执行\n缓存一致性：需要协调多个 SM 的缓存\n内存事务：需要往返全局内存\n\n争用程度影响很大：\n\n\n\n场景\n桶数\n争用程度\n性能\n\n\n\n\n字母统计\n26\n极高\n很慢\n\n\n灰度直方图\n256\n高\n较慢\n\n\n颜色直方图\n16M\n低\n接近峰值\n\n\n\n桶越多，争用越低，性能越好。\n私有化（Privatization）\n核心思想\n私有化：每个线程/块维护自己的私有直方图，最后合并。\n原本：所有线程 → 全局直方图（高争用）私有化：  线程/块 → 私有直方图（无争用）  最后：私有直方图 → 全局直方图（一次性合并）\n共享内存私有化\n每个 Block 用共享内存维护私有直方图：\n#define NUM_BINS 256__global__ void histogram_privatized(unsigned char *data, int *histogram, int n) &#123;    // 私有直方图（共享内存）    __shared__ int private_hist[NUM_BINS];        // 初始化私有直方图    if (threadIdx.x &lt; NUM_BINS) &#123;        private_hist[threadIdx.x] = 0;    &#125;    __syncthreads();        // 统计到私有直方图    int i = blockIdx.x * blockDim.x + threadIdx.x;    int stride = blockDim.x * gridDim.x;        while (i &lt; n) &#123;        atomicAdd(&amp;private_hist[data[i]], 1);  // 共享内存原子操作        i += stride;    &#125;    __syncthreads();        // 合并到全局直方图    if (threadIdx.x &lt; NUM_BINS) &#123;        atomicAdd(&amp;histogram[threadIdx.x], private_hist[threadIdx.x]);    &#125;&#125;\n为什么更快\n共享内存原子操作比全局内存快得多：\n\n\n\n操作位置\n延迟\n带宽\n\n\n\n\n全局内存\n~400 周期\n~500 GB/s\n\n\n共享内存\n~20 周期\n~10 TB/s\n\n\n\n加速比约 20 倍（理想情况）。\n争用也减少：\n原本：所有线程争用同一个全局直方图私有化：  - Block 内线程争用私有直方图（共享内存，快）  - Block 间合并时争用全局直方图（但只有 gridDim 次）\n分阶段分析\n阶段 1（初始化）：NUM_BINS 次写入共享内存阶段 2（私有统计）：n/gridDim 次共享内存原子操作阶段 3（合并）：NUM_BINS 次全局内存原子操作\n全局原子操作从 n 次降到 NUM_BINS × gridDim 次，大幅减少。\n线程粗化\nGrid-Stride Loop\n之前代码已经用了 grid-stride loop：\nint i = blockIdx.x * blockDim.x + threadIdx.x;int stride = blockDim.x * gridDim.x;while (i &lt; n) &#123;    // 处理元素 i    i += stride;&#125;\n优势：\n\n每个线程处理多个元素，分摊开销\nGrid 大小可以固定，不随数据量变化\n更好的缓存利用\n\n连续访问优化\n让每个线程处理连续的一段数据：\n__global__ void histogram_coarsened(unsigned char *data, int *histogram, int n) &#123;    __shared__ int private_hist[NUM_BINS];        // 初始化    for (int i = threadIdx.x; i &lt; NUM_BINS; i += blockDim.x) &#123;        private_hist[i] = 0;    &#125;    __syncthreads();        // 每线程处理连续的 COARSEN_FACTOR 个元素    int base = (blockIdx.x * blockDim.x + threadIdx.x) * COARSEN_FACTOR;        for (int k = 0; k &lt; COARSEN_FACTOR; k++) &#123;        int idx = base + k;        if (idx &lt; n) &#123;            atomicAdd(&amp;private_hist[data[idx]], 1);        &#125;    &#125;    __syncthreads();        // 合并    for (int i = threadIdx.x; i &lt; NUM_BINS; i += blockDim.x) &#123;        atomicAdd(&amp;histogram[i], private_hist[i]);    &#125;&#125;\n优势：连续访问利于内存合并。\n聚合（Aggregation）\n问题\n即使用了共享内存私有化，同一 Warp 内的线程可能频繁争用同一个桶。\n例子：处理全黑图像（所有像素值都是 0）\n32 个线程同时 atomicAdd(&amp;private_hist[0], 1)→ 32 次串行化的原子操作\n解决方案：线程束级聚合\n先在线程束内统计每个值出现多少次，再做一次原子操作：\n__global__ void histogram_aggregated(unsigned char *data, int *histogram, int n) &#123;    __shared__ int private_hist[NUM_BINS];        // 初始化    if (threadIdx.x &lt; NUM_BINS) &#123;        private_hist[threadIdx.x] = 0;    &#125;    __syncthreads();        int i = blockIdx.x * blockDim.x + threadIdx.x;        if (i &lt; n) &#123;        unsigned char value = data[i];                // Warp 级投票：找出同值线程        unsigned int mask = __match_any_sync(__activemask(), value);                // 只有组内第一个线程执行原子操作        if (__ffs(mask) - 1 == (threadIdx.x % 32)) &#123;            atomicAdd(&amp;private_hist[value], __popc(mask));        &#125;    &#125;    __syncthreads();        // 合并到全局    if (threadIdx.x &lt; NUM_BINS) &#123;        atomicAdd(&amp;histogram[threadIdx.x], private_hist[threadIdx.x]);    &#125;&#125;\n线程束级原语\n\n\n\n函数\n功能\n\n\n\n\n__match_any_sync\n返回值相同的线程掩码\n\n\n__ffs\n找第一个置位的位（Find First Set）\n\n\n__popc\n统计置位的位数（Population Count）\n\n\n__activemask\n当前活跃线程掩码\n\n\n\n__match_any_sync 示例：\n线程束内前8个线程的值：[5, 3, 5, 5, 2, 3, 5, 2]__match_any_sync 返回值：  线程 0,2,3,6 返回 0b01001101（值为5的线程掩码）  线程 1,5 返回 0b00100010（值为3的线程掩码）  线程 4,7 返回 0b10010000（值为2的线程掩码）\n效果：原子操作次数从32次降到3次（等于不同值的数量）。对于数据重复率高的场景，性能提升显著。\n完整优化版本\n综合所有优化\n#define BLOCK_SIZE 256#define NUM_BINS 256#define COARSEN_FACTOR 4__global__ void histogram_optimized(unsigned char *data, int *histogram, int n) &#123;    // 共享内存私有直方图    __shared__ int private_hist[NUM_BINS];        // 协作初始化    for (int i = threadIdx.x; i &lt; NUM_BINS; i += blockDim.x) &#123;        private_hist[i] = 0;    &#125;    __syncthreads();        // Grid-stride loop + 粗化    int tid = blockIdx.x * blockDim.x + threadIdx.x;    int stride = blockDim.x * gridDim.x;        for (int base = tid * COARSEN_FACTOR; base &lt; n; base += stride * COARSEN_FACTOR) &#123;        // 加载连续的 COARSEN_FACTOR 个元素        unsigned char values[COARSEN_FACTOR];                #pragma unroll        for (int k = 0; k &lt; COARSEN_FACTOR; k++) &#123;            int idx = base + k;            values[k] = (idx &lt; n) ? data[idx] : 0xFF;  // 0xFF 作为无效标记        &#125;                // 逐个处理，使用线程束聚合        #pragma unroll        for (int k = 0; k &lt; COARSEN_FACTOR; k++) &#123;            if (values[k] != 0xFF) &#123;                unsigned int mask = __match_any_sync(__activemask(), values[k]);                if (__ffs(mask) - 1 == (threadIdx.x % 32)) &#123;                    atomicAdd(&amp;private_hist[values[k]], __popc(mask));                &#125;            &#125;        &#125;    &#125;    __syncthreads();        // 合并到全局直方图    for (int i = threadIdx.x; i &lt; NUM_BINS; i += blockDim.x) &#123;        if (private_hist[i] &gt; 0) &#123;            atomicAdd(&amp;histogram[i], private_hist[i]);        &#125;    &#125;&#125;\n启动配置\nint numBlocks = (n + BLOCK_SIZE * COARSEN_FACTOR - 1) / (BLOCK_SIZE * COARSEN_FACTOR);numBlocks = min(numBlocks, 256);  // 限制 block 数量histogram_optimized&lt;&lt;&lt;numBlocks, BLOCK_SIZE&gt;&gt;&gt;(d_data, d_histogram, n);\n性能对比\n以 1920×1080 灰度图像直方图计算为例：\n\n\n\n版本\n相对性能\n主要瓶颈\n\n\n\n\n朴素全局原子操作\n1×\n全局内存争用\n\n\n共享内存私有化\n10×\n共享内存原子\n\n\n+ 线程粗化\n15×\n原子操作\n\n\n+ 线程束聚合\n25×\n接近带宽上限\n\n\n\n测试环境：\n\n图像大小：1920×1080（约207万像素）\nGPU：NVIDIA RTX 3080（8704 CUDA 核心）\n桶数：256（灰度值0-255）\n块大小：256线程\n\n其他私有化策略\n线程级私有化\n如果桶数很少（如 8 个），可以用寄存器：\n__global__ void histogram_register(unsigned char *data, int *histogram, int n) &#123;    // 每线程私有直方图（寄存器）    int local_hist[8] = &#123;0&#125;;        int i = blockIdx.x * blockDim.x + threadIdx.x;    int stride = blockDim.x * gridDim.x;        while (i &lt; n) &#123;        int bin = data[i] % 8;  // 假设只有 8 个桶        local_hist[bin]++;        i += stride;    &#125;        // 合并到全局    for (int b = 0; b &lt; 8; b++) &#123;        atomicAdd(&amp;histogram[b], local_hist[b]);    &#125;&#125;\n优势：寄存器最快，无争用。\n限制：桶数必须很少（寄存器数量有限）。\n多级私有化\n对于大桶数：\n寄存器（极少桶）→ 共享内存（中等桶）→ 全局内存（大桶数）\n每级容量递增，速度递减。\n原子操作的硬件支持\n支持的数据类型\n\n\n\n类型\n原子操作支持\n备注\n\n\n\n\nint\n全部\n最常用\n\n\nunsigned\n全部\n\n\n\nfloat\natomicAdd\nKepler+ (CC 3.0)\n\n\ndouble\natomicAdd\nPascal+ (CC 6.0)\n\n\nhalf\natomicAdd\nVolta+ (CC 7.0)\n\n\n\n共享内存 vs 全局内存原子\n\n\n\n特性\n共享内存原子\n全局内存原子\n\n\n\n\n延迟\n~20 周期\n~400 周期\n\n\n带宽\n高\n低\n\n\n争用范围\nBlock 内\n全设备\n\n\n适用场景\n中间结果\n最终结果\n\n\n\n原子操作实现原理\nCompare-And-Swap (CAS)：\n// atomicAdd 的本质实现__device__ int atomicAdd_manual(int *addr, int val) &#123;    int old = *addr, assumed;    do &#123;        assumed = old;        old = atomicCAS(addr, assumed, assumed + val);    &#125; while (old != assumed);    return old;&#125;\n循环直到成功——高争用时可能循环很多次。\n应用扩展\n多通道直方图\nRGB 图像的三通道直方图：\n__global__ void histogram_rgb(unsigned char *image, int *hist_r, int *hist_g, int *hist_b, int n) &#123;    __shared__ int priv_r[256], priv_g[256], priv_b[256];        // 初始化    // ...        int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        atomicAdd(&amp;priv_r[image[3*i + 0]], 1);        atomicAdd(&amp;priv_g[image[3*i + 1]], 1);        atomicAdd(&amp;priv_b[image[3*i + 2]], 1);    &#125;    __syncthreads();        // 合并    // ...&#125;\n加权直方图\n每个数据点有权重：\natomicAdd(&amp;histogram[data[i]], weight[i]);\n用于直方图均衡化等场景。\n二维直方图\n统计两个变量的联合分布：\nint bin_x = data_x[i] / bin_width_x;int bin_y = data_y[i] / bin_width_y;int bin = bin_y * num_bins_x + bin_x;atomicAdd(&amp;histogram_2d[bin], 1);\n性能调优建议\n选择策略\n\n\n\n桶数\n推荐策略\n\n\n\n\n&lt; 16\n寄存器私有化\n\n\n16 - 1024\n共享内存私有化 + 聚合\n\n\n&gt; 1024\n直接全局原子（争用低）\n\n\n\n关键参数\nBlock 大小：256 或 512，保证足够的并行度。\n粗化因子：4-16，平衡寄存器压力和计算粒度。\nGrid 大小：不要太大，否则合并阶段开销增加。\nNsight 指标\n\n\n\n指标\n含义\n目标\n\n\n\n\nAtomic Operations\n原子操作数\n越少越好\n\n\nShared Memory Bandwidth\n共享内存带宽\n接近峰值\n\n\nWarp Efficiency\nWarp 利用率\n&gt; 90%\n\n\n\n小结\n第九章解决了&quot;输出冲突&quot;问题：\n原子操作：保证&quot;读-改-写&quot;的原子性，解决竞态条件。但全局内存原子操作很慢，尤其在高争用时。\n私有化：每个 Block 用共享内存维护私有副本，最后合并。共享内存原子比全局快 20 倍，争用也被限制在 Block 内。\n线程粗化：每线程处理多个元素，分摊初始化和合并开销。Grid-stride loop 是通用模式。\n线程束聚合：使用 __match_any_sync 找同值线程，只做一次原子操作。在数据重复率高时效果显著。\n策略选择：桶数决定策略——少桶用寄存器，中桶用共享内存，多桶直接全局原子。\n直方图是&quot;归约到多个目标&quot;的典型代表。原子操作和私有化技术也适用于其他类似问题：散射（scatter）、分组聚合、哈希表构建等。下一章将学习另一个重要模式——归约。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 09\n第九章：并行直方图\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","直方图","原子操作","私有化"]},{"title":"PMPP-第二十二章：高级实践与未来演变","url":"/posts/a3a140de/","content":"前言\n第二十一章介绍了动态并行性。作为全书的最后一章，第二十二章总结了高级实践（Advanced Practices）并展望了未来演变（Future Evolution）。本章不再引入新的编程技术，而是讨论如何在实际项目中应用前面学到的知识，以及 GPU 计算领域的发展趋势。掌握这些内容，将有助于在快速变化的技术环境中持续成长。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n性能优化方法论\n性能分析驱动\n不要猜测，要测量。\n优化前必须先找到瓶颈：\n\n使用 Nsight Systems 分析整体流程\n使用 Nsight Compute 分析单个 kernel\n根据数据决定优化方向\n\nRoofline 模型回顾\n性能上限 = min(峰值算力, 带宽 × 算术强度)\n算术强度 = FLOP / Byte\n\n\n\n算术强度\n瓶颈类型\n优化方向\n\n\n\n\n&lt; 10\n内存受限\n提高数据复用、减少访存\n\n\n&gt; 10\n计算受限\n优化计算效率、减少指令数\n\n\n\n优化层次\n┌─────────────────────────────────────────┐│ 第五层：算法选择                         ││   选择更高效的算法（收益最大）            │├─────────────────────────────────────────┤│ 第四层：数据布局                         ││   SoA vs AoS、对齐、Padding             │├─────────────────────────────────────────┤│ 第三层：并行策略                         ││   任务分解、负载均衡、线程映射            │├─────────────────────────────────────────┤│ 第二层：内存层次                         ││   共享内存、寄存器、缓存利用              │├─────────────────────────────────────────┤│ 第一层：指令级                           ││   循环展开、向量化、快速数学函数          │└─────────────────────────────────────────┘\n从上往下优化：高层优化的收益通常远大于低层。\n常见优化技术总结\n内存优化\n\n\n\n技术\n适用场景\n效果\n\n\n\n\n合并访问\n全局内存访问\n减少内存事务\n\n\n共享内存\n数据复用\n减少全局访问\n\n\n常量内存\n只读广播数据\n利用缓存\n\n\n纹理内存\n2D 局部性\n硬件插值\n\n\n寄存器 Tiling\n矩阵运算\n最大化复用\n\n\n\n计算优化\n\n\n\n技术\n适用场景\n效果\n\n\n\n\n循环展开\n固定迭代循环\n减少指令开销\n\n\n线程粗化\n每线程工作太少\n减少调度开销\n\n\n快速数学\n精度要求不高\n减少时钟周期\n\n\nWarp Shuffle\nWarp 内通信\n避免共享内存\n\n\n\n并行度优化\n\n\n\n技术\n适用场景\n效果\n\n\n\n\n增加线程数\n隐藏延迟\n提高占用率\n\n\n动态并行\n递归/自适应\n减少 CPU 参与\n\n\nCUDA 流\n多任务重叠\n隐藏传输延迟\n\n\n\n代码可移植性\n跨 GPU 架构\n不同 GPU 架构有不同特性：\n\n\n\n架构\n特点\n\n\n\n\nKepler (sm_35)\n动态并行首次支持\n\n\nMaxwell (sm_50)\n改进的共享内存\n\n\nPascal (sm_60)\n统一内存改进\n\n\nVolta (sm_70)\nTensor Core、独立线程调度\n\n\nAmpere (sm_80)\n异步拷贝、更大 L2\n\n\nHopper (sm_90)\nTransformer Engine\n\n\n\n编写可移植代码\n参数化关键常量：\n#if __CUDA_ARCH__ &gt;= 800    #define SHARED_MEM_SIZE 164 * 1024  // Ampere: 164KB#elif __CUDA_ARCH__ &gt;= 700    #define SHARED_MEM_SIZE 96 * 1024   // Volta: 96KB#else    #define SHARED_MEM_SIZE 48 * 1024   // 默认: 48KB#endif\n运行时查询能力：\ncudaDeviceProp prop;cudaGetDeviceProperties(&amp;prop, 0);int blocks_per_sm = prop.maxBlocksPerMultiProcessor;int shared_mem = prop.sharedMemPerBlock;int max_threads = prop.maxThreadsPerBlock;\n跨平台技术\n\n\n\n技术\n描述\n优势\n\n\n\n\nCUDA\nNVIDIA 专用\n性能最佳\n\n\nOpenCL\n跨厂商标准\n可移植性\n\n\nSYCL\nC++ 标准化\n现代 C++ 风格\n\n\nHIP\nAMD 兼容 CUDA\n易于迁移\n\n\nKokkos\n抽象层\n多后端支持\n\n\n\n调试与验证\n常见错误类型\n\n内存错误：越界访问、未初始化内存\n竞态条件：同步不当导致数据竞争\n数值误差：浮点精度、舍入误差\n死锁：同步原语使用不当\n\n调试工具\n\n\n\n工具\n用途\n\n\n\n\ncuda-memcheck\n内存错误检测\n\n\ncompute-sanitizer\n新一代错误检测\n\n\nNsight Eclipse\nIDE 集成调试\n\n\nNsight Visual Studio\nWindows 调试\n\n\nprintf\n简单调试（慎用）\n\n\n\n验证策略\n// 1. 保留 CPU 参考实现void cpu_reference(float *output, float *input, int n);// 2. 对比 GPU 结果bool verify_result(float *gpu, float *cpu, int n, float epsilon) &#123;    for (int i = 0; i &lt; n; i++) &#123;        if (fabsf(gpu[i] - cpu[i]) &gt; epsilon) &#123;            printf(&quot;Mismatch at %d: GPU=%.6f, CPU=%.6f\\n&quot;,                    i, gpu[i], cpu[i]);            return false;        &#125;    &#125;    return true;&#125;// 3. 渐进式测试// 小规模 → 中规模 → 大规模// 1 Block → 多 Block → 多 SM\n生产环境最佳实践\n错误处理\n#define CUDA_CHECK(call) \\    do &#123; \\        cudaError_t err = call; \\        if (err != cudaSuccess) &#123; \\            fprintf(stderr, &quot;CUDA error at %s:%d: %s\\n&quot;, \\                    __FILE__, __LINE__, cudaGetErrorString(err)); \\            exit(EXIT_FAILURE); \\        &#125; \\    &#125; while(0)// 使用CUDA_CHECK(cudaMalloc(&amp;d_ptr, size));CUDA_CHECK(cudaMemcpy(d_ptr, h_ptr, size, cudaMemcpyHostToDevice));\n资源管理\n// RAII 风格管理 CUDA 资源class CudaBuffer &#123;    void *ptr;    size_t size;public:    CudaBuffer(size_t n) : size(n) &#123;        CUDA_CHECK(cudaMalloc(&amp;ptr, n));    &#125;    ~CudaBuffer() &#123;        cudaFree(ptr);    &#125;    void* get() &#123; return ptr; &#125;    // 禁止拷贝    CudaBuffer(const CudaBuffer&amp;) = delete;    CudaBuffer&amp; operator=(const CudaBuffer&amp;) = delete;&#125;;\n性能监控\n// 计时cudaEvent_t start, stop;cudaEventCreate(&amp;start);cudaEventCreate(&amp;stop);cudaEventRecord(start);my_kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(args);cudaEventRecord(stop);cudaEventSynchronize(stop);float milliseconds = 0;cudaEventElapsedTime(&amp;milliseconds, start, stop);printf(&quot;Kernel time: %.3f ms\\n&quot;, milliseconds);cudaEventDestroy(start);cudaEventDestroy(stop);\nGPU 计算生态系统\nCUDA 库\n\n\n\n库\n领域\n功能\n\n\n\n\ncuBLAS\n线性代数\n矩阵运算\n\n\ncuFFT\n信号处理\n傅里叶变换\n\n\ncuDNN\n深度学习\n神经网络原语\n\n\ncuSPARSE\n稀疏矩阵\n稀疏运算\n\n\ncuRAND\n随机数\n伪随机生成\n\n\nThrust\n通用\nSTL 风格容器\n\n\nCUB\n底层\n原语库\n\n\n\n使用库的优势\n\n经过高度优化：专家团队持续调优\n版本间改进：自动受益于新架构优化\n减少开发时间：专注业务逻辑\n减少错误：经过广泛测试\n\n何时自己实现\n\n特殊需求库不满足\n库的通用实现不够高效\n学习目的\n\n未来趋势\n硬件演进\n更多核心：\n\nSM 数量持续增加\n更高的并行度\n对负载均衡要求更高\n\n专用加速器：\n\nTensor Core（矩阵运算）\nRT Core（光线追踪）\nTransformer Engine（AI）\n\n内存技术：\n\nHBM 带宽持续增长\n更大的 L2 缓存\n统一内存性能改进\n\n编程模型演进\n更高抽象：\n\nCUDA Graphs：静态任务图\nCUDA Cooperative Groups：灵活同步\nC++ 标准并行：std::execution\n\n跨平台标准：\n\nSYCL 普及\noneAPI 生态\n可移植性重要性增加\n\n应用领域扩展\n传统 HPC：\n\n气象模拟\n分子动力学\n流体力学\n\nAI/ML：\n\n大语言模型训练\n推理加速\n自动驾驶\n\n新兴领域：\n\n量子计算模拟\n数字孪生\n元宇宙渲染\n\n持续学习资源\n官方资源\n\nCUDA 文档：https://docs.nvidia.com/cuda/\nNVIDIA Developer Blog：技术文章和最佳实践\nGTC 大会：最新技术发布\nCUDA Zone：示例代码和教程\n\n学术资源\n\nPMPP 教材：本书是经典参考\nUIUC ECE 408：配套课程（Coursera 可看）\nStanford CS 149：并行计算基础\n论文：GTC、SC、ICS 会议\n\n社区\n\nStack Overflow：cuda 标签\nNVIDIA 开发者论坛：官方支持\nGitHub：开源 CUDA 项目\nReddit r/CUDA：讨论社区\n\n全书回顾\n基础篇（1-6章）\n\n\n\n章节\n主题\n核心概念\n\n\n\n\n1\n引言\n异构计算、CUDA 生态\n\n\n2\n数据并行\nThread、Block、Grid\n\n\n3\n多维数据\n线程索引、边界检查\n\n\n4\n计算架构\nSM、Warp、调度\n\n\n5\n内存架构\n层次结构、Tiling\n\n\n6\n性能考虑\n合并访问、发散、资源\n\n\n\n模式篇（7-15章）\n\n\n\n章节\n主题\n核心模式\n\n\n\n\n7\n卷积\nTiling、Halo\n\n\n8\n模板\n缓存、Register Tiling\n\n\n9\n直方图\n原子操作、私有化\n\n\n10\n归约\n树形归约、Warp 原语\n\n\n11\n前缀和\nScan、Work-Efficient\n\n\n12\n归并\nCo-Rank、循环展开\n\n\n13\n排序\n基数排序、并行归并\n\n\n14\n稀疏矩阵\nCSR/ELL/COO 格式\n\n\n15\n图算法\nBFS、边界推进\n\n\n\n应用篇（16-18章）\n\n\n\n章节\n主题\n应用领域\n\n\n\n\n16\n深度学习\n卷积、池化、全连接\n\n\n17\nMRI 重建\nNUFFT、共轭梯度\n\n\n18\n静电势能\nN-body、空间分区\n\n\n\n高级篇（19-22章）\n\n\n\n章节\n主题\n核心内容\n\n\n\n\n19\n计算思维\n方法论、设计原则\n\n\n20\n集群编程\nMPI+CUDA、Halo交换\n\n\n21\n动态并行\n设备端启动、递归\n\n\n22\n高级实践\n最佳实践、未来趋势\n\n\n\n写在最后\n并行编程心法十条\n\n理解硬件：了解 GPU 架构，扬长避短\n数据为王：性能通常受限于数据移动\n最大化并行：暴露足够的并行性隐藏延迟\n最小化同步：同步是性能杀手\n合并访问：让内存访问连续\n复用数据：共享内存是你最好的朋友\n避免发散：让 Warp 内线程走相同路径\n权衡取舍：没有银弹，只有适合的解\nProfile 优先：数据驱动优化，不要猜测\n渐进迭代：先正确，后优化，持续改进\n\n从学习到实践\n阶段一：理解基础  ↓ 多写代码、多做练习阶段二：掌握模式  ↓ 在实际项目中应用阶段三：形成直觉  ↓ 阅读论文、参与开源阶段四：持续精进\n结语\n这本书带你从 CUDA 入门走到了高级实践。但学习永无止境——GPU 技术快速演进，新架构、新特性不断涌现。\n核心能力胜过具体知识：\n\n理解并行计算原理 &gt; 记住 API 细节\n掌握优化方法论 &gt; 背诵优化技巧\n培养计算思维 &gt; 复制代码模板\n\n希望这本书和这个系列博客能帮助你建立扎实的并行计算基础。接下来，不断实践、持续学习，在 GPU 计算的世界里探索更多可能！\n\n参考资料：\n\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nNVIDIA. CUDA C++ Programming Guide. https://docs.nvidia.com/cuda/cuda-c-programming-guide/\nNVIDIA. CUDA C++ Best Practices Guide. https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/\n\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n系列完结：感谢阅读 PMPP 全书 22 章博客系列！\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","性能优化","未来趋势","最佳实践"]},{"title":"PMPP-第二十一章：CUDA动态并行性","url":"/posts/e519c4bc/","content":"前言\n第二十章介绍了多 GPU 集群编程。第二十一章回到单 GPU 的高级特性——动态并行性（Dynamic Parallelism）。传统 CUDA 程序中，只有 CPU 能启动核函数；而动态并行性允许GPU 核函数直接启动子核函数，无需返回 CPU。这一特性对递归算法、自适应计算、不规则数据结构（如树、图）的处理特别有用。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n什么是动态并行性\n传统 CUDA 模型的限制\n传统 CUDA 程序中：\nCPU 代码 → 启动 kernel1 → GPU 执行 → 返回 CPU         → 启动 kernel2 → GPU 执行 → 返回 CPU         → ...\n问题：\n\n每次启动 kernel 都需要 CPU 参与\n递归算法难以表达\n自适应算法需要多次 CPU-GPU 往返\n\n动态并行性\n动态并行性：允许 GPU kernel 直接启动子 kernel（child kernel）。\nCPU 代码 → 启动父 kernel → GPU 执行                           ├→ 启动子 kernel1 → GPU 执行                           ├→ 启动子 kernel2 → GPU 执行                           └→ ...\n优势：\n\n减少 CPU-GPU 通信\n自然表达递归算法\n根据数据特性动态调整计算\n\n硬件要求\n动态并行性需要计算能力 3.5 或更高的 GPU。\n# 编译时需要特殊选项nvcc -arch=sm_35 -rdc=true my_program.cu -lcudadevrt\n\n-rdc=true：启用可重定位设备代码\n-lcudadevrt：链接设备运行时库\n\n基本语法\n在设备代码中启动 kernel\n__global__ void child_kernel(int *data, int n) &#123;    int idx = threadIdx.x + blockIdx.x * blockDim.x;    if (idx &lt; n) &#123;        data[idx] *= 2;    &#125;&#125;__global__ void parent_kernel(int *data, int n) &#123;    // 在设备代码中启动子 kernel    child_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;(data, n);        // 等待子 kernel 完成    cudaDeviceSynchronize();&#125;\n设备端同步\n// 等待当前线程启动的所有子 kernel 完成cudaDeviceSynchronize();// 等待特定流中的操作完成cudaStreamSynchronize(stream);\n注意：父 kernel 退出时会隐式等待所有子 kernel 完成。\n设备端内存管理\n__global__ void parent_kernel() &#123;    float *temp;        // 在设备端分配内存    cudaMalloc(&amp;temp, 1024 * sizeof(float));        // 使用内存...    child_kernel&lt;&lt;&lt;1, 256&gt;&gt;&gt;(temp, 1024);    cudaDeviceSynchronize();        // 释放内存    cudaFree(temp);&#125;\n内存可见性\n哪些内存子 kernel 可以访问\n\n\n\n内存类型\n子 kernel 可访问\n说明\n\n\n\n\n全局内存\n✓\n父子共享\n\n\n常量内存\n✓\n编译时确定，共享\n\n\n纹理内存\n✓\n父子共享\n\n\n共享内存\n✗\n仅限当前 Block\n\n\n局部内存\n✗\n仅限当前线程\n\n\n\n内存一致性\n父 kernel 的全局内存写入对子 kernel 可见，需要遵循一定规则：\n__global__ void parent_kernel(int *data) &#123;    // 写入全局内存    data[threadIdx.x] = threadIdx.x * 2;        // 确保写入完成（块内同步）    __threadfence();        // 启动子 kernel    if (threadIdx.x == 0) &#123;        child_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;(data);    &#125;&#125;\n关键点：\n\n父线程在启动子 kernel 前的写入对子 kernel 可见\n子 kernel 的写入在 cudaDeviceSynchronize() 后对父线程可见\n\n流与并发\n默认流行为\n__global__ void parent_kernel() &#123;    // 这两个 kernel 在同一个 Block 的默认流中顺序执行    child_kernel1&lt;&lt;&lt;1, 32&gt;&gt;&gt;();    child_kernel2&lt;&lt;&lt;1, 32&gt;&gt;&gt;();  // 等待 child_kernel1 完成&#125;\n重要：同一 Block 内的线程共享默认流，因此子 kernel 会串行执行。\n使用独立流实现并发\n__global__ void parent_kernel() &#123;    cudaStream_t stream;    cudaStreamCreateWithFlags(&amp;stream, cudaStreamNonBlocking);        // 在独立流中启动，可以与其他 kernel 并发    child_kernel&lt;&lt;&lt;1, 32, 0, stream&gt;&gt;&gt;();        cudaStreamDestroy(stream);&#125;\n并发子 kernel 示例\n__global__ void parent_kernel(float *data, int n) &#123;    int chunk_size = n / 4;    cudaStream_t streams[4];        for (int i = 0; i &lt; 4; i++) &#123;        cudaStreamCreateWithFlags(&amp;streams[i], cudaStreamNonBlocking);        child_kernel&lt;&lt;&lt;1, 256, 0, streams[i]&gt;&gt;&gt;(            data + i * chunk_size, chunk_size);    &#125;        // 等待所有流完成    cudaDeviceSynchronize();        for (int i = 0; i &lt; 4; i++) &#123;        cudaStreamDestroy(streams[i]);    &#125;&#125;\n启动池配置\n什么是启动池\n每次子 kernel 启动需要从启动池分配资源。\n两种池：\n\n固定大小池：默认 2048 个槽位，预分配\n虚拟化池：动态扩展，但性能较低\n\n配置启动池\n// 获取当前设备属性cudaDeviceProp prop;cudaGetDeviceProperties(&amp;prop, 0);// 设置固定池大小cudaDeviceSetLimit(cudaLimitDevRuntimePendingLaunchCount, 8192);\n建议：\n\n如果预期子 kernel 数量超过默认值，增大固定池\n如果子 kernel 数量可预测，设置为该值\n\n应用示例：Bezier 曲线细分\n问题描述\nBezier 曲线由控制点定义。曲线越弯曲，需要越多采样点才能平滑显示。\n自适应细分：根据曲率决定采样点数量。\n数据结构\n#define MAX_TESS_POINTS 32struct BezierLine &#123;    float2 CP[3];                      // 3 个控制点    float2 vertexPos[MAX_TESS_POINTS]; // 细分后的顶点    int nVertices;                     // 顶点数量&#125;;\n计算曲率\n__device__ float computeCurvature(float2 *cp) &#123;    // 计算首尾连线长度    float dx = cp[2].x - cp[0].x;    float dy = cp[2].y - cp[0].y;    float line_length = sqrtf(dx * dx + dy * dy);        if (line_length &lt; 0.001f) return 0.0f;        // 计算中点到直线的距离（曲率近似）    float cross = fabsf((cp[1].x - cp[0].x) * dy -                         (cp[1].y - cp[0].y) * dx);    return cross / line_length;&#125;\n子 kernel：计算细分点\n__global__ void computeBezierLine_child(    int lidx, BezierLine *bLines, int nTessPoints) &#123;        int idx = threadIdx.x + blockDim.x * blockIdx.x;    if (idx &lt; nTessPoints) &#123;        // 计算参数 u ∈ [0, 1]        float u = (float)idx / (float)(nTessPoints - 1);        float omu = 1.0f - u;                // 二次 Bezier 基函数        float B[3];        B[0] = omu * omu;        B[1] = 2.0f * u * omu;        B[2] = u * u;                // 计算点位置        float2 pos = &#123;0, 0&#125;;        for (int i = 0; i &lt; 3; i++) &#123;            pos.x += B[i] * bLines[lidx].CP[i].x;            pos.y += B[i] * bLines[lidx].CP[i].y;        &#125;                bLines[lidx].vertexPos[idx] = pos;    &#125;&#125;\n父 kernel：动态决定细分程度\n__global__ void computeBezierLines_parent(    BezierLine *bLines, int nLines) &#123;        int lidx = threadIdx.x + blockDim.x * blockIdx.x;    if (lidx &lt; nLines) &#123;        // 根据曲率计算需要的顶点数        float curvature = computeCurvature(bLines[lidx].CP);        int nVertices = min(max((int)(curvature * 16.0f), 4),                             MAX_TESS_POINTS);        bLines[lidx].nVertices = nVertices;                // 动态启动子 kernel        int blocks = (nVertices + 31) / 32;        computeBezierLine_child&lt;&lt;&lt;blocks, 32&gt;&gt;&gt;(            lidx, bLines, nVertices);    &#125;&#125;\n动态 vs 静态对比\n// 静态版本：每条曲线使用固定 Block，循环处理__global__ void computeBezierLines_static(    BezierLine *bLines, int nLines) &#123;        int bidx = blockIdx.x;    if (bidx &lt; nLines) &#123;        float curvature = computeCurvature(bLines[bidx].CP);        int nVertices = min(max((int)(curvature * 16.0f), 4),                             MAX_TESS_POINTS);        bLines[bidx].nVertices = nVertices;                // 用循环代替子 kernel        for (int inc = 0; inc &lt; nVertices; inc += blockDim.x) &#123;            int idx = inc + threadIdx.x;            if (idx &lt; nVertices) &#123;                // ... 计算顶点 ...            &#125;        &#125;    &#125;&#125;\n对比：\n\n\n\n方面\n动态并行\n静态版本\n\n\n\n\n代码结构\n更自然\n需要手动循环\n\n\n资源利用\n子 kernel 精确配置\n可能浪费线程\n\n\n启动开销\n较高\n无额外开销\n\n\n适用场景\n工作量变化大\n工作量均匀\n\n\n\n应用示例：四叉树构建\n问题描述\n四叉树（Quadtree）：递归地将 2D 空间划分为四个象限，用于空间索引、碰撞检测、图像压缩等。\n初始区域         第一次划分         继续划分...┌─────────┐     ┌────┬────┐     ┌──┬──┬────┐│         │     │ TL │ TR │     │  │  │ TR ││    *    │  →  ├────┼────┤  →  ├──┼──┼────┤│   **    │     │ BL │ BR │     │  │  │    │└─────────┘     └────┴────┘     └──┴──┴────┘\n递归算法\nfunction build_quadtree(node, points):    if depth &gt; max_depth or len(points) &lt; threshold:        return  // 停止递归        // 将点分类到四个象限    for each point in points:        classify to TL, TR, BL, or BR        // 递归处理每个象限    build_quadtree(node.TL, TL_points)    build_quadtree(node.TR, TR_points)    build_quadtree(node.BL, BL_points)    build_quadtree(node.BR, BR_points)\n数据结构\nclass Quadtree_node &#123;    int m_id;                  // 节点 ID    Bounding_box m_bbox;       // 边界框    int m_begin, m_end;        // 点范围 [begin, end)    public:    __device__ int num_points() const &#123; return m_end - m_begin; &#125;    // ...&#125;;struct Parameters &#123;    int point_selector;         // 双缓冲选择器    int num_nodes_at_this_level; // 当前层节点数    int depth;                  // 当前深度    int max_depth;              // 最大深度    int min_points_per_node;    // 停止阈值&#125;;\n核心 kernel\n__global__ void build_quadtree_kernel(    Quadtree_node *nodes, Points *points, Parameters params) &#123;        __shared__ int smem[8];  // 每个象限的点数和偏移        Quadtree_node *node = &amp;nodes[blockIdx.x];    int num_points = node-&gt;num_points();        // 检查停止条件    if (params.depth &gt;= params.max_depth ||         num_points &lt;= params.min_points_per_node) &#123;        return;    &#125;        // 计算边界框中心    float2 center;    node-&gt;bounding_box().compute_center(&amp;center);        // 统计每个象限的点数    count_points_in_children(points[params.point_selector],                               smem, node, center);        // 计算重排偏移    scan_for_offsets(node-&gt;points_begin(), smem);        // 重排点到双缓冲    reorder_points(points[(params.point_selector + 1) % 2],                   points[params.point_selector], smem, node, center);        // 递归启动子 kernel    if (threadIdx.x == 0) &#123;        Quadtree_node *children =             &amp;nodes[params.num_nodes_at_this_level + blockIdx.x * 4];                prepare_children(children, node, smem, center);                Parameters next_params(params, true);  // 更新参数                for (int i = 0; i &lt; 4; i++) &#123;            if (smem[i] &gt; 0) &#123;  // 只处理非空象限                build_quadtree_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;(                    &amp;children[i], points, next_params);            &#125;        &#125;    &#125;&#125;\n点分类（统计阶段）\n__device__ void count_points_in_children(    const Points &amp;in_points, int *smem,     int range_begin, int range_end, float2 center) &#123;        // 初始化计数    if (threadIdx.x &lt; 4) &#123;        smem[threadIdx.x] = 0;    &#125;    __syncthreads();        // 每个线程处理多个点    for (int iter = range_begin + threadIdx.x;          iter &lt; range_end; iter += blockDim.x) &#123;        float2 p = in_points.get_point(iter);                if (p.x &lt; center.x &amp;&amp; p.y &gt;= center.y) &#123;            atomicAdd(&amp;smem[0], 1);  // 左上        &#125; else if (p.x &gt;= center.x &amp;&amp; p.y &gt;= center.y) &#123;            atomicAdd(&amp;smem[1], 1);  // 右上        &#125; else if (p.x &lt; center.x &amp;&amp; p.y &lt; center.y) &#123;            atomicAdd(&amp;smem[2], 1);  // 左下        &#125; else &#123;            atomicAdd(&amp;smem[3], 1);  // 右下        &#125;    &#125;    __syncthreads();&#125;\n深度分析\n假设初始有 64 个均匀分布的点：\n\n\n\n深度\n节点数\n每节点点数\n\n\n\n\n0\n1\n64\n\n\n1\n4\n16\n\n\n2\n16\n4\n\n\n3\n64\n1\n\n\n\n总共启动 1 + 4 + 16 = 21 个子 kernel。\n性能考虑\n启动开销\n子 kernel 启动有开销：\n\n资源分配\n参数传递\n调度延迟\n\n建议：只在工作量足够大时使用动态并行。\n嵌套深度限制\nCUDA 限制嵌套深度（通常 24 层）。\n// 检查支持的嵌套深度int max_depth;cudaDeviceGetAttribute(&amp;max_depth,     cudaDevAttrMaxDeviceRuntimeSynchronizationDepth, 0);\n内存消耗\n每层递归消耗栈空间。深度递归可能导致栈溢出。\n// 增大栈大小cudaDeviceSetLimit(cudaLimitStackSize, 8192);\n何时使用动态并行\n适合使用：\n\n递归算法（树遍历、分治）\n自适应细分（网格细化、LOD）\n不规则数据（稀疏图、不平衡树）\n\n不适合使用：\n\n规则的数据并行（矩阵运算）\n子 kernel 工作量很小\n需要极致性能的场景\n\n调试与最佳实践\n错误处理\n__global__ void parent_kernel() &#123;    cudaError_t err;        child_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;();    err = cudaGetLastError();    if (err != cudaSuccess) &#123;        printf(&quot;Child kernel launch failed: %s\\n&quot;,                cudaGetErrorString(err));    &#125;        err = cudaDeviceSynchronize();    if (err != cudaSuccess) &#123;        printf(&quot;Child kernel execution failed: %s\\n&quot;,                cudaGetErrorString(err));    &#125;&#125;\n避免过度嵌套\n__global__ void recursive_kernel(int depth, int max_depth) &#123;    if (depth &gt;= max_depth) &#123;        return;  // 停止递归    &#125;        recursive_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;(depth + 1, max_depth);&#125;\n资源管理\n__global__ void parent_kernel() &#123;    float *temp;    cudaMalloc(&amp;temp, size);        // 确保子 kernel 完成后再释放    child_kernel&lt;&lt;&lt;1, 32&gt;&gt;&gt;(temp);    cudaDeviceSynchronize();        cudaFree(temp);&#125;\n小结\n第二十一章介绍了 CUDA 动态并行性这一高级特性：\n核心概念：GPU kernel 可以直接启动子 kernel，无需返回 CPU。这使得递归算法和自适应计算可以完全在 GPU 上执行。\n语法要点：\n\n在 __global__ 函数中使用 &lt;&lt;&lt;...&gt;&gt;&gt; 启动子 kernel\ncudaDeviceSynchronize() 等待子 kernel 完成\n可以在设备端使用 cudaMalloc/cudaFree\n\n内存可见性：\n\n全局、常量、纹理内存父子共享\n共享内存和局部内存不能传递给子 kernel\n\n流与并发：\n\n同一 Block 的默认流共享，子 kernel 串行执行\n使用非阻塞流实现子 kernel 并发\n\n应用场景：\n\nBezier 曲线自适应细分：根据曲率动态决定采样密度\n四叉树构建：递归划分空间\n\n性能考虑：\n\n启动开销不可忽视\n深度递归消耗栈空间\n配置启动池大小\n\n动态并行性让 GPU 编程更加灵活，但要权衡使用——对于规则的数据并行任务，传统方式可能更高效。对于天然递归或自适应的问题，动态并行性是强大的工具。\n🚀 下一步\n\n实现 Bezier 曲线的自适应细分，体验动态并行性的优势\n构建一个四叉树或八叉树，学习递归算法的 GPU 实现\n探索其他递归算法：快速排序、归并排序、分治算法\n学习动态并行性的性能调优：启动池配置、嵌套深度控制\n对比动态并行性与传统方法的性能差异，理解适用场景\n研究自适应网格细化（AMR）等高级应用\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 21\n第二十一章：CUDA动态并行性\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nNVIDIA. CUDA C++ Programming Guide - Dynamic Parallelism. https://docs.nvidia.com/cuda/cuda-c-programming-guide/\nNVIDIA. CUDA Dynamic Parallelism. https://developer.nvidia.com/blog/cuda-dynamic-parallelism-api-principles/\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","动态并行","递归算法","四叉树"]},{"title":"PMPP-第二十章：异构计算集群编程","url":"/posts/9506dbb9/","content":"前言\n第十九章总结了并行编程的思维方法。第二十章将视野扩展到计算集群（Computing Cluster）——多台计算机通过高速网络连接，每台计算机可能配备多个 GPU。这是当今超级计算机和数据中心的典型架构。本章讨论如何使用 **MPI（Message Passing Interface，消息传递接口）**与 CUDA 结合，实现跨节点的异构并行计算。掌握这些技术，就能编写可扩展到数千个 GPU 的大规模并行程序。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n异构计算集群架构\n什么是异构集群\n异构集群：由多个计算节点组成，每个节点包含：\n\nCPU（主机）\n一个或多个 GPU（加速器）\n本地内存\n网络接口\n\n节点之间通过高速网络（如 InfiniBand、NVLink）连接。\n典型架构\n┌─────────────────────────────────────────────────────────┐│                    计算集群                              │├─────────────────┬─────────────────┬─────────────────────┤│    节点 0       │    节点 1       │    节点 N-1         ││  ┌─────────┐   │  ┌─────────┐   │  ┌─────────┐        ││  │  CPU    │   │  │  CPU    │   │  │  CPU    │        ││  └────┬────┘   │  └────┬────┘   │  └────┬────┘        ││       │        │       │        │       │             ││  ┌────┴────┐   │  ┌────┴────┐   │  ┌────┴────┐        ││  │GPU0│GPU1│   │  │GPU0│GPU1│   │  │GPU0│GPU1│        ││  └─────────┘   │  └─────────┘   │  └─────────┘        │└────────┬───────┴────────┬───────┴────────┬────────────┘         │                │                │         └────────────────┴────────────────┘                    高速网络\n编程挑战\n\n分布式内存：每个节点有独立的内存空间，不能直接访问\n数据通信：需要显式地在节点间传递数据\n同步协调：多个进程需要协调工作\n故障容错：单个节点故障不应导致整个计算崩溃\n\nMPI 基础\n什么是 MPI\nMPI（Message Passing Interface）：一种标准化的消息传递编程模型。\n\n定义了进程间通信的 API\n支持点对点通信和集合通信\n与硬件无关，可移植性好\n\n常见实现：OpenMPI、MPICH、Intel MPI。\n基本概念\n进程（Process）：MPI 程序的基本执行单元。每个进程有：\n\n唯一的秩（Rank）：0 到 N-1\n独立的地址空间\n可以运行在不同的物理节点上\n\n通信子（Communicator）：定义参与通信的进程组。\n\nMPI_COMM_WORLD：包含所有进程的默认通信子\n\nMPI 程序骨架\n#include &lt;mpi.h&gt;int main(int argc, char *argv[]) &#123;    int rank, size;        // 初始化 MPI    MPI_Init(&amp;argc, &amp;argv);        // 获取当前进程的秩    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);        // 获取进程总数    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);        printf(&quot;进程 %d / %d\\n&quot;, rank, size);        // 计算和通信...        // 结束 MPI    MPI_Finalize();    return 0;&#125;\n运行方式：\nmpirun -np 4 ./my_program   # 启动 4 个进程\n点对点通信\n基本发送和接收\n// 发送MPI_Send(    void *buf,          // 发送缓冲区    int count,          // 元素个数    MPI_Datatype dtype, // 数据类型（MPI_FLOAT, MPI_INT 等）    int dest,           // 目标进程秩    int tag,            // 消息标签    MPI_Comm comm       // 通信子);// 接收MPI_Recv(    void *buf,          // 接收缓冲区    int count,          // 最大元素个数    MPI_Datatype dtype, // 数据类型    int source,         // 源进程秩    int tag,            // 消息标签    MPI_Comm comm,      // 通信子    MPI_Status *status  // 状态信息);\n阻塞与非阻塞\n阻塞通信：函数返回时，操作已完成或缓冲区可安全复用。\n\nMPI_Send：可能阻塞直到接收方准备好（取决于实现）\nMPI_Recv：阻塞直到消息到达\n\n非阻塞通信：函数立即返回，后续检查完成状态。\nMPI_Request request;// 非阻塞发送MPI_Isend(buf, count, dtype, dest, tag, comm, &amp;request);// 做其他事情...// 等待完成MPI_Wait(&amp;request, &amp;status);\nSend-Receive 组合\n避免死锁的常用模式：\nMPI_Sendrecv(    send_buf, send_count, send_type, dest, send_tag,    recv_buf, recv_count, recv_type, source, recv_tag,    comm, &amp;status);\n同时发送和接收，系统自动处理顺序。\nMPI + CUDA 编程\n基本策略\n每个 MPI 进程管理一个或多个 GPU：\nint rank;MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);// 每个进程选择不同的 GPUint num_devices;cudaGetDeviceCount(&amp;num_devices);cudaSetDevice(rank % num_devices);\n数据流模式\n典型的 MPI + CUDA 计算流程：\n1. MPI 进程接收输入数据（主机内存）2. 复制数据到 GPU（cudaMemcpy H2D）3. GPU 计算（kernel）4. 复制结果到主机（cudaMemcpy D2H）5. MPI 进程发送结果\n示例：分布式向量加法\nvoid distributed_vector_add(float *a, float *b, float *c, int n, int rank, int size) &#123;    int local_n = n / size;    int start = rank * local_n;        // 分配 GPU 内存    float *d_a, *d_b, *d_c;    cudaMalloc(&amp;d_a, local_n * sizeof(float));    cudaMalloc(&amp;d_b, local_n * sizeof(float));    cudaMalloc(&amp;d_c, local_n * sizeof(float));        // 复制本地数据到 GPU    cudaMemcpy(d_a, a + start, local_n * sizeof(float), cudaMemcpyHostToDevice);    cudaMemcpy(d_b, b + start, local_n * sizeof(float), cudaMemcpyHostToDevice);        // GPU 计算    int block_size = 256;    int grid_size = (local_n + block_size - 1) / block_size;    vector_add&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(d_a, d_b, d_c, local_n);        // 复制结果回主机    cudaMemcpy(c + start, d_c, local_n * sizeof(float), cudaMemcpyDeviceToHost);        // 收集所有结果到进程 0    MPI_Gather(c + start, local_n, MPI_FLOAT,               c, local_n, MPI_FLOAT,               0, MPI_COMM_WORLD);        cudaFree(d_a);    cudaFree(d_b);    cudaFree(d_c);&#125;\nHalo 交换与边界通信\n什么是 Halo\n在模板计算（stencil）、有限差分等应用中，每个点的计算依赖于邻近点。\n当数据分布在多个进程时，边界点的计算需要相邻进程的数据。\nHalo（光晕/幽灵区域）：存储来自邻居进程的边界数据。\n进程 0 的数据        进程 1 的数据┌──────────────┐    ┌──────────────┐│              │    │              ││   内部区域   │    │   内部区域   ││              │    │              │├──────────────┤    ├──────────────┤│  右边界 →→→  │ ↔  │ ←←← 左 Halo ││ (发送给 P1)  │    │ (来自 P0)   │└──────────────┘    └──────────────┘\n3D 模板计算示例\n以 25 点模板为例（每个方向延伸 4 个点）：\n// 计算每个进程需要多少 Halo 点int halo_size = 4;  // 每侧 4 层int num_halo_points = dimx * dimy * halo_size;// 分配包含 Halo 的数据int total_z = local_dimz + 2 * halo_size;float *data = malloc(dimx * dimy * total_z * sizeof(float));\nHalo 交换实现\nvoid exchange_halos(float *data, int dimx, int dimy, int dimz,                     int left_neighbor, int right_neighbor) &#123;    int halo_size = 4;    int num_halo_points = dimx * dimy * halo_size;        float *left_send = data + num_halo_points;  // 左边界数据    float *right_send = data + dimx * dimy * (dimz - halo_size);  // 右边界数据    float *left_recv = data;  // 左 Halo 接收区    float *right_recv = data + dimx * dimy * (dimz + halo_size);  // 右 Halo 接收区        MPI_Status status;        // 发送到左邻居，从右邻居接收    MPI_Sendrecv(left_send, num_halo_points, MPI_FLOAT, left_neighbor, 0,                 right_recv, num_halo_points, MPI_FLOAT, right_neighbor, 0,                 MPI_COMM_WORLD, &amp;status);        // 发送到右邻居，从左邻居接收    MPI_Sendrecv(right_send, num_halo_points, MPI_FLOAT, right_neighbor, 1,                 left_recv, num_halo_points, MPI_FLOAT, left_neighbor, 1,                 MPI_COMM_WORLD, &amp;status);&#125;\n计算与通信重叠\n问题\n通信需要时间，如果先计算完再通信，GPU 会空闲等待。\n解决方案\n思路：重叠计算与通信。\n\n先计算边界区域（通信需要的数据）\n边界计算完成后，开始通信\n同时计算内部区域\n通信完成后，所有计算都完成了\n\nCUDA 流实现\ncudaStream_t stream_boundary, stream_internal;cudaStreamCreate(&amp;stream_boundary);cudaStreamCreate(&amp;stream_internal);// 阶段 1：计算边界（在 stream_boundary 中）stencil_kernel&lt;&lt;&lt;grid_boundary, block, 0, stream_boundary&gt;&gt;&gt;(    d_output + left_offset, d_input + left_offset, dimx, dimy, 12);stencil_kernel&lt;&lt;&lt;grid_boundary, block, 0, stream_boundary&gt;&gt;&gt;(    d_output + right_offset, d_input + right_offset, dimx, dimy, 12);// 阶段 2：同时进行——// 2a: 计算内部区域（在 stream_internal 中）stencil_kernel&lt;&lt;&lt;grid_internal, block, 0, stream_internal&gt;&gt;&gt;(    d_output + internal_offset, d_input + internal_offset, dimx, dimy, dimz - 8);// 2b: 复制边界到主机，准备发送cudaMemcpyAsync(h_left_boundary, d_output + boundary_left,                num_halo_bytes, cudaMemcpyDeviceToHost, stream_boundary);cudaMemcpyAsync(h_right_boundary, d_output + boundary_right,                num_halo_bytes, cudaMemcpyDeviceToHost, stream_boundary);// 等待边界复制完成cudaStreamSynchronize(stream_boundary);// 阶段 3：MPI 通信MPI_Sendrecv(h_left_boundary, num_halo_points, MPI_FLOAT, left_neighbor, 0,             h_right_halo, num_halo_points, MPI_FLOAT, right_neighbor, 0,             MPI_COMM_WORLD, &amp;status);MPI_Sendrecv(h_right_boundary, num_halo_points, MPI_FLOAT, right_neighbor, 1,             h_left_halo, num_halo_points, MPI_FLOAT, left_neighbor, 1,             MPI_COMM_WORLD, &amp;status);// 复制 Halo 回 GPUcudaMemcpyAsync(d_output + left_halo_offset, h_left_halo,                num_halo_bytes, cudaMemcpyHostToDevice, stream_boundary);cudaMemcpyAsync(d_output + right_halo_offset, h_right_halo,                num_halo_bytes, cudaMemcpyHostToDevice, stream_boundary);// 等待所有操作完成cudaDeviceSynchronize();\n时间线分析\n                    时间 →stream_boundary:  [边界计算][D2H][       ][H2D]stream_internal:  [           内部计算          ]MPI 通信:         [      ][Sendrecv][      ]                           ↑                     重叠区域：内部计算                     与 MPI 通信同时进行\nCUDA-Aware MPI\n传统方式的问题\n// 传统方式：必须经过主机内存cudaMemcpy(h_buf, d_buf, size, cudaMemcpyDeviceToHost);  // GPU → CPUMPI_Send(h_buf, count, MPI_FLOAT, dest, tag, comm);       // CPU → 网络// 接收端MPI_Recv(h_buf, count, MPI_FLOAT, src, tag, comm, &amp;status);  // 网络 → CPU  cudaMemcpy(d_buf, h_buf, size, cudaMemcpyHostToDevice);      // CPU → GPU\n问题：额外的内存拷贝开销。\nCUDA-Aware MPI\nCUDA-Aware MPI：MPI 实现能直接识别 GPU 指针。\n// 直接传递 GPU 指针——不需要手动拷贝MPI_Send(d_buf, count, MPI_FLOAT, dest, tag, comm);MPI_Recv(d_buf, count, MPI_FLOAT, src, tag, comm, &amp;status);\nMPI 库自动处理：\n\n通过 GPUDirect RDMA 直接 GPU 到 GPU 传输\n如果不支持，自动回退到经过主机的方式\n\n环境配置\n# 编译时链接 CUDA-Aware MPImpicc -o my_prog my_prog.c -I$&#123;CUDA_HOME&#125;/include -L$&#123;CUDA_HOME&#125;/lib64 -lcudart# 运行前设置export UCX_RNDV_SCHEME=cudaexport UCX_TLS=rc,cuda_copy,cuda_ipc\n使用 CUDA-Aware MPI 改写\n// 无需 host buffer，直接使用 device bufferMPI_Sendrecv(d_output + boundary_left, num_halo_points, MPI_FLOAT, left_neighbor, 0,             d_output + right_halo_offset, num_halo_points, MPI_FLOAT, right_neighbor, 0,             MPI_COMM_WORLD, &amp;status);\n优势：\n\n减少内存拷贝\n更低延迟\n代码更简洁\n\n数据服务器模式\n问题\n大规模集群中，I/O 可能成为瓶颈。每个计算节点都从存储读数据会导致争用。\n解决方案\n数据服务器模式：一个进程专门负责 I/O，其他进程专门计算。\n┌──────────────────────────────────────────────────────┐│  数据服务器 (Rank N-1)                               ││  - 读取输入数据                                      ││  - 分发数据给计算节点                                ││  - 收集计算结果                                      ││  - 写入输出                                          │└──────────────────────────────────────────────────────┘         ↓ 分发           ↑ 收集┌─────────┬─────────┬─────────┬─────────┐│ Rank 0  │ Rank 1  │ Rank 2  │   ...   ││ 计算    │ 计算    │ 计算    │         │└─────────┴─────────┴─────────┴─────────┘\n实现\nvoid data_server(int dimx, int dimy, int dimz, int nreps) &#123;    int np, num_comp_nodes;    MPI_Comm_size(MPI_COMM_WORLD, &amp;np);    num_comp_nodes = np - 1;        // 分配并初始化数据    float *input = malloc(dimx * dimy * dimz * sizeof(float));    float *output = malloc(dimx * dimy * dimz * sizeof(float));    initialize_data(input, dimx, dimy, dimz);        // 计算每个节点的数据量    int slice_per_node = dimz / num_comp_nodes;    int halo_size = 4;        // 分发数据给计算节点    for (int p = 0; p &lt; num_comp_nodes; p++) &#123;        int start_z = p * slice_per_node - (p &gt; 0 ? halo_size : 0);        int num_slices = slice_per_node + (p &gt; 0 ? halo_size : 0)                                         + (p &lt; num_comp_nodes - 1 ? halo_size : 0);        int num_points = dimx * dimy * num_slices;                MPI_Send(input + start_z * dimx * dimy, num_points, MPI_FLOAT,                 p, 0, MPI_COMM_WORLD);    &#125;        // 等待计算完成    MPI_Barrier(MPI_COMM_WORLD);        // 收集结果    for (int p = 0; p &lt; num_comp_nodes; p++) &#123;        int offset = p * slice_per_node * dimx * dimy;        int num_points = slice_per_node * dimx * dimy;                MPI_Recv(output + offset, num_points, MPI_FLOAT,                 p, DATA_COLLECT, MPI_COMM_WORLD, MPI_STATUS_IGNORE);    &#125;        // 保存结果    save_output(output, dimx, dimy, dimz);        free(input);    free(output);&#125;\n完整示例：MPI + CUDA 模板计算\n程序结构\nint main(int argc, char *argv[]) &#123;    int pid, np;        MPI_Init(&amp;argc, &amp;argv);    MPI_Comm_rank(MPI_COMM_WORLD, &amp;pid);    MPI_Comm_size(MPI_COMM_WORLD, &amp;np);        if (pid &lt; np - 1) &#123;        // 计算节点：设置 GPU 并计算        int device = pid % num_devices;        cudaSetDevice(device);        compute_node_stencil(dimx, dimy, dimz / (np - 1), nreps);    &#125; else &#123;        // 数据服务器：I/O 和数据分发        data_server(dimx, dimy, dimz, nreps);    &#125;        MPI_Finalize();    return 0;&#125;\n计算节点实现\nvoid compute_node_stencil(int dimx, int dimy, int dimz, int nreps) &#123;    int pid, np;    MPI_Comm_rank(MPI_COMM_WORLD, &amp;pid);    MPI_Comm_size(MPI_COMM_WORLD, &amp;np);        int server = np - 1;    int left_neighbor = (pid &gt; 0) ? (pid - 1) : MPI_PROC_NULL;    int right_neighbor = (pid &lt; np - 2) ? (pid + 1) : MPI_PROC_NULL;        // 分配内存    int halo = 4;    int total_z = dimz + 2 * halo;    size_t num_bytes = dimx * dimy * total_z * sizeof(float);        float *h_input = malloc(num_bytes);    float *h_output = malloc(num_bytes);    float *d_input, *d_output;    cudaMalloc(&amp;d_input, num_bytes);    cudaMalloc(&amp;d_output, num_bytes);        // Halo 缓冲区（固定内存，加速传输）    float *h_left_boundary, *h_right_boundary;    float *h_left_halo, *h_right_halo;    size_t halo_bytes = dimx * dimy * halo * sizeof(float);    cudaHostAlloc(&amp;h_left_boundary, halo_bytes, cudaHostAllocDefault);    cudaHostAlloc(&amp;h_right_boundary, halo_bytes, cudaHostAllocDefault);    cudaHostAlloc(&amp;h_left_halo, halo_bytes, cudaHostAllocDefault);    cudaHostAlloc(&amp;h_right_halo, halo_bytes, cudaHostAllocDefault);        // 创建 CUDA 流    cudaStream_t stream_boundary, stream_internal;    cudaStreamCreate(&amp;stream_boundary);    cudaStreamCreate(&amp;stream_internal);        // 从数据服务器接收初始数据    MPI_Status status;    MPI_Recv(h_input, dimx * dimy * total_z, MPI_FLOAT,             server, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);    cudaMemcpy(d_input, h_input, num_bytes, cudaMemcpyHostToDevice);        // 迭代计算    for (int iter = 0; iter &lt; nreps; iter++) &#123;        // 阶段 1：边界计算        launch_boundary_kernel(d_output, d_input, dimx, dimy, stream_boundary);                // 阶段 2：内部计算（与通信重叠）        launch_internal_kernel(d_output, d_input, dimx, dimy, dimz, stream_internal);                // 复制边界到主机        copy_boundary_to_host(d_output, h_left_boundary, h_right_boundary,                               dimx, dimy, halo, stream_boundary);        cudaStreamSynchronize(stream_boundary);                // Halo 交换        MPI_Sendrecv(h_left_boundary, dimx * dimy * halo, MPI_FLOAT, left_neighbor, iter,                     h_right_halo, dimx * dimy * halo, MPI_FLOAT, right_neighbor, iter,                     MPI_COMM_WORLD, &amp;status);        MPI_Sendrecv(h_right_boundary, dimx * dimy * halo, MPI_FLOAT, right_neighbor, iter,                     h_left_halo, dimx * dimy * halo, MPI_FLOAT, left_neighbor, iter,                     MPI_COMM_WORLD, &amp;status);                // 复制 Halo 回 GPU        copy_halo_to_device(d_output, h_left_halo, h_right_halo,                             dimx, dimy, dimz, halo, stream_boundary);                cudaDeviceSynchronize();                // 交换输入输出指针        float *temp = d_output;        d_output = d_input;        d_input = temp;    &#125;        // 发送结果给数据服务器    cudaMemcpy(h_output, d_input, num_bytes, cudaMemcpyDeviceToHost);    MPI_Send(h_output + dimx * dimy * halo, dimx * dimy * dimz, MPI_FLOAT,             server, DATA_COLLECT, MPI_COMM_WORLD);        // 清理    free(h_input);    free(h_output);    cudaFreeHost(h_left_boundary);    cudaFreeHost(h_right_boundary);    cudaFreeHost(h_left_halo);    cudaFreeHost(h_right_halo);    cudaFree(d_input);    cudaFree(d_output);    cudaStreamDestroy(stream_boundary);    cudaStreamDestroy(stream_internal);&#125;\n性能优化\n通信优化\n\n\n\n技术\n描述\n效果\n\n\n\n\n非阻塞通信\n使用 MPI_Isend/MPI_Irecv\n重叠通信与计算\n\n\n集合通信\n使用 MPI_Allreduce 而非循环 P2P\n利用优化的算法\n\n\nCUDA-Aware MPI\n直接传递 GPU 指针\n减少内存拷贝\n\n\n固定内存\ncudaHostAlloc\n加速 H2D/D2H 传输\n\n\n\n负载均衡\n确保每个节点的工作量大致相等：\n// 处理不能整除的情况int base_slices = dimz / num_nodes;int remainder = dimz % num_nodes;for (int p = 0; p &lt; num_nodes; p++) &#123;    int slices = base_slices + (p &lt; remainder ? 1 : 0);    // 分配 slices 给节点 p&#125;\n可扩展性分析\n对于 25 点模板计算：\n\n\n\n节点数\n通信量（每节点）\n计算量（每节点）\n计算/通信比\n\n\n\n\n16\n2×64×64×4 = 32K\n64×64×128 = 512K\n16:1\n\n\n64\n2×64×64×4 = 32K\n64×64×32 = 128K\n4:1\n\n\n256\n2×64×64×4 = 32K\n64×64×8 = 32K\n1:1\n\n\n\n观察：节点越多，通信开销占比越高。这是强扩展的典型特征。\n常见问题与解决\n死锁\n原因：所有进程都在等待接收，没有进程发送。\n// 错误示例——会死锁！if (rank == 0) &#123;    MPI_Recv(..., 1, ...);  // 等待 rank 1    MPI_Send(..., 1, ...);&#125; else &#123;    MPI_Recv(..., 0, ...);  // 等待 rank 0    MPI_Send(..., 0, ...);&#125;\n解决：使用 MPI_Sendrecv 或非阻塞通信。\nGPU 内存不足\n原因：每个节点分配的数据太多。\n解决：\n\n增加节点数\n使用统一内存自动管理\n分批处理\n\n性能不佳\n诊断：使用 Nsight Systems 分析 MPI + CUDA 程序。\nnsys profile --trace=cuda,mpi mpirun -np 4 ./my_program\n查看是否有：\n\n过长的 MPI 等待时间\n未重叠的计算和通信\nGPU 空闲时间\n\n小结\n第二十章扩展了并行编程的视野，从单 GPU 扩展到多节点集群：\n异构集群架构：每个节点包含 CPU 和 GPU，节点间通过网络连接。分布式内存模型要求显式通信。\nMPI 基础：消息传递编程模型。进程通过发送/接收消息通信。点对点通信（Send/Recv）和集合通信（Broadcast/Reduce）。\nMPI + CUDA：每个 MPI 进程管理一个或多个 GPU。数据在主机内存和 GPU 内存之间传输，在进程间通过 MPI 传输。\nHalo 交换：模板计算中，边界数据需要与邻居进程交换。使用 Sendrecv 避免死锁。\n计算与通信重叠：利用 CUDA 流，边界计算完成后立即开始通信，同时进行内部计算。显著减少总执行时间。\nCUDA-Aware MPI：MPI 库直接接受 GPU 指针，利用 GPUDirect 技术减少内存拷贝。\n数据服务器模式：一个进程专门负责 I/O，减少存储争用。\n掌握 MPI + CUDA 编程，你就能编写可扩展到数千 GPU 的应用程序——这是当今 AI 训练、科学计算、天气预报等领域的核心技术。\n🚀 下一步\n\n搭建一个简单的多节点 GPU 集群环境，配置 MPI 和 CUDA-Aware MPI\n实现一个分布式矩阵乘法，学习数据分割和结果收集\n掌握 Halo 交换模式，实现分布式模板计算（如热传导方程）\n学习集合通信操作：Allreduce、Allgather、Alltoall\n探索性能分析工具：Nsight Systems 分析 MPI + CUDA 程序的性能瓶颈\n了解现代 HPC 框架：NCCL（多 GPU 通信）、Horovod（分布式深度学习）\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 20\n第二十章：异构计算集群编程\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nMPI Forum. MPI: A Message-Passing Interface Standard. https://www.mpi-forum.org/\nNVIDIA. CUDA-Aware MPI. https://developer.nvidia.com/blog/introduction-cuda-aware-mpi/\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","MPI","集群计算","CUDA流","分布式计算"]},{"title":"PMPP-第二章：异构数据并行计算","url":"/posts/3ee22ce5/","content":"前言\n第一章讲了理论，第二章开始写代码了。虽然例子是经典的向量加法，但它包含了CUDA编程的所有核心环节：内存管理、kernel编写、线程组织。掌握这个简单例子，后面的复杂应用就是在此基础上的扩展。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n为什么从向量加法开始\n数据并行的典型例子\n向量加法是数据并行的最佳入口：\nC[0] = A[0] + B[0]C[1] = A[1] + B[1]...C[n-1] = A[n-1] + B[n-1]\n每个元素的计算完全独立，C[0]不需要等C[1]算完。这种独立性正是并行计算的黄金场景。\n内存受限问题\n向量加法的算术强度很低：\n\n每元素：读2个float + 写1个float = 12字节\n计算：1次浮点加法\n算术强度：1 FLOP / 12 Bytes ≈ 0.083 FLOP/Byte\n\n典型内存受限（Memory-Bound）问题。GPU计算单元会经常等数据。虽然性能达不到峰值，但作为入门例子足够简单直观。\nCUDA程序结构：三步走\nCPU版本（对比）\nvoid vecAddCPU(float *A, float *B, float *C, int n) &#123;    for (int i = 0; i &lt; n; i++) &#123;        C[i] = A[i] + B[i];    &#125;&#125;\n串行执行，n=10000就要循环10000次。\nCUDA版本\n1. Host端准备\nint n = 10000;size_t size = n * sizeof(float);// 分配Host内存float *h_A = (float*)malloc(size);float *h_B = (float*)malloc(size);float *h_C = (float*)malloc(size);// 初始化数据for (int i = 0; i &lt; n; i++) &#123;    h_A[i] = i * 1.0f;    h_B[i] = i * 2.0f;&#125;\nh_前缀表示Host变量，这是个好习惯。\n2. Device端准备\n// 分配Device内存float *d_A, *d_B, *d_C;cudaMalloc((void**)&amp;d_A, size);cudaMalloc((void**)&amp;d_B, size);cudaMalloc((void**)&amp;d_C, size);// Host → DevicecudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);\n关键：\n\ncudaMalloc参数是二级指针（需要修改指针值）\nd_A是Device指针，在Host代码中不能直接解引用d_A[0]（会段错误）\n\n3. 执行与回传\n// 启动kernelint threadsPerBlock = 256;int blocksPerGrid = (n + threadsPerBlock - 1) / threadsPerBlock;vecAdd&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_A, d_B, d_C, n);// Device → HostcudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);// 验证for (int i = 0; i &lt; n; i++) &#123;    if (fabs(h_C[i] - (h_A[i] + h_B[i])) &gt; 1e-5) &#123;        printf(&quot;Error at index %d\\n&quot;, i);    &#125;&#125;// 清理cudaFree(d_A);cudaFree(d_B);cudaFree(d_C);free(h_A);free(h_B);free(h_C);\nKernel函数\n基本结构\n__global__ void vecAdd(float *A, float *B, float *C, int n) &#123;    int i = blockDim.x * blockIdx.x + threadIdx.x;    if (i &lt; n) &#123;        C[i] = A[i] + B[i];    &#125;&#125;\n逐行解析：\n\n\n__global__：GPU上执行，CPU调用\n\n__device__：GPU上执行，GPU调用\n__host__：CPU上执行，CPU调用（默认，可省略）\n\n\n\n线程索引计算：i = blockIdx.x * blockDim.x + threadIdx.x\n\nblockIdx.x：block在grid中的索引\nblockDim.x：block的大小\nthreadIdx.x：thread在block中的索引\n\n\n\n边界检查：if (i &lt; n) 必须有（总线程数通常多于数组元素）\n\n\n线程层次结构\nGrid├── Block 0 (256 threads)│   ├── Thread 0   → i = 0*256 + 0 = 0│   ├── Thread 1   → i = 0*256 + 1 = 1│   └── Thread 255 → i = 0*256 + 255 = 255├── Block 1 (256 threads)│   ├── Thread 0   → i = 1*256 + 0 = 256│   └── Thread 255 → i = 1*256 + 255 = 511└── ...\n每个thread得到唯一索引，对应数组元素。\n为什么256个threads？\n不是随便选的：\n\nWarp的倍数：GPU以32线程为一组（warp）执行，256 = 8 × 32\n硬件限制：每block最多1024 threads\n经验值：128-512通常性能较好\n\n具体最优值需要profiling确定。\n边界检查的必要性\nblocksPerGrid = (10000 + 255) / 256 = 40总线程数 = 40 × 256 = 10240\n多出240个线程。不检查边界会越界访问，导致错误或崩溃。\n内存管理\n主机内存 vs 设备内存\n关键：两个独立的内存空间，不能直接互访。\n\n主机内存（Host Memory）：CPU 的 DDR4/DDR5\n设备内存（Device Memory）：GPU 的 GDDR6/HBM\n\n错误示例：\nfloat *d_A;cudaMalloc((void**)&amp;d_A, size);d_A[0] = 1.0f;  // 段错误！CPU 不能直接访问 GPU 内存\n正确做法：\nfloat *h_A = (float*)malloc(size);h_A[0] = 1.0f;cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);\n数据传输开销\nPCIe带宽（~32 GB/s）远低于GPU内存带宽（500+ GB/s）。对于简单计算，传输时间可能是计算时间的数十倍。\n优化原则：\n\n减少传输次数（批量传输）\n保持数据在GPU（多步计算不回传）\n异步传输与计算重叠（高级技巧）\n\n统一内存（Unified Memory，可选）\n从 CUDA 6.0 起可以使用：\nfloat *data;cudaMallocManaged(&amp;data, size);data[0] = 1.0f;              // CPU 访问kernel&lt;&lt;&lt;...&gt;&gt;&gt;(data);       // GPU 访问（自动迁移）printf(&quot;%f\\n&quot;, data[0]);     // CPU 访问（自动传回）cudaFree(data);\n方便，但有性能开销。学习和原型开发友好，生产环境建议显式管理。\n执行配置\n启动语法\nvecAdd&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_A, d_B, d_C, n);\n完整形式：\nkernel&lt;&lt;&lt;gridDim, blockDim, sharedMem, stream&gt;&gt;&gt;(args);\n参数说明：\n\ngridDim：网格的维度（1D/2D/3D）\nblockDim：块的维度\nsharedMem：动态共享内存大小（可选，默认0）\nstream：CUDA 流（可选，默认0）\n\n计算网格大小\nint threads = 256;int blocks = (n + threads - 1) / threads;  // 向上取整\n数学上等价于 ceil(n / threads)，但整数运算更高效。\n错误处理\nCUDA 函数返回 cudaError_t，需要显式检查：\n#define CUDA_CHECK(call) \\do &#123; \\    cudaError_t err = call; \\    if (err != cudaSuccess) &#123; \\        fprintf(stderr, &quot;CUDA Error: %s at %s:%d\\n&quot;, \\                cudaGetErrorString(err), __FILE__, __LINE__); \\        exit(EXIT_FAILURE); \\    &#125; \\&#125; while(0)// 使用CUDA_CHECK(cudaMalloc((void**)&amp;d_A, size));CUDA_CHECK(cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice));\n核函数启动不返回错误码，需要这样检查：\nvecAdd&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(d_A, d_B, d_C, n);CUDA_CHECK(cudaGetLastError());          // 检查核函数启动错误CUDA_CHECK(cudaDeviceSynchronize());     // 同步并检查核函数执行错误\n小结\n第二章通过向量加法建立了 CUDA 编程的基本框架：\n核心流程：内存分配 → 数据传输 → 核函数启动 → 结果回传，这是所有 CUDA 程序的骨架。\n线程组织：网格（Grid）/块（Block）/线程（Thread）三级结构，索引计算 i = blockIdx.x * blockDim.x + threadIdx.x 要烂熟于心。\n内存模型：主机和设备是独立空间，必须显式传输。数据传输开销不容忽视。\n性能认知：向量加法虽然能在 GPU 上运行，但受内存带宽限制，性能提升有限。真正发挥 GPU 优势需要高算术强度的任务。\n代码习惯：\n\n变量命名区分 h_/d_（主机/设备）\n边界检查必须严格\n错误处理不能省略\n\n下一章进入多维数据处理（矩阵、图像），会用到2D 网格/块组织。理解了一维的原理，多维只是自然扩展。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 02\n第二章：异构数据并行计算\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","向量加法"]},{"title":"PMPP-第五章：内存架构和数据局部性","url":"/posts/3bb3179b/","content":"前言\n第四章理解了GPU的调度机制和硬件架构，这一章进入性能优化的核心——内存。GPU计算能力强大，但数据供应跟不上就白搭。第五章讲解GPU的内存层次结构，重点是Shared Memory和Tiling技术。掌握这些，矩阵乘法性能可以提升10倍以上。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n内存带宽：性能的天花板\n问题的本质\n回顾第三章的矩阵乘法：\n__global__ void matMul(float *M, float *N, float *P, int width) &#123;    int row = blockIdx.y * blockDim.y + threadIdx.y;    int col = blockIdx.x * blockDim.x + threadIdx.x;        if (row &lt; width &amp;&amp; col &lt; width) &#123;        float sum = 0.0f;        for (int k = 0; k &lt; width; k++) &#123;            sum += M[row * width + k] * N[k * width + col];        &#125;        P[row * width + col] = sum;    &#125;&#125;\n计算 P[row][col] 需要读取 M 的一行和 N 的一列，共 2×width 个元素。每个元素 4 字节，width=1024 时：\n每线程读取：2 × 1024 × 4 = 8192 字节每线程计算：2 × 1024 = 2048 FLOP算术强度：2048 / 8192 = 0.25 FLOP/Byte\n现代 GPU 峰值 10+ TFLOPS，带宽 500+ GB/s，需要 20 FLOP/Byte 才能跑满计算单元。实际只有 0.25，GPU 大部分时间在等数据。\n数据重复访问\n更严重的是：同一数据被多个线程重复读取。\nM[i][k] 被第 i 行的所有线程读取，N[k][j] 被第 j 列的所有线程读取。1024×1024 矩阵，每个元素被读 1024 次，但每次都从全局内存（DRAM）读。\n这就是优化的切入点：让数据复用发生在快速存储上，而不是全局内存。\nGPU 内存层次\n层次结构\n┌─────────────────────────────────────────────┐│                   Host Memory               │   CPU DDR4/DDR5│                   (GB 级别)                  │   ~50 GB/s├─────────────────────────────────────────────┤│              Global Memory (DRAM)           │   GPU 显存│                  (GB 级别)                   │   ~500 GB/s├─────────────────────────────────────────────┤│    L2 Cache (SM 共享)                        │   几 MB│                                              │   ~1-2 TB/s├──────────────┬──────────────┬───────────────┤│   Shared     │   Shared     │   Shared      │   每 SM│   Memory     │   Memory     │   Memory      │   ~100 KB│   L1 Cache   │   L1 Cache   │   L1 Cache    │   ~10 TB/s├──────────────┼──────────────┼───────────────┤│  Registers   │  Registers   │  Registers    │   每线程│              │              │               │   ~几十 TB/s└──────────────┴──────────────┴───────────────┘     SM 0           SM 1           SM 2\n核心规律：越靠近计算单元，容量越小，速度越快。\n各级存储特点\n\n\n\n存储类型\n作用域\n容量\n延迟\n程序员控制\n\n\n\n\n寄存器\n单线程\n~255个/线程\n1周期\n隐式（变量）\n\n\n共享内存\nBlock内\n~100KB/SM\n~20周期\n显式\n\n\nL1缓存\nSM内\n~128KB/SM\n~20周期\n部分\n\n\nL2缓存\n全局\n~6MB\n~200周期\n无\n\n\n全局内存\n全局\n~数GB\n~400周期\n显式\n\n\n\n关键洞察：\n\n寄存器最快，但容量有限，且只属于单个线程\n共享内存是程序员可控的 Block 级缓存，这是优化的主战场\n全局内存是唯一能容纳大数据的地方，但太慢\n\n共享内存（Shared Memory）\n基本概念\n共享内存是 SM 上的可编程缓存：\n\nBlock 内所有线程共享：同 Block 的线程可以读写同一块共享内存\n生命周期与 Block 绑定：Block 结束，共享内存释放\n低延迟：约 20 周期，比全局内存快 20 倍\n\n声明语法\n静态分配（编译时确定大小）：\n__global__ void kernel() &#123;    __shared__ float sharedData[256];  // Block 内共享    // ...&#125;\n动态分配（运行时确定大小）：\n__global__ void kernel() &#123;    extern __shared__ float sharedData[];  // 大小由启动配置指定    // ...&#125;// 启动时指定共享内存大小kernel&lt;&lt;&lt;grid, block, sharedMemBytes&gt;&gt;&gt;(args);\n同步：__syncthreads()\n共享内存是 Block 内共享的，需要同步保证数据一致性：\n__shared__ float data[256];// 阶段1：所有线程写入data[threadIdx.x] = input[globalIdx];__syncthreads();  // 等待所有线程完成写入// 阶段2：所有线程读取（此时数据已就绪）float val = data[(threadIdx.x + 1) % 256];\n__syncthreads() 是栅栏同步：Block 内所有线程必须到达这一点，才能继续执行。\n常见错误：\n// 危险！条件内使用 syncthreadsif (threadIdx.x &lt; 128) &#123;    data[threadIdx.x] = ...;    __syncthreads();  // 只有部分线程执行，会死锁！&#125;\n同步必须保证 Block 内所有活跃线程都执行到。\nTiling：分块处理\n核心思想\n既然全局内存慢但共享内存快，策略就是：\n\n分块加载：将数据分成小块（Tile），逐块加载到共享内存\n计算复用：在共享内存中完成该块的所有计算\n移动窗口：处理下一块，直到完成\n\n这样，每个数据从全局内存只读一次，但在共享内存中被多次使用。\nTiled 矩阵乘法\n问题：计算 P = M × N，每个 P[i][j] = Σ M[i][k] × N[k][j]\n朴素版本：每个线程独立读取整行和整列（大量重复读取）\nTiled 版本：\n┌───────────────┐   ┌───────────────┐│   M 矩阵       │   │   N 矩阵       ││  ┌───┐        │   │      ┌───┐    ││  │Tile│ ────→ │   │      │Tile│   ││  └───┘        │   │      └───┘    ││               │   │        │      │└───────────────┘   └────────│──────┘                             ↓                    ┌───────────────┐                    │   P 矩阵       │                    │      ┌───┐    │                    │      │计算│    │                    │      └───┘    │                    └───────────────┘\n步骤：\n\n将 M 的一个 Tile 和 N 的一个 Tile 加载到共享内存\nBlock 内所有线程使用共享内存中的数据进行部分计算\n加载下一对 Tile，累加结果\n重复直到完成\n\n代码实现\n#define TILE_WIDTH 16__global__ void matMulTiled(float *M, float *N, float *P, int width) &#123;    // 共享内存声明    __shared__ float Mds[TILE_WIDTH][TILE_WIDTH];    __shared__ float Nds[TILE_WIDTH][TILE_WIDTH];        int bx = blockIdx.x, by = blockIdx.y;    int tx = threadIdx.x, ty = threadIdx.y;        // 计算该线程负责的 P 元素位置    int row = by * TILE_WIDTH + ty;    int col = bx * TILE_WIDTH + tx;        float Pvalue = 0;        // 分块循环    for (int ph = 0; ph &lt; width / TILE_WIDTH; ++ph) &#123;                // 协作加载 M 的 Tile        Mds[ty][tx] = M[row * width + (ph * TILE_WIDTH + tx)];                // 协作加载 N 的 Tile        Nds[ty][tx] = N[(ph * TILE_WIDTH + ty) * width + col];                __syncthreads();  // 确保 Tile 加载完成                // 使用共享内存计算部分点积        for (int k = 0; k &lt; TILE_WIDTH; ++k) &#123;            Pvalue += Mds[ty][k] * Nds[k][tx];        &#125;                __syncthreads();  // 确保计算完成再加载下一个 Tile    &#125;        P[row * width + col] = Pvalue;&#125;\n关键点解析\n1. 协作加载\nBlock 内的线程分工加载 Tile：\nMds[ty][tx] = M[row * width + (ph * TILE_WIDTH + tx)];\n每个线程加载一个元素，16×16 = 256 个线程加载 256 个元素。比单线程加载整个 Tile 高效得多。\n2. 两次同步\n__syncthreads();  // 第一次：确保数据加载完成// ... 计算 ...__syncthreads();  // 第二次：确保计算完成再覆盖共享内存\n两次同步都必要：\n\n第一次：防止读到未加载的数据\n第二次：防止快线程覆盖慢线程还在用的数据\n\n3. 内层循环\nfor (int k = 0; k &lt; TILE_WIDTH; ++k) &#123;    Pvalue += Mds[ty][k] * Nds[k][tx];&#125;\n这个循环只访问共享内存，没有全局内存访问。这是性能提升的来源。\n性能分析\n朴素版本：\n\n每线程读取全局内存：2 × width 次\n总全局内存访问：width³ × 2（读）+ width²（写）\n\nTiled 版本：\n\n每 Tile 阶段：Block 读 2 × TILE_WIDTH² 个元素\n共 width/TILE_WIDTH 个阶段\n每线程贡献：2 × width 次（与朴素相同？不对！）\n\n关键差异：在 Tiled 版本中，每个全局内存读取被 TILE_WIDTH 个线程共享使用。\n全局内存访问减少倍数 = TILE_WIDTH算术强度提升 = TILE_WIDTH 倍\nTILE_WIDTH = 16 时，算术强度从 0.25 提升到 4 FLOP/Byte。TILE_WIDTH = 32 时可达 8 FLOP/Byte。\n边界处理\n上面的代码假设 width 是 TILE_WIDTH 的倍数。实际需要处理边界：\n// 带边界检查的加载if (row &lt; width &amp;&amp; (ph * TILE_WIDTH + tx) &lt; width)    Mds[ty][tx] = M[row * width + (ph * TILE_WIDTH + tx)];else    Mds[ty][tx] = 0;  // 越界元素填0if ((ph * TILE_WIDTH + ty) &lt; width &amp;&amp; col &lt; width)    Nds[ty][tx] = N[(ph * TILE_WIDTH + ty) * width + col];else    Nds[ty][tx] = 0;\n填 0 不影响加法结果，是处理边界的常用技巧。\n内存访问模式\n合并访问（Coalesced Access）\nGPU 内存控制器按 32 字节或 128 字节 的事务读写数据。如果 Warp 中的线程访问连续地址，可以合并成一次事务：\n好的访问模式：\n// 线程 0,1,2,...,31 访问连续地址data[threadIdx.x];  // 一次 128B 事务\n差的访问模式：\n// 线程 0,1,2,...,31 访问跨步地址data[threadIdx.x * 32];  // 32 次事务！\n矩阵访问的陷阱：\n// P[i][j] 遍历// 按行遍历（好）：data[row * width + col]，col 连续// 按列遍历（差）：data[row * width + col]，row 连续（跨步 = width）\n共享内存 Bank 冲突\n共享内存分成 32 个 Bank，每个 Bank 宽度 4 字节。不同 Bank 可以同时访问，但同一 Bank 的不同地址会串行化。\nBank 映射：\n地址 0,32,64,...  → Bank 0地址 4,36,68,...  → Bank 1地址 8,40,72,...  → Bank 2...地址 124,156,... → Bank 31\n无冲突：\ndata[threadIdx.x];      // 32 线程访问 32 个 Bankdata[threadIdx.x * 2];  // 跨步 2，访问 Bank 0,2,4,...（无冲突）\n有冲突：\ndata[threadIdx.x * 32]; // 所有线程访问 Bank 0！32-way 冲突\n特例——广播：\ndata[0];  // 所有线程读同一地址，硬件广播，无冲突\n矩阵转置的 Bank 冲突\n考虑共享内存中 16×16 的矩阵：\n__shared__ float tile[16][16];// 加载（列访问）tile[ty][tx] = input[row * width + col];  // 无冲突// 存储（行访问）output[col * width + row] = tile[tx][ty];  // 有冲突！\ntile[tx][ty] 使得线程 0,1,2,…,15 分别访问 tile[0][ty], tile[1][ty], …，这些元素地址为 ty, ty+16, ty+32, …，步长 16×4 = 64 字节 = 16 个 Bank。部分线程会访问同一 Bank。\n解决方案——Padding：\n__shared__ float tile[16][17];  // 多加一列// 现在 tile[i][j] 的地址是 i*17 + j// 步长变成 17×4 = 68 字节，不再对齐\nPadding 打破了 Bank 对齐，消除冲突。代价是浪费一点共享内存。\n常量内存（Constant Memory）\n特点\n\n只读：Kernel 内不能写\n缓存优化：有专用缓存，广播访问效率高\n容量有限：64 KB\n\n适用场景\n所有线程读相同数据（如卷积核、变换矩阵）：\n__constant__ float kernel[9];  // 声明// Host 端写入cudaMemcpyToSymbol(kernel, h_kernel, 9 * sizeof(float));// Kernel 内使用__global__ void conv(...) &#123;    float sum = 0;    for (int i = 0; i &lt; 9; i++) &#123;        sum += data[i] * kernel[i];  // 所有线程读相同 kernel[i]    &#125;&#125;\n如果每个线程读不同地址，常量内存反而更慢（串行化）。\n寄存器优化\n寄存器的重要性\n寄存器是最快的存储，单周期延迟。但数量有限（每 SM 约 64K 个），过度使用会导致：\n\n寄存器溢出（Spilling）：溢出到 Local Memory（实际是全局内存），极慢\n占用率下降：每线程用更多寄存器，SM 能容纳的线程数减少\n\n查看寄存器使用\nnvcc --ptxas-options=-v kernel.cu\n输出：\nptxas info: Used 32 registers, ...\n控制策略\n编译器提示：\n__global__ void __launch_bounds__(256, 4) kernel(...) &#123;    // 告诉编译器：每 Block 256 线程，每 SM 至少 4 个 Block    // 编译器据此优化寄存器分配&#125;\n编译选项：\nnvcc -maxrregcount=32 kernel.cu  # 限制每线程最多 32 个寄存器\n权衡：限制过严可能导致溢出，限制过松可能降低占用率。需要实测。\n数据局部性优化清单\n空间局部性\n定义：访问的数据在内存中相邻\n优化手段：\n\n连续访问，利用合并\n数据布局优化（AoS → SoA）\n\n// Array of Structures（差）struct Particle &#123; float x, y, z; &#125;;Particle particles[N];particles[i].x;  // 跨步 12 字节// Structure of Arrays（好）struct Particles &#123; float x[N], y[N], z[N]; &#125;;Particles p;p.x[i];  // 连续访问\n时间局部性\n定义：同一数据短期内被多次访问\n优化手段：\n\nTiling 到共享内存/寄存器\n循环分块\n\n// 无时间局部性for (int k = 0; k &lt; N; k++) &#123;    C[i][j] += A[i][k] * B[k][j];  // A、B 每次从全局内存读&#125;// 有时间局部性（Tiled）for (int tile = 0; tile &lt; N/TILE; tile++) &#123;    // 加载 tile 到共享内存    for (int k = 0; k &lt; TILE; k++) &#123;        C[i][j] += As[ty][k] * Bs[k][tx];  // 从共享内存读，复用    &#125;&#125;\n实战：优化后的矩阵乘法性能\n以 1024×1024 单精度矩阵为例：\n\n\n\n版本\n全局内存访问\n算术强度\n相对性能\n\n\n\n\n朴素\n2×10⁹ 次\n0.25\n1×\n\n\nTiled (16×16)\n1.25×10⁸ 次\n4\n~8×\n\n\nTiled (32×32)\n6.25×10⁷ 次\n8\n~12×\n\n\n+ 寄存器优化\n更少\n16+\n~20×\n\n\n\n测试环境：\n\nGPU：NVIDIA RTX 3080（8704 CUDA 核心）\nCUDA：11.x\n编译器：nvcc -O3\n\n实际提升取决于具体 GPU 和问题规模，但 10× 以上是常见的。cuBLAS 的高度优化实现可达到 30-40× 加速。\n小结\n第五章是性能优化的核心：\n内存层次认知：寄存器→共享内存→L2→全局内存，速度差 100 倍以上。写高性能代码就是让热数据留在快存储。\n共享内存本质：程序员可控的 Block 级缓存。声明简单，但需要正确同步。两次 __syncthreads() 别忘。\nTiling 核心：分块加载，块内复用。矩阵乘法从 0.25 提升到 8+ FLOP/Byte，这是实打实的 10× 加速。\n访问模式：\n\n全局内存要合并访问\n共享内存要避免 Bank 冲突\n必要时用 Padding\n\n局部性原则：空间局部性（连续访问），时间局部性（重复使用）。Tiling 同时利用了两者。\n掌握了内存优化，GPU 的计算能力才能真正发挥。第六章将讨论更多性能优化的细节考虑，而第七章开始将学习具体的并行计算模式——卷积、模板、归约、前缀和等，这些都需要精心设计的内存访问策略。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 05\n第五章：内存架构和数据局部性\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","Tiling","共享内存"]},{"title":"PMPP-第八章：模板","url":"/posts/93c68d7a/","content":"前言\n第七章学习了卷积，本章学习模板计算（Stencil）。这两者在计算模式上很相似，但侧重点不同。卷积强调信号处理中的滑动加权和，权重来自滤波器；模板计算强调科学计算中的邻域更新，常见于偏微分方程（PDE）求解、物理仿真等场景。从 CUDA 优化角度看，两者的技术是相通的，但模板计算有其特点：通常需要多次迭代，必须处理时间步进和双缓冲问题。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n模板计算基础\n什么是模板计算\n模板计算（Stencil Computation）：用固定的邻域模式更新网格中的每个点。\n一维热传导（最简单的例子）：\n时间 t:    [..., A, B, C, ...]时间 t+1:       B&#x27; = (A + B + C) / 3\n每个点的新值是自己和邻居的加权平均。这就是模板：一个描述&quot;如何从邻居计算自己&quot;的模式。\n模板的形状\n常见的模板形状：\n1D 三点模板：\n[ -1  0  +1 ]   ↓  ↓  ↓   A  B  C\n2D 五点模板（冯·诺依曼邻域）：\n       [0,-1]         ↑[-1,0] ← [0,0] → [+1,0]         ↓       [0,+1]\n2D 九点模板（摩尔邻域）：\n[-1,-1] [0,-1] [+1,-1][-1, 0] [0, 0] [+1, 0][-1,+1] [0,+1] [+1,+1]\n3D 七点模板：\n上下前后左右 + 自己\n模板 vs 卷积\n\n\n\n特性\n卷积\n模板\n\n\n\n\n权重\n来自滤波器，任意值\n通常是固定系数\n\n\n迭代\n通常单次\n多次时间步进\n\n\n边界\n零填充常见\n周期/固定边界更常见\n\n\n应用\n信号/图像处理\nPDE/物理仿真\n\n\n读写模式\n只读输入，写输出\n读旧值，写新值\n\n\n\n从 GPU 优化角度，两者的核心技术是相同的：常量内存存系数，共享内存 Tiling 减少全局内存访问。\n2D 模板：热传导方程\n物理背景\n二维热传导方程：\n∂T∂t=α(∂2T∂x2+∂2T∂y2)\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right)\n∂t∂T​=α(∂x2∂2T​+∂y2∂2T​)\n用有限差分离散化后：\nTi,jn+1=Ti,jn+αΔt(Ti+1,jn+Ti−1,jn+Ti,j+1n+Ti,j−1n−4Ti,jnΔx2)T_{i,j}^{n+1} = T_{i,j}^n + \\alpha \\Delta t \\left( \\frac{T_{i+1,j}^n + T_{i-1,j}^n + T_{i,j+1}^n + T_{i,j-1}^n - 4T_{i,j}^n}{\\Delta x^2} \\right)\nTi,jn+1​=Ti,jn​+αΔt(Δx2Ti+1,jn​+Ti−1,jn​+Ti,j+1n​+Ti,j−1n​−4Ti,jn​​)\n简化为五点模板：\nT_new[i][j] = c0 * T[i][j] + c1 * (T[i-1][j] + T[i+1][j] + T[i][j-1] + T[i][j+1])\n其中 c0 = 1 - 4*alpha*dt/dx²，c1 = alpha*dt/dx²。\n朴素实现\n__global__ void stencil_2d_basic(float *in, float *out, int N) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    int j = blockIdx.y * blockDim.y + threadIdx.y;        if (i &gt; 0 &amp;&amp; i &lt; N-1 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; N-1) &#123;        out[i*N + j] = C0 * in[i*N + j] +                       C1 * (in[(i-1)*N + j] + in[(i+1)*N + j] +                             in[i*N + (j-1)] + in[i*N + (j+1)]);    &#125;&#125;\n问题：每个点读取 5 次全局内存，相邻点的访问有大量重叠。\n数据复用分析\n考虑一行线程计算：\n线程 j:   读取 T[i][j-1], T[i][j], T[i][j+1], T[i-1][j], T[i+1][j]线程 j+1: 读取 T[i][j], T[i][j+1], T[i][j+2], T[i-1][j+1], T[i+1][j+1]                ↑           ↑ 共享\n相邻线程共享了 T[i][j] 和 T[i][j+1]。如果把一个 Tile 的数据加载到共享内存，这些共享访问都变成快速的片上访问。\nTiled 模板实现\n输入输出 Tile 关系\n与卷积类似，计算 OUT_TILE_SIZE × OUT_TILE_SIZE 的输出，需要 (OUT_TILE_SIZE + 2*r) × (OUT_TILE_SIZE + 2*r) 的输入。\n对于五点模板（r=1）：\n输入 Tile：(T + 2) × (T + 2)输出 Tile：T × T\n线程与数据映射\n有两种策略：\n策略 1：线程数 = 输入 Tile 大小\nBlock: (T+2) × (T+2) 线程每线程加载 1 个输入元素只有内部 T × T 线程计算输出\n策略 2：线程数 = 输出 Tile 大小\nBlock: T × T 线程部分线程负责加载 Halo 元素所有线程都计算输出\n书中推荐策略 1，因为加载更简单，且边界线程虽不计算但仍能并行执行。\n完整实现\n#define IN_TILE_SIZE 18  // 16 + 2#define OUT_TILE_SIZE 16__global__ void stencil_2d_tiled(float *in, float *out, int N) &#123;    __shared__ float tile[IN_TILE_SIZE][IN_TILE_SIZE];        // 线程在输入 Tile 中的位置    int tx = threadIdx.x, ty = threadIdx.y;        // 对应的全局输入位置    int in_row = blockIdx.y * OUT_TILE_SIZE + ty - 1;  // -1 是因为 Halo    int in_col = blockIdx.x * OUT_TILE_SIZE + tx - 1;        // 加载（含边界检查）    if (in_row &gt;= 0 &amp;&amp; in_row &lt; N &amp;&amp; in_col &gt;= 0 &amp;&amp; in_col &lt; N) &#123;        tile[ty][tx] = in[in_row * N + in_col];    &#125; else &#123;        tile[ty][tx] = 0.0f;  // 边界外填 0    &#125;        __syncthreads();        // 只有内部线程计算输出    if (tx &gt; 0 &amp;&amp; tx &lt; IN_TILE_SIZE - 1 &amp;&amp;         ty &gt; 0 &amp;&amp; ty &lt; IN_TILE_SIZE - 1) &#123;                int out_row = blockIdx.y * OUT_TILE_SIZE + ty - 1;        int out_col = blockIdx.x * OUT_TILE_SIZE + tx - 1;                if (out_row &lt; N &amp;&amp; out_col &lt; N) &#123;            out[out_row * N + out_col] =                 C0 * tile[ty][tx] +                C1 * (tile[ty-1][tx] + tile[ty+1][tx] +                      tile[ty][tx-1] + tile[ty][tx+1]);        &#125;    &#125;&#125;\n启动配置\ndim3 block(IN_TILE_SIZE, IN_TILE_SIZE);  // 18×18 = 324 线程dim3 grid((N + OUT_TILE_SIZE - 1) / OUT_TILE_SIZE,          (N + OUT_TILE_SIZE - 1) / OUT_TILE_SIZE);stencil_2d_tiled&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_in, d_out, N);\n性能分析\n\n\n\n指标\n朴素实现\nTiled 实现\n\n\n\n\n每输出元素\n5 次全局读取\n18²/16² ≈ 1.27 次\n\n\n加速比\n1×\n~4×\n\n\n共享内存\n0\n18×18×4 = 1.3 KB\n\n\n\n线程粗化（Thread Coarsening）\n为什么粗化\nTiled 模板有个问题：边界线程只加载不计算，效率不高。\nBlock 线程数：18×18 = 324计算线程数：16×16 = 256利用率：256/324 = 79%\n如果模板半径更大，利用率更低。\n线程粗化的思路：让每个线程计算多个输出元素，分摊边界开销。\nZ 方向粗化\n对于 3D 模板，常用的技巧是在 Z 方向展开：\n#define IN_TILE_SIZE 18#define OUT_TILE_SIZE 16#define Z_COARSEN 8  // 每线程处理 8 层__global__ void stencil_3d_coarsened(float *in, float *out,                                       int Nx, int Ny, int Nz) &#123;    __shared__ float tile[3][IN_TILE_SIZE][IN_TILE_SIZE];  // 只需 3 层        int tx = threadIdx.x, ty = threadIdx.y;    int ox = blockIdx.x * OUT_TILE_SIZE + tx - 1;    int oy = blockIdx.y * OUT_TILE_SIZE + ty - 1;        // 预加载前两层    load_layer(tile[0], in, ox, oy, 0, Nx, Ny, Nz);    load_layer(tile[1], in, ox, oy, 1, Nx, Ny, Nz);        // 滑动窗口遍历 Z 方向    for (int z = 1; z &lt; Nz - 1; z++) &#123;        // 加载下一层        load_layer(tile[(z+1) % 3], in, ox, oy, z+1, Nx, Ny, Nz);        __syncthreads();                // 计算当前层        if (tx &gt; 0 &amp;&amp; tx &lt; IN_TILE_SIZE - 1 &amp;&amp;             ty &gt; 0 &amp;&amp; ty &lt; IN_TILE_SIZE - 1) &#123;            int idx = z * Nx * Ny + oy * Nx + ox;            out[idx] = compute_stencil(tile, tx, ty, z);        &#125;        __syncthreads();    &#125;&#125;\n寄存器粗化\n更激进的做法：把滑动窗口存在寄存器里：\n__global__ void stencil_3d_register(float *in, float *out,                                      int Nx, int Ny, int Nz) &#123;    __shared__ float tile[IN_TILE_SIZE][IN_TILE_SIZE];        int tx = threadIdx.x, ty = threadIdx.y;    int ox = blockIdx.x * OUT_TILE_SIZE + tx - 1;    int oy = blockIdx.y * OUT_TILE_SIZE + ty - 1;        // 寄存器存 Z 方向的三个值    float z_prev, z_curr, z_next;        z_prev = load_element(in, ox, oy, 0, Nx, Ny, Nz);    z_curr = load_element(in, ox, oy, 1, Nx, Ny, Nz);        for (int z = 1; z &lt; Nz - 1; z++) &#123;        z_next = load_element(in, ox, oy, z+1, Nx, Ny, Nz);                // 加载 XY 平面到共享内存        tile[ty][tx] = z_curr;        __syncthreads();                // 计算        if (valid_output_thread) &#123;            out[idx] = C0 * tile[ty][tx] +                       C1 * (tile[ty-1][tx] + tile[ty+1][tx] +                             tile[ty][tx-1] + tile[ty][tx+1]) +                       C2 * (z_prev + z_next);  // Z 方向用寄存器        &#125;                // 滑动窗口        z_prev = z_curr;        z_curr = z_next;        __syncthreads();    &#125;&#125;\n优势：Z 方向的访问完全在寄存器，无需共享内存。\n边界条件处理\n常见边界条件\n1. 固定边界（Dirichlet）\nif (is_boundary) &#123;    out[idx] = BOUNDARY_VALUE;  // 固定值&#125;\n2. 周期边界（Periodic）\nint wrapped_x = (x + N) % N;  // 环绕int wrapped_y = (y + N) % N;\n3. 零梯度边界（Neumann）\n// 边界处用相邻内部值if (x == 0) x = 1;if (x == N-1) x = N-2;\n边界处理策略\n方法 1：条件分支\nif (i &gt; 0 &amp;&amp; i &lt; N-1 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; N-1) &#123;    // 内部点计算&#125; else &#123;    // 边界处理&#125;\n问题：分支发散。\n方法 2：填充（Padding）\n预先在数据周围加一圈边界值，核函数内部无需边界判断。\n原始数据 N×N → 填充后 (N+2)×(N+2)所有计算都在 [1, N] 范围内\n方法 3：分离边界核函数\n// 先处理内部区域stencil_interior&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(in, out, N);// 再处理边界区域stencil_boundary&lt;&lt;&lt;1, boundary_threads&gt;&gt;&gt;(in, out, N);\n内部核函数无分支，边界核函数线程少但逻辑复杂。\n时间步进与双缓冲\n迭代模式\n模板计算通常需要多次迭代：\nfor (int t = 0; t &lt; num_steps; t++) &#123;    stencil_kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_in, d_out, N);    cudaDeviceSynchronize();    swap(d_in, d_out);  // 交换输入输出&#125;\n关键：不能原地更新！读取邻居时可能读到已更新的值，导致错误。所以需要双缓冲：读旧写新，然后交换。\n时间阻塞（Temporal Blocking）\n每次 kernel 启动有开销。如果能在一次 kernel 中计算多个时间步，就能减少启动开销。\n原理：\n输入 Tile 计算 T 个时间步：时间 0：需要 (OUT + 2r*T) 的输入时间 1：需要 (OUT + 2r*(T-1)) 的输入...时间 T：输出 OUT 的结果\n随着时间推进，有效数据区域向内收缩。\n实现复杂度高，通常在高性能计算库中使用，手写较难。\n3D 模板优化\n挑战\n3D 模板的共享内存需求更大：\n2D: (T+2)² × 4 = 324 × 4 = 1.3 KB3D: (T+2)³ × 4 = 8000 × 4 = 32 KB  // 可能超限！\n解决方案\n1. 减小 Tile 大小\n#define TILE_3D 8// (8+2)³ = 1000 元素，4 KB\n代价：降低数据复用率。\n2. 2.5D 分解\n只加载 XY 平面的 Tile，Z 方向逐层处理：\n__shared__ float tile[TILE_Y][TILE_X];  // 只存一层 XYfor (int z = 0; z &lt; Nz; z++) &#123;    // 加载当前层    // 计算（Z 方向邻居从全局内存读）&#125;\nZ 方向的访问仍走全局内存，但 XY 方向利用共享内存。\n3. 寄存器滑动窗口\n如前所述，Z 方向 3 个值存寄存器，XY 平面存共享内存。\n指令级优化\n循环展开\n对于小模板，手动展开消除循环开销：\n// 展开前for (int di = -1; di &lt;= 1; di++) &#123;    for (int dj = -1; dj &lt;= 1; dj++) &#123;        sum += tile[ty+di][tx+dj] * weight[di+1][dj+1];    &#125;&#125;// 展开后sum = tile[ty-1][tx-1] * W00 + tile[ty-1][tx] * W01 + tile[ty-1][tx+1] * W02 +      tile[ty  ][tx-1] * W10 + tile[ty  ][tx] * W11 + tile[ty  ][tx+1] * W12 +      tile[ty+1][tx-1] * W20 + tile[ty+1][tx] * W21 + tile[ty+1][tx+1] * W22;\n编译器通常会自动展开，但显式展开保证效果。\n常量预计算\n// 编译时常量#define C0 0.25f#define C1 0.125f// 或使用 constexpr（C++11）__device__ constexpr float c0 = 0.25f;\n避免运行时计算系数。\n向量化加载\n对于对齐的访问模式，使用向量类型：\nfloat4 data = *reinterpret_cast&lt;float4*&gt;(&amp;in[idx]);// 一次加载 4 个 float\n需要数据对齐（16 字节边界）。\n实战：Jacobi 迭代求解器\n问题设置\n求解泊松方程 ∇²u = f：\n// Jacobi 迭代：u_new = (u_left + u_right + u_up + u_down - h²f) / 4\nCUDA 实现\n#define BLOCK_SIZE 16#define TILE_SIZE 18  // BLOCK_SIZE + 2__global__ void jacobi_iteration(float *u, float *u_new, float *f,                                  int N, float h2) &#123;    __shared__ float tile[TILE_SIZE][TILE_SIZE];        int tx = threadIdx.x + 1;  // 偏移 1，留出 Halo    int ty = threadIdx.y + 1;    int gx = blockIdx.x * BLOCK_SIZE + threadIdx.x;    int gy = blockIdx.y * BLOCK_SIZE + threadIdx.y;        // 加载中心    if (gx &lt; N &amp;&amp; gy &lt; N) &#123;        tile[ty][tx] = u[gy * N + gx];    &#125;        // 加载 Halo    if (threadIdx.x == 0 &amp;&amp; gx &gt; 0) &#123;        tile[ty][0] = u[gy * N + gx - 1];    &#125;    if (threadIdx.x == BLOCK_SIZE - 1 &amp;&amp; gx &lt; N - 1) &#123;        tile[ty][TILE_SIZE - 1] = u[gy * N + gx + 1];    &#125;    if (threadIdx.y == 0 &amp;&amp; gy &gt; 0) &#123;        tile[0][tx] = u[(gy - 1) * N + gx];    &#125;    if (threadIdx.y == BLOCK_SIZE - 1 &amp;&amp; gy &lt; N - 1) &#123;        tile[TILE_SIZE - 1][tx] = u[(gy + 1) * N + gx];    &#125;        __syncthreads();        // 计算（跳过边界）    if (gx &gt; 0 &amp;&amp; gx &lt; N - 1 &amp;&amp; gy &gt; 0 &amp;&amp; gy &lt; N - 1) &#123;        float f_val = f[gy * N + gx];        u_new[gy * N + gx] = 0.25f * (tile[ty-1][tx] + tile[ty+1][tx] +                                       tile[ty][tx-1] + tile[ty][tx+1] -                                       h2 * f_val);    &#125;&#125;// Host 端迭代void jacobi_solve(float *u, float *f, int N, int max_iter, float tol) &#123;    float *d_u, *d_u_new, *d_f;    // ... 分配内存 ...        dim3 block(BLOCK_SIZE, BLOCK_SIZE);    dim3 grid((N + BLOCK_SIZE - 1) / BLOCK_SIZE,              (N + BLOCK_SIZE - 1) / BLOCK_SIZE);        for (int iter = 0; iter &lt; max_iter; iter++) &#123;        jacobi_iteration&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_u, d_u_new, d_f, N, h*h);        cudaDeviceSynchronize();                // 交换指针        float *temp = d_u;        d_u = d_u_new;        d_u_new = temp;                // 可选：检查收敛    &#125;&#125;\n收敛检查\n每隔几步检查残差：\n__global__ void compute_residual(float *u, float *f, float *residual,                                  int N, float h2) &#123;    // 计算 ||∇²u - f||    // 使用规约求和&#125;\n不需要每步都检查，开销太大。\n性能调优建议\nTile 大小选择\n共享内存限制：96 KB / SM（Ampere）每 Block 可用：~48 KB2D Tile: sqrt(48K/4) ≈ 110 → 实际用 32、48、643D Tile: cbrt(48K/4) ≈ 23  → 实际用 8、12、16\n需要考虑占用率：Tile 太大导致每 SM 的 Block 数减少。\nNsight 指标\n关注：\n\n\n\n指标\n意义\n目标\n\n\n\n\nMemory Throughput\n带宽利用\n接近峰值\n\n\nCompute Throughput\n计算利用\n越高越好\n\n\nShared Memory Usage\n共享内存\n不超限\n\n\nWarp Occupancy\n占用率\n&gt;50%\n\n\n\n常见瓶颈\n带宽受限：Tiling 优化、寄存器缓存\n计算受限：向量化、指令级并行\n延迟受限：增加占用率、预取\n模板优化总结\n核心技术\n┌─────────────────────────────────────────────────────────────┐│ Level 3: 高级优化                                            ││   - 时间阻塞（多步合并）                                      ││   - 自动调优（搜索最优参数）                                  │├─────────────────────────────────────────────────────────────┤│ Level 2: 数据局部性                                          ││   - 共享内存 Tiling                                          ││   - 寄存器滑动窗口                                           ││   - 线程粗化                                                 │├─────────────────────────────────────────────────────────────┤│ Level 1: 基础优化                                            ││   - 双缓冲避免竞争                                           ││   - 边界条件处理                                             ││   - 合并内存访问                                             │└─────────────────────────────────────────────────────────────┘\n模板 vs 卷积决策\n\n\n\n场景\n推荐技术\n\n\n\n\n单次滤波\n卷积 + 常量内存\n\n\n迭代求解\n模板 + 双缓冲\n\n\n大半径模板\n时间阻塞\n\n\n3D + 大规模\n2.5D + 寄存器滑动\n\n\n\n小结\n第八章围绕模板计算，在第七章卷积的基础上增加了：\n迭代结构：模板计算通常是多步迭代的。双缓冲是基本技巧——读旧写新，然后交换。\n线程粗化：让每个线程计算多个输出，分摊边界线程的开销。Z 方向粗化是 3D 模板的常用技巧。\n寄存器优化：对于滑动窗口模式，把时间维度或空间维度的小邻域存寄存器，比共享内存更快。\n边界处理：Dirichlet、Neumann、周期边界各有策略。Padding 预处理能简化 kernel 逻辑，但需要额外内存。\n3D 挑战：共享内存需求爆炸。2.5D 分解、寄存器滑动是解决方案。\n模板计算是科学计算的核心，热传导、流体力学、电磁仿真都用到。掌握这套优化技术，就能高效实现各种 PDE 求解器。下一章进入另一个重要模式——并行直方图。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 08\n第八章：模板\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","共享内存","模板计算","Stencil"]},{"title":"PMPP-第六章：性能方面的考虑","url":"/posts/220818c3/","content":"前言\n第五章学习了内存层次和分块（Tiling）技术，矩阵乘法性能提升了10倍。但这只是开始——实际优化中还有很多细节会影响性能。第六章系统梳理这些性能因素：内存合并、分支发散、资源分配、指令吞吐量等。本章内容偏重工程实践，掌握这些技巧，可以让代码性能进一步提升数倍。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n内存合并（Memory Coalescing）\n全局内存的硬件特性\n全局内存（DRAM）不是按单个字节访问的，而是按**事务（Transaction）**批量访问：\n\n每次事务读取一个内存段（Memory Segment）\n段大小通常是 32 字节或 128 字节\n段必须对齐（起始地址是段大小的倍数）\n\n这意味着：读 1 个 float（4 字节）和读 32 个 float（128 字节），如果落在同一个段，硬件开销相同。\n合并访问的条件\n当 Warp 中的 32 个线程访问连续且对齐的内存地址时，这些访问可以合并成最少的事务：\n理想情况：32 线程访问连续 128 字节\n// 合并访问（1 次 128B 事务）float val = data[threadIdx.x];// 线程 0 访问 data[0], 线程 1 访问 data[1], ...\n糟糕情况：32 线程访问跨步地址\n// 非合并访问（可能 32 次事务！）float val = data[threadIdx.x * 32];// 线程 0 访问 data[0], 线程 1 访问 data[32], ...// 每个访问落在不同段\n量化影响\n假设每次事务延迟相同，合并访问带来的加速：\n\n\n\n访问模式\n事务数\n相对带宽\n\n\n\n\n完全合并\n1\n100%\n\n\n步长 2\n2\n50%\n\n\n步长 4\n4\n25%\n\n\n步长 32\n32\n3%\n\n\n\n步长越大，带宽利用率越低。\n矩阵访问模式的影响\n考虑行主序矩阵 M[row][col]，一维索引为 M[row * width + col]：\n按行遍历（合并访问）：\n// 同一线程束的线程，row 相同，col 连续int idx = row * width + threadIdx.x;float val = M[idx];  // 连续地址，实现合并访问\n按列遍历（非合并访问）：\n// 同一线程束的线程，col 相同，row 连续int idx = threadIdx.x * width + col;float val = M[idx];  // 步长 = width，无法合并\n对于 width = 1024 的矩阵，步长为 1024×4 = 4096 字节，远超内存段大小，每个线程访问不同的内存段，无法合并。\n矩阵转置优化\n矩阵转置 B[j][i] = A[i][j]，必然有一个矩阵按列访问。解决方案：用共享内存做中转。\n__global__ void transposeCoalesced(float *A, float *B, int width) &#123;    __shared__ float tile[32][33];  // 注意 padding 防 bank 冲突        int x = blockIdx.x * 32 + threadIdx.x;    int y = blockIdx.y * 32 + threadIdx.y;        // 合并读取 A（按行）    if (x &lt; width &amp;&amp; y &lt; width)        tile[threadIdx.y][threadIdx.x] = A[y * width + x];        __syncthreads();        // 交换 block 索引    x = blockIdx.y * 32 + threadIdx.x;    y = blockIdx.x * 32 + threadIdx.y;        // 合并写入 B（按行，但数据来自 tile 的列）    if (x &lt; width &amp;&amp; y &lt; width)        B[y * width + x] = tile[threadIdx.x][threadIdx.y];&#125;\n关键：共享内存没有合并要求，可以任意顺序访问（只需注意 Bank 冲突）。通过共享内存&quot;转换&quot;访问模式，让全局内存读写都是合并的。\n分区露营（Partition Camping）\nDRAM 的分区结构\n全局内存由多个**分区（Partition）**组成，每个分区有独立的访问通道。地址到分区的映射通常是：\n分区 = (地址 / 256) % 分区数\n如果所有访问都落在同一分区，其他分区空闲，带宽只有 1/N。\n何时发生\n当多个 Warp 访问地址&quot;步调一致&quot;时：\n// 假设每个 block 处理矩阵的一列int col = blockIdx.x;for (int row = 0; row &lt; height; row++) &#123;    float val = M[row * width + col];  // 所有 block 同步访问&#125;\n如果 width 恰好是分区数的倍数，所有 block 同时访问同一分区。\n解决方案\n\n调整数据布局：加 padding 打破对齐\n调整访问顺序：让不同 block 访问不同分区\n通常问题不大：现代 GPU 分区多，自动调度能力强\n\n分区露营在早期 GPU 上是严重问题，现代架构（Ampere+）影响较小，但仍值得注意。\n指令混合与吞吐量\n不同指令的吞吐量\n并非所有操作速度相同：\n\n\n\n操作类型\n吞吐量（FLOP/周期/SM）\n相对速度\n\n\n\n\nFP32 加法/乘法\n128\n1×\n\n\nFP32 FMA\n128\n1×\n\n\nFP32 除法\n16\n1/8\n\n\nFP32 特殊函数\n32\n1/4\n\n\nFP64 加法/乘法\n64（或更少）\n1/2\n\n\n整数乘法\n64\n1/2\n\n\n\n注意：除法和特殊函数（sin/cos/exp）慢很多。\n优化策略\n用乘法替代除法：\n// 慢float y = x / 3.0f;// 快（预计算倒数）float inv3 = 1.0f / 3.0f;  // 常量，编译时计算float y = x * inv3;\n用近似函数：\n// 精确但慢float y = sinf(x);// 快速近似（误差略大）float y = __sinf(x);  // 内置快速版本\n减少特殊函数调用：\n// 差：3 次特殊函数float a = expf(x);float b = expf(y);float c = expf(z);// 好：利用数学性质float abc = expf(x + y + z);\n混合精度\n如果精度允许，用 FP16 或 TF32：\n// 使用 half 精度（需要 include cuda_fp16.h）half x = __float2half(input);half y = __hmul(x, x);  // FP16 乘法，吞吐量更高float result = __half2float(y);\nTensor Core 可以做 FP16/TF32 矩阵乘法，吞吐量比 FP32 CUDA 核心高数倍。\n线程粒度\n每线程工作量\n线程粒度指每个线程处理的数据量。两个极端：\n细粒度：每线程处理 1 个元素\n// 每线程 1 个元素int i = blockIdx.x * blockDim.x + threadIdx.x;C[i] = A[i] + B[i];\n粗粒度：每线程处理多个元素\n// 每线程 4 个元素int base = (blockIdx.x * blockDim.x + threadIdx.x) * 4;for (int i = 0; i &lt; 4; i++) &#123;    C[base + i] = A[base + i] + B[base + i];&#125;\n粗粒度的优势\n\n减少启动开销：更少的线程总数\n寄存器复用：循环变量、指针可复用\n指令级并行：循环展开后多条指令可流水\n减少同步：每线程更多独立工作\n\n粗粒度的风险\n\n负载不均衡：如果元素数不是粒度倍数，最后一批线程工作量不同\n占用率下降：每线程更多寄存器，可能降低并行度\n复杂边界处理：需要额外检查\n\n实践建议\n// 每线程处理 4 个元素，带边界检查__global__ void vectorAddCoarsened(float *A, float *B, float *C, int n) &#123;    int tid = blockIdx.x * blockDim.x + threadIdx.x;    int stride = blockDim.x * gridDim.x;        // Grid-stride loop    for (int i = tid; i &lt; n; i += stride) &#123;        C[i] = A[i] + B[i];    &#125;&#125;\nGrid-stride loop 是经典模式：每线程从自己的起始位置开始，按 grid 大小步进，直到处理完所有元素。兼顾了粒度和灵活性。\n资源平衡\n占用率 vs 每线程资源\n回顾第四章的占用率概念。资源使用增加会降低占用率：\n\n\n\n每线程寄存器\n每 SM 线程数\n占用率\n\n\n\n\n32\n2048\n100%\n\n\n64\n1024\n50%\n\n\n128\n512\n25%\n\n\n256\n256\n12.5%\n\n\n\n类似地，每 Block 共享内存越多，能同时运行的 Block 越少。\n权衡案例\n场景：Tiled 矩阵乘法\n// 方案 A：小 Tile#define TILE 16__shared__ float As[16][16];  // 2 KB__shared__ float Bs[16][16];  // 2 KB// 共享内存少，可以多 Block，高占用率// 但 Tile 小，算术强度低// 方案 B：大 Tile#define TILE 32__shared__ float As[32][32];  // 8 KB__shared__ float Bs[32][32];  // 8 KB// 共享内存多，Block 少，低占用率// 但 Tile 大，算术强度高\n通常大 Tile 更优：矩阵乘法是计算密集型，算术强度比占用率更重要。但需要实测验证。\n使用 Launch Bounds\n告诉编译器你的配置，帮助优化寄存器分配：\n__global__ void __launch_bounds__(256, 4) matMulKernel(...) &#123;    // 每 Block 256 线程    // 期望每 SM 至少 4 个 Block    // 编译器据此限制寄存器使用&#125;\n如果不指定，编译器可能过度使用寄存器，导致占用率低于预期。\nWarp 执行效率\n线程束利用率\n如果 Block 大小不是 32 的倍数，最后一个 Warp 有线程空闲：\ndim3 block(100);  // 100 / 32 = 3.125 → 4 个 warp// Warp 3 只有 4 个活跃线程，28 个空闲// warp 利用率 = 100 / 128 = 78%\n永远用 32 的倍数作为 Block 大小。\n动态分支的额外开销\n即使没有分支发散，动态分支本身也有开销：\n// 有分支开销if (condition) &#123;    doWork();&#125;// 无分支（条件总为 true）doWork();\n编译器无法知道 condition 是否总为 true，必须生成分支指令。如果条件可以在编译时确定，用模板或 constexpr。\n数据预取\n软件流水\n通过提前发起内存请求，与计算重叠：\n// 无预取for (int i = 0; i &lt; n; i++) &#123;    float data = load(i);      // 等待    process(data);             // 计算&#125;// 有预取float next = load(0);for (int i = 0; i &lt; n - 1; i++) &#123;    float curr = next;    next = load(i + 1);        // 提前请求    process(curr);             // 同时计算&#125;process(next);\n预取让 load 和 compute 重叠，隐藏部分延迟。\n在 CUDA 中的应用\n__global__ void prefetchExample(float *in, float *out, int n) &#123;    __shared__ float buffer[2][TILE_SIZE];  // 双缓冲        int tile = 0;        // 预加载第一块    buffer[0][threadIdx.x] = in[threadIdx.x];        for (int i = TILE_SIZE; i &lt; n; i += TILE_SIZE) &#123;        __syncthreads();                // 加载下一块到另一个缓冲区        buffer[1 - tile][threadIdx.x] = in[i + threadIdx.x];                // 处理当前块        out[i - TILE_SIZE + threadIdx.x] = process(buffer[tile][threadIdx.x]);                tile = 1 - tile;  // 切换缓冲区        __syncthreads();    &#125;        // 处理最后一块    out[n - TILE_SIZE + threadIdx.x] = process(buffer[tile][threadIdx.x]);&#125;\n双缓冲是经典技术：一个缓冲区处理，另一个加载，交替进行。\n性能分析工具\nNsight Compute\nNVIDIA 官方 profiler，分析 kernel 性能：\nncu --set full ./myprogram\n关键指标：\n\n\n\n指标\n含义\n目标\n\n\n\n\nSM Throughput\n计算单元利用率\n越高越好\n\n\nMemory Throughput\n内存带宽利用率\n接近硬件峰值\n\n\nOccupancy\n占用率\n视情况而定\n\n\nWarp Execution Efficiency\n线程束效率\n接近 100%\n\n\nMemory Coalescing\n合并效率\n接近 100%\n\n\n\nNsight Systems\n分析整体执行流程：\nnsys profile ./myprogram\n可视化：\n\nKernel 执行时间线\nMemory 拷贝时间\nCPU/GPU 交互\n流和事件\n\n常见性能模式\n内存受限：Memory Throughput 高，SM Throughput 低\n\n解决：提高算术强度、用共享内存\n\n计算受限：SM Throughput 高，Memory Throughput 低\n\n解决：已经很好了，优化算法复杂度\n\n延迟受限：两个 Throughput 都低，Occupancy 也低\n\n解决：增加并行度，调整 Block 配置\n\n优化检查清单\n按优先级排序的优化步骤：\n1. 正确性优先\n\n[ ] 边界检查完整\n[ ] 同步正确使用\n[ ] 无竞态条件\n\n2. 内存优化\n\n[ ] 全局内存合并访问\n[ ] 使用共享内存减少全局内存访问\n[ ] 避免 Bank 冲突\n[ ] 常量数据用 __constant__\n\n3. 执行优化\n\n[ ] Block 大小是 32 的倍数\n[ ] 避免 Warp 内分支发散\n[ ] 减少同步次数\n[ ] 合理线程粒度\n\n4. 指令优化\n\n[ ] 避免除法和特殊函数\n[ ] 用 FMA（编译器自动）\n[ ] 考虑混合精度\n\n5. 资源平衡\n\n[ ] 监控寄存器使用\n[ ] 使用 launch_bounds\n[ ] 实测不同配置\n\n小结\n第六章是性能优化的工程实践：\n内存合并核心：Warp 线程访问连续地址，事务数最少。矩阵按行访问好，按列访问差。用共享内存转换访问模式。\n分支发散回顾：Warp 内走不同分支会串行化。按 Warp 边界划分任务，用算术替代分支。\n指令吞吐量：除法慢 8 倍，特殊函数慢 4 倍。预计算倒数，用快速近似，考虑混合精度。\n线程粒度：每线程处理多个元素可提高效率。Grid-stride loop 是通用模式。\n资源平衡：占用率不是越高越好。计算密集型可接受低占用率，内存密集型需要高占用率来隐藏延迟。\n工具驱动优化：用 Nsight Compute 分析瓶颈，不要猜测。Memory Throughput 和 SM Throughput 指明优化方向。\n这些技巧组合使用，能让代码性能再提升数倍。下一章开始学习具体的并行模式——卷积、规约、前缀和，这些都需要本章的优化技术。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 06\n第六章：性能方面的考虑\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","性能优化","内存合并"]},{"title":"PMPP-第十一章：前缀和","url":"/posts/a6fc4cf6/","content":"前言\n第十章学习了归约——把 N 个数归约成 1 个数。本章学习前缀和（Prefix Sum），也称为 Scan——把 N 个数变换成 N 个数，每个位置存储之前所有元素的累计结果。虽然看起来计算量更大，但前缀和是并行计算的&quot;瑞士军刀&quot;，能解决许多看似无法并行的问题：流压缩、基数排序、稀疏矩阵运算等。第十一章重点讲解**工作效率（Work Efficiency）**的概念——如何让并行算法的总工作量不超过串行算法太多。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n前缀和基础\n什么是前缀和\n前缀和：对于输入数组 [a₀, a₁, a₂, ..., aₙ₋₁]，输出每个位置之前所有元素的累计值。\n有两种变体：\n包含式扫描（Inclusive Scan）：包含当前元素\n输入:  [3, 1, 7, 0, 4, 1, 6, 3]输出:  [3, 4, 11, 11, 15, 16, 22, 25]       3  3+1  4+7  11+0  ...\n排除式扫描（Exclusive Scan）：不包含当前元素\n输入:  [3, 1, 7, 0, 4, 1, 6, 3]输出:  [0, 3, 4, 11, 11, 15, 16, 22]       0  前缀  前缀+1  前缀+7  ...\n关系：exclusive[i] = inclusive[i-1]，exclusive[0] = 0\n数学定义\n对于二元结合运算 ⊕：\nInclusive Scan:\nyi=⨁j=0ixj=x0⊕x1⊕...⊕xiy_i = \\bigoplus_{j=0}^{i} x_j = x_0 \\oplus x_1 \\oplus ... \\oplus x_i\nyi​=j=0⨁i​xj​=x0​⊕x1​⊕...⊕xi​\nExclusive Scan:\nyi=⨁j=0i−1xj=x0⊕x1⊕...⊕xi−1y_i = \\bigoplus_{j=0}^{i-1} x_j = x_0 \\oplus x_1 \\oplus ... \\oplus x_{i-1}\nyi​=j=0⨁i−1​xj​=x0​⊕x1​⊕...⊕xi−1​\n其中 y₀ = identity（单位元）。\n应用场景\n前缀和用途极广：\n\n\n\n应用\n说明\n\n\n\n\n流压缩\n根据条件筛选元素\n\n\n基数排序\n计算每个桶的起始位置\n\n\n稀疏矩阵\nCSR 格式的行指针数组\n\n\n多项式求值\nHorner 法则的并行化\n\n\n求解三对角方程\n循环归约\n\n\n直方图均衡化\n累积分布函数\n\n\n\n核心思想：前缀和把&quot;依赖前面结果&quot;的问题转化为可并行的形式。\n串行实现\nvoid inclusive_scan_sequential(float *x, float *y, int n) &#123;    y[0] = x[0];    for (int i = 1; i &lt; n; i++) &#123;        y[i] = y[i-1] + x[i];    &#125;&#125;\n时间复杂度 O(n)，存在严格的数据依赖：y[i] 依赖 y[i-1]。\n看似无法并行？其实可以！\nKogge-Stone 算法\n核心思想\n利用结合律，不需要按顺序计算：\ny[i] = x[0] + x[1] + ... + x[i]     = (x[0] + x[1] + ... + x[i-k]) + (x[i-k+1] + ... + x[i])\n思路：每一步让每个元素与距离为 2^k 的元素相加。\n算法过程\n初始:     [3, 1, 7, 0, 4, 1, 6, 3]Step 1 (stride=1):  y[i] = x[i] + x[i-1]  结果: [3, 4, 8, 7, 4, 5, 7, 9]Step 2 (stride=2):  y[i] = y[i] + y[i-2]  结果: [3, 4, 11, 11, 12, 12, 11, 14]Step 3 (stride=4):  y[i] = y[i] + y[i-4]  结果: [3, 4, 11, 11, 15, 16, 22, 25]完成！\n每一步，每个元素都并行更新。log₂N 步后完成。\nCUDA 实现\n__global__ void kogge_stone_scan(float *X, float *Y, int n) &#123;    __shared__ float XY[SECTION_SIZE];        int i = blockIdx.x * blockDim.x + threadIdx.x;        // 加载到共享内存    if (i &lt; n) &#123;        XY[threadIdx.x] = X[i];    &#125; else &#123;        XY[threadIdx.x] = 0;    &#125;        // Kogge-Stone 扫描    for (unsigned int stride = 1; stride &lt; blockDim.x; stride *= 2) &#123;        __syncthreads();        float temp;        if (threadIdx.x &gt;= stride) &#123;            temp = XY[threadIdx.x] + XY[threadIdx.x - stride];        &#125;        __syncthreads();        if (threadIdx.x &gt;= stride) &#123;            XY[threadIdx.x] = temp;        &#125;    &#125;        // 写回    if (i &lt; n) &#123;        Y[i] = XY[threadIdx.x];    &#125;&#125;\n为什么需要两次同步？\n__syncthreads();  // 第一次：确保所有线程读完temp = XY[...] + XY[...];  // 读取__syncthreads();  // 第二次：确保所有线程读完再写XY[...] = temp;  // 写入\n如果不用临时变量：\n// 错误！XY[i] = XY[i] + XY[i-stride];  // 如果邻居还没读完就被覆盖\n关键：读和写必须分离，用同步保证。\n工作量分析\n\n\n\n指标\n串行算法\nKogge-Stone\n\n\n\n\n步数\nN\nlog₂N\n\n\n每步操作\n1\n~N\n\n\n总操作\nN\nN·log₂N\n\n\n\n问题：Kogge-Stone 做了更多的工作！\n对于 N=1024：\n\n串行：1024 次操作\nKogge-Stone：1024 × 10 = 10240 次操作\n\n这就是**工作效率（Work Efficiency）**问题。\nBrent-Kung 算法\n工作效率优化\n思路：减少冗余计算，分两个阶段：\n\n归约阶段（Reduce）：自底向上，构建部分和\n分发阶段（Downsweep）：自顶向下，分发结果\n\n算法过程\n阶段 1：归约\n初始:     [3, 1, 7, 0, 4, 1, 6, 3]Step 1 (stride=1): 相邻元素配对求和          [3, 4, 7, 7, 4, 5, 6, 9]              ↑     ↑     ↑     ↑             1+3   0+7   1+4   3+6Step 2 (stride=2): 隔一个配对          [3, 4, 7, 11, 4, 5, 6, 14]                   ↑           ↑                  4+7         5+9Step 3 (stride=4): 隔三个配对          [3, 4, 7, 11, 4, 5, 6, 25]                               ↑                             11+14\n现在 XY[7] = 25 = 全部元素之和。\n阶段 2：分发（Downsweep）\n从右到左，把部分和&quot;传播&quot;下去：Step 1 (stride=2):  XY[5] = XY[5] + XY[3] = 5 + 11 = 16          [3, 4, 7, 11, 4, 16, 6, 25]Step 2 (stride=1):  XY[2] = XY[2] + XY[1] = 7 + 4 = 11  XY[4] = XY[4] + XY[3] = 4 + 11 = 15  XY[6] = XY[6] + XY[5] = 6 + 16 = 22          [3, 4, 11, 11, 15, 16, 22, 25]完成！\nCUDA 实现\n__global__ void brent_kung_scan(float *X, float *Y, int n) &#123;    __shared__ float XY[SECTION_SIZE];        int i = 2 * blockIdx.x * blockDim.x + threadIdx.x;        // 加载（每线程两个元素）    if (i &lt; n) XY[threadIdx.x] = X[i];    if (i + blockDim.x &lt; n) XY[threadIdx.x + blockDim.x] = X[i + blockDim.x];        // ========== 归约阶段 ==========    for (unsigned int stride = 1; stride &lt;= blockDim.x; stride *= 2) &#123;        __syncthreads();        int index = (threadIdx.x + 1) * 2 * stride - 1;        if (index &lt; SECTION_SIZE) &#123;            XY[index] += XY[index - stride];        &#125;    &#125;        // ========== 分发阶段 ==========    for (unsigned int stride = SECTION_SIZE / 4; stride &gt; 0; stride /= 2) &#123;        __syncthreads();        int index = (threadIdx.x + 1) * 2 * stride - 1;        if (index + stride &lt; SECTION_SIZE) &#123;            XY[index + stride] += XY[index];        &#125;    &#125;        __syncthreads();        // 写回    if (i &lt; n) Y[i] = XY[threadIdx.x];    if (i + blockDim.x &lt; n) Y[i + blockDim.x] = XY[threadIdx.x + blockDim.x];&#125;\n工作量分析\n\n\n\n阶段\n步数\n每步操作\n总操作\n\n\n\n\n归约\nlog₂N\nN/2^k\nN-1\n\n\n分发\nlog₂N - 1\nN/2^k\nN-1-log₂N\n\n\n总计\n\n\n2N-2-log₂N\n\n\n\n对于 N=1024：\n\nKogge-Stone：10240 次操作\nBrent-Kung：~2046 次操作\n\n工作效率提升 5 倍！\n为什么每线程处理两个元素？\nint i = 2 * blockIdx.x * blockDim.x + threadIdx.x;\n如果 Section 有 1024 个元素，只需要 512 个线程。每线程加载两个元素，减少了线程开销。\nKogge-Stone vs Brent-Kung\n对比\n\n\n\n指标\nKogge-Stone\nBrent-Kung\n\n\n\n\n总操作数\nN·log₂N\n2N - 2 - log₂N\n\n\n步数\nlog₂N\n2·log₂N - 1\n\n\n并行度（每步）\nN\n递减/递增\n\n\n控制逻辑\n简单\n复杂\n\n\n工作效率\n低\n高（接近串行）\n\n\n\n算法选择策略\n\n\n\n场景\n推荐算法\n原因\n\n\n\n\n小数组（&lt;1K）\nKogge-Stone\n简单，步数少\n\n\n大数组\nBrent-Kung\n工作量小\n\n\n带宽受限\nKogge-Stone\n更多并行隐藏延迟\n\n\n计算受限\nBrent-Kung\n总操作少\n\n\n\n实际中，混合策略最常见：大部分用 Brent-Kung，最后几层用 Kogge-Stone。\n三阶段分层扫描\n问题：超出单 Block\n当数据量超过共享内存容量时，需要多 Block 协作。\n三阶段算法\n阶段 1：Block 内扫描\n每个 Block 独立扫描自己的 Section，保存最后一个元素（Section Sum）。\nBlock 0: [3,4,11,11]  → sum[0] = 11Block 1: [4,5,11,14]  → sum[1] = 14Block 2: [5,6,12,15]  → sum[2] = 15...\n阶段 2：扫描 Section Sums\n对所有 Block 的 sum 做扫描：\nsum: [11, 14, 15, ...]扫描后: [0, 11, 25, 40, ...]  // Exclusive\n这给出了每个 Block 的&quot;起始偏移&quot;。\n阶段 3：加上偏移\n每个 Block 的所有元素加上对应的偏移：\nBlock 0: [3,4,11,11] + 0  → [3,4,11,11]Block 1: [4,5,11,14] + 11 → [15,16,22,25]Block 2: [5,6,12,15] + 25 → [30,31,37,40]...\n实现\nKernel 1：Block 内扫描\n__global__ void scan_phase1(float *X, float *Y, float *S, int n) &#123;    __shared__ float XY[SECTION_SIZE];        // Block 内扫描（Brent-Kung）    // ...        // 保存 Section Sum    if (threadIdx.x == blockDim.x - 1) &#123;        S[blockIdx.x] = XY[SECTION_SIZE - 1];    &#125;        // 写回    // ...&#125;\nKernel 2：扫描 Section Sums\n// 通常只有一个 Block，因为 Section 数量不多scan_single_block&lt;&lt;&lt;1, numSections&gt;&gt;&gt;(S, S, numSections);\nKernel 3：加偏移\n__global__ void scan_phase3(float *Y, float *S, int n) &#123;    int i = blockIdx.x * SECTION_SIZE + threadIdx.x;    if (blockIdx.x &gt; 0 &amp;&amp; i &lt; n) &#123;        Y[i] += S[blockIdx.x - 1];  // Exclusive 扫描的结果    &#125;&#125;\n递归处理\n如果 Section 数量也很大，对 S 的扫描本身需要分层。形成递归结构：\nLevel 0: 扫描原始数据 → Section SumsLevel 1: 扫描 Section Sums → Super Section SumsLevel 2: 扫描 Super Section Sums...Level K: 单 Block 完成然后逆向加偏移：Level K → Level K-1 → ... → Level 0\n层数：log(N/SECTION_SIZE)\n单遍扫描（Single-Pass Scan）\n动机\n三阶段扫描需要多次 Kernel 启动，有开销。能否一遍完成？\n思路\n用原子操作 + 内存标志实现 Block 间通信：\n\n每个 Block 完成扫描后，发布自己的 Section Sum\n等待前一个 Block 的结果\n加上前缀并继续\n\n实现\n__global__ void single_pass_scan(float *X, float *Y, float *flags,                                   float *sums, int n) &#123;    __shared__ float XY[SECTION_SIZE];    __shared__ float prefix;        int bid = blockIdx.x;        // Phase 1: Block 内扫描    // ... 标准 Brent-Kung ...        // Phase 2: 等待前一个 Block    if (threadIdx.x == 0) &#123;        // 发布自己的和        sums[bid] = XY[SECTION_SIZE - 1];        __threadfence();  // 确保写入对其他 Block 可见        atomicExch(&amp;flags[bid], 1);  // 标记完成                // 等待前缀        if (bid &gt; 0) &#123;            // 等待 Block bid-1            while (atomicAdd(&amp;flags[bid - 1], 0) == 0);            __threadfence();                        // 累加所有前缀（可优化为 Kogge-Stone 风格）            float pre = 0;            for (int i = 0; i &lt; bid; i++) &#123;                pre += sums[i];            &#125;            prefix = pre;        &#125; else &#123;            prefix = 0;        &#125;    &#125;    __syncthreads();        // Phase 3: 加偏移并写回    int i = bid * SECTION_SIZE + threadIdx.x;    if (i &lt; n) &#123;        Y[i] = XY[threadIdx.x] + prefix;    &#125;&#125;\n问题\n顺序依赖：Block 必须按顺序完成，可能导致串行化。\n改进：使用 Decoupled Look-back（分离回溯）算法，每个 Block 只查看部分前缀，链式传播。\n工作效率的本质\n时间 vs 操作\n并行时间：所有处理器同时工作需要的时间步数\n总操作数：所有处理器执行的操作总和\n工作效率 = 串行操作数 / 并行操作数\n\n\n\n算法\n并行时间\n总操作\n工作效率\n\n\n\n\n串行\nN\nN\n100%\n\n\nKogge-Stone\nlog N\nN·log N\n1/log N\n\n\nBrent-Kung\n2·log N\n2N\n~50%\n\n\n\n何时追求工作效率？\n处理器充足时：\n\n操作数主导时间\n应该追求工作效率\n\n处理器不足时：\n\n步数主导时间\n可以牺牲工作效率换取更少步数\n\nGPU 通常处理器&quot;足够多&quot;，所以工作效率很重要。\n前缀和的应用\n流压缩（Stream Compaction）\n筛选满足条件的元素：\n输入:    [3, 1, 7, 0, 4, 1, 6, 3]条件:    x &gt; 2标志:    [1, 0, 1, 0, 1, 0, 1, 1]前缀和:  [0, 1, 1, 2, 2, 3, 3, 4]  // Exclusive输出位置: 0, -, 1, -, 2, -, 3, 4输出:    [3, 7, 4, 6, 3]\nExclusive 前缀和给出每个满足条件元素的输出位置！\n__global__ void compact(int *flags, int *positions,                         float *in, float *out, int n) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n &amp;&amp; flags[i]) &#123;        out[positions[i]] = in[i];    &#125;&#125;\n基数排序\n按位排序，每一位用前缀和确定位置：\n第 0 位 = 0 的元素: 前缀和确定位置第 0 位 = 1 的元素: 紧随其后\n分配工作\n根据负载分配任务：\n任务大小:  [5, 3, 8, 2, 4]前缀和:    [0, 5, 8, 16, 18]线程 7 应该处理哪个任务？→ 二分查找前缀和数组→ 任务 1（因为 5 ≤ 7 &lt; 8）\nCUB 库\n使用 CUB 实现扫描\n#include &lt;cub/cub.cuh&gt;void scanWithCub(float *d_in, float *d_out, int n) &#123;    void *d_temp = nullptr;    size_t temp_bytes = 0;        // 确定临时存储大小    cub::DeviceScan::InclusiveSum(d_temp, temp_bytes, d_in, d_out, n);        cudaMalloc(&amp;d_temp, temp_bytes);        // 执行扫描    cub::DeviceScan::InclusiveSum(d_temp, temp_bytes, d_in, d_out, n);        cudaFree(d_temp);&#125;\nCUB 提供的扫描\n\n\n\n函数\n功能\n\n\n\n\nDeviceScan::InclusiveSum\n包含式求和\n\n\nDeviceScan::ExclusiveSum\n排除式求和\n\n\nDeviceScan::InclusiveScan\n包含式自定义\n\n\nDeviceScan::ExclusiveScan\n排除式自定义\n\n\n\n自定义操作\nstruct MaxOp &#123;    __device__ float operator()(float a, float b) &#123;        return (a &gt; b) ? a : b;    &#125;&#125;;MaxOp max_op;cub::DeviceScan::InclusiveScan(d_temp, temp_bytes,                                 d_in, d_out, max_op, n);\n小结\n第十一章深入讲解前缀和：\n两种变体：Inclusive（含当前）vs Exclusive（不含当前）。Exclusive 的应用更广，特别是确定输出位置。\nKogge-Stone：简单直接，log N 步，但工作量 N·log N，工作效率低。\nBrent-Kung：分归约和分发两阶段，工作量 ~2N，接近串行。步数略多但更高效。\n分层扫描：大数据需要多 Block 协作。三阶段：Block 内扫描 → 扫描 Section Sums → 加偏移。可递归处理超大数据。\n工作效率：并行算法的总操作数不应远超串行。GPU 处理器多，工作效率比步数更重要。\n核心应用：流压缩、基数排序、负载分配。前缀和把&quot;输出位置&quot;问题变成并行可解。\n前缀和是并行计算的基础原语，理解它对于实现复杂并行算法至关重要。下一章学习合并（Merge）——另一个重要的并行原语。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 11\n第十一章：前缀和\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","前缀和","Scan","工作效率"]},{"title":"PMPP-第十七章：迭代式磁共振成像重建","url":"/posts/fab0715b/","content":"前言\n前面的章节主要讨论了通用的并行算法和深度学习应用。第十七章转向一个具体的应用领域——医学影像（Medical Imaging），特别是**磁共振成像（MRI，Magnetic Resonance Imaging）**的图像重建。MRI 重建是计算密集型任务，涉及大量的傅里叶变换和迭代优化，是 GPU 加速的理想场景。本章将展示如何将前面学到的并行技术（FFT、矩阵运算、迭代求解）综合应用于实际问题。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\nMRI 成像基础\nMRI 物理原理简述\nMRI 利用人体中氢原子核的磁共振现象成像：\n\n激发：射频脉冲激发氢原子核\n弛豫：原子核恢复平衡时发出信号\n采集：接收线圈采集信号\n编码：梯度磁场对空间位置进行编码\n\n采集到的信号位于k 空间（k-space）——图像的傅里叶变换域。\n从 k 空间到图像\n基本公式：\ns(kx,ky)=∫∫m(x,y)⋅e−i2π(kxx+kyy)dxdys(k_x, k_y) = \\int \\int m(x, y) \\cdot e^{-i2\\pi(k_x x + k_y y)} dx dy\ns(kx​,ky​)=∫∫m(x,y)⋅e−i2π(kx​x+ky​y)dxdy\n其中：\n\ns(kx,ky)s(k_x, k_y)s(kx​,ky​)：k 空间信号\nm(x,y)m(x, y)m(x,y)：图像（磁化强度分布）\n\n重建就是从 sss 恢复 mmm，即逆傅里叶变换。\n笛卡尔采样 vs 非笛卡尔采样\n笛卡尔采样：k 空间数据在规则网格上采集。\n\n优点：直接用 FFT 重建\n缺点：采集速度受限\n\n非笛卡尔采样（如螺旋、径向）：\n\n优点：采集更快，对运动不敏感\n缺点：不能直接 FFT，需要特殊处理\n\n直接重建与迭代重建\n直接重建\n对于笛卡尔采样的全采样数据：\n图像 = IFFT(k空间数据)\n简单快速，但有两个问题：\n\n欠采样：为加速扫描，往往只采集部分 k 空间数据\n非笛卡尔轨迹：数据不在网格上\n\n欠采样的问题\n根据奈奎斯特定理，欠采样会导致混叠伪影（Aliasing）。\n直接 IFFT 重建欠采样数据会产生严重的图像失真。\n迭代重建\n思路：把重建建模为优化问题。\nm^=arg⁡min⁡m12∥Am−s∥22+λR(m)\\hat{m} = \\arg\\min_m \\frac{1}{2}\\|Am - s\\|_2^2 + \\lambda R(m)\nm^=argmmin​21​∥Am−s∥22​+λR(m)\n其中：\n\nAAA：前向模型（编码矩阵）\nsss：采集的 k 空间数据\nR(m)R(m)R(m)：正则化项（先验约束）\nλ\\lambdaλ：正则化权重\n\n迭代求解：通过梯度下降、共轭梯度等方法逐步逼近最优解。\n非均匀傅里叶变换（NUFFT）\n问题\n非笛卡尔采样的数据不在规则网格上，不能直接用 FFT。\n非均匀离散傅里叶变换（NUDFT）：\ns(kj)=∑i=1Nm(xi)⋅e−i2πkjxis(k_j) = \\sum_{i=1}^{N} m(x_i) \\cdot e^{-i2\\pi k_j x_i}\ns(kj​)=i=1∑N​m(xi​)⋅e−i2πkj​xi​\n直接计算复杂度 O(MN)，太慢。\nNUFFT 算法\n核心思想：先插值到规则网格，再用 FFT。\nType-1 NUFFT（非均匀到均匀）：\n\n把非均匀点的值&quot;散布&quot;到规则网格（卷积/插值）\n对规则网格执行 FFT\n去卷积校正\n\nType-2 NUFFT（均匀到非均匀）：\n\n对规则网格执行 IFFT\n在非均匀点插值采样\n\nGPU 实现要点\n__global__ void gridding_kernel(    cuComplex *non_uniform_data,  // 非均匀采样数据    float2 *trajectory,            // 采样轨迹 (kx, ky)    cuComplex *grid,               // 输出网格    int num_samples,    int grid_size,    float kernel_width) &#123;        int idx = blockIdx.x * blockDim.x + threadIdx.x;    if (idx &gt;= num_samples) return;        float kx = trajectory[idx].x;    float ky = trajectory[idx].y;    cuComplex val = non_uniform_data[idx];        // 找到影响的网格点范围    int x_start = max(0, (int)(kx - kernel_width));    int x_end = min(grid_size - 1, (int)(kx + kernel_width));    int y_start = max(0, (int)(ky - kernel_width));    int y_end = min(grid_size - 1, (int)(ky + kernel_width));        // 散布到网格    for (int gx = x_start; gx &lt;= x_end; gx++) &#123;        for (int gy = y_start; gy &lt;= y_end; gy++) &#123;            float weight = kaiser_bessel(kx - gx, ky - gy, kernel_width);            atomicAdd(&amp;grid[gy * grid_size + gx].x, val.x * weight);            atomicAdd(&amp;grid[gy * grid_size + gx].y, val.y * weight);        &#125;    &#125;&#125;\n关键优化：\n\n使用 Kaiser-Bessel 窗函数插值\n原子操作处理网格冲突\n过采样网格减少误差\n\n共轭梯度法（CG）\n算法概述\n共轭梯度法求解线性系统 Ax=bAx = bAx=b：\n初始化：x_0, r_0 = b - A*x_0, p_0 = r_0循环：    alpha_k = (r_k·r_k) / (p_k·A*p_k)    x_&#123;k+1&#125; = x_k + alpha_k * p_k    r_&#123;k+1&#125; = r_k - alpha_k * A*p_k    beta_k = (r_&#123;k+1&#125;·r_&#123;k+1&#125;) / (r_k·r_k)    p_&#123;k+1&#125; = r_&#123;k+1&#125; + beta_k * p_k\nGPU 实现\nCG 的主要操作：\n\n矩阵-向量乘：A*p（使用 NUFFT）\n向量内积：r·r（归约）\n向量加法：x + alpha*p（逐元素）\n\nvoid cg_solve(    cuComplex *x,      // 解（图像）    cuComplex *b,      // 右端项（k空间数据）    int max_iter,    float tol) &#123;        // 分配中间变量    cuComplex *r, *p, *Ap;        // r = b - A*x    apply_forward_model(x, Ap);    vector_subtract(b, Ap, r, n);    vector_copy(r, p, n);        float rr = vector_dot(r, r, n);        for (int k = 0; k &lt; max_iter &amp;&amp; rr &gt; tol; k++) &#123;        // Ap = A * p        apply_forward_model(p, Ap);                // alpha = rr / (p·Ap)        float pAp = vector_dot(p, Ap, n);        float alpha = rr / pAp;                // x = x + alpha * p        vector_axpy(alpha, p, x, n);                // r = r - alpha * Ap        vector_axpy(-alpha, Ap, r, n);                // beta = rr_new / rr_old        float rr_new = vector_dot(r, r, n);        float beta = rr_new / rr;                // p = r + beta * p        vector_xpay(r, beta, p, n);                rr = rr_new;    &#125;&#125;\nNUFFT 作为前向模型\n在 MRI 重建中，AAA 不是显式存储的矩阵，而是通过 NUFFT 计算：\nvoid apply_forward_model(cuComplex *image, cuComplex *kspace) &#123;    // 1. 图像空间 → k空间（Type-2 NUFFT）    nufft_type2(image, kspace, trajectory, num_samples, grid_size);&#125;void apply_adjoint_model(cuComplex *kspace, cuComplex *image) &#123;    // 2. k空间 → 图像空间（Type-1 NUFFT，共轭转置）    nufft_type1(kspace, image, trajectory, num_samples, grid_size);&#125;\n共轭梯度中的 AHAA^H AAHA 操作变成：NUFFT^H · NUFFT。\n正则化\n为什么需要正则化\n欠采样导致问题欠定：方程数少于未知数。\n需要额外约束来选择&quot;好&quot;的解。\n常见正则化项\nTikhonov 正则化（L2）：\nR(m)=∥m∥22R(m) = \\|m\\|_2^2\nR(m)=∥m∥22​\n促进解的平滑，抑制噪声。\n全变分（TV）：\nR(m)=∑i(∇xmi)2+(∇ymi)2R(m) = \\sum_i \\sqrt{(\\nabla_x m_i)^2 + (\\nabla_y m_i)^2}\nR(m)=i∑​(∇x​mi​)2+(∇y​mi​)2​\n保留边缘的同时抑制噪声。\n小波稀疏：\nR(m)=∥Ψm∥1R(m) = \\|\\Psi m\\|_1\nR(m)=∥Ψm∥1​\n利用图像在小波域的稀疏性。\nGPU 实现 TV 正则化\n__global__ void gradient_kernel(float *image, float *grad_x, float *grad_y,                                  int H, int W) &#123;    int x = blockIdx.x * blockDim.x + threadIdx.x;    int y = blockIdx.y * blockDim.y + threadIdx.y;        if (x &lt; W &amp;&amp; y &lt; H) &#123;        int idx = y * W + x;                // 前向差分        grad_x[idx] = (x &lt; W - 1) ? image[idx + 1] - image[idx] : 0;        grad_y[idx] = (y &lt; H - 1) ? image[idx + W] - image[idx] : 0;    &#125;&#125;__global__ void tv_proximal_kernel(float *grad_x, float *grad_y,                                     float lambda, int H, int W) &#123;    int x = blockIdx.x * blockDim.x + threadIdx.x;    int y = blockIdx.y * blockDim.y + threadIdx.y;        if (x &lt; W &amp;&amp; y &lt; H) &#123;        int idx = y * W + x;                float gx = grad_x[idx];        float gy = grad_y[idx];        float norm = sqrtf(gx * gx + gy * gy) + 1e-8f;                // 软阈值        float shrink = fmaxf(1.0f - lambda / norm, 0.0f);        grad_x[idx] = gx * shrink;        grad_y[idx] = gy * shrink;    &#125;&#125;\n多线圈成像\n并行成像\n现代 MRI 使用多接收线圈，每个线圈有不同的灵敏度分布：\nsc(k)=∫Sc(x)⋅m(x)⋅e−i2πk⋅xdxs_c(k) = \\int S_c(x) \\cdot m(x) \\cdot e^{-i2\\pi k \\cdot x} dx\nsc​(k)=∫Sc​(x)⋅m(x)⋅e−i2πk⋅xdx\n其中 ScS_cSc​ 是第 ccc 个线圈的灵敏度。\nSENSE 重建\nSENSE（Sensitivity Encoding）：利用线圈灵敏度差异解混叠。\nm^=arg⁡min⁡m∑c∥AScm−sc∥22\\hat{m} = \\arg\\min_m \\sum_c \\|A S_c m - s_c\\|_2^2\nm^=argmmin​c∑​∥ASc​m−sc​∥22​\nGPU 实现\n多线圈增加了计算量，但也增加了并行度：\nvoid sense_cg_iteration(    cuComplex *image,           // [H, W]    cuComplex **coil_data,      // [num_coils][num_samples]    cuComplex **sensitivity,    // [num_coils][H, W]    int num_coils) &#123;        // 并行处理每个线圈    for (int c = 0; c &lt; num_coils; c++) &#123;        // 应用灵敏度        elementwise_multiply(image, sensitivity[c], coil_image, H * W);                // NUFFT        nufft_forward(coil_image, coil_kspace, trajectory);                // 累加        vector_add(residual, coil_residual, residual, num_samples);    &#125;&#125;\n线圈间完全独立，适合 GPU 并行。\n压缩感知 MRI\n基本原理\n压缩感知（Compressed Sensing）：如果信号在某个域是稀疏的，可以用远少于奈奎斯特采样数的测量重建。\nMRI 中的稀疏性：\n\n图像在小波域稀疏\n图像梯度稀疏（分段平滑）\n\nCS-MRI 优化问题\nm^=arg⁡min⁡m12∥Am−s∥22+λ1∥Ψm∥1+λ2TV(m)\\hat{m} = \\arg\\min_m \\frac{1}{2}\\|Am - s\\|_2^2 + \\lambda_1 \\|\\Psi m\\|_1 + \\lambda_2 TV(m)\nm^=argmmin​21​∥Am−s∥22​+λ1​∥Ψm∥1​+λ2​TV(m)\nADMM 求解\n**交替方向乘子法（ADMM）**将问题分解为子问题：\n1. 数据保真度子问题（CG 求解）2. 小波稀疏子问题（软阈值）3. TV 子问题（TV 去噪）4. 更新拉格朗日乘子\n每个子问题都可以高效并行。\n性能优化\n内存管理\nMRI 数据量大（3D、多线圈、多时相）：\n4 线圈 × 256³ 复数 = 4 × 256³ × 8 = 512 MB\n策略：\n\n流水线处理时相\n压缩存储低秩数据\n使用统一内存自动管理\n\n计算优化\n\n\n\n操作\n优化策略\n\n\n\n\nFFT\n使用 cuFFT，批量处理\n\n\nNUFFT\n纹理缓存加速插值\n\n\n规约\nWarp Shuffle 高效求和\n\n\nTV\n共享内存差分模板\n\n\n\n多 GPU\nMRI 重建天然适合多 GPU：\n\n线圈间并行\n切片间并行\n时相间并行\n\n#pragma omp parallel forfor (int c = 0; c &lt; num_coils; c++) &#123;    int device = c % num_gpus;    cudaSetDevice(device);    process_coil(c);&#125;\n实际应用\n加速倍数\n\n\n\n技术\n加速倍数\n\n\n\n\n并行成像\n2-4×\n\n\n压缩感知\n4-8×\n\n\n两者结合\n8-16×\n\n\n\n临床意义：扫描时间从 10 分钟缩短到 1 分钟，减少患者不适，提高通量。\nGPU 加速效果\n\n\n\n平台\n256³ 重建时间\n\n\n\n\n单核 CPU\n~300 秒\n\n\n多核 CPU (8)\n~40 秒\n\n\nGPU (V100)\n~2 秒\n\n\n\n加速比：150× 以上。\n小结\n第十七章展示了 GPU 在医学影像领域的强大能力：\nMRI 重建本质：从 k 空间数据恢复图像，涉及傅里叶变换和优化问题。\nNUFFT：处理非笛卡尔采样的核心算法。GPU 的网格化和 FFT 实现比 CPU 快两个数量级。\n迭代重建：共轭梯度 + 正则化解决欠采样问题。每次迭代包含 NUFFT、规约、逐元素操作——都是 GPU 擅长的。\n多线圈 + 压缩感知：进一步加速采集，但计算量增加。GPU 的并行能力正好应对。\n综合应用：本章综合了前面学的 FFT、矩阵运算、规约、迭代求解等技术，展示了实际问题中如何组合使用这些工具。\nMRI 重建只是医学影像的冰山一角。CT 重建、PET 重建、超声成像都有类似的计算密集型任务，GPU 正在改变整个医学影像领域。\n🚀 下一步\n\n实现一个简单的 NUFFT，从 Type-1 和 Type-2 开始，理解网格化和插值的过程\n学习共轭梯度法的 GPU 实现，掌握迭代求解器的优化技巧\n探索不同的正则化方法：TV、小波稀疏、字典学习\n研究压缩感知 MRI，了解稀疏重建的理论基础\n了解其他医学影像重建方法：CT 重建（FBP、迭代重建）、PET 重建\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 17\n第十七章：迭代式磁共振成像重建\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nLustig, M., Donoho, D., &amp; Pauly, J. M. (2007). Sparse MRI: The Application of Compressed Sensing for Rapid MR Imaging. MRM.\nFessler, J. A., &amp; Sutton, B. P. (2003). Nonuniform Fast Fourier Transforms Using Min-Max Interpolation. IEEE TSP.\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","MRI","医学影像","迭代重建"]},{"title":"PMPP-第十三章：排序","url":"/posts/d9ee9484/","content":"前言\n前两章学习了归约和归并，本章学习排序（Sorting）——把无序数据变成有序数据。排序是最基础的算法之一，在几乎所有计算领域都有应用。GPU 排序的挑战在于：传统排序算法（如快速排序）的递归结构和数据依赖不适合 GPU 的 SIMT 模型。第十三章介绍适合 GPU 的排序算法，重点是基数排序（Radix Sort）——通过前缀和实现高效并行排序。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n排序算法概览\n基于比较的排序\n\n\n\n算法\n平均复杂度\n最坏复杂度\n空间\n稳定性\n\n\n\n\n冒泡排序\nO(n²)\nO(n²)\nO(1)\n稳定\n\n\n插入排序\nO(n²)\nO(n²)\nO(1)\n稳定\n\n\n快速排序\nO(n log n)\nO(n²)\nO(log n)\n不稳定\n\n\n归并排序\nO(n log n)\nO(n log n)\nO(n)\n稳定\n\n\n堆排序\nO(n log n)\nO(n log n)\nO(1)\n不稳定\n\n\n\n理论下界：基于比较的排序最优是 O(n log n)。\n非比较排序\n\n\n\n算法\n复杂度\n适用类型\n\n\n\n\n计数排序\nO(n + k)\n小范围整数\n\n\n基数排序\nO(d(n + k))\n固定位数整数\n\n\n桶排序\nO(n + k)\n均匀分布\n\n\n\n突破下界：非比较排序可以达到 O(n)，但有类型限制。\nGPU 排序的选择\n快速排序不适合 GPU：\n\n递归深度不确定\n分区不平衡导致负载不均\n数据依赖导致分支发散\n\nGPU 友好的算法：\n\n基数排序：规则的数据访问模式，利用前缀和\n归并排序：确定的步骤数，可并行归并\n双调排序：完全数据无关的比较网络\n\n基数排序\n核心思想\n按位排序，从最低位到最高位：\n原始:    [329, 457, 657, 839, 436, 720, 355]按个位排序（第0位）:         [720, 355, 436, 457, 657, 329, 839]按十位排序（第1位）:         [720, 329, 436, 839, 355, 457, 657]按百位排序（第2位）:         [329, 355, 436, 457, 657, 720, 839]完成！\n关键：每一轮排序必须是稳定的，保持相同键值元素的相对顺序。\n位排序与计数排序\n每一轮按某一位排序，使用计数排序：\n1. 统计每个值的出现次数2. 计算前缀和得到每个值的起始位置3. 按原顺序分配到输出位置\n对于二进制位（0 或 1）：\n输入:    [1, 0, 1, 1, 0, 0, 1, 0]计数:    count[0]=4, count[1]=4前缀和:  pos[0]=0, pos[1]=4分配:    输出位置 = pos[bit]++结果:    [0, 0, 0, 0, 1, 1, 1, 1]\n多位一起处理\n一次处理多位（如 4 位）可以减少轮数：\n32 位整数:  1 位/轮: 32 轮  4 位/轮: 8 轮  8 位/轮: 4 轮\n代价是每轮需要更大的计数数组（2^b 个桶）。\n并行基数排序\n单 Block 版本\n#define RADIX_BITS 4#define RADIX (1 &lt;&lt; RADIX_BITS)  // 16#define RADIX_MASK (RADIX - 1)__global__ void radix_sort_block(unsigned int *data, int n, int bit) &#123;    __shared__ unsigned int s_data[BLOCK_SIZE];    __shared__ int s_count[RADIX];    __shared__ int s_offset[RADIX];        int tid = threadIdx.x;        // 加载数据    s_data[tid] = (tid &lt; n) ? data[tid] : 0xFFFFFFFF;    __syncthreads();        // 统计每个桶的计数（这里简化，实际需要原子或规约）    if (tid &lt; RADIX) s_count[tid] = 0;    __syncthreads();        int digit = (s_data[tid] &gt;&gt; bit) &amp; RADIX_MASK;    atomicAdd(&amp;s_count[digit], 1);    __syncthreads();        // 前缀和得到偏移    // ... exclusive scan on s_count → s_offset ...        // 分配到输出位置    int pos = atomicAdd(&amp;s_offset[digit], 1);  // 动态分配        __shared__ unsigned int s_temp[BLOCK_SIZE];    s_temp[pos] = s_data[tid];    __syncthreads();        // 写回    s_data[tid] = s_temp[tid];    __syncthreads();        if (tid &lt; n) data[tid] = s_data[tid];&#125;\n大规模基数排序\n对于超过单 Block 的数据，需要分阶段：\n阶段 1：局部直方图\n每个 Block 统计自己区域的桶计数。\n__global__ void compute_histograms(unsigned int *data, int *histograms,                                     int n, int bit) &#123;    __shared__ int local_hist[RADIX];        // 初始化    if (threadIdx.x &lt; RADIX) local_hist[threadIdx.x] = 0;    __syncthreads();        // 统计    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        int digit = (data[i] &gt;&gt; bit) &amp; RADIX_MASK;        atomicAdd(&amp;local_hist[digit], 1);    &#125;    __syncthreads();        // 写入全局直方图    if (threadIdx.x &lt; RADIX) &#123;        histograms[blockIdx.x * RADIX + threadIdx.x] = local_hist[threadIdx.x];    &#125;&#125;\n阶段 2：前缀和\n对所有 Block 的直方图做全局前缀和，得到每个 Block 每个桶的全局起始位置。\nBlock 0 桶 k 的起始位置 = Σ(Block &lt; 0, 桶 &lt; k 的计数) + Σ(Block &lt; 0, 桶 k 的计数)\n这是一个二维前缀和问题。\n阶段 3：重排（Scatter）\n根据计算出的位置，把元素移动到正确位置。\n__global__ void scatter(unsigned int *in, unsigned int *out,                         int *prefix, int n, int bit) &#123;    __shared__ int local_prefix[RADIX];        // 加载本 Block 的前缀    if (threadIdx.x &lt; RADIX) &#123;        local_prefix[threadIdx.x] = prefix[blockIdx.x * RADIX + threadIdx.x];    &#125;    __syncthreads();        int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        int digit = (in[i] &gt;&gt; bit) &amp; RADIX_MASK;        int pos = atomicAdd(&amp;local_prefix[digit], 1);        out[pos] = in[i];    &#125;&#125;\n完整流程\nvoid radix_sort(unsigned int *data, int n) &#123;    unsigned int *d_data, *d_temp;    int *d_histograms, *d_prefix;        int num_blocks = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;        cudaMalloc(&amp;d_data, n * sizeof(unsigned int));    cudaMalloc(&amp;d_temp, n * sizeof(unsigned int));    cudaMalloc(&amp;d_histograms, num_blocks * RADIX * sizeof(int));    cudaMalloc(&amp;d_prefix, num_blocks * RADIX * sizeof(int));        cudaMemcpy(d_data, data, n * sizeof(unsigned int), cudaMemcpyHostToDevice);        for (int bit = 0; bit &lt; 32; bit += RADIX_BITS) &#123;        // 阶段 1：计算直方图        compute_histograms&lt;&lt;&lt;num_blocks, BLOCK_SIZE&gt;&gt;&gt;            (d_data, d_histograms, n, bit);                // 阶段 2：全局前缀和        exclusive_scan(d_histograms, d_prefix, num_blocks * RADIX);                // 阶段 3：重排        scatter&lt;&lt;&lt;num_blocks, BLOCK_SIZE&gt;&gt;&gt;            (d_data, d_temp, d_prefix, n, bit);                // 交换缓冲区        swap(d_data, d_temp);    &#125;        cudaMemcpy(data, d_data, n * sizeof(unsigned int), cudaMemcpyDeviceToHost);&#125;\n优化技术\n避免原子操作\n阶段 3 的 atomicAdd 是瓶颈。可以用本地排序 + 前缀和替代：\n1. 每个线程处理多个元素2. 本地计算每个桶的元素个数3. Block 内前缀和得到每个线程的起始偏移4. 无冲突地写入输出\n向量化加载\n每次加载 4 个元素：\nuint4 data4 = *reinterpret_cast&lt;uint4*&gt;(&amp;data[i]);// 处理 data4.x, data4.y, data4.z, data4.w\n减少内存事务数。\n分桶优化\n对于大范围数据，先按高位分成大桶，再分别排序小桶：\n第一遍：按高 8 位分成 256 个桶第二遍：对每个桶按剩余 24 位排序\n减少每轮需要处理的数据量。\n归并排序\nGPU 归并排序流程\n1. Block 内排序（用共享内存）2. 跨 Block 归并（用并行归并）\nBlock 内排序可以用：\n\n比特序列排序（Bitonic Sort）\n奇偶归并排序\n直接归并排序\n\nBlock 内排序\n__global__ void block_sort(int *data, int n) &#123;    __shared__ int s_data[BLOCK_SIZE];        int tid = threadIdx.x;    int gid = blockIdx.x * blockDim.x + tid;        // 加载    s_data[tid] = (gid &lt; n) ? data[gid] : INT_MAX;    __syncthreads();        // 双调排序（Bitonic Sort）    for (int k = 2; k &lt;= BLOCK_SIZE; k *= 2) &#123;        for (int j = k / 2; j &gt; 0; j /= 2) &#123;            int ixj = tid ^ j;            if (ixj &gt; tid) &#123;                bool ascending = ((tid &amp; k) == 0);                if ((s_data[tid] &gt; s_data[ixj]) == ascending) &#123;                    // 交换                    int temp = s_data[tid];                    s_data[tid] = s_data[ixj];                    s_data[ixj] = temp;                &#125;            &#125;            __syncthreads();        &#125;    &#125;        // 写回    if (gid &lt; n) data[gid] = s_data[tid];&#125;\n跨 Block 归并\n使用第十二章的并行归并技术：\nvoid merge_sort_gpu(int *data, int n) &#123;    // 阶段 1：Block 内排序    int num_blocks = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;    block_sort&lt;&lt;&lt;num_blocks, BLOCK_SIZE&gt;&gt;&gt;(data, n);        // 阶段 2：逐层归并    for (int width = BLOCK_SIZE; width &lt; n; width *= 2) &#123;        int num_merges = (n + 2 * width - 1) / (2 * width);                parallel_merge&lt;&lt;&lt;num_merges, BLOCK_SIZE&gt;&gt;&gt;(            data, n, width);    &#125;&#125;\n复杂度分析\n\n\n\n阶段\n工作量\n并行度\n\n\n\n\nBlock 排序\nO(n log B)\nn/B 个 Block\n\n\n归并 k 层\nO(n) × log(n/B)\n递减\n\n\n总计\nO(n log n)\n\n\n\n\n样本排序（Sample Sort）\n思想\n\n采样：从数据中随机选取样本\n排序样本：得到分割点（splitters）\n分区：根据分割点把数据分到不同桶\n桶排序：每个桶独立排序\n合并：按顺序拼接所有桶\n\n优势\n\n负载均衡更好（采样保证桶大小接近）\n减少同步开销（桶间独立）\n\nGPU 实现要点\nvoid sample_sort(int *data, int n) &#123;    // 1. 采样    int sample_size = min(n, 1024);    sample_and_sort(data, n, samples, sample_size);        // 2. 选择分割点    int num_buckets = 256;    select_splitters(samples, sample_size, splitters, num_buckets);        // 3. 分区    partition_to_buckets(data, n, splitters, bucket_ids, bucket_counts);        // 4. 前缀和得到桶偏移    exclusive_scan(bucket_counts, bucket_offsets, num_buckets);        // 5. 重排到桶    scatter_to_buckets(data, bucket_ids, bucket_offsets, temp, n);        // 6. 桶内排序    for (int b = 0; b &lt; num_buckets; b++) &#123;        int start = bucket_offsets[b];        int end = bucket_offsets[b + 1];        sort_bucket&lt;&lt;&lt;...&gt;&gt;&gt;(temp + start, end - start);    &#125;        // 7. 拷贝回    cudaMemcpy(data, temp, n * sizeof(int), cudaMemcpyDeviceToDevice);&#125;\n排序稳定性\n为什么重要\n稳定排序：相同键值的元素保持原有的相对顺序。\n原始:    [(3,&#x27;a&#x27;), (1,&#x27;b&#x27;), (3,&#x27;c&#x27;), (2,&#x27;d&#x27;)]按数字稳定排序:         [(1,&#x27;b&#x27;), (2,&#x27;d&#x27;), (3,&#x27;a&#x27;), (3,&#x27;c&#x27;)]                          ↑ &#x27;a&#x27; 仍在 &#x27;c&#x27; 前面\n应用：\n\n多关键字排序（先按次关键字，再按主关键字）\n数据库操作（保持插入顺序）\n基数排序的正确性依赖稳定性\n\nGPU 排序的稳定性\n\n\n\n算法\n稳定性\n\n\n\n\n基数排序\n稳定\n\n\n归并排序\n稳定\n\n\n双调排序\n不稳定\n\n\n快速排序\n不稳定\n\n\n\n基数排序天然稳定，是 GPU 排序的首选。\nCUB/Thrust 库\n使用 Thrust\n#include &lt;thrust/sort.h&gt;#include &lt;thrust/device_vector.h&gt;void sortWithThrust(int *d_data, int n) &#123;    thrust::device_ptr&lt;int&gt; d_ptr(d_data);    thrust::sort(d_ptr, d_ptr + n);&#125;// 稳定排序thrust::stable_sort(d_ptr, d_ptr + n);// 按键排序thrust::sort_by_key(d_keys, d_keys + n, d_values);\n使用 CUB\n#include &lt;cub/cub.cuh&gt;void sortWithCub(unsigned int *d_data, int n) &#123;    void *d_temp = nullptr;    size_t temp_bytes = 0;        // 确定临时存储大小    cub::DeviceRadixSort::SortKeys(d_temp, temp_bytes,                                     d_data, d_data, n);        cudaMalloc(&amp;d_temp, temp_bytes);        // 执行排序    cub::DeviceRadixSort::SortKeys(d_temp, temp_bytes,                                    d_data, d_data, n);        cudaFree(d_temp);&#125;// 键值对排序cub::DeviceRadixSort::SortPairs(d_temp, temp_bytes,                                 d_keys, d_keys,                                 d_values, d_values, n);\n性能对比\n以 1 亿个32位整数排序为例：\n\n\n\n实现\n时间\n吞吐量\n\n\n\n\nstd::sort (CPU)\n~8 秒\n50 M元素/s\n\n\nThrust sort\n~30 ms\n3.3 G元素/s\n\n\nCUB RadixSort\n~15 ms\n6.6 G元素/s\n\n\n\n测试环境：\n\nCPU：Intel i9-12900K（16核）\nGPU：NVIDIA RTX 3090（10496 CUDA 核心，24GB 显存）\n数据：随机生成的32位无符号整数\n\nGPU 排序比单核 CPU 快 500 倍以上，比多核 CPU 快 200 倍以上。\n性能优化总结\n优化层次\n┌─────────────────────────────────────────────────┐│ Level 4: 算法选择                                ││   - 基数排序（整数最快）                         ││   - 归并排序（通用稳定）                         ││   - 样本排序（负载均衡）                         │├─────────────────────────────────────────────────┤│ Level 3: 数据局部性                              ││   - Block 内共享内存排序                         ││   - 向量化加载/存储                              │├─────────────────────────────────────────────────┤│ Level 2: 减少同步                                ││   - Warp 内排序无需同步                          ││   - 减少 Kernel 启动次数                         │├─────────────────────────────────────────────────┤│ Level 1: 利用前缀和                              ││   - 高效的直方图和分配                           ││   - 避免原子操作争用                             │└─────────────────────────────────────────────────┘\n选择指南\n\n\n\n数据类型\n推荐算法\n\n\n\n\n32 位整数\n基数排序\n\n\n64 位整数\n基数排序\n\n\n浮点数\n基数排序\n\n\n结构体/自定义\n归并排序\n\n\n需要稳定性\n基数/归并\n\n\n\n浮点数需要特殊处理符号位和指数。\n小结\n第十三章系统讲解 GPU 排序：\n基数排序：GPU 上最快的整数排序。按位处理，利用前缀和确定输出位置。多轮（32 位需要 8 轮 4 位）但每轮高度并行。\n三阶段流程：直方图统计 → 前缀和计算 → 元素重排。每个阶段都是高效的并行操作。\n归并排序：通用且稳定。Block 内用双调排序，跨 Block 用并行归并。适合任意可比较类型。\n样本排序：通过采样实现负载均衡。适合数据分布不均匀的情况。\n稳定性：基数排序天然稳定，多关键字排序和数据库操作必需。\n库优先：CUB 的 RadixSort 高度优化，生产环境直接使用。理解原理有助于特殊需求的定制。\n排序是并行计算的试金石，把前面学的归约、前缀和、归并等技术综合运用。掌握 GPU 排序，就掌握了这些基础原语的实战应用。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 13\n第十三章：排序\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","排序","基数排序","归并排序"]},{"title":"PMPP-第十九章：并行编程与计算思维","url":"/posts/46b3d994/","content":"前言\n经过前十八章的学习，我们掌握了 CUDA 编程的各种技术细节。第十九章是全书的总结与升华，从&quot;术&quot;上升到&quot;道&quot;——计算思维（Computational Thinking）。本章不再讲解具体的 API 或优化技巧，而是讨论如何思考并行问题、如何设计并行算法、如何权衡各种因素。这些思维方式将帮助读者应对未来的各种并行计算挑战。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n什么是计算思维\n定义\n计算思维：用计算机科学的基本概念来解决问题、设计系统、理解人类行为。\n——Jeannette Wing, 2006\n在并行计算语境下，计算思维包括：\n\n识别问题的并行性\n分解任务与数据\n设计高效的通信模式\n权衡各种资源约束\n\n为什么重要\n硬件在变，但思维方式持久。\n\nCUDA 可能被其他技术取代\n但并行思维的核心原则不变\n掌握思维方式 &gt; 记住 API\n\n问题分解\n任务并行 vs 数据并行\n任务并行（Task Parallelism）：\n\n不同的处理器执行不同的任务\n适合异构任务\n例：流水线处理\n\n数据并行（Data Parallelism）：\n\n相同的操作应用到不同的数据\n适合同构任务\n例：向量加法、矩阵乘法\n\nGPU 偏好数据并行：\n\nSIMT 模型天然支持\n数千线程执行相同代码\n分支发散会降低效率\n\n分解策略\n输出驱动：每个线程负责计算一个输出元素\n\n适合输出位置确定的问题\n例：矩阵乘法、图像滤波\n\n输入驱动：每个线程处理一个输入元素\n\n适合输出需要聚合的问题\n例：直方图、归约\n\n混合：根据问题特性灵活选择\n\n例：稀疏矩阵——每行一个线程或每 Warp 一行\n\n算法设计模式\n常见并行模式\n经过前面章节的学习，你已经见过这些经典模式：\n\n\n\n模式\n描述\n示例\n\n\n\n\nMap\n一对一变换\nReLU、标量乘法\n\n\nReduce\n多对一聚合\n求和、最大值\n\n\nScan\n前缀操作\n流压缩、基数排序\n\n\nStencil\n邻域模式\n卷积、PDE 求解\n\n\nGather\n间接读取\n查表、稀疏访问\n\n\nScatter\n间接写入\n直方图、排序分桶\n\n\n\n模式组合\n复杂算法通常是基本模式的组合：\n基数排序 = Histogram + Scan + Scatter\n稀疏矩阵-向量乘 = Gather + Reduce\nBFS = Gather + Scatter + Reduce\n识别这些模式有助于快速设计并行算法。\n性能优化思维\n瓶颈分析\n任何程序都有瓶颈，优化要找对方向：\n计算瓶颈：\n\n算术操作是限制因素\n优化：减少操作数、使用快速数学函数\n\n内存瓶颈：\n\n数据传输是限制因素\n优化：提高缓存利用、减少访问次数\n\n延迟瓶颈：\n\n等待时间是限制因素\n优化：增加并行度隐藏延迟\n\nRoofline 模型\n性能 = min(峰值算力, 带宽 × 算术强度)\n算术强度 = FLOP / Byte\n\n\n\n算术强度\n瓶颈类型\n优化方向\n\n\n\n\n&lt; 10\n内存受限\n提高数据复用\n\n\n&gt; 10\n计算受限\n优化计算效率\n\n\n\n优化层次\n┌─────────────────────────────────────────┐│ 第四层：算法层                           ││   选择更高效的算法                       ││   减少总操作数                           │├─────────────────────────────────────────┤│ 第三层：并行策略层                       ││   任务分解方式                           ││   负载均衡                               │├─────────────────────────────────────────┤│ 第二层：内存层                           ││   全局/共享/寄存器的使用                 ││   访问模式优化                           │├─────────────────────────────────────────┤│ 第一层：指令层                           ││   循环展开                               ││   指令级并行                             │└─────────────────────────────────────────┘\n从上往下优化：算法级改进的收益最大。\n权衡与决策\n常见权衡\n1. 并行度 vs 冗余计算\n增加并行度可能需要冗余计算：\n\nTiling 需要 Halo 区域重叠\n归约需要额外的合并操作\n\n2. 内存使用 vs 计算效率\n\n预计算查找表：省计算，费内存\n实时计算：省内存，费计算\n\n3. 通用性 vs 专用优化\n\n通用代码易维护\n专用优化性能好\n模板/代码生成可以兼顾\n\n决策框架\n1. 理解问题   - 输入/输出特性   - 计算密度   - 数据依赖2. 选择算法   - 理论复杂度   - 并行友好度   - 实现复杂度3. 设计并行策略   - 分解方式   - 同步需求   - 通信模式4. 实现与优化   - 先正确，后优化   - Profile 驱动   - 迭代改进\n可扩展性思维\n强扩展与弱扩展\n强扩展（Strong Scaling）：\n\n问题规模固定\n增加处理器，减少时间\n受 Amdahl 定律限制\n\n弱扩展（Weak Scaling）：\n\n每处理器负载固定\n增加处理器，处理更大问题\n受 Gustafson 定律指导\n\nAmdahl 定律\n加速比=1(1−P)+PN加速比 = \\frac{1}{(1-P) + \\frac{P}{N}}\n加速比=(1−P)+NP​1​\n其中 P 是可并行部分比例，N 是处理器数。\n启示：串行部分决定加速上限。\n例：95% 可并行，最大加速比 = 20×（无论多少 GPU）\nGustafson 定律\n加速比=N−(1−P)(N−1)加速比 = N - (1-P)(N-1)\n加速比=N−(1−P)(N−1)\n启示：增大问题规模可以提高并行效率。\n例：95% 可并行，100 GPU，加速比 = 95×\n调试与验证\n并行程序调试挑战\n\n不确定性：竞态条件导致结果不可重复\n规模：数千线程难以逐一追踪\n隐蔽性：边界情况难以触发\n\n策略\n1. 简化问题\n先在小规模数据上测试1 个 Block → 多 Block1 个 Warp → 多 Warp\n2. 串行参考\n// 总是保留串行版本用于验证float result_cpu = compute_cpu(data, n);float result_gpu = compute_gpu(data, n);assert(abs(result_cpu - result_gpu) &lt; epsilon);\n3. 使用工具\n\n\n\n工具\n用途\n\n\n\n\ncuda-memcheck\n内存错误检测\n\n\nNsight Compute\n性能分析\n\n\nNsight Systems\n系统级分析\n\n\nprintf\n简单调试（慎用）\n\n\n\n4. 渐进式开发\n1. 实现朴素版本，验证正确性2. 添加一个优化，验证正确性3. 重复直到满足性能需求\n跨平台思维\n硬件多样性\n不同 GPU 架构有不同特性：\n\n\n\n特性\nKepler\nPascal\nVolta\nAmpere\n\n\n\n\nSM 内存(KB)\n64\n64\n96\n164\n\n\nL2 缓存(MB)\n1.5\n4\n6\n40\n\n\nTensor Core\n无\n无\n有\n有\n\n\n\n策略：\n\n使用运行时查询能力\n参数化关键常量\n针对目标硬件调优\n\n可移植性\nCUDA 之外：\n\nOpenCL：跨厂商\nSYCL：C++ 标准化\nHIP：AMD GPU\n\n抽象库：\n\nThrust：STL 风格\nCUB：低级原语\ncuBLAS/cuDNN：领域特定\n\n持续学习\n技术演进\nGPU 技术快速发展：\n过去：可编程着色器 → CUDA 诞生\n现在：Tensor Core、光线追踪\n未来：量子模拟？神经形态计算？\n保持学习：\n\n阅读最新论文\n关注 GTC 大会\n参与开源项目\n\n社区资源\n\nNVIDIA Developer Blog：技术文章\nCUDA Zone：官方资源\nGitHub：开源项目\nStack Overflow：问题解答\n课程：UIUC、Stanford 公开课\n\n总结：并行编程心法\n十条原则\n\n\n理解硬件：了解你的 GPU 架构，扬长避短\n\n\n数据为王：并行程序性能通常受限于数据移动\n\n\n最大化并行：暴露足够的并行性隐藏延迟\n\n\n最小化同步：同步是性能杀手\n\n\n合并访问：让内存访问连续\n\n\n复用数据：共享内存是你最好的朋友\n\n\n避免发散：让同一 Warp 的线程走相同路径\n\n\n权衡取舍：没有银弹，只有适合具体问题的解\n\n\nProfile 优先：数据驱动优化，不要猜测\n\n\n渐进迭代：先正确，后优化，持续改进\n\n\n从技术到思维\n初学者：学习 API 和语法         ↓进阶者：掌握优化技巧         ↓高手：形成并行思维         ↓专家：能设计新算法\n这本书带你走完了前两个阶段，后两个阶段需要通过实践和持续学习来达成。\n小结\n第十九章是全书的升华，总结了并行编程的核心思维：\n计算思维：用计算的视角看问题——分解、模式匹配、抽象、算法设计。\n问题分解：任务并行 vs 数据并行，输出驱动 vs 输入驱动。根据问题特性选择。\n设计模式：Map、Reduce、Scan、Stencil、Gather、Scatter——识别这些模式能快速构建解决方案。\n性能思维：瓶颈分析、Roofline 模型、分层优化。从算法层开始，逐层向下。\n权衡决策：没有完美方案，只有最适合当前约束的方案。理解各种权衡才能做出好决策。\n可扩展性：Amdahl vs Gustafson，强扩展 vs 弱扩展。理解极限有助于设定合理预期。\nCUDA 只是工具，思维方式才是核心竞争力。希望这本书不仅教会你 CUDA 编程，更培养了你的并行计算思维。\n\n参考资料：\n\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nWing, J. M. (2006). Computational Thinking. Communications of the ACM.\nWilliams, S., et al. (2009). Roofline: An Insightful Visual Performance Model. Communications of the ACM.\n\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","性能优化","计算思维","方法论"]},{"title":"PMPP-第十二章：归并","url":"/posts/31928809/","content":"前言\n第十一章学习了前缀和，本章学习归并（Merge）——把两个有序数组合并成一个有序数组。归并是排序算法的核心组件（归并排序），也是数据库操作的基础（JOIN 操作）。并行归并的挑战在于：输出位置取决于两个数组的数据内容，不像矩阵乘法那样可以根据线程索引直接确定位置。第十二章讲解如何使用**协同排名（Co-Rank）**技术解决这个&quot;动态数据识别&quot;问题。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n归并基础\n什么是归并\n归并：给定两个已排序的数组 A 和 B，生成一个包含所有元素的有序数组 C。\nA = [1, 3, 5, 7, 9]B = [2, 4, 6, 8, 10]C = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n串行归并\n经典的双指针算法：\nvoid merge_sequential(int *A, int m, int *B, int n, int *C) &#123;    int i = 0, j = 0, k = 0;        while (i &lt; m &amp;&amp; j &lt; n) &#123;        if (A[i] &lt;= B[j]) &#123;            C[k++] = A[i++];        &#125; else &#123;            C[k++] = B[j++];        &#125;    &#125;        // 处理剩余元素    while (i &lt; m) C[k++] = A[i++];    while (j &lt; n) C[k++] = B[j++];&#125;\n时间复杂度 O(m+n)，空间复杂度 O(1)（不计输出）。\n并行化的挑战\n问题：输出位置 k 对应的输入位置 (i, j) 取决于数据内容。\n要填充 C[5]，需要知道：- A 和 B 中有多少元素 ≤ C[5] 的值- 这取决于 A 和 B 的具体内容\n不像矩阵乘法那样可以根据线程 ID 直接计算输入位置。\n核心问题：如何让每个线程知道自己应该处理 A 和 B 的哪一段？\n协同排名（Co-Rank）\n核心洞察\n对于输出位置 k，假设它对应 A 中的前 i 个元素和 B 中的前 j 个元素，则：\ni + j = k\n这就是协同排名约束。\n问题转化：给定 k，找到满足约束且保持有序性的 (i, j)。\n二分搜索解法\n有序性条件：\nA[i-1] ≤ B[j]  且  B[j-1] ≤ A[i]\n即：A 中第 i 个元素应该排在 B 的第 j 个元素之前或相等，反之亦然。\n算法：\nint co_rank(int k, int *A, int m, int *B, int n) &#123;    // i 的范围    int i_low = max(0, k - n);    int i_high = min(k, m);        while (i_low &lt; i_high) &#123;        int i = (i_low + i_high) / 2;        int j = k - i;                if (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; A[i-1] &gt; B[j]) &#123;            // A[i-1] 太大，i 需要减小            i_high = i;        &#125; else if (j &gt; 0 &amp;&amp; i &lt; m &amp;&amp; B[j-1] &gt; A[i]) &#123;            // B[j-1] 太大，i 需要增大            i_low = i + 1;        &#125; else &#123;            // 找到了            return i;        &#125;    &#125;    return i_low;&#125;\n时间复杂度：O(log(min(k, m, n)))\n示例\nA = [1, 3, 5, 7, 9]  (m=5)B = [2, 4, 6, 8, 10] (n=5)k = 6（输出位置 6）i + j = 6尝试 i=3: j=3  A[2]=5 ≤ B[3]=8? ✓  B[2]=6 ≤ A[3]=7? ✓  找到！所以 C[0..5] 来自 A[0..2] 和 B[0..2]C[6..9] 来自 A[3..4] 和 B[3..4]\n基础并行归并\n每线程一个元素\n最简单的并行化：每个线程负责计算一个输出元素。\n__global__ void merge_basic(int *A, int m, int *B, int n, int *C) &#123;    int k = blockIdx.x * blockDim.x + threadIdx.x;        if (k &lt; m + n) &#123;        int i = co_rank(k, A, m, B, n);        int j = k - i;                int i_next = co_rank(k + 1, A, m, B, n);        int j_next = k + 1 - i_next;                // 确定这个位置的值        if (i_next &gt; i) &#123;            C[k] = A[i];        &#125; else &#123;            C[k] = B[j];        &#125;    &#125;&#125;\n问题\n效率低：每个线程都做一次二分搜索（O(log n)），总工作量 O(n log n)。\n串行只需 O(n)，并行反而做了更多工作！\n分块并行归并\n思路\n不要每个元素都二分搜索，而是：\n\n把输出分成若干块（Tile）\n每个 Tile 做一次 Co-Rank 找到边界\nTile 内部用串行归并\n\n算法\n输出大小：m + nTile 大小：TTile 数量：(m + n + T - 1) / T对于 Tile k：  起始位置：k * T  结束位置：min((k+1) * T, m+n)    Co-Rank 找到 (i_start, j_start) 和 (i_end, j_end)    归并 A[i_start..i_end] 和 B[j_start..j_end]\nCUDA 实现\n#define TILE_SIZE 1024__global__ void merge_tiled(int *A, int m, int *B, int n, int *C) &#123;    // 每个 Block 处理一个 Tile    int k_start = blockIdx.x * TILE_SIZE;    int k_end = min(k_start + TILE_SIZE, m + n);        // Co-Rank 找边界    __shared__ int i_start, j_start, i_end, j_end;        if (threadIdx.x == 0) &#123;        i_start = co_rank(k_start, A, m, B, n);        j_start = k_start - i_start;        i_end = co_rank(k_end, A, m, B, n);        j_end = k_end - i_end;    &#125;    __syncthreads();        // 每个线程处理 Tile 中的一部分    int tile_size = k_end - k_start;    int elements_per_thread = (tile_size + blockDim.x - 1) / blockDim.x;        int local_k = threadIdx.x * elements_per_thread;    int local_k_end = min(local_k + elements_per_thread, tile_size);        // 线程内 Co-Rank    int A_seg_size = i_end - i_start;    int B_seg_size = j_end - j_start;        int local_i = co_rank(local_k, A + i_start, A_seg_size,                                    B + j_start, B_seg_size);    int local_j = local_k - local_i;        int local_i_end = co_rank(local_k_end, A + i_start, A_seg_size,                                           B + j_start, B_seg_size);    int local_j_end = local_k_end - local_i_end;        // 串行归并    merge_sequential(A + i_start + local_i, local_i_end - local_i,                     B + j_start + local_j, local_j_end - local_j,                     C + k_start + local_k);&#125;\n工作量分析\n\n\n\n操作\n次数\n单次复杂度\n\n\n\n\nBlock Co-Rank\n(m+n)/T\nO(log(m+n))\n\n\n线程 Co-Rank\n(m+n)/T × blockDim\nO(log T)\n\n\n串行归并\n(m+n)/T × blockDim\nO(T/blockDim)\n\n\n\n总工作量 ≈ O(m+n)，接近串行！\n共享内存优化\n动机\n前面的实现每个线程都访问全局内存做串行归并。如果把 Tile 数据加载到共享内存，可以大幅减少全局内存访问。\n实现\n#define TILE_SIZE 1024__global__ void merge_shared(int *A, int m, int *B, int n, int *C) &#123;    __shared__ int A_s[TILE_SIZE];    __shared__ int B_s[TILE_SIZE];    __shared__ int C_s[TILE_SIZE];        int k_start = blockIdx.x * TILE_SIZE;    int k_end = min(k_start + TILE_SIZE, m + n);    int tile_size = k_end - k_start;        // Co-Rank 找边界    __shared__ int i_start, j_start, i_end, j_end;        if (threadIdx.x == 0) &#123;        i_start = co_rank(k_start, A, m, B, n);        j_start = k_start - i_start;        i_end = co_rank(k_end, A, m, B, n);        j_end = k_end - i_end;    &#125;    __syncthreads();        int A_size = i_end - i_start;    int B_size = j_end - j_start;        // 加载到共享内存    for (int i = threadIdx.x; i &lt; A_size; i += blockDim.x) &#123;        A_s[i] = A[i_start + i];    &#125;    for (int i = threadIdx.x; i &lt; B_size; i += blockDim.x) &#123;        B_s[i] = B[j_start + i];    &#125;    __syncthreads();        // 线程内 Co-Rank（使用共享内存）    int elements_per_thread = (tile_size + blockDim.x - 1) / blockDim.x;    int local_k = threadIdx.x * elements_per_thread;    int local_k_end = min(local_k + elements_per_thread, tile_size);        int local_i = co_rank(local_k, A_s, A_size, B_s, B_size);    int local_j = local_k - local_i;        int local_i_end = co_rank(local_k_end, A_s, A_size, B_s, B_size);    int local_j_end = local_k_end - local_i_end;        // 归并到共享内存    merge_sequential(A_s + local_i, local_i_end - local_i,                     B_s + local_j, local_j_end - local_j,                     C_s + local_k);    __syncthreads();        // 写回全局内存    for (int i = threadIdx.x; i &lt; tile_size; i += blockDim.x) &#123;        C[k_start + i] = C_s[i];    &#125;&#125;\n性能提升\n\n\n\n版本\n全局内存访问\n性能\n\n\n\n\n基础\nO(m+n) 次\n1×\n\n\n分块\nO(m+n) 次\n~5×\n\n\n共享内存\nO(m+n)/T 次\n~10×\n\n\n\n循环缓冲区优化\n问题\n共享内存有限，如果 A_size + B_size &gt; 共享内存容量怎么办？\n思路：流式处理\n用循环缓冲区逐块处理：\n\n加载 A 和 B 的一小块到共享内存\n归并能归并的部分\n加载下一块，继续归并\n重复直到完成\n\n关键点\n消费跟踪：记录 A 和 B 各消费了多少元素。\n缓冲区管理：循环使用缓冲区空间。\n__global__ void merge_circular(int *A, int m, int *B, int n, int *C) &#123;    __shared__ int buffer_A[BUFFER_SIZE];    __shared__ int buffer_B[BUFFER_SIZE];        // ... 初始化 ...        int a_consumed = 0, b_consumed = 0;    int a_loaded = 0, b_loaded = 0;    int c_produced = 0;        while (c_produced &lt; tile_size) &#123;        // 填充缓冲区        while (a_loaded - a_consumed &lt; BUFFER_SIZE &amp;&amp; a_loaded &lt; A_size) &#123;            buffer_A[a_loaded % BUFFER_SIZE] = A_s[a_loaded];            a_loaded++;        &#125;        while (b_loaded - b_consumed &lt; BUFFER_SIZE &amp;&amp; b_loaded &lt; B_size) &#123;            buffer_B[b_loaded % BUFFER_SIZE] = B_s[b_loaded];            b_loaded++;        &#125;                // 归并一批        // ...    &#125;&#125;\n这种技术在数据量远超共享内存时很有用。\n归并路径可视化\nCo-Rank 的几何解释\n把归并过程可视化为 2D 网格中的路径：\n  B: 0   1   2   3   4     +---+---+---+---+A:0  |   |   |   |   |     +---+---+---+---+  1  |   |   |   |   |     +---+---+───+───+  2  |   |   |\\  |   |     +---+---+─\\─+---+  3  |   |   |  \\|   |     +---+---+---+\\--+  4  |   |   |   | \\ |     +---+---+---+---+\n路径规则：\n\n从 (0,0) 到 (m,n)\n每步向右（取 A 元素）或向下（取 B 元素）\n选择较小的元素决定方向\n\nCo-Rank(k)：路径上第 k 步的位置。\n并行化视角\n把输出分成 T 段：  段 0: 路径 [0, T)  段 1: 路径 [T, 2T)  ...每段的起点由 Co-Rank 确定。\n归并排序\n分治结构\n归并排序 = 递归拆分 + 归并合并\n[3,1,7,4,5,2,6,8]       ↓ 拆分[3,1,7,4] [5,2,6,8]    ↓ 拆分[3,1] [7,4] [5,2] [6,8]  ↓ 拆分[3][1] [7][4] [5][2] [6][8]  ↓ 归并[1,3] [4,7] [2,5] [6,8]    ↓ 归并[1,3,4,7] [2,5,6,8]       ↓ 归并[1,2,3,4,5,6,7,8]\n并行归并排序\n每层归并可以并行：\nvoid parallel_merge_sort(int *data, int n) &#123;    // 从单元素开始，逐层归并    for (int width = 1; width &lt; n; width *= 2) &#123;        int num_merges = (n + 2 * width - 1) / (2 * width);                // 并行执行所有归并        merge_kernel&lt;&lt;&lt;num_merges, BLOCK_SIZE&gt;&gt;&gt;(            data, n, width        );    &#125;&#125;__global__ void merge_kernel(int *data, int n, int width) &#123;    int merge_id = blockIdx.x;    int left = merge_id * 2 * width;    int mid = min(left + width, n);    int right = min(left + 2 * width, n);        // 归并 [left, mid) 和 [mid, right)    merge_shared(data + left, mid - left,                  data + mid, right - mid,                  temp + left);&#125;\n复杂度\n\n\n\n指标\n串行归并排序\n并行归并排序\n\n\n\n\n层数\nlog₂N\nlog₂N\n\n\n每层工作\nO(N)\nO(N)\n\n\n总工作\nO(N log N)\nO(N log N)\n\n\n并行时间\nO(N log N)\nO(log²N)*\n\n\n\n*假设有足够多的处理器，每层归并并行完成。\n与其他算法的关系\n归并 vs 基数排序\n\n\n\n特性\n归并排序\n基数排序\n\n\n\n\n比较次数\nO(N log N)\nO(N × 位数)\n\n\n稳定性\n稳定\n稳定\n\n\n适用类型\n通用\n整数/定长键\n\n\nGPU 友好度\n中等\n高\n\n\n\n基数排序在 GPU 上通常更快，但归并排序适用范围更广。\n归并 vs 快速排序\n\n\n\n特性\n归并排序\n快速排序\n\n\n\n\n最坏复杂度\nO(N log N)\nO(N²)\n\n\n空间\nO(N)\nO(log N)\n\n\n并行化\n容易\n较难\n\n\n稳定性\n稳定\n不稳定\n\n\n\n归并排序的确定性和稳定性使其在并行计算中更受欢迎。\nCUB/Thrust 库\n使用 Thrust\n#include &lt;thrust/merge.h&gt;#include &lt;thrust/device_vector.h&gt;void mergeWithThrust(int *A, int m, int *B, int n, int *C) &#123;    thrust::device_ptr&lt;int&gt; d_A(A);    thrust::device_ptr&lt;int&gt; d_B(B);    thrust::device_ptr&lt;int&gt; d_C(C);        thrust::merge(d_A, d_A + m, d_B, d_B + n, d_C);&#125;\n使用 CUB\n#include &lt;cub/cub.cuh&gt;void mergeWithCub(int *d_A, int m, int *d_B, int n, int *d_C) &#123;    void *d_temp = nullptr;    size_t temp_bytes = 0;        cub::DeviceMerge::Merge(d_temp, temp_bytes,                             d_A, m, d_B, n, d_C);        cudaMalloc(&amp;d_temp, temp_bytes);        cub::DeviceMerge::Merge(d_temp, temp_bytes,                            d_A, m, d_B, n, d_C);        cudaFree(d_temp);&#125;\n小结\n第十二章深入讲解并行归并：\n核心挑战：输出位置取决于输入数据内容（动态数据识别），不能简单根据线程 ID 确定。\nCo-Rank 技术：给定输出位置 k，用二分搜索找到对应的输入位置 (i, j)，满足 i + j = k。这是并行归并的关键。\n分块归并：把输出分成 Tile，每个 Tile 做一次 Co-Rank 找边界，Tile 内串行归并。平衡了并行开销和工作效率。\n共享内存优化：把 Tile 数据加载到共享内存，减少全局内存访问。循环缓冲区处理大 Tile。\n归并路径：归并过程可视化为 2D 网格中的路径，Co-Rank 找的是路径上的点。\n归并排序：log N 层归并，每层可以并行。总工作量 O(N log N)，并行时间可达 O(log² N)。\n归并是排序、数据库操作的基础。掌握 Co-Rank 技术，就能处理各种&quot;输出位置依赖输入数据&quot;的问题。下一章学习排序——归并的直接应用。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 12\n第十二章：归并\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","归并","Merge","动态数据识别"]},{"title":"PMPP-第十五章：图遍历","url":"/posts/70b05668/","content":"前言\n第十四章我们学习了稀疏矩阵，那一章的重点是 SpMV（稀疏矩阵-向量乘法）。其实，图（Graph）和稀疏矩阵是一体两面的：图的邻接矩阵通常就是稀疏矩阵。第十五章我们将深入探讨图算法的核心——图遍历，特别是广度优先搜索（BFS）。BFS 是最短路径、连通分量、最大流等众多图算法的基础，也是 GPU 处理不规则数据结构的典型案例。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n图的表示\n从现实世界到图\n图由节点（Vertex）和边（Edge）组成。\n\n社交网络：节点是人，边是关注/好友关系。\n道路网：节点是路口，边是道路。\n引用网络：节点是论文，边是引用关系。\n\n这些图通常是稀疏的（每个节点平均只连接少数其他节点）且无标度的（少数节点有极多连接，俗称&quot;大V&quot;）。\n存储格式：CSR\n上一章介绍的 CSR (Compressed Sparse Row) 格式不仅适合 SpMV，也是存储图的标准格式。\n对于一个有 VVV 个节点、EEE 条边的图：\n\nrow_ptr (长度 V+1V+1V+1)：row_ptr[i] 指向节点 iii 的邻居列表在 col_idx 中的起始位置。\ncol_idx (长度 EEE)：存储所有边的目标节点。\n\n节点 0 的邻居：col_idx[row_ptr[0]] ... col_idx[row_ptr[1]-1]节点 i 的邻居数：row_ptr[i+1] - row_ptr[i]\n广度优先搜索 (BFS)\n问题定义\n给定起点 SSS，BFS 需要访问所有可达节点，并计算从 SSS 到每个节点的最短距离（层数）。\n串行 BFS\n经典实现使用队列（Queue）：\nvoid BFS_sequential(int S, int *row_ptr, int *col_idx, int *level, int num_nodes) &#123;    std::queue&lt;int&gt; q;    q.push(S);    level[S] = 0; // 初始化其他为 -1    while (!q.empty()) &#123;        int u = q.front(); q.pop();                // 遍历所有邻居 v        for (int i = row_ptr[u]; i &lt; row_ptr[u+1]; i++) &#123;            int v = col_idx[i];                        // 如果 v 未被访问            if (level[v] == -1) &#123;                level[v] = level[u] + 1;                q.push(v);            &#125;        &#125;    &#125;&#125;\n并行化的挑战\n\n不规则访问：每个节点的邻居数量差异巨大（负载不均衡）。\n动态工作集：每一层的节点数都在变化。\n并发冲突：多个节点可能同时尝试访问同一个邻居。\n\n并行 BFS：按层同步\nGPU 适合解决可以分层的任务。BFS 天然分层：\n第 0 层（起点） → 第 1 层邻居 → 第 2 层邻居 → …\n我们可以采用**按层同步（Level Synchronous）**的方法：\n\n维护一个**前沿（Frontier）**数组，标记当前层需要扩展的节点\n并行处理 Frontier 中的每个节点，找到下一层的邻居\n更新 Frontier，进入下一轮迭代\n\n方法一：布尔前沿数组\n用一个布尔数组 F 表示当前层节点，next_F 表示下一层。\n__global__ void BFS_kernel_boolean(int *row_ptr, int *col_idx, int *level,                                    bool *F, bool *next_F, int num_nodes,                                    int current_depth) &#123;    int tid = blockIdx.x * blockDim.x + threadIdx.x;        if (tid &lt; num_nodes &amp;&amp; F[tid]) &#123;        // 遍历邻居        int start = row_ptr[tid];        int end = row_ptr[tid + 1];                for (int i = start; i &lt; end; i++) &#123;            int neighbor = col_idx[i];                        // 使用原子比较交换确保只更新一次            if (atomicCAS(&amp;level[neighbor], -1, current_depth + 1) == -1) &#123;                next_F[neighbor] = true;            &#125;        &#125;    &#125;&#125;\nHost 端循环：\nbool *d_F, *d_next_F;cudaMalloc(&amp;d_F, num_nodes * sizeof(bool));cudaMalloc(&amp;d_next_F, num_nodes * sizeof(bool));// 初始化：只有源节点在前沿cudaMemset(d_F, 0, num_nodes * sizeof(bool));cudaMemset(d_next_F, 0, num_nodes * sizeof(bool));bool h_start = true;cudaMemcpy(&amp;d_F[source], &amp;h_start, sizeof(bool), cudaMemcpyHostToDevice);int depth = 0;bool frontier_not_empty = true;while (frontier_not_empty) &#123;    int grid_size = (num_nodes + 255) / 256;    BFS_kernel_boolean&lt;&lt;&lt;grid_size, 256&gt;&gt;&gt;(        d_row_ptr, d_col_idx, d_level, d_F, d_next_F, num_nodes, depth    );    cudaDeviceSynchronize();        // 检查是否还有节点在前沿    // （简化版，实际应该用 thrust::reduce 或自定义 kernel）    bool h_F[num_nodes];    cudaMemcpy(h_F, d_next_F, num_nodes * sizeof(bool), cudaMemcpyDeviceToHost);    frontier_not_empty = false;    for (int i = 0; i &lt; num_nodes; i++) &#123;        if (h_F[i]) &#123;            frontier_not_empty = true;            break;        &#125;    &#125;        // 交换前沿    std::swap(d_F, d_next_F);    cudaMemset(d_next_F, 0, num_nodes * sizeof(bool));    depth++;&#125;\n优点：\n\n实现简单直观\n每层的并行度很高\n\n缺点：\n\n每层都启动 num_nodes 个线程，工作效率低\n前沿稀疏时浪费严重\n需要频繁的内存拷贝检查终止条件\n\n优化一：稀疏前沿队列\n工作效率问题\n布尔数组方法有一个严重的工作效率问题：\n假设图有 100 万个节点，当前层只有 10 个节点在前沿布尔方法：启动 100 万个线程，其中 99.999% 的线程立即退出真正工作的线程：10 个浪费的调度开销：极大\n稀疏前沿（Sparse Frontier）：\n只存储当前层节点的 ID，用紧凑的队列表示。\n布尔前沿：[false, true, false, false, false, true, ...]  // 100万个元素稀疏队列：[1, 5, ...]  // 只有10个元素\n只需启动 frontier_size 个线程，而不是 num_nodes 个。\n方法二：队列版本（朴素）\n__global__ void BFS_kernel_queue(int *row_ptr, int *col_idx, int *level,                                  int *current_queue, int current_size,                                  int *next_queue, int *next_size,                                  int current_depth) &#123;    int tid = blockIdx.x * blockDim.x + threadIdx.x;        if (tid &lt; current_size) &#123;        int u = current_queue[tid];  // 从队列取节点                // 遍历邻居        int start = row_ptr[u];        int end = row_ptr[u + 1];                for (int i = start; i &lt; end; i++) &#123;            int v = col_idx[i];                        // 只有第一个访问的线程能成功更新            if (atomicCAS(&amp;level[v], -1, current_depth + 1) == -1) &#123;                // 原子地获取队列位置并插入                int pos = atomicAdd(next_size, 1);                next_queue[pos] = v;            &#125;        &#125;    &#125;&#125;\nHost 端循环：\nint *d_queue1, *d_queue2;int *d_queue_size1, *d_queue_size2;cudaMalloc(&amp;d_queue1, num_nodes * sizeof(int));cudaMalloc(&amp;d_queue2, num_nodes * sizeof(int));cudaMalloc(&amp;d_queue_size1, sizeof(int));cudaMalloc(&amp;d_queue_size2, sizeof(int));// 初始化int h_size = 1;cudaMemcpy(d_queue1, &amp;source, sizeof(int), cudaMemcpyHostToDevice);cudaMemcpy(d_queue_size1, &amp;h_size, sizeof(int), cudaMemcpyHostToDevice);int depth = 0;int *current_queue = d_queue1;int *next_queue = d_queue2;int *current_size = d_queue_size1;int *next_size = d_queue_size2;while (true) &#123;    // 获取当前前沿大小    cudaMemcpy(&amp;h_size, current_size, sizeof(int), cudaMemcpyDeviceToHost);    if (h_size == 0) break;  // 没有节点了，结束        // 重置下一层计数器    cudaMemset(next_size, 0, sizeof(int));        // 启动 kernel    int grid_size = (h_size + 255) / 256;    BFS_kernel_queue&lt;&lt;&lt;grid_size, 256&gt;&gt;&gt;(        d_row_ptr, d_col_idx, d_level,        current_queue, h_size, next_queue, next_size, depth    );    cudaDeviceSynchronize();        // 交换队列    std::swap(current_queue, next_queue);    std::swap(current_size, next_size);    depth++;&#125;\n优点：\n\n只启动必要的线程数\n工作效率大幅提升\n\n缺点：\n\n全局原子操作 atomicAdd(next_size, 1) 成为严重瓶颈\n所有线程争用同一个计数器\n高度数节点会导致大量原子操作\n\n优化二：私有化队列\n减少原子操作争用\n类似于第九章的直方图优化，我们可以使用**私有化（Privatization）**技术。\n核心思想：\n\n每个 Block 在共享内存维护局部队列\n线程先写入局部队列（只有 Block 内争用）\nBlock 结束时一次性申请全局空间\n批量拷贝局部队列到全局\n\n完整实现\n#define BLOCK_SIZE 256#define WARP_SIZE 32__global__ void BFS_kernel_privatized(    int *row_ptr, int *col_idx, int *level,    int *current_queue, int current_size,    int *next_queue, int *next_size,    int current_depth) &#123;        __shared__ int s_queue[BLOCK_SIZE * 2];  // 局部队列（预留2倍空间）    __shared__ int s_tail;                    // 局部队列计数器        // 初始化局部队列    if (threadIdx.x == 0) &#123;        s_tail = 0;    &#125;    __syncthreads();        int tid = blockIdx.x * blockDim.x + threadIdx.x;        if (tid &lt; current_size) &#123;        int u = current_queue[tid];                // 遍历邻居        int start = row_ptr[u];        int end = row_ptr[u + 1];                for (int i = start; i &lt; end; i++) &#123;            int v = col_idx[i];                        // 尝试更新距离            if (atomicCAS(&amp;level[v], -1, current_depth + 1) == -1) &#123;                // 成功更新，加入局部队列                int s_pos = atomicAdd(&amp;s_tail, 1);                if (s_pos &lt; BLOCK_SIZE * 2) &#123;                    s_queue[s_pos] = v;                &#125; else &#123;                    // 局部队列满了，直接写全局（降级）                    int g_pos = atomicAdd(next_size, 1);                    next_queue[g_pos] = v;                &#125;            &#125;        &#125;    &#125;    __syncthreads();        // Block 内线程协作：将局部队列拷贝到全局    int num_local = min(s_tail, BLOCK_SIZE * 2);        if (num_local &gt; 0) &#123;        __shared__ int g_offset;                // 一次性申请全局空间        if (threadIdx.x == 0) &#123;            g_offset = atomicAdd(next_size, num_local);        &#125;        __syncthreads();                // 并行拷贝        for (int i = threadIdx.x; i &lt; num_local; i += BLOCK_SIZE) &#123;            next_queue[g_offset + i] = s_queue[i];        &#125;    &#125;&#125;\n性能分析：\n\n\n\n操作\n布尔方法\n队列朴素\n队列私有化\n\n\n\n\n启动线程数\nnum_nodes\nfrontier 大小\nfrontier 大小\n\n\n全局原子操作\n0（但有竞争）\n每条边\n每 Block\n\n\n共享内存原子\n0\n0\n每条边\n\n\n工作效率\n极低\n中等\n高\n\n\n相对性能\n1×\n5×\n15×\n\n\n\n关键改进：\n\n全局原子操作从 O(边数) 降到 O(Block数)\n共享内存原子操作比全局快 20 倍\n批量拷贝提高内存带宽利用率\n\n优化三：方向优化 BFS\nTop-Down vs Bottom-Up\n这是 BFS 优化中最重要的策略之一，源自 Scott Beamer 等人的开创性工作。\nTop-Down（Push）模式\n传统的 BFS 是**推（Push）**模式：从前沿节点出发，推送更新到邻居。\n__global__ void BFS_top_down(int *row_ptr, int *col_idx, int *level,                              int *frontier, int frontier_size,                              int *next_frontier, int *next_size,                              int depth) &#123;    int tid = blockIdx.x * blockDim.x + threadIdx.x;        if (tid &lt; frontier_size) &#123;        int u = frontier[tid];                // Push：检查 u 的所有邻居        for (int i = row_ptr[u]; i &lt; row_ptr[u + 1]; i++) &#123;            int v = col_idx[i];            if (atomicCAS(&amp;level[v], -1, depth + 1) == -1) &#123;                int pos = atomicAdd(next_size, 1);                next_frontier[pos] = v;            &#125;        &#125;    &#125;&#125;\n工作量：\n\n遍历前沿节点的所有出边\n工作量 = frontier中节点的总度数\n\n适用场景：\n\n前沿很小（图的早期层）\n平均度数不高\n\nBottom-Up（Pull）模式\n反向思考：从未访问节点出发，拉取父节点信息。\n__global__ void BFS_bottom_up(int *row_ptr, int *col_idx, int *level,                               bool *frontier_map, int num_nodes,                               bool *next_frontier_map, int *found_count,                               int depth) &#123;    int v = blockIdx.x * blockDim.x + threadIdx.x;        if (v &lt; num_nodes &amp;&amp; level[v] == -1) &#123;  // 未访问节点        // Pull：检查 v 的邻居中是否有在前沿的        int start = row_ptr[v];        int end = row_ptr[v + 1];                for (int i = start; i &lt; end; i++) &#123;            int u = col_idx[i];                        // 如果邻居 u 在当前前沿            if (frontier_map[u]) &#123;                level[v] = depth + 1;                next_frontier_map[v] = true;                atomicAdd(found_count, 1);                break;  // 找到一个就够了，不需要继续            &#125;        &#125;    &#125;&#125;\n关键差异：\n\nTop-Down：遍历 frontier 节点的出边\nBottom-Up：遍历未访问节点的入边\nBottom-Up 找到一个父节点就可以停止\n\n工作量：\n\n检查所有未访问节点的入边\n最坏情况：所有未访问节点的总度数\n最好情况：每个节点只检查一条边就找到父节点\n\n适用场景：\n\n前沿很大（覆盖大部分节点）\n图密集度较高\n\n方向切换策略\nvoid BFS_direction_optimizing(Graph &amp;graph, int source, int *level) &#123;    // 初始化    cudaMemset(level, -1, num_nodes * sizeof(int));    // ...        int depth = 0;    bool use_top_down = true;        while (frontier_not_empty) &#123;        int frontier_size = get_frontier_size();        int unvisited_count = num_nodes - visited_count;        int frontier_edges = estimate_frontier_edges(frontier);                // 方向切换启发式        if (use_top_down) &#123;            // 切换到 Bottom-Up 的条件：            // 前沿边数 &gt; 未访问节点边数的一定比例            if (frontier_edges &gt; unvisited_count * ALPHA) &#123;                use_top_down = false;            &#125;        &#125; else &#123;            // 切回 Top-Down 的条件：            // 前沿节点数 &lt; 总节点数的一定比例            if (frontier_size &lt; num_nodes * BETA) &#123;                use_top_down = true;            &#125;        &#125;                if (use_top_down) &#123;            BFS_top_down&lt;&lt;&lt;...&gt;&gt;&gt;(...);        &#125; else &#123;            BFS_bottom_up&lt;&lt;&lt;...&gt;&gt;&gt;(...);        &#125;                depth++;    &#125;&#125;\n典型参数：\n\nALPHA = 14（前沿边数超过未访问边数的14倍时切换）\nBETA = 0.001（前沿小于总节点数的0.1%时切回）\n\n性能提升：\n\n\n\n图类型\nTop-Down\nBottom-Up\n混合策略\n\n\n\n\n社交网络\n1×\n0.8×\n3×\n\n\n路网\n1×\n0.5×\n1.2×\n\n\n随机图\n1×\n1.5×\n2×\n\n\n无标度网络\n1×\n0.6×\n4×\n\n\n\n混合策略在各种图上都有显著提升。\n优化四：负载均衡策略\n无标度网络的挑战\n真实世界的图（社交网络、互联网）通常是**无标度（Scale-Free）**的：\n度数分布：节点数 | 度数范围-------|----------90%    | 1-109%     | 10-1000.9%   | 100-10000.1%   | 1000+（高度数&quot;Hub&quot;节点）\n问题：一个线程处理一个节点导致严重的负载不均衡。\nWarp 0:线程 0: 处理节点度数 = 3     （3次迭代）线程 1: 处理节点度数 = 100000 （10万次迭代）线程 2-31: 处理节点度数 = 5   （5次迭代）→ 整个 Warp 等待线程 1 完成→ Warp 利用率：3%\n分层负载均衡\n根据节点度数选择不同的处理策略：\n__global__ void BFS_adaptive(int *row_ptr, int *col_idx, int *level,                              int *frontier, int frontier_size,                              int *next_frontier, int *next_size,                              int depth) &#123;    int tid = blockIdx.x * blockDim.x + threadIdx.x;        if (tid &lt; frontier_size) &#123;        int u = frontier[tid];        int degree = row_ptr[u + 1] - row_ptr[u];                if (degree &lt; 32) &#123;            // 小度数节点：单线程处理            process_node_single(u, row_ptr, col_idx, level,                                 next_frontier, next_size, depth);        &#125; else if (degree &lt; 512) &#123;            // 中等度数：Warp 协作处理            if (threadIdx.x % 32 == 0) &#123;                process_node_warp(u, row_ptr, col_idx, level,                                  next_frontier, next_size, depth);            &#125;        &#125; else &#123;            // 大度数：Block 协作处理            if (threadIdx.x == 0) &#123;                process_node_block(u, row_ptr, col_idx, level,                                   next_frontier, next_size, depth);            &#125;        &#125;    &#125;&#125;\nWarp 级协作\n让一个 Warp 的32个线程协作处理一个节点：\n__device__ void process_node_warp(int u, int *row_ptr, int *col_idx,                                    int *level, int *next_frontier,                                    int *next_size, int depth) &#123;    int lane = threadIdx.x % 32;    int start = row_ptr[u];    int end = row_ptr[u + 1];        __shared__ int warp_queue[32];    __shared__ int warp_tail;        if (lane == 0) warp_tail = 0;    __syncwarp();        // Warp 内线程协作遍历邻居    for (int i = start + lane; i &lt; end; i += 32) &#123;        int v = col_idx[i];                if (atomicCAS(&amp;level[v], -1, depth + 1) == -1) &#123;            int pos = atomicAdd(&amp;warp_tail, 1);            if (pos &lt; 32) &#123;                warp_queue[pos] = v;            &#125;        &#125;    &#125;    __syncwarp();        // Warp 的第一个线程提交到全局    if (lane == 0 &amp;&amp; warp_tail &gt; 0) &#123;        int offset = atomicAdd(next_size, warp_tail);        for (int i = 0; i &lt; warp_tail; i++) &#123;            next_frontier[offset + i] = warp_queue[i];        &#125;    &#125;&#125;\n性能对比\n以 Twitter 社交网络图为例：\n\n\n\n策略\n时间（ms）\n加速比\n\n\n\n\n每线程一节点\n2800\n1×\n\n\n线程束协作\n800\n3.5×\n\n\n自适应负载均衡\n450\n6.2×\n\n\n+ 方向优化\n180\n15.6×\n\n\n\n测试环境：\n\n图数据：Twitter 社交网络（4100万节点，14.7亿条边）\nGPU：NVIDIA A100（6912 CUDA 核心，40GB HBM2）\n块大小：256线程\n\n观察：负载均衡和方向优化的组合效果最好，在无标度网络中尤其明显。\nWarp 级原语优化\n使用 Ballot 和 Shuffle\n现代 GPU 的 Warp 级原语可以进一步优化 BFS：\n__device__ void process_neighbors_warp_optimized(    int start, int end, int *col_idx, int *level,    int *next_frontier, int *next_size, int depth) &#123;        int lane = threadIdx.x % 32;    int found = 0;        // Warp 协作遍历    for (int i = start + lane; i &lt; end; i += 32) &#123;        int v = col_idx[i];        if (atomicCAS(&amp;level[v], -1, depth + 1) == -1) &#123;            found = v;        &#125;    &#125;        // 使用 ballot 统计有多少线程找到了新节点    unsigned mask = __ballot_sync(0xffffffff, found != 0);    int count = __popc(mask);        if (count &gt; 0) &#123;        // 第一个有效线程申请空间        __shared__ int warp_offset;        if (lane == __ffs(mask) - 1) &#123;            warp_offset = atomicAdd(next_size, count);        &#125;        __syncwarp();                // 使用前缀和确定每个线程的位置        if (found != 0) &#123;            unsigned preceding = mask &amp; ((1u &lt;&lt; lane) - 1);            int local_pos = __popc(preceding);            next_frontier[warp_offset + local_pos] = found;        &#125;    &#125;&#125;\n优势：\n\n减少原子操作到每 Warp 最多一次\n利用 Warp 内隐式同步\n紧凑存储，无空隙\n\n终止条件检测\n问题\n每次迭代都需要检查前沿是否为空，传统方法需要：\ncudaMemcpy(&amp;h_size, d_queue_size, sizeof(int), cudaMemcpyDeviceToHost);if (h_size == 0) break;\n每次迭代都有 D2H 拷贝，延迟高。\n优化：GPU 端终止检测\n使用 CUDA 流和回调函数：\n__global__ void check_termination(int *queue_size, int *terminate_flag) &#123;    if (*queue_size == 0) &#123;        *terminate_flag = 1;    &#125;&#125;// Host 端int *d_terminate;cudaMallocHost(&amp;h_terminate, sizeof(int));  // 固定内存cudaMalloc(&amp;d_terminate, sizeof(int));while (true) &#123;    BFS_kernel&lt;&lt;&lt;...&gt;&gt;&gt;(...);        // 异步检测终止    check_termination&lt;&lt;&lt;1, 1&gt;&gt;&gt;(d_queue_size, d_terminate);    cudaMemcpyAsync(h_terminate, d_terminate, sizeof(int),                      cudaMemcpyDeviceToHost);    cudaDeviceSynchronize();        if (*h_terminate == 1) break;&#125;\n更优：重叠检测与计算\n// 使用双缓冲和流while (true) &#123;    BFS_kernel&lt;&lt;&lt;..., stream1&gt;&gt;&gt;(...);        // 在另一个流中异步检测    check_termination&lt;&lt;&lt;1, 1, 0, stream2&gt;&gt;&gt;(d_queue_size, d_terminate);    cudaMemcpyAsync(h_terminate, d_terminate, sizeof(int),                     cudaMemcpyDeviceToHost, stream2);        // 准备下一次迭代（与检测重叠）    prepare_next_iteration&lt;&lt;&lt;..., stream1&gt;&gt;&gt;(...);        cudaStreamSynchronize(stream2);    if (*h_terminate == 1) break;&#125;\n完整优化版本\n综合所有优化\n#define BLOCK_SIZE 256#define WARP_SIZE 32#define LOCAL_QUEUE_SIZE 512__global__ void BFS_optimized(    int *row_ptr, int *col_idx, int *level,    int *current_queue, int current_size,    int *next_queue, int *next_size,    bool *frontier_bitmap,  // 用于 Bottom-Up    int depth, bool top_down_mode) &#123;        __shared__ int s_queue[LOCAL_QUEUE_SIZE];    __shared__ int s_tail;        if (threadIdx.x == 0) s_tail = 0;    __syncthreads();        if (top_down_mode) &#123;        // ========== Top-Down 模式 ==========        int tid = blockIdx.x * blockDim.x + threadIdx.x;        int warp_id = tid / WARP_SIZE;        int lane = tid % WARP_SIZE;                if (tid &lt; current_size) &#123;            int u = current_queue[tid];            int degree = row_ptr[u + 1] - row_ptr[u];                        if (degree &lt; WARP_SIZE) &#123;                // 单线程处理小度数节点                for (int i = row_ptr[u]; i &lt; row_ptr[u + 1]; i++) &#123;                    int v = col_idx[i];                    if (atomicCAS(&amp;level[v], -1, depth + 1) == -1) &#123;                        int pos = atomicAdd(&amp;s_tail, 1);                        if (pos &lt; LOCAL_QUEUE_SIZE) &#123;                            s_queue[pos] = v;                        &#125;                    &#125;                &#125;            &#125; else &#123;                // Warp 协作处理大度数节点                for (int i = row_ptr[u] + lane; i &lt; row_ptr[u + 1]; i += WARP_SIZE) &#123;                    int v = col_idx[i];                    if (atomicCAS(&amp;level[v], -1, depth + 1) == -1) &#123;                        int pos = atomicAdd(&amp;s_tail, 1);                        if (pos &lt; LOCAL_QUEUE_SIZE) &#123;                            s_queue[pos] = v;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125; else &#123;        // ========== Bottom-Up 模式 ==========        int v = blockIdx.x * blockDim.x + threadIdx.x;                if (v &lt; num_nodes &amp;&amp; level[v] == -1) &#123;            for (int i = row_ptr[v]; i &lt; row_ptr[v + 1]; i++) &#123;                int u = col_idx[i];                if (frontier_bitmap[u]) &#123;                    level[v] = depth + 1;                    int pos = atomicAdd(&amp;s_tail, 1);                    if (pos &lt; LOCAL_QUEUE_SIZE) &#123;                        s_queue[pos] = v;                    &#125;                    break;                &#125;            &#125;        &#125;    &#125;        __syncthreads();        // 批量提交局部队列到全局    if (s_tail &gt; 0) &#123;        __shared__ int g_offset;        if (threadIdx.x == 0) &#123;            g_offset = atomicAdd(next_size, s_tail);        &#125;        __syncthreads();                for (int i = threadIdx.x; i &lt; s_tail; i += BLOCK_SIZE) &#123;            next_queue[g_offset + i] = s_queue[i];        &#125;    &#125;&#125;\n性能分析与对比\n不同优化的累计效果\n以美国道路网络图为例：\n\n\n\n优化阶段\n时间（ms）\n单阶段加速\n累计加速\n\n\n\n\n朴素布尔前沿\n8500\n1×\n1×\n\n\n稀疏队列\n2100\n4.0×\n4.0×\n\n\n+ 私有化队列\n620\n3.4×\n13.7×\n\n\n+ 线程束协作\n380\n1.6×\n22.4×\n\n\n+ 方向优化\n95\n4.0×\n89.5×\n\n\n+ CUB DeviceSelect优化\n75\n1.3×\n113×\n\n\n\n实际测试环境\n硬件配置：\n\nGPU：NVIDIA RTX 3090（10496 CUDA 核心，24GB GDDR6X）\nCPU：Intel i9-12900K（用于对比）\nCUDA 版本：11.8\n编译选项：nvcc -O3 -arch=sm_86\n\n测试图数据集：\n\n社交网络：Twitter 图（4100万节点，14.7亿条边）\n路网：USA Road Network（2300万节点，5800万条边）\n随机图：RMAT Scale-26（6700万节点，5.3亿条边）\n\n说明：性能数据为10次运行的平均值，不包括图数据传输时间。\n各优化的瓶颈分析\n\n\n\n版本\n主要瓶颈\n带宽利用率\n占用率\n\n\n\n\n布尔前沿\n分支发散、浪费\n5%\n10%\n\n\n朴素队列\n全局原子争用\n15%\n35%\n\n\n私有化\n共享内存原子\n45%\n60%\n\n\nWarp 协作\n负载不均\n65%\n75%\n\n\n方向优化\n接近最优\n85%\n80%\n\n\n\n应用扩展\n单源最短路径（SSSP）\nBFS 可以扩展到加权图的最短路径：\n__global__ void SSSP_kernel(int *row_ptr, int *col_idx, float *weights,                             float *dist, bool *updated, int num_nodes) &#123;    int u = blockIdx.x * blockDim.x + threadIdx.x;        if (u &lt; num_nodes &amp;&amp; updated[u]) &#123;        updated[u] = false;                for (int i = row_ptr[u]; i &lt; row_ptr[u + 1]; i++) &#123;            int v = col_idx[i];            float new_dist = dist[u] + weights[i];                        // 使用原子操作更新更短的距离            atomicMin_float(&amp;dist[v], new_dist);            updated[v] = true;        &#125;    &#125;&#125;\n关键差异：\n\nBFS 每个节点只访问一次\nSSSP 可能多次更新（松弛操作）\n需要迭代直到收敛\n\n连通分量\n找到图中的所有连通分量：\n__global__ void connected_components_kernel(    int *row_ptr, int *col_idx, int *component,     bool *changed, int num_nodes) &#123;        int u = blockIdx.x * blockDim.x + threadIdx.x;        if (u &lt; num_nodes) &#123;        int my_component = component[u];                for (int i = row_ptr[u]; i &lt; row_ptr[u + 1]; i++) &#123;            int v = col_idx[i];            int neighbor_component = component[v];                        // 取较小的分量标签            if (neighbor_component &lt; my_component) &#123;                atomicMin(&amp;component[u], neighbor_component);                *changed = true;            &#125;        &#125;    &#125;&#125;\n迭代执行直到没有变化。\n三角形计数\n统计图中三角形的数量（社交网络分析的重要指标）：\n__global__ void triangle_count_kernel(    int *row_ptr, int *col_idx, int num_nodes,     unsigned long long *count) &#123;        int u = blockIdx.x * blockDim.x + threadIdx.x;        if (u &lt; num_nodes) &#123;        int u_start = row_ptr[u];        int u_end = row_ptr[u + 1];                // 遍历 u 的邻居 v        for (int i = u_start; i &lt; u_end; i++) &#123;            int v = col_idx[i];            if (v &gt; u) &#123;  // 避免重复计数                int v_start = row_ptr[v];                int v_end = row_ptr[v + 1];                                // 找 u 和 v 的共同邻居                int j = u_start, k = v_start;                while (j &lt; u_end &amp;&amp; k &lt; v_end) &#123;                    int u_neighbor = col_idx[j];                    int v_neighbor = col_idx[k];                                        if (u_neighbor == v_neighbor &amp;&amp; u_neighbor &gt; v) &#123;                        atomicAdd(count, 1ULL);                        j++; k++;                    &#125; else if (u_neighbor &lt; v_neighbor) &#123;                        j++;                    &#125; else &#123;                        k++;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n优化：利用邻居列表有序的特性，用归并式遍历查找交集。\n使用 CUB/cuGraph 库\nCUB 的队列管理\nCUB 提供高效的 Select 操作，可用于队列管理：\n#include &lt;cub/cub.cuh&gt;// 从布尔前沿中提取节点 IDvoid compact_frontier(bool *d_frontier, int *d_queue, int *d_size, int num_nodes) &#123;    void *d_temp = nullptr;    size_t temp_bytes = 0;        // 计算需要的临时空间    cub::DeviceSelect::Flagged(d_temp, temp_bytes,                                 d_indices, d_frontier,  // 输入                                 d_queue, d_size,        // 输出                                 num_nodes);        cudaMalloc(&amp;d_temp, temp_bytes);        // 执行压缩    cub::DeviceSelect::Flagged(d_temp, temp_bytes,                                 d_indices, d_frontier,                                 d_queue, d_size,                                 num_nodes);        cudaFree(d_temp);&#125;\ncuGraph 库\nNVIDIA 的图分析库提供优化的 BFS 实现：\n#include &lt;cugraph/algorithms.hpp&gt;void bfs_cugraph(int num_nodes, int num_edges,                  int *offsets, int *indices, int source) &#123;    // 创建图对象    cugraph::GraphCSRView&lt;int, int, float&gt; graph(        offsets, indices, nullptr,  // CSR 格式        num_nodes, num_edges    );        // 分配结果数组    rmm::device_vector&lt;int&gt; distances(num_nodes);    rmm::device_vector&lt;int&gt; predecessors(num_nodes);        // 执行 BFS    cugraph::bfs(graph,                  distances.data().get(),                  predecessors.data().get(),                  source,                  false);  // 不计算前驱节点&#125;\ncuGraph 集成了本章讨论的所有优化技术。\n实战建议\n图预处理\n在执行图算法前，预处理可以提升性能：\n\n\n按度数排序节点：\n\n大度数节点聚集\n方便负载均衡\n\n\n\n重新编号：\n\n使用 BFS 顺序重新编号\n提高缓存局部性\n\n\n\n去除自环和重边：\n\n减少无效边\n简化算法逻辑\n\n\n\n选择合适的算法\n\n\n\n图特征\n推荐策略\n\n\n\n\n小前沿（&lt;1%）\nTop-Down\n\n\n大前沿（&gt;10%）\nBottom-Up\n\n\n动态变化\n方向优化\n\n\n度数均匀\n简单队列\n\n\n无标度网络\nWarp 协作\n\n\n超大规模\n多 GPU + 图分割\n\n\n\n性能调优检查清单\n\n[ ] 使用 CSR 格式存储图\n[ ] 实现稀疏队列而非布尔数组\n[ ] 使用共享内存私有化队列\n[ ] 根据度数自适应选择策略\n[ ] 考虑方向优化（Push/Pull 切换）\n[ ] 使用 Warp 级原语减少原子操作\n[ ] 优化终止条件检测\n[ ] 考虑使用 cuGraph 库\n\n小结\n第十五章深入讲解了 GPU 图遍历算法，相比于规则的矩阵运算，图算法充满了挑战：\nCSR 格式：是图和稀疏矩阵的桥梁。row_ptr 和 col_idx 两个数组高效表示稀疏邻接关系。\n按层同步：并行 BFS 的基本框架。每层并行处理当前前沿的所有节点。\n队列管理：\n\n布尔前沿：简单但工作效率极低\n稀疏队列：只启动必要线程\n私有化队列：减少全局原子操作争用\n\n方向优化：\n\nTop-Down（Push）：前沿小时高效\nBottom-Up（Pull）：前沿大时高效\n动态切换：自适应图的演化过程\n\n负载均衡：\n\n无标度网络中度数差异巨大\n单线程、Warp 协作、Block 协作分层处理\n自适应策略根据度数选择\n\nWarp 级优化：\n\n使用 ballot、shuffle 等原语\n减少原子操作次数\n提高内存效率\n\n综合性能：\n\n优化后可达 100× 以上加速\n接近内存带宽上限\n方向优化贡献最大（通常 4-8×）\n\n图算法是 GPU 并行计算的试金石，它综合运用了前面学到的所有技术：原子操作、私有化、线程束原语、负载均衡、内存优化。掌握了图遍历，就掌握了处理不规则数据结构的核心技能。下一章将学习深度学习——GPU 计算当前最重要的应用领域。\n🚀 下一步\n\n尝试实现一个完整的 BFS 算法，从简单的布尔前沿数组开始，逐步优化到稀疏前沿和方向优化版本\n探索其他图算法：最短路径（Dijkstra、Bellman-Ford）、连通分量、PageRank\n学习 cuGraph 库，了解工业级的图算法实现\n阅读 Graph500 基准测试，了解大规模图计算的性能指标\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 15\n第十五章：图遍历\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nMerrill, D., et al. (2012). Scalable GPU Graph Traversal. PPoPP.\nBeamer, S., et al. (2012). Direction-Optimizing Breadth-First Search. SC12.\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","图算法","BFS","CSR格式"]},{"title":"PMPP-第十八章：静电势能图","url":"/posts/d7c6e6a8/","content":"前言\n第十七章探索了 MRI 重建这一医学影像应用。第十八章转向另一个重要的科学计算领域——分子动力学（Molecular Dynamics）中的静电势能计算。静电相互作用是分子模拟的核心，理解分子如何通过电荷相互作用，对药物设计、蛋白质折叠研究等具有重要意义。本章将展示如何利用 GPU 的并行能力高效计算静电势能图（Electrostatic Potential Map）。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n静电势能基础\n库仑定律\n两个点电荷之间的静电势能：\nV=k⋅qrV = \\frac{k \\cdot q}{r}\nV=rk⋅q​\n其中：\n\nkkk：库仑常数\nqqq：电荷量\nrrr：距离\n\n分子中的静电势能\n一个分子由多个原子组成，每个原子携带部分电荷。空间中任意一点的静电势是所有原子贡献的总和：\nV(p)=∑i=1Nk⋅qi∣p−ri∣V(\\mathbf{p}) = \\sum_{i=1}^{N} \\frac{k \\cdot q_i}{|\\mathbf{p} - \\mathbf{r}_i|}\nV(p)=i=1∑N​∣p−ri​∣k⋅qi​​\n其中：\n\np\\mathbf{p}p：空间中的网格点\nri\\mathbf{r}_iri​：第 iii 个原子的位置\nqiq_iqi​：第 iii 个原子的部分电荷\n\n静电势能图\n静电势能图：在分子周围的 3D 网格上，计算每个网格点的静电势能值。\n典型规模：\n\n网格：256³ = 1670 万个点\n原子：数千到数万个\n\n计算量：网格点数 × 原子数 = 数千亿次运算\n直接求和法\n基本算法\n最直接的方法——对每个网格点，遍历所有原子求和：\nvoid compute_potential_cpu(    float *potential,     // 输出：[Gx, Gy, Gz]    float *atoms,         // 原子坐标：[N, 3]    float *charges,       // 原子电荷：[N]    int N,                // 原子数    int Gx, int Gy, int Gz,  // 网格尺寸    float grid_spacing) &#123;        for (int gx = 0; gx &lt; Gx; gx++) &#123;        for (int gy = 0; gy &lt; Gy; gy++) &#123;            for (int gz = 0; gz &lt; Gz; gz++) &#123;                float px = gx * grid_spacing;                float py = gy * grid_spacing;                float pz = gz * grid_spacing;                                float sum = 0.0f;                for (int i = 0; i &lt; N; i++) &#123;                    float dx = px - atoms[i * 3 + 0];                    float dy = py - atoms[i * 3 + 1];                    float dz = pz - atoms[i * 3 + 2];                    float r = sqrtf(dx*dx + dy*dy + dz*dz);                    if (r &gt; 0.001f) &#123;  // 避免除以零                        sum += charges[i] / r;                    &#125;                &#125;                potential[gx * Gy * Gz + gy * Gz + gz] = sum;            &#125;        &#125;    &#125;&#125;\n复杂度：O(G³ × N)，对于 256³ 网格和 10000 个原子 ≈ 10¹¹ 次操作。\nGPU 朴素实现\n每个线程计算一个网格点：\n__global__ void compute_potential_naive(    float *potential,    float *atoms,     // [N, 3]    float *charges,   // [N]    int N,    int Gx, int Gy, int Gz,    float grid_spacing) &#123;        int gx = blockIdx.x * blockDim.x + threadIdx.x;    int gy = blockIdx.y * blockDim.y + threadIdx.y;    int gz = blockIdx.z * blockDim.z + threadIdx.z;        if (gx &gt;= Gx || gy &gt;= Gy || gz &gt;= Gz) return;        float px = gx * grid_spacing;    float py = gy * grid_spacing;    float pz = gz * grid_spacing;        float sum = 0.0f;    for (int i = 0; i &lt; N; i++) &#123;        float dx = px - atoms[i * 3 + 0];        float dy = py - atoms[i * 3 + 1];        float dz = pz - atoms[i * 3 + 2];        float r = sqrtf(dx*dx + dy*dy + dz*dz);        if (r &gt; 0.001f) &#123;            sum += charges[i] / r;        &#125;    &#125;        potential[gx * Gy * Gz + gy * Gz + gz] = sum;&#125;\n问题：每个线程都要读取所有原子数据——大量重复的全局内存访问。\n共享内存优化\n原子数据分块\n把原子数据分成小块，每块加载到共享内存，复用于 Block 内所有线程：\n#define TILE_SIZE 128__global__ void compute_potential_tiled(    float *potential,    float *atoms,    float *charges,    int N,    int Gx, int Gy, int Gz,    float grid_spacing) &#123;        __shared__ float s_atoms[TILE_SIZE * 3];    __shared__ float s_charges[TILE_SIZE];        int gx = blockIdx.x * blockDim.x + threadIdx.x;    int gy = blockIdx.y * blockDim.y + threadIdx.y;    int gz = blockIdx.z * blockDim.z + threadIdx.z;        float px = gx * grid_spacing;    float py = gy * grid_spacing;    float pz = gz * grid_spacing;        float sum = 0.0f;        // 分块处理原子    for (int tile = 0; tile &lt; N; tile += TILE_SIZE) &#123;        // 协作加载原子数据到共享内存        int tid = threadIdx.x + threadIdx.y * blockDim.x + threadIdx.z * blockDim.x * blockDim.y;        int num_threads = blockDim.x * blockDim.y * blockDim.z;                for (int i = tid; i &lt; TILE_SIZE &amp;&amp; (tile + i) &lt; N; i += num_threads) &#123;            int atom_idx = tile + i;            s_atoms[i * 3 + 0] = atoms[atom_idx * 3 + 0];            s_atoms[i * 3 + 1] = atoms[atom_idx * 3 + 1];            s_atoms[i * 3 + 2] = atoms[atom_idx * 3 + 2];            s_charges[i] = charges[atom_idx];        &#125;        __syncthreads();                // 计算这一块原子的贡献        int tile_atoms = min(TILE_SIZE, N - tile);        for (int i = 0; i &lt; tile_atoms; i++) &#123;            float dx = px - s_atoms[i * 3 + 0];            float dy = py - s_atoms[i * 3 + 1];            float dz = pz - s_atoms[i * 3 + 2];            float r = sqrtf(dx*dx + dy*dy + dz*dz);            if (r &gt; 0.001f) &#123;                sum += s_charges[i] / r;            &#125;        &#125;        __syncthreads();    &#125;        if (gx &lt; Gx &amp;&amp; gy &lt; Gy &amp;&amp; gz &lt; Gz) &#123;        potential[gx * Gy * Gz + gy * Gz + gz] = sum;    &#125;&#125;\n性能分析\n\n\n\n版本\n全局内存读取次数\n加速比\n\n\n\n\n朴素\nG³ × N\n1×\n\n\nTiled\nG³ × N / B + N\n~10×\n\n\n\n其中 B 是 Block 内线程数。\n常量内存优化\n原子数据放入常量内存\n如果原子数不太多（&lt; 16K），可以放入常量内存：\n#define MAX_ATOMS 16000__constant__ float c_atoms[MAX_ATOMS * 4];  // x, y, z, chargevoid setup_atoms(float *atoms, float *charges, int N) &#123;    float atoms_packed[MAX_ATOMS * 4];    for (int i = 0; i &lt; N; i++) &#123;        atoms_packed[i * 4 + 0] = atoms[i * 3 + 0];        atoms_packed[i * 4 + 1] = atoms[i * 3 + 1];        atoms_packed[i * 4 + 2] = atoms[i * 3 + 2];        atoms_packed[i * 4 + 3] = charges[i];    &#125;    cudaMemcpyToSymbol(c_atoms, atoms_packed, N * 4 * sizeof(float));&#125;__global__ void compute_potential_const(    float *potential,    int N,    int Gx, int Gy, int Gz,    float grid_spacing) &#123;        // ... 网格点坐标计算 ...        float sum = 0.0f;    for (int i = 0; i &lt; N; i++) &#123;        float ax = c_atoms[i * 4 + 0];        float ay = c_atoms[i * 4 + 1];        float az = c_atoms[i * 4 + 2];        float q  = c_atoms[i * 4 + 3];                float dx = px - ax;        float dy = py - ay;        float dz = pz - az;        float r = sqrtf(dx*dx + dy*dy + dz*dz);        if (r &gt; 0.001f) &#123;            sum += q / r;        &#125;    &#125;        // ... 写入结果 ...&#125;\n优势：\n\n常量内存有专用缓存\n广播机制：Warp 内线程访问同一地址只需一次读取\n\n截断方法\n为什么截断\n真实分子模拟中，远距离原子的贡献很小。可以设置截断半径，只计算距离小于截断半径的原子。\nV(p)=∑∣p−ri∣&lt;rcutk⋅qi∣p−ri∣V(\\mathbf{p}) = \\sum_{|\\mathbf{p} - \\mathbf{r}_i| &lt; r_{cut}} \\frac{k \\cdot q_i}{|\\mathbf{p} - \\mathbf{r}_i|}\nV(p)=∣p−ri​∣&lt;rcut​∑​∣p−ri​∣k⋅qi​​\n空间分区\n为了快速找到&quot;附近&quot;的原子，使用空间哈希或Cell List：\n\n把空间划分成小格子（边长 = 截断半径）\n每个原子分配到所在格子\n计算网格点时，只遍历邻近 27 个格子中的原子\n\n__global__ void compute_potential_cutoff(    float *potential,    int *cell_start,    // [Cx, Cy, Cz] 每个格子的原子起始索引    int *cell_count,    // [Cx, Cy, Cz] 每个格子的原子数    float *sorted_atoms,    float *sorted_charges,    float cutoff,    int Gx, int Gy, int Gz,    int Cx, int Cy, int Cz,    float grid_spacing,    float cell_size) &#123;        int gx = blockIdx.x * blockDim.x + threadIdx.x;    int gy = blockIdx.y * blockDim.y + threadIdx.y;    int gz = blockIdx.z * blockDim.z + threadIdx.z;        if (gx &gt;= Gx || gy &gt;= Gy || gz &gt;= Gz) return;        float px = gx * grid_spacing;    float py = gy * grid_spacing;    float pz = gz * grid_spacing;        // 确定所在格子    int cx = (int)(px / cell_size);    int cy = (int)(py / cell_size);    int cz = (int)(pz / cell_size);        float sum = 0.0f;        // 遍历邻近 27 个格子    for (int dcx = -1; dcx &lt;= 1; dcx++) &#123;        for (int dcy = -1; dcy &lt;= 1; dcy++) &#123;            for (int dcz = -1; dcz &lt;= 1; dcz++) &#123;                int ncx = cx + dcx;                int ncy = cy + dcy;                int ncz = cz + dcz;                                if (ncx &lt; 0 || ncx &gt;= Cx || ncy &lt; 0 || ncy &gt;= Cy || ncz &lt; 0 || ncz &gt;= Cz)                    continue;                                int cell_idx = ncx * Cy * Cz + ncy * Cz + ncz;                int start = cell_start[cell_idx];                int count = cell_count[cell_idx];                                for (int i = 0; i &lt; count; i++) &#123;                    int atom_idx = start + i;                    float dx = px - sorted_atoms[atom_idx * 3 + 0];                    float dy = py - sorted_atoms[atom_idx * 3 + 1];                    float dz = pz - sorted_atoms[atom_idx * 3 + 2];                    float r = sqrtf(dx*dx + dy*dy + dz*dz);                                        if (r &gt; 0.001f &amp;&amp; r &lt; cutoff) &#123;                        sum += sorted_charges[atom_idx] / r;                    &#125;                &#125;            &#125;        &#125;    &#125;        potential[gx * Gy * Gz + gy * Gz + gz] = sum;&#125;\n复杂度分析\n\n\n\n方法\n复杂度\n适用场景\n\n\n\n\n直接求和\nO(G³ × N)\n小系统\n\n\n截断 + Cell\nO(G³ × ρ × r³)\n大系统\n\n\n\n其中 ρ 是原子密度，r 是截断半径。\n多层网格方法\nEwald 求和\n对于周期性边界条件，需要考虑所有周期镜像的贡献。\nEwald 方法将求和分成两部分：\n\n实空间：截断求和（短程）\n倒空间：FFT 求和（长程）\n\nPME（Particle Mesh Ewald）\nPME 是 Ewald 的高效变体：\n\n把电荷分配到网格\n对网格做 FFT\n在倒空间计算势能\n做 IFFT\n插值回原子位置\n\n复杂度：O(N log N) vs 直接 Ewald 的 O(N^1.5)\nGPU 上的 PME\nvoid pme_potential(    float *potential,    float *atoms,    float *charges,    int N,    int grid_size) &#123;        // 1. 电荷分配到网格（B-spline 插值）    charge_spreading&lt;&lt;&lt;...&gt;&gt;&gt;(charges, atoms, grid_charges, N, grid_size);        // 2. 3D FFT    cufftExecC2C(plan, grid_charges, grid_kspace, CUFFT_FORWARD);        // 3. 倒空间操作（乘以 Green 函数）    reciprocal_kernel&lt;&lt;&lt;...&gt;&gt;&gt;(grid_kspace, grid_size);        // 4. 3D IFFT    cufftExecC2C(plan, grid_kspace, grid_potential, CUFFT_INVERSE);        // 5. 插值回网格点    interpolate_kernel&lt;&lt;&lt;...&gt;&gt;&gt;(grid_potential, potential, grid_size);&#125;\n多 GPU 实现\n数据并行\n对于大网格，可以将网格分割到多个 GPU：\nvoid multi_gpu_potential(    float *potential,    float *atoms,    float *charges,    int N,    int Gx, int Gy, int Gz,    int num_gpus) &#123;        int slices_per_gpu = Gx / num_gpus;        #pragma omp parallel for num_threads(num_gpus)    for (int gpu = 0; gpu &lt; num_gpus; gpu++) &#123;        cudaSetDevice(gpu);                int gx_start = gpu * slices_per_gpu;        int gx_end = (gpu == num_gpus - 1) ? Gx : (gpu + 1) * slices_per_gpu;                compute_potential_kernel&lt;&lt;&lt;...&gt;&gt;&gt;(            potential + gx_start * Gy * Gz,            atoms_d[gpu], charges_d[gpu], N,            gx_start, gx_end, Gy, Gz, grid_spacing);    &#125;        // 收集结果    // ...&#125;\n注意事项\n\n每个 GPU 需要完整的原子数据副本\n边界区域可能需要重叠计算\n使用 NCCL 高效通信\n\n应用：分子对接\n药物设计中的应用\n静电势能图用于分子对接：预测配体分子与蛋白质靶点的结合方式。\n流程：\n\n计算蛋白质的静电势能图\n配体在势能图中搜索最优位置\n评估结合亲和力\n\n实时可视化\nGPU 计算的静电势能图可以实时渲染：\n// 将势能图转换为颜色__global__ void potential_to_color(    float *potential,    uchar4 *colors,    float min_val, float max_val,    int num_points) &#123;        int idx = blockIdx.x * blockDim.x + threadIdx.x;    if (idx &gt;= num_points) return;        float val = potential[idx];    float normalized = (val - min_val) / (max_val - min_val);        // 红色表示正电势，蓝色表示负电势    colors[idx].x = (unsigned char)(255 * fmaxf(normalized, 0.0f));    colors[idx].y = 0;    colors[idx].z = (unsigned char)(255 * fmaxf(-normalized, 0.0f));    colors[idx].w = 255;&#125;\n性能总结\n各优化的加速效果\n\n\n\n优化技术\n相对加速\n累计加速\n\n\n\n\nGPU 朴素\n50×\n50×\n\n\n共享内存 Tiling\n10×\n500×\n\n\n常量内存\n1.5×\n750×\n\n\n截断 + Cell\n5-20×\n3000×+\n\n\n\n实际性能\n256³ 网格，10000 个原子：\n\nCPU（单核）：~600 秒\nGPU（V100）：~0.2 秒\n\n加速比：3000× 以上\n小结\n第十八章展示了静电势能计算的 GPU 加速：\n问题本质：N-body 类型的全对问题，每个网格点需要遍历所有原子。直接计算复杂度 O(G³ × N)。\n共享内存优化：把原子数据分块加载到共享内存，Block 内线程共享，大幅减少全局内存访问。\n常量内存：对于小规模原子数据，利用常量缓存和广播机制进一步加速。\n截断方法：利用物理特性（远场贡献小）减少计算量。Cell List 数据结构快速查找邻近原子。\nPME 方法：对于周期性系统，用 FFT 处理长程相互作用，复杂度降至 O(N log N)。\n多 GPU 扩展：网格天然可分割，适合数据并行。\n静电势能计算是分子动力学模拟的核心组件。掌握本章技术，就能理解 GROMACS、AMBER 等分子动力学软件的 GPU 加速原理。\n🚀 下一步\n\n实现一个完整的静电势能计算程序，从直接求和开始，逐步优化到共享内存和截断方法\n学习 PME 方法，实现基于 FFT 的长程相互作用计算\n探索其他 N-body 问题：引力模拟、流体动力学中的粒子方法\n了解分子动力学模拟的完整流程：力场计算、积分器、温度/压力控制\n研究 GROMACS 或 AMBER 的 GPU 加速实现，学习工业级优化技巧\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 18\n第十八章：静电势能图\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nStone, J. E., et al. (2007). Accelerating Molecular Modeling Applications with GPU Computing. JCC.\nDarden, T., et al. (1993). Particle Mesh Ewald: An N·log(N) Method for Ewald Sums. JCP.\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","分子动力学","静电势能","科学计算"]},{"title":"PMPP-第十六章：深度学习","url":"/posts/feaca34d/","content":"前言\n前面的章节学习了各种并行算法原语：归约、扫描、排序、稀疏矩阵、图遍历。这些技术在深度学习中都有应用。第十六章将这些技术串联起来，展示 GPU 如何加速深度学习（Deep Learning）——当今 GPU 最重要的应用领域之一。本章不深入讲解神经网络理论，而是聚焦于计算视角：神经网络的核心操作是什么？GPU 如何高效实现这些操作？\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n深度学习基础\n神经网络的计算本质\n无论是全连接层、卷积层还是注意力层，神经网络的核心操作都是：\n\n线性变换：矩阵乘法（GEMM）\n非线性激活：ReLU、Sigmoid、Softmax 等\n归约操作：Pooling、Normalization\n\n计算量分布（以 ResNet-50 为例）：\n\n卷积层：~95% 的计算量\n全连接层：~4%\n其他：~1%\n\n卷积才是 GPU 优化的主战场。\n深度学习为什么需要 GPU\n\n\n\n特性\nCPU\nGPU\n\n\n\n\n核心数\n8-64\n数千\n\n\n时钟频率\n3-5 GHz\n1-2 GHz\n\n\n峰值算力(FP32)\n~1 TFLOPS\n~30 TFLOPS\n\n\n内存带宽\n~100 GB/s\n~1000 GB/s\n\n\n\n深度学习的计算是高度并行的：\n\n批量处理（Batch）：独立样本并行\n空间并行：图像不同位置并行\n通道并行：不同特征图并行\n\n这是 GPU 的理想场景。\n卷积层的 GPU 实现\n卷积的计算复杂度\n给定输入张量 [N, C_in, H, W] 和卷积核 [C_out, C_in, K, K]：\nFLOPs=2×N×Cout×Hout×Wout×Cin×K×K\\text{FLOPs} = 2 \\times N \\times C_{out} \\times H_{out} \\times W_{out} \\times C_{in} \\times K \\times K\nFLOPs=2×N×Cout​×Hout​×Wout​×Cin​×K×K\n对于 ResNet-50 的第一个卷积层：\n\n输入：[1, 3, 224, 224]\n卷积核：[64, 3, 7, 7]\nFLOPs ≈ 1.2 亿次\n\n整个网络约需 40 亿次浮点操作。\n直接卷积\n最直观的实现，第七章已详细讲过：\n__global__ void conv2d_direct(float *input, float *kernel, float *output,                               int N, int C_in, int H, int W,                                int C_out, int K) &#123;    int n = blockIdx.z;    int c_out = blockIdx.y;    int h_out = blockIdx.x * blockDim.x + threadIdx.x;    int w_out = blockIdx.x * blockDim.y + threadIdx.y;        if (h_out &lt; H_out &amp;&amp; w_out &lt; W_out) &#123;        float sum = 0.0f;        for (int c_in = 0; c_in &lt; C_in; c_in++) &#123;            for (int kh = 0; kh &lt; K; kh++) &#123;                for (int kw = 0; kw &lt; K; kw++) &#123;                    int h_in = h_out + kh - K/2;                    int w_in = w_out + kw - K/2;                    if (h_in &gt;= 0 &amp;&amp; h_in &lt; H &amp;&amp; w_in &gt;= 0 &amp;&amp; w_in &lt; W) &#123;                        sum += input[...] * kernel[...];                    &#125;                &#125;            &#125;        &#125;        output[...] = sum;    &#125;&#125;\n问题：循环太多，内存访问不规则，效率低。\nIm2col + GEMM\n核心思想：把卷积转化为矩阵乘法。\nIm2col：把输入的每个滑动窗口展开成一列。\n输入图像 [C_in, H, W]，卷积核 [K, K]Im2col 后：  列数 = H_out × W_out  行数 = C_in × K × K每一列对应一个滑动窗口的展开\n转换后：\n输出 = Kernel × Im2col(Input)[C_out, H_out×W_out] = [C_out, C_in×K×K] × [C_in×K×K, H_out×W_out]\n这是标准的 GEMM！可以调用高度优化的 cuBLAS。\n代价：Im2col 需要额外内存，约为原输入的 K² 倍。\nWinograd 卷积\n核心思想：用更多加法换更少乘法。\n对于 3×3 卷积，Winograd F(2×2, 3×3) 可以把乘法次数从 36 减少到 16。\n公式：\nY=AT[(G⋅g⋅GT)⊙(BT⋅d⋅B)]AY = A^T \\left[ (G \\cdot g \\cdot G^T) \\odot (B^T \\cdot d \\cdot B) \\right] A\nY=AT[(G⋅g⋅GT)⊙(BT⋅d⋅B)]A\n其中：\n\nggg：卷积核\nddd：输入 Tile\nG,B,AG, B, AG,B,A：变换矩阵\n⊙\\odot⊙：逐元素乘法\n\n优势：计算量减少 2.25 倍（理论上）。\n限制：\n\n只适合小卷积核（3×3 最常用）\n数值稳定性问题\n实现复杂\n\nFFT 卷积\n核心思想：卷积定理——时域卷积 = 频域逐元素乘法。\nOutput = IFFT(FFT(Input) ⊙ FFT(Kernel))\n复杂度：O(N² log N) vs 直接卷积的 O(N² K²)\n适用场景：大卷积核（K &gt; 7）。深度学习中卷积核通常很小（1×1, 3×3），所以 FFT 卷积较少使用。\ncuDNN 策略选择\ncuDNN 内置多种卷积算法，会根据问题规模自动选择：\n\n\n\n算法\n适用场景\n\n\n\n\nIMPLICIT_GEMM\n通用\n\n\nIMPLICIT_PRECOMP_GEMM\n大 Batch\n\n\nGEMM\n小卷积核\n\n\nWINOGRAD\n3×3 卷积\n\n\nFFT\n大卷积核\n\n\n\ncudnnConvolutionFwdAlgoPerf_t perfResults[8];cudnnFindConvolutionForwardAlgorithm(    handle, inputDesc, filterDesc, convDesc, outputDesc,    8, &amp;returnedAlgoCount, perfResults);// 选择最快的算法cudnnConvolutionFwdAlgo_t algo = perfResults[0].algo;\n全连接层\n本质：矩阵乘法\ny = W × x + b[out_features] = [out_features, in_features] × [in_features] + [out_features]\n批量处理：\nY = X × W^T + B[batch, out] = [batch, in] × [in, out] + [batch, out]\n直接调用 cuBLAS GEMM 即可。\n优化：Tensor Core\n从 Volta 架构开始，GPU 有专门的 Tensor Core：\n\n\n\n操作\nCUDA Core\nTensor Core\n\n\n\n\n4×4 矩阵乘加\n128 FLOPs\n1 周期\n\n\n精度\nFP32\nFP16/BF16\n\n\n峰值算力(A100)\n19 TFLOPS\n312 TFLOPS\n\n\n\n使用 Tensor Core 需要：\n\n数据类型为 FP16 或 BF16\n矩阵维度是 8 或 16 的倍数\n使用 cuBLAS 或 WMMA API\n\n激活函数\nReLU\n__global__ void relu(float *x, int n) &#123;    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; n) &#123;        x[i] = max(x[i], 0.0f);    &#125;&#125;\n计算简单，属于 Memory-Bound：访存时间远大于计算时间。\nFusion 优化：把 ReLU 融合到卷积 Kernel 中，避免额外的内存读写。\n// 卷积结果直接应用 ReLUoutput[idx] = max(conv_result, 0.0f);\nSoftmax\n// 数值稳定版本__global__ void softmax(float *x, float *y, int n) &#123;    // 1. 找最大值（规约）    float max_val = reduce_max(x, n);        // 2. exp(x - max) 并求和（规约）    float sum = 0;    for (int i = threadIdx.x; i &lt; n; i += blockDim.x) &#123;        sum += expf(x[i] - max_val);    &#125;    sum = reduce_sum(sum);        // 3. 归一化    for (int i = threadIdx.x; i &lt; n; i += blockDim.x) &#123;        y[i] = expf(x[i] - max_val) / sum;    &#125;&#125;\n需要两次归约，三次遍历数据。\nPooling 层\nMax Pooling\n__global__ void max_pool2d(float *input, float *output,                            int H, int W, int pool_size, int stride) &#123;    int h_out = blockIdx.y * blockDim.y + threadIdx.y;    int w_out = blockIdx.x * blockDim.x + threadIdx.x;        float max_val = -FLT_MAX;    for (int ph = 0; ph &lt; pool_size; ph++) &#123;        for (int pw = 0; pw &lt; pool_size; pw++) &#123;            int h_in = h_out * stride + ph;            int w_in = w_out * stride + pw;            max_val = max(max_val, input[h_in * W + w_in]);        &#125;    &#125;    output[h_out * W_out + w_out] = max_val;&#125;\n类似于卷积，但用 max 替代加权和。\nGlobal Average Pooling\n对整个特征图求平均：\n// 就是一个 2D 归约！float sum = reduce_2d(feature_map, H, W);output = sum / (H * W);\n第十章的归约技术直接适用。\nBatch Normalization\n计算过程\n\n计算均值：μ=1m∑xi\\mu = \\frac{1}{m} \\sum x_iμ=m1​∑xi​（归约）\n计算方差：σ2=1m∑(xi−μ)2\\sigma^2 = \\frac{1}{m} \\sum (x_i - \\mu)^2σ2=m1​∑(xi​−μ)2（归约）\n归一化：x^=x−μσ2+ϵ\\hat{x} = \\frac{x - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}}x^=σ2+ϵ​x−μ​（逐元素）\n缩放平移：y=γx^+βy = \\gamma \\hat{x} + \\betay=γx^+β（逐元素）\n\nGPU 实现要点\n__global__ void batch_norm(float *x, float *y,                            float *gamma, float *beta,                           int N, int C, int H, int W) &#123;    int c = blockIdx.x;  // 每个 Block 处理一个通道        // 1. 计算该通道的均值和方差    float mean = compute_mean(x, c, N, H, W);    float var = compute_var(x, c, mean, N, H, W);        __syncthreads();        // 2. 归一化并缩放    for (int i = threadIdx.x; i &lt; N * H * W; i += blockDim.x) &#123;        float val = x[index(i, c)];        y[index(i, c)] = gamma[c] * (val - mean) / sqrtf(var + 1e-5f) + beta[c];    &#125;&#125;\n关键是按通道归约，每个通道独立处理。\n反向传播\n计算图与自动微分\n深度学习框架（PyTorch、TensorFlow）通过计算图追踪操作，自动计算梯度。\n前向传播：\nx → Conv → ReLU → Pool → FC → Softmax → Loss\n反向传播：\ndLoss/dL ← dL/dFC ← dFC/dPool ← dPool/dReLU ← dReLU/dConv ← dConv/dx\n每个操作都有对应的梯度计算 Kernel。\n卷积的反向传播\n卷积的梯度计算也是卷积！\n# 对输入的梯度dL/dInput = Convolution(dL/dOutput, Kernel^T)# 对权重的梯度dL/dKernel = Convolution(Input, dL/dOutput)\n所以卷积的优化同样适用于反向传播。\ncuDNN 接口\n基本使用\n#include &lt;cudnn.h&gt;// 1. 创建句柄cudnnHandle_t handle;cudnnCreate(&amp;handle);// 2. 创建张量描述符cudnnTensorDescriptor_t inputDesc, outputDesc;cudnnCreateTensorDescriptor(&amp;inputDesc);cudnnSetTensor4dDescriptor(inputDesc, CUDNN_TENSOR_NCHW, CUDNN_DATA_FLOAT,                           N, C, H, W);// 3. 创建卷积描述符cudnnConvolutionDescriptor_t convDesc;cudnnCreateConvolutionDescriptor(&amp;convDesc);cudnnSetConvolution2dDescriptor(convDesc, pad, pad, stride, stride, 1, 1,                                 CUDNN_CROSS_CORRELATION, CUDNN_DATA_FLOAT);// 4. 查询工作空间大小size_t workspaceSize;cudnnGetConvolutionForwardWorkspaceSize(handle, inputDesc, filterDesc,                                         convDesc, outputDesc, algo, &amp;workspaceSize);// 5. 分配工作空间并执行void *workspace;cudaMalloc(&amp;workspace, workspaceSize);float alpha = 1.0f, beta = 0.0f;cudnnConvolutionForward(handle, &amp;alpha, inputDesc, input,                        filterDesc, filter, convDesc, algo,                        workspace, workspaceSize,                        &amp;beta, outputDesc, output);\n常用操作\n\n\n\n操作\n函数\n\n\n\n\n卷积前向\ncudnnConvolutionForward\n\n\n卷积反向（数据）\ncudnnConvolutionBackwardData\n\n\n卷积反向（权重）\ncudnnConvolutionBackwardFilter\n\n\n池化\ncudnnPoolingForward/Backward\n\n\n激活\ncudnnActivationForward/Backward\n\n\nBatchNorm\ncudnnBatchNormForward/Backward\n\n\nSoftmax\ncudnnSoftmaxForward/Backward\n\n\n\n混合精度训练\nFP16 的优势\n\n\n\n精度\n存储\n带宽\n算力(A100)\n\n\n\n\nFP32\n4 字节\n1×\n19 TFLOPS\n\n\nFP16\n2 字节\n2×\n312 TFLOPS\n\n\n\n自动混合精度（AMP）\n# PyTorch 示例from torch.cuda.amp import autocast, GradScalerscaler = GradScaler()for data, target in dataloader:    optimizer.zero_grad()        with autocast():  # 自动转换到 FP16        output = model(data)        loss = criterion(output, target)        scaler.scale(loss).backward()  # 梯度缩放    scaler.step(optimizer)    scaler.update()\nLoss Scaling：防止 FP16 梯度下溢，先放大 Loss，计算完梯度后缩小。\n小结\n第十六章展示了深度学习与 GPU 并行计算的紧密联系：\n核心操作：深度学习的计算本质是矩阵乘法（GEMM）和卷积。这两个操作占据了 95% 以上的计算量。\n卷积实现：直接卷积简单但低效；Im2col + GEMM 转化为矩阵乘法；Winograd 减少乘法次数；cuDNN 自动选择最优策略。\n融合优化：把多个操作融合到一个 Kernel 中，减少内存访问。ReLU、BatchNorm 等常与卷积融合。\nTensor Core：专用硬件加速矩阵运算，FP16 峰值算力是 FP32 的 16 倍。混合精度训练已成为标准做法。\ncuDNN：封装了所有优化，是深度学习框架的底层依赖。理解其原理有助于调优和调试。\n深度学习是 GPU 计算的&quot;杀手级应用&quot;，正是这一需求推动了 GPU 硬件和软件的飞速发展。掌握本章内容，你就能理解 PyTorch、TensorFlow 在底层是如何工作的。\n🚀 下一步\n\n深入学习 cuDNN 的 API，尝试手动调用不同的卷积算法并对比性能\n实现一个简单的卷积神经网络，从零开始构建前向和反向传播\n探索混合精度训练，了解 FP16/BF16 的使用场景和注意事项\n学习 Tensor Core 编程，使用 WMMA API 实现自定义的矩阵乘法\n研究算子融合技术，将多个操作合并到一个 Kernel 中\n\n\n📚 参考资料\n\nPMPP 第四版 Chapter 16\n第十六章：深度学习\nHwu, W., Kirk, D., &amp; El Hajj, I. (2022). Programming Massively Parallel Processors: A Hands-on Approach (4th Edition). Morgan Kaufmann.\nNVIDIA cuDNN Developer Guide\nLavin, A., &amp; Gray, S. (2016). Fast Algorithms for Convolutional Neural Networks. CVPR.\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["深度学习","CUDA","GPU编程","并行计算","PMPP","卷积神经网络","cuDNN"]},{"title":"PMPP-第十四章：稀疏矩阵计算","url":"/posts/7af84cf7/","content":"前言\n前几章学习了归约、排序等处理&quot;规则数据&quot;的并行算法。本章学习稀疏矩阵（Sparse Matrix）——大部分元素为零的矩阵。稀疏矩阵在科学计算、图算法、机器学习中广泛应用。存储所有零元素既浪费空间又浪费计算，因此需要特殊的存储格式和算法。第十四章讲解常见的稀疏矩阵格式及其在 GPU 上的高效实现。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n稀疏矩阵基础\n什么是稀疏矩阵\n稀疏矩阵：非零元素占比很小的矩阵。\n密集矩阵 (Dense):[1, 2, 3, 4][5, 6, 7, 8][9, 10, 11, 12]稀疏矩阵 (Sparse):[0, 0, 3, 0][0, 0, 0, 0][2, 0, 0, 5]\n稀疏度：零元素占比。通常稀疏度 &gt; 90% 就值得用稀疏格式存储。\n应用场景\n\n\n\n领域\n应用\n稀疏度\n\n\n\n\n图算法\n邻接矩阵\n&gt; 99%\n\n\n物理仿真\n有限元刚度矩阵\n&gt; 95%\n\n\n推荐系统\n用户-物品评分矩阵\n&gt; 99.9%\n\n\nNLP\n词-文档矩阵\n&gt; 99%\n\n\n深度学习\n剪枝后的权重矩阵\n50%-90%\n\n\n\n为什么需要特殊格式\n存储效率：\n\n密集格式：n² 个元素\n稀疏格式：O(nnz) 个元素，nnz = 非零元素数\n\n计算效率：\n\n密集 SpMV：O(n²) 操作\n稀疏 SpMV：O(nnz) 操作\n\n对于 10000×10000 矩阵，1% 稀疏度：\n\n密集：10⁸ 个元素，400 MB\n稀疏：10⁶ 个非零元素，~12 MB\n\n常见稀疏格式\nCOO（Coordinate）格式\n最直观的格式：存储每个非零元素的 (行, 列, 值)。\n矩阵:[0, 0, 3, 0][0, 0, 0, 0][2, 0, 0, 5]COO 表示:row:    [0, 2, 2]col:    [2, 0, 3]value:  [3, 2, 5]\n存储空间：3 × nnz\n优点：简单，构建方便，支持乱序插入\n缺点：按行遍历效率低，不适合 SpMV\nCSR（Compressed Sparse Row）格式\n最常用的格式：压缩行索引。\n矩阵:[0, 0, 3, 0][0, 0, 0, 0][2, 0, 0, 5]CSR 表示:row_ptr:  [0, 1, 1, 3]  // 每行的起始位置col_idx:  [2, 0, 3]      // 列索引values:   [3, 2, 5]      // 值\nrow_ptr 解读：\n\n第 0 行：row_ptr[0] 到 row_ptr[1]，即 [0, 1)，包含 1 个元素\n第 1 行：row_ptr[1] 到 row_ptr[2]，即 [1, 1)，包含 0 个元素\n第 2 行：row_ptr[2] 到 row_ptr[3]，即 [1, 3)，包含 2 个元素\n\n存储空间：(n + 1) + 2 × nnz\n优点：按行访问高效，SpMV 友好\n缺点：插入/删除代价高，负载可能不均衡\nCSC（Compressed Sparse Column）格式\nCSR 的转置：压缩列索引。\ncol_ptr:  [0, 1, 1, 2, 3]  // 每列的起始位置row_idx:  [2, 0, 2]         // 行索引values:   [2, 3, 5]         // 值\n适用场景：按列访问频繁，如 SpMV 的转置操作。\nELL（ELLPACK/ITPACK）格式\n每行填充到相同长度：\n矩阵:[1, 0, 2, 0][0, 3, 0, 0][4, 5, 6, 0]ELL 表示（每行最多 3 个非零元素）:values:       col_idx:[1, 2, *]     [0, 2, *][3, *, *]     [1, *, *][4, 5, 6]     [0, 1, 2]\n\n表示填充值（无效元素）\n\n优点：规则访问模式，适合 GPU 向量化\n缺点：行长度差异大时浪费空间\nHybrid（HYB）格式\nELL + COO 的组合：\n\n大部分元素用 ELL 存储（规则部分）\n超出 ELL 宽度的元素用 COO 存储（溢出部分）\n\n适用场景：行长度分布不均匀的矩阵。\n稀疏矩阵-向量乘法（SpMV）\n问题定义\ny = A × x，其中 A 是 m × n 稀疏矩阵。\ny[i] = Σ A[i][j] × x[j]  （j 遍历第 i 行的非零元素）\nSpMV 是科学计算最常见的操作，是迭代求解器（CG、GMRES）的核心。\nCSR SpMV 串行实现\nvoid spmv_csr_sequential(int m, int *row_ptr, int *col_idx,                           float *values, float *x, float *y) &#123;    for (int i = 0; i &lt; m; i++) &#123;        float sum = 0;        for (int j = row_ptr[i]; j &lt; row_ptr[i + 1]; j++) &#123;            sum += values[j] * x[col_idx[j]];        &#125;        y[i] = sum;    &#125;&#125;\nCSR SpMV 并行实现\n每行一个线程：\n__global__ void spmv_csr_scalar(int m, int *row_ptr, int *col_idx,                                 float *values, float *x, float *y) &#123;    int row = blockIdx.x * blockDim.x + threadIdx.x;        if (row &lt; m) &#123;        float sum = 0;        for (int j = row_ptr[row]; j &lt; row_ptr[row + 1]; j++) &#123;            sum += values[j] * x[col_idx[j]];        &#125;        y[row] = sum;    &#125;&#125;\n问题：\n\n负载不均衡：行长度差异导致线程工作量不同\n分支发散：同一 Warp 的线程循环次数不同\n非合并访问：x[col_idx[j]] 是间接访问，不连续\n\nCSR SpMV 优化\n每行一个 Warp\n用一个 Warp（32 线程）处理一行，Warp 内规约求和：\n__global__ void spmv_csr_vector(int m, int *row_ptr, int *col_idx,                                 float *values, float *x, float *y) &#123;    int row = blockIdx.x * blockDim.x / 32 + threadIdx.x / 32;    int lane = threadIdx.x % 32;        if (row &lt; m) &#123;        float sum = 0;        int row_start = row_ptr[row];        int row_end = row_ptr[row + 1];                // Warp 内线程协作遍历行        for (int j = row_start + lane; j &lt; row_end; j += 32) &#123;            sum += values[j] * x[col_idx[j]];        &#125;                // Warp 内规约        for (int offset = 16; offset &gt; 0; offset /= 2) &#123;            sum += __shfl_down_sync(0xffffffff, sum, offset);        &#125;                if (lane == 0) &#123;            y[row] = sum;        &#125;    &#125;&#125;\n优势：\n\n负载在 Warp 内均衡\n无分支发散（所有线程做相同次循环）\n部分合并（values 连续）\n\n自适应策略\n根据行长度选择策略：\nif (row_length &lt; 32) &#123;    // 每行一个线程组（如 8 线程）&#125; else if (row_length &lt; 256) &#123;    // 每行一个 Warp&#125; else &#123;    // 每行多个 Warp&#125;\ncuSPARSE 库会自动选择最优策略。\nELL SpMV\n实现\n__global__ void spmv_ell(int m, int max_nnz_per_row,                          int *col_idx, float *values,                          float *x, float *y) &#123;    int row = blockIdx.x * blockDim.x + threadIdx.x;        if (row &lt; m) &#123;        float sum = 0;        for (int j = 0; j &lt; max_nnz_per_row; j++) &#123;            int idx = row + j * m;  // 列主序存储            int col = col_idx[idx];            if (col &gt;= 0) &#123;  // 有效元素                sum += values[idx] * x[col];            &#125;        &#125;        y[row] = sum;    &#125;&#125;\n列主序布局\n原始（行主序）:row 0: [a, b, c]row 1: [d, e, *]row 2: [f, g, h]列主序:j=0: [a, d, f]  ← 连续访问！j=1: [b, e, g]j=2: [c, *, h]\n优势：同一 Warp 的线程访问连续内存，实现合并访问。\nELL vs CSR\n\n\n\n特性\nCSR\nELL\n\n\n\n\n空间\n2×nnz + (m+1)\n2×m×max_nnz\n\n\n访问合并\n差（值和列索引）\n好（列主序）\n\n\n负载均衡\n需要额外处理\n自然均衡（固定循环）\n\n\n适用矩阵\n通用\n行长度相近\n\n\n\nJDS（Jagged Diagonal Storage）格式\n思想\n按行长度降序排列行，然后用类似 ELL 的方式存储：\n原始矩阵:row 0: [a, b]       (长度 2)row 1: [c, d, e, f] (长度 4)row 2: [g]          (长度 1)row 3: [h, i, j]    (长度 3)按长度排序后:row 1: [c, d, e, f]row 3: [h, i, j, *]row 0: [a, b, *, *]row 2: [g, *, *, *]JDS 存储:jds_ptr:  [0, 4, 7, 9, 10]  // 每&quot;对角线&quot;的起始位置col_idx:  [1列索引...]values:   [c, h, a, g, d, i, b, e, j, f]perm:     [1, 3, 0, 2]      // 行重排映射\n优势\n\n短行集中在后面，减少填充浪费\n前面的迭代负载均衡更好\n\n缺点\n\n需要额外的行重排数组\n结果需要按原顺序写回\n\n分块格式\nBSR（Block Sparse Row）\n把矩阵分成小块（如 4×4），用 CSR 存储块：\n原始矩阵 (8×8):[A, 0, B, 0]     A, B, C, D 是 2×2 块[0, C, 0, D]BSR 表示（块大小 2×2）:block_row_ptr: [0, 2, 4]block_col_idx: [0, 2, 1, 3]block_values:  [A的4个值, B的4个值, C的4个值, D的4个值]\n优势\n\n减少索引开销：每个块只需一个 (行, 列) 索引\n提高缓存利用：块内数据连续\n利用密集计算：块内可以用密集矩阵乘法\n\n适用场景\n物理仿真中的多自由度系统（每个节点多个自由度），自然形成块结构。\n格式选择指南\n决策树\n              ┌─────────────────┐              │    稀疏矩阵      │              └────────┬────────┘                       │              ┌────────▼────────┐              │ 行长度差异大？   │              └────────┬────────┘             是        │        否        ┌──────────────┼──────────────┐        │              │              │┌───────▼───────┐      │      ┌───────▼───────┐│ HYB 或 JDS     │      │      │ ELL           │└───────────────┘      │      └───────────────┘                       │              ┌────────▼────────┐              │ 有块结构？      │              └────────┬────────┘             是        │        否        ┌──────────────┼──────────────┐        │              │              │┌───────▼───────┐      │      ┌───────▼───────┐│ BSR            │      │      │ CSR           │└───────────────┘      │      └───────────────┘\n格式对比\n\n\n\n格式\n构建难度\n空间效率\nSpMV 性能\n适用场景\n\n\n\n\nCOO\n容易\n中\n差\n构建阶段\n\n\nCSR\n中\n好\n中\n通用\n\n\nELL\n中\n差-中\n好\n均匀行长\n\n\nHYB\n复杂\n中\n好\n不均匀\n\n\nBSR\n复杂\n好\n很好\n块结构\n\n\n\n格式转换\nCOO 到 CSR\nvoid coo_to_csr(int m, int nnz, int *coo_row, int *coo_col,                 float *coo_val, int *csr_row_ptr, int *csr_col,                 float *csr_val) &#123;    // 1. 统计每行元素数    for (int i = 0; i &lt; nnz; i++) &#123;        csr_row_ptr[coo_row[i] + 1]++;    &#125;        // 2. 前缀和得到行指针    for (int i = 0; i &lt; m; i++) &#123;        csr_row_ptr[i + 1] += csr_row_ptr[i];    &#125;        // 3. 填充列索引和值    int *temp = calloc(m, sizeof(int));    for (int i = 0; i &lt; nnz; i++) &#123;        int row = coo_row[i];        int pos = csr_row_ptr[row] + temp[row];        csr_col[pos] = coo_col[i];        csr_val[pos] = coo_val[i];        temp[row]++;    &#125;&#125;\n并行转换\n利用前面学的技术：\n\n统计：并行直方图\n前缀和：并行扫描\n分配：原子操作或前缀和确定位置\n\ncuSPARSE 库\n基本使用\n#include &lt;cusparse.h&gt;void spmv_cusparse(int m, int n, int nnz,                   int *row_ptr, int *col_idx, float *values,                   float *x, float *y) &#123;    cusparseHandle_t handle;    cusparseCreate(&amp;handle);        // 创建矩阵描述符    cusparseSpMatDescr_t matA;    cusparseCreateCsr(&amp;matA, m, n, nnz,                      row_ptr, col_idx, values,                      CUSPARSE_INDEX_32I, CUSPARSE_INDEX_32I,                      CUSPARSE_INDEX_BASE_ZERO, CUDA_R_32F);        // 创建向量描述符    cusparseDnVecDescr_t vecX, vecY;    cusparseCreateDnVec(&amp;vecX, n, x, CUDA_R_32F);    cusparseCreateDnVec(&amp;vecY, m, y, CUDA_R_32F);        // 分配临时空间    float alpha = 1.0f, beta = 0.0f;    size_t bufferSize;    cusparseSpMV_bufferSize(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,                            &amp;alpha, matA, vecX, &amp;beta, vecY,                            CUDA_R_32F, CUSPARSE_SPMV_ALG_DEFAULT,                            &amp;bufferSize);        void *buffer;    cudaMalloc(&amp;buffer, bufferSize);        // 执行 SpMV    cusparseSpMV(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,                 &amp;alpha, matA, vecX, &amp;beta, vecY,                 CUDA_R_32F, CUSPARSE_SPMV_ALG_DEFAULT, buffer);        // 清理    cusparseDestroySpMat(matA);    cusparseDestroyDnVec(vecX);    cusparseDestroyDnVec(vecY);    cudaFree(buffer);    cusparseDestroy(handle);&#125;\ncuSPARSE 特性\n\n\n\n功能\n说明\n\n\n\n\nSpMV\n稀疏矩阵-向量乘\n\n\nSpMM\n稀疏矩阵-密集矩阵乘\n\n\nSpGEMM\n稀疏矩阵-稀疏矩阵乘\n\n\n三角求解\n稀疏三角矩阵求解\n\n\n格式转换\nCOO/CSR/CSC/BSR 互转\n\n\n矩阵分析\n着色、重排序\n\n\n\n性能优化总结\n内存访问优化\n\n值和列索引：CSR 中这两者通常连续访问，合并良好\nx 向量：间接访问，考虑用纹理缓存\n列主序 ELL：保证同一 Warp 的线程访问连续\n\n负载均衡\n\n分行策略：短行用少线程，长行用多线程\n分块处理：把非零元素均匀分配给线程块\n动态调度：运行时根据行长度分配资源\n\n减少开销\n\n合并迭代：多次 SpMV 之间不必来回拷贝\n重用分析结果：矩阵结构不变时，analysis 只做一次\n混合精度：索引用 int32，值用 fp16/bf16\n\n小结\n第十四章深入讲解稀疏矩阵：\n存储格式：COO（简单）、CSR（通用）、ELL（规则）、BSR（块结构）。选择取决于矩阵特性和操作类型。\nCSR SpMV：最常用。每行一线程简单但负载不均；每行一 Warp 更均衡但需要规约。自适应策略根据行长度选择。\nELL SpMV：列主序存储保证合并访问。适合行长度相近的矩阵。\n格式转换：COO → CSR 用前缀和确定位置。并行转换利用直方图和扫描。\ncuSPARSE：生产环境首选。提供多种格式和操作，自动选择最优算法。\n稀疏矩阵是科学计算的基础。掌握格式选择和 SpMV 优化，就能高效处理图算法、物理仿真、机器学习中的大规模稀疏数据。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 14\n第十四章：稀疏矩阵计算\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","CSR格式","稀疏矩阵","SpMV"]},{"title":"PMPP-第十章：归约和最小化发散","url":"/posts/43b40d12/","content":"前言\n第九章学习了直方图计算，使用原子操作处理输出冲突。本章学习归约（Reduction）——把一组数据&quot;归约&quot;成一个值，例如求和、求最大值。归约操作看似简单，实际涉及并行算法的核心问题：如何高效地合并部分结果？如何避免分支发散？如何最大化硬件利用率？第十章系统讲解这些优化技术。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\n归约基础\n什么是归约\n归约：用一个二元结合运算把 N 个元素合并成 1 个值。\n常见归约操作：\n\n\n\n操作\n运算符\n单位元\n示例\n\n\n\n\n求和\n+\n0\n1+2+3+4 = 10\n\n\n求积\n×\n1\n1×2×3×4 = 24\n\n\n最大值\nmax\n-∞\nmax(1,5,3,2) = 5\n\n\n最小值\nmin\n+∞\nmin(1,5,3,2) = 1\n\n\n逻辑与\n&amp;&amp;\ntrue\ntrue &amp;&amp; false = false\n\n\n逻辑或\n||\nfalse\ntrue || false = true\n\n\n位与\n&amp;\n~0\n0b1100 &amp; 0b1010 = 0b1000\n\n\n位或\n|\n0\n0b1100 | 0b1010 = 0b1110\n\n\n\n结合律是关键：(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)\n有了结合律，就能任意分组并行计算。\n串行归约\nfloat sum_sequential(float *data, int n) &#123;    float sum = 0;    for (int i = 0; i &lt; n; i++) &#123;        sum += data[i];    &#125;    return sum;&#125;\n时间复杂度 O(n)，无法利用并行性。\n并行归约的思路\n树形归约：\nLevel 0: [a0, a1, a2, a3, a4, a5, a6, a7]Level 1: [a0+a1, a2+a3, a4+a5, a6+a7]Level 2: [a0+a1+a2+a3, a4+a5+a6+a7]Level 3: [a0+a1+a2+a3+a4+a5+a6+a7]\n每层把元素数减半，log₂N 层后得到结果。\n时间复杂度：O(log N) 步，每步 O(N/2^k) 次操作\n工作量：总操作数 = N/2 + N/4 + … + 1 = N - 1（与串行相同）\n并行度：第 k 层需要 N/2^k 个并行操作\n朴素并行归约\n相邻配对\n最直观的并行化：相邻元素配对求和\n__global__ void reduce_naive(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x + threadIdx.x;        // 加载到共享内存    sdata[tid] = (i &lt; n) ? g_data[i] : 0;    __syncthreads();        // 树形归约    for (int stride = 1; stride &lt; blockDim.x; stride *= 2) &#123;        if (tid % (2 * stride) == 0) &#123;            sdata[tid] += sdata[tid + stride];        &#125;        __syncthreads();    &#125;        // 写回结果    if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n问题：分支发散\n看这个条件：if (tid % (2 * stride) == 0)\nLevel 0 (stride=1)：线程 0,2,4,6… 活跃，1,3,5,7… 空闲\nLevel 1 (stride=2)：线程 0,4,8… 活跃\nLevel 2 (stride=4)：线程 0,8… 活跃\nWarp 内有的线程活跃、有的空闲 = 分支发散！\nWarp 必须串行执行两个分支，效率减半。\n问题：Bank 冲突\nsdata[tid] 和 sdata[tid + stride] 的访问模式：\n\nstride=1：线程 0 访问 [0,1]，线程 2 访问 [2,3]…（无冲突）\nstride=16：线程 0 访问 [0,16]，线程 32 访问 [32,48]…\n\nstride 是 2 的幂时，可能产生 Bank 冲突。\n优化 1：交错配对\n改进思路\n把&quot;空闲线程在右边&quot;改成&quot;空闲线程在后面&quot;：\n朴素：线程 0,2,4,6 活跃，1,3,5,7 空闲交错：线程 0,1,2,3 活跃，4,5,6,7 空闲\n这样，活跃线程是连续的，前几个 Warp 满载，最后的 Warp 才逐渐空闲。\n实现\n__global__ void reduce_interleaved(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x + threadIdx.x;        sdata[tid] = (i &lt; n) ? g_data[i] : 0;    __syncthreads();        // 交错归约    for (int stride = blockDim.x / 2; stride &gt; 0; stride &gt;&gt;= 1) &#123;        if (tid &lt; stride) &#123;            sdata[tid] += sdata[tid + stride];        &#125;        __syncthreads();    &#125;        if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n分析\nLevel 0 (stride=128)：线程 0-127 活跃\nLevel 1 (stride=64)：线程 0-63 活跃\nLevel 2 (stride=32)：线程 0-31 活跃（恰好一个 Warp）\n前几层有多个完整 Warp 同时工作，分支发散只在最后几层出现。\n性能提升：约 2× 相比朴素版本。\n优化 2：首次加载时归约\n观察\n每个线程只加载一个元素，但 Block 数可能远多于 SM 数。如果让每个线程加载多个元素并在加载时求和，可以减少 Block 数，提高效率。\n实现\n__global__ void reduce_first_add(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * (blockDim.x * 2) + threadIdx.x;        // 首次加载时就求和两个元素    float sum = 0;    if (i &lt; n) sum += g_data[i];    if (i + blockDim.x &lt; n) sum += g_data[i + blockDim.x];    sdata[tid] = sum;    __syncthreads();        // 后续归约    for (int stride = blockDim.x / 2; stride &gt; 0; stride &gt;&gt;= 1) &#123;        if (tid &lt; stride) &#123;            sdata[tid] += sdata[tid + stride];        &#125;        __syncthreads();    &#125;        if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n扩展：Grid-Stride 加载\n让每个线程加载多个元素：\n__global__ void reduce_grid_stride(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x + threadIdx.x;    int gridSize = blockDim.x * gridDim.x;        // Grid-stride 累加    float sum = 0;    while (i &lt; n) &#123;        sum += g_data[i];        i += gridSize;    &#125;    sdata[tid] = sum;    __syncthreads();        // 树形归约    for (int stride = blockDim.x / 2; stride &gt; 0; stride &gt;&gt;= 1) &#123;        if (tid &lt; stride) &#123;            sdata[tid] += sdata[tid + stride];        &#125;        __syncthreads();    &#125;        if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n优势：\n\nBlock 数量可以固定（如 256），不随数据量变化\n每线程做更多有效工作，分摊同步开销\n更好的指令级并行\n\n优化 3：展开最后 Warp\n观察\n当 stride &lt; 32 时，只有一个 Warp 在工作。Warp 内线程自动同步（SIMT），不需要 __syncthreads()！\n实现\n__device__ void warpReduce(volatile float *sdata, int tid) &#123;    sdata[tid] += sdata[tid + 32];    sdata[tid] += sdata[tid + 16];    sdata[tid] += sdata[tid + 8];    sdata[tid] += sdata[tid + 4];    sdata[tid] += sdata[tid + 2];    sdata[tid] += sdata[tid + 1];&#125;__global__ void reduce_warp_unroll(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x * 2 + threadIdx.x;        sdata[tid] = 0;    if (i &lt; n) sdata[tid] += g_data[i];    if (i + blockDim.x &lt; n) sdata[tid] += g_data[i + blockDim.x];    __syncthreads();        // 常规归约（stride &gt;= 64）    for (int stride = blockDim.x / 2; stride &gt; 32; stride &gt;&gt;= 1) &#123;        if (tid &lt; stride) &#123;            sdata[tid] += sdata[tid + stride];        &#125;        __syncthreads();    &#125;        // Warp 内展开（stride &lt; 32）    if (tid &lt; 32) &#123;        warpReduce(sdata, tid);    &#125;        if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n关键点\nvolatile：告诉编译器不要优化掉对 sdata 的读写，确保每次都访问共享内存。\n隐式同步：Warp 内的 32 个线程执行相同指令，自动保持同步。\n性能提升：减少 5 次 __syncthreads() 调用。\n优化 4：完全展开\n当 Block 大小已知时\n如果 Block 大小是编译时常量（如 256），可以完全展开循环：\ntemplate &lt;unsigned int blockSize&gt;__global__ void reduce_complete_unroll(float *g_data, float *g_result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockSize * 2 + threadIdx.x;        sdata[tid] = 0;    if (i &lt; n) sdata[tid] += g_data[i];    if (i + blockSize &lt; n) sdata[tid] += g_data[i + blockSize];    __syncthreads();        // 编译时展开    if (blockSize &gt;= 512) &#123;        if (tid &lt; 256) sdata[tid] += sdata[tid + 256];        __syncthreads();    &#125;    if (blockSize &gt;= 256) &#123;        if (tid &lt; 128) sdata[tid] += sdata[tid + 128];        __syncthreads();    &#125;    if (blockSize &gt;= 128) &#123;        if (tid &lt; 64) sdata[tid] += sdata[tid + 64];        __syncthreads();    &#125;        // Warp 内展开    if (tid &lt; 32) &#123;        volatile float *smem = sdata;        if (blockSize &gt;= 64) smem[tid] += smem[tid + 32];        if (blockSize &gt;= 32) smem[tid] += smem[tid + 16];        if (blockSize &gt;= 16) smem[tid] += smem[tid + 8];        if (blockSize &gt;= 8)  smem[tid] += smem[tid + 4];        if (blockSize &gt;= 4)  smem[tid] += smem[tid + 2];        if (blockSize &gt;= 2)  smem[tid] += smem[tid + 1];    &#125;        if (tid == 0) &#123;        g_result[blockIdx.x] = sdata[0];    &#125;&#125;\n启动\n// 根据 Block 大小选择模板实例switch (blockSize) &#123;    case 512: reduce_complete_unroll&lt;512&gt;&lt;&lt;&lt;grid, 512, 512*sizeof(float)&gt;&gt;&gt;(...); break;    case 256: reduce_complete_unroll&lt;256&gt;&lt;&lt;&lt;grid, 256, 256*sizeof(float)&gt;&gt;&gt;(...); break;    case 128: reduce_complete_unroll&lt;128&gt;&lt;&lt;&lt;grid, 128, 128*sizeof(float)&gt;&gt;&gt;(...); break;    // ...&#125;\n优势：编译器可以完全展开循环，消除循环开销和分支。\n优化 5：Warp Shuffle\n现代方法\n从 Kepler 架构开始，CUDA 提供 Warp Shuffle 指令，线程可以直接交换寄存器值，无需共享内存：\n__device__ float warpReduceSum(float val) &#123;    for (int offset = 16; offset &gt; 0; offset /= 2) &#123;        val += __shfl_down_sync(0xffffffff, val, offset);    &#125;    return val;&#125;\n完整实现\n__global__ void reduce_shuffle(float *g_data, float *g_result, int n) &#123;    int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x + threadIdx.x;    int gridSize = blockDim.x * gridDim.x;        // Grid-stride 累加    float sum = 0;    while (i &lt; n) &#123;        sum += g_data[i];        i += gridSize;    &#125;        // Warp 内归约（shuffle）    sum = warpReduceSum(sum);        // Warp 间归约    __shared__ float warpSums[32];  // 最多 32 个 Warp    int lane = tid % 32;    int wid = tid / 32;        if (lane == 0) &#123;        warpSums[wid] = sum;    &#125;    __syncthreads();        // 第一个 Warp 做最终归约    if (wid == 0) &#123;        sum = (tid &lt; blockDim.x / 32) ? warpSums[lane] : 0;        sum = warpReduceSum(sum);                if (tid == 0) &#123;            g_result[blockIdx.x] = sum;        &#125;    &#125;&#125;\nShuffle 函数\n\n\n\n函数\n功能\n\n\n\n\n__shfl_sync\n从指定 lane 获取值\n\n\n__shfl_up_sync\n从低 lane 获取值\n\n\n__shfl_down_sync\n从高 lane 获取值\n\n\n__shfl_xor_sync\n与 XOR 偏移的 lane 交换\n\n\n\n优势：\n\n不需要共享内存\n延迟比共享内存低\n无 Bank 冲突\n\n多级归约\n单 Block 不够\n如果数据量超过单 Block 能处理的范围，需要多级归约：\nLevel 1: 每个 Block 归约自己的部分 → gridDim 个部分和Level 2: 再启动一个 Kernel 归约这些部分和...重复直到只剩一个值\n实现\nvoid reduce_multi_level(float *d_data, float *d_result, int n) &#123;    int blockSize = 256;    int numBlocks = (n + blockSize * 2 - 1) / (blockSize * 2);        float *d_partial;    cudaMalloc(&amp;d_partial, numBlocks * sizeof(float));        // Level 1    reduce_kernel&lt;&lt;&lt;numBlocks, blockSize, blockSize * sizeof(float)&gt;&gt;&gt;        (d_data, d_partial, n);        // 后续 Level    while (numBlocks &gt; 1) &#123;        int n_next = numBlocks;        numBlocks = (n_next + blockSize * 2 - 1) / (blockSize * 2);                reduce_kernel&lt;&lt;&lt;numBlocks, blockSize, blockSize * sizeof(float)&gt;&gt;&gt;            (d_partial, d_partial, n_next);    &#125;        // 拷贝最终结果    cudaMemcpy(d_result, d_partial, sizeof(float), cudaMemcpyDeviceToHost);    cudaFree(d_partial);&#125;\n优化：原子累加\n如果只需要最终和，可以用原子操作避免多级：\n__global__ void reduce_atomic(float *g_data, float *g_result, int n) &#123;    // ... 常规 Block 内归约 ...        if (tid == 0) &#123;        atomicAdd(g_result, sdata[0]);  // 直接累加到结果    &#125;&#125;\n注意：需要先将 g_result 初始化为 0。\n分支发散深入分析\n发散的代价\n当 Warp 内线程走不同分支时：\nif (condition) &#123;    doA();  // 部分线程&#125; else &#123;    doB();  // 其他线程&#125;\n硬件执行：\n\n所有线程执行 doA()，不满足条件的线程结果被丢弃\n所有线程执行 doB()，满足条件的线程结果被丢弃\n总时间 = doA() + doB()\n\n发散程度影响性能：\n\n\n\n发散比例\n性能影响\n\n\n\n\n0/32\n无影响\n\n\n1/32\n几乎无影响\n\n\n16/32\n约 50% 性能\n\n\n按 Warp 边界\n无发散\n\n\n\n最小化发散的策略\n1. 让条件按 Warp 对齐\n// 差：混合发散if (tid % 2 == 0) &#123; ... &#125;// 好：Warp 内无发散if (tid &lt; 128) &#123; ... &#125;  // 前 4 个 Warp vs 后 4 个 Warp\n2. 用算术替代分支\n// 有分支if (a &gt; b) result = a;else result = b;// 无分支result = (a &gt; b) * a + (a &lt;= b) * b;// 更好：用内置函数result = max(a, b);\n3. 预先分离数据\n// 差：运行时分支if (data[i] &gt; threshold) processA();else processB();// 好：预处理分离// Kernel 1: 分离数据// Kernel 2: 批量处理 A 类// Kernel 3: 批量处理 B 类\n归约中的发散控制\n朴素 vs 交错的对比：\n朴素 (stride=1):  Warp 0: threads 0,2,4,...,30 活跃（16个）  ↪ 每个 Warp 都有 50% 发散交错 (stride=128):  Warp 0-3: 全部活跃  Warp 4-7: 全部空闲  ↪ 没有 Warp 内发散！\n性能对比\n以 2²⁴（约1600万）个单精度浮点数求和为例：\n\n\n\n优化版本\n带宽利用率\n相对性能\n\n\n\n\n朴素相邻配对\n4%\n1×\n\n\n交错配对\n8%\n2×\n\n\n首次加载归约\n16%\n4×\n\n\n展开最后线程束\n25%\n6×\n\n\n完全展开\n40%\n10×\n\n\n+ 线程束 Shuffle\n60%\n15×\n\n\n\n测试环境：\n\nGPU：NVIDIA RTX 3090（10496 CUDA 核心）\n数据量：16,777,216 个 float（64MB）\n块大小：256线程\n\n带宽利用率达到60%已经很高——剩余开销来自核函数启动、同步等不可避免的开销。\n其他归约操作\n最大值/最小值\n__device__ float warpReduceMax(float val) &#123;    for (int offset = 16; offset &gt; 0; offset /= 2) &#123;        val = max(val, __shfl_down_sync(0xffffffff, val, offset));    &#125;    return val;&#125;\n带索引的最大值\n返回最大值及其位置：\n__device__ void warpReduceArgMax(float &amp;val, int &amp;idx) &#123;    for (int offset = 16; offset &gt; 0; offset /= 2) &#123;        float other_val = __shfl_down_sync(0xffffffff, val, offset);        int other_idx = __shfl_down_sync(0xffffffff, idx, offset);        if (other_val &gt; val) &#123;            val = other_val;            idx = other_idx;        &#125;    &#125;&#125;\n点积\n两个向量的点积 = 逐元素乘法 + 求和归约：\n__global__ void dotProduct(float *a, float *b, float *result, int n) &#123;    extern __shared__ float sdata[];        int tid = threadIdx.x;    int i = blockIdx.x * blockDim.x + threadIdx.x;        float sum = 0;    while (i &lt; n) &#123;        sum += a[i] * b[i];        i += blockDim.x * gridDim.x;    &#125;    sdata[tid] = sum;    __syncthreads();        // 归约    // ...&#125;\nCUB 库\n为什么用库\n手写归约容易出错，且难以覆盖所有优化。NVIDIA 的 CUB 库提供高度优化的实现：\n#include &lt;cub/cub.cuh&gt;void reduceWithCub(float *d_data, float *d_result, int n) &#123;    // 确定临时存储大小    void *d_temp = nullptr;    size_t temp_bytes = 0;    cub::DeviceReduce::Sum(d_temp, temp_bytes, d_data, d_result, n);        // 分配临时存储    cudaMalloc(&amp;d_temp, temp_bytes);        // 执行归约    cub::DeviceReduce::Sum(d_temp, temp_bytes, d_data, d_result, n);        cudaFree(d_temp);&#125;\nCUB 提供的归约\n\n\n\n函数\n功能\n\n\n\n\nDeviceReduce::Sum\n求和\n\n\nDeviceReduce::Max\n最大值\n\n\nDeviceReduce::Min\n最小值\n\n\nDeviceReduce::ArgMax\n最大值及索引\n\n\nDeviceReduce::ArgMin\n最小值及索引\n\n\nDeviceReduce::Reduce\n自定义操作符\n\n\n\nBlock 级归约\n#include &lt;cub/cub.cuh&gt;__global__ void myKernel(float *data, float *result) &#123;    typedef cub::BlockReduce&lt;float, 256&gt; BlockReduce;    __shared__ typename BlockReduce::TempStorage temp_storage;        float val = data[threadIdx.x];    float sum = BlockReduce(temp_storage).Sum(val);        if (threadIdx.x == 0) &#123;        result[blockIdx.x] = sum;    &#125;&#125;\n小结\n第十章系统讲解了并行归约：\n树形归约：log N 步完成，但朴素实现有严重的分支发散和 Bank 冲突。\n交错配对：让活跃线程连续，消除 Warp 内发散。这是最关键的优化。\n首次加载归约：Grid-stride loop 让每线程处理多个元素，减少 Block 数和同步开销。\n展开优化：利用 Warp 内隐式同步，消除最后几层的 __syncthreads()。完全展开进一步消除循环开销。\nWarp Shuffle：现代 GPU 的利器，直接交换寄存器，无需共享内存。\n分支发散：按 Warp 边界划分条件，用算术替代分支，是通用的发散最小化技术。\nCUB 库：生产环境优先使用库，它集成了所有优化且经过充分测试。\n归约是并行计算的基础模式，卷积的边界处理、直方图的最终合并、神经网络的 Softmax 都用到。下一章学习前缀和——另一个基础且强大的并行原语。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 10\n第十章：归约和最小化发散\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","归约","分支发散","并行算法"]},{"title":"PMPP-第四章：计算架构和调度","url":"/posts/bd5d1d6/","content":"前言\n前三章打下了基础：第一章理解&quot;为什么使用 GPU&quot;，第二章学会&quot;如何编写核函数&quot;，第三章掌握&quot;多维数据处理&quot;。但到目前为止，我们只是在使用 GPU，还未深入理解其内部机制。第四章开始深入 GPU 内部——硬件架构如何影响性能，线程如何被调度执行，代码性能差异的根本原因。理解这些硬件细节，才算真正入门 GPU 编程。\n\n📦 配套资源：本系列文章配有完整的 GitHub 仓库，包含每章的练习题解答、CUDA 代码实现和详细注释。所有代码都经过测试，可以直接运行。\n\nGPU架构概览\n流式多处理器（SM）\nGPU并不是一个巨大的处理器，而是由多个**流式多处理器（Streaming Multiprocessor, SM）**组成的阵列。每个SM是相对独立的执行单元，可以同时运行多个线程块。\n以NVIDIA Ampere架构（如RTX 3080）为例：\n\n\n\n组件\n数量/规格\n\n\n\n\nSM数量\n68\n\n\n每SM CUDA核心\n128\n\n\n每SM最大线程\n1536\n\n\n每SM最大Block\n16\n\n\n共享内存\n每SM 128KB可配置\n\n\nL2缓存\n5MB\n\n\n\n不同架构参数不同，但核心思想相同：大量小核心并行工作。\nSM内部结构\n每个SM包含：\n\nCUDA核心：执行整数和单精度浮点运算\nTensor核心：专用矩阵运算（深度学习加速）\n特殊功能单元（SFU）：执行sin/cos/exp等超越函数\n加载/存储单元（LD/ST）：处理内存访问\nWarp调度器：调度线程执行\n寄存器文件：快速存储，每SM约64KB\n共享内存：block内共享的可编程缓存\n\n关键认识：SM是资源池，多个block共享这些资源。block分配多少资源，决定了SM能同时运行几个block。\n线程块到SM的映射\n启动kernel时，runtime负责将线程块分配到各SM：\nkernel&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(args);         ↓运行时分配：Block 0→SM0, Block 1→SM2, Block 2→SM1, ...\n关键规则：\n\n每个block只在一个SM上执行，不会跨SM\n一个SM可以同时执行多个block（资源允许的话）\nBlock之间没有执行顺序保证\nBlock一旦开始执行，会运行到结束\n\n这种设计的好处：block完全独立，硬件可以自由调度，适应不同规模的GPU。\n线程束（Warp）：执行的基本单位\n什么是线程束\n线程束（Warp）是32个连续线程组成的执行单位。这是 NVIDIA GPU 的核心设计，理解线程束就理解了 GPU 执行模型的一半。\n块（Block）包含256个线程├── 线程束 0：线程 0-31├── 线程束 1：线程 32-63├── 线程束 2：线程 64-95├── 线程束 3：线程 96-127├── 线程束 4：线程 128-159├── 线程束 5：线程 160-191├── 线程束 6：线程 192-223└── 线程束 7：线程 224-255\n为什么是32个？硬件设计决定的。每个 SM 有一定数量的计算单元，32是效率最优的分组大小。\nSIMT 执行模型\nGPU 采用 SIMT（Single Instruction Multiple Thread，单指令多线程） 模型：\n\n同一线程束内的32个线程，在同一时钟周期执行相同指令\n但操作不同的数据（不同的寄存器）\n类似 SIMD，但更灵活（线程可以有独立状态）\n\n举例：\nC[i] = A[i] + B[i];\n线程束中的32个线程同时执行&quot;加法&quot;指令：\n线程束 0 执行：线程 0：C[0] = A[0] + B[0]  ─┐线程 1：C[1] = A[1] + B[1]   │ 同一条 add 指令...                         │ 同一时钟周期线程 31：C[31] = A[31] + B[31]─┘\n硬件只需取一次指令，就能完成32个操作。这就是 GPU 高吞吐的来源。\n线程束调度\n每个 SM 有多个线程束调度器（如 Ampere 架构有4个）。每个时钟周期，调度器选择一个就绪的线程束发射指令：\n周期1：线程束调度器0选择线程束3，发射 add 指令周期2：线程束调度器0选择线程束7，发射 load 指令周期3：线程束调度器0选择线程束0，发射 mul 指令...\n关键：线程束之间是独立调度的。如果线程束3在等待内存数据，调度器可以切换到线程束7执行，避免浪费时钟周期。\n控制流发散：性能杀手\n什么是分支发散\n当warp内的线程走不同分支时，就发生控制流发散（Control Divergence）：\nif (threadIdx.x &lt; 16) &#123;    // 分支A    A[i] = ...;&#125; else &#123;    // 分支B    B[i] = ...;&#125;\n问题来了：32个线程必须执行相同指令，但这里线程0-15需要执行分支A，线程16-31需要执行分支B。怎么办？\n硬件如何处理\nGPU采用谓词执行（Predicated Execution）：\n\n所有线程先执行分支A，但只有满足条件的线程写入结果\n再执行分支B，只有不满足条件的线程写入结果\n\n实际执行序列:Step 1: 执行分支A（线程0-15活跃，16-31抑制）Step 2: 执行分支B（线程0-15抑制，16-31活跃）\n代价：两个分支都被执行，时间翻倍。如果有n个分支，最坏情况性能降为1/n。\n性能影响量化\n场景1：无发散\nint i = blockIdx.x * blockDim.x + threadIdx.x;C[i] = A[i] + B[i];  // 所有线程执行相同操作\n100%效率，理想情况。\n场景2：warp内发散\nif (threadIdx.x % 2 == 0) &#123;    C[i] = A[i] + B[i];&#125; else &#123;    C[i] = A[i] * B[i];&#125;\n每个warp一半执行加法，一半执行乘法。效率约50%。\n场景3：warp间无发散\nif (threadIdx.x &lt; 32) &#123;  // warp 0整体走这边    C[i] = A[i] + B[i];&#125; else &#123;                  // warp 1-7整体走这边    C[i] = A[i] * B[i];&#125;\n每个warp内部不发散，效率接近100%。\n核心原则：分支发散只在warp内部有开销。让同一warp的线程走相同分支，就不损失性能。\n避免发散的技巧\n技巧1：按warp边界划分任务\n// 差：奇偶分支，warp内发散if (threadIdx.x % 2 == 0) &#123; taskA(); &#125;else &#123; taskB(); &#125;// 好：按warp划分，warp间分工if (threadIdx.x / 32 == 0) &#123; taskA(); &#125;  // warp 0else &#123; taskB(); &#125;                         // 其他warp\n技巧2：重组数据\n如果必须处理不同类型的元素，可以先排序，让同类元素落在同一warp。\n// 原始：type分布随机，每个warp都发散if (type[i] == 0) &#123; processType0(); &#125;else &#123; processType1(); &#125;// 优化：按type排序后处理，warp内type相同sort_by_type(data);  // 预处理kernel&lt;&lt;&lt;...&gt;&gt;&gt;(sorted_data);\n技巧3：用算术替代分支\n// 分支版本if (x &gt; 0) &#123; y = x; &#125;else &#123; y = -x; &#125;// 无分支版本（ReLU可以这样）y = x * (x &gt; 0);  // 利用布尔转int// 或用内置函数y = fabs(x);\n延迟隐藏：GPU的核心优化策略\n什么是延迟\n**延迟（Latency）**是指令从发出到完成需要的时钟周期：\n\n\n\n操作\n典型延迟\n\n\n\n\n算术运算\n4-8周期\n\n\n共享内存\n20-30周期\n\n\n全局内存\n200-400周期\n\n\n特殊函数(sin/exp)\n20-40周期\n\n\n\n全局内存访问是大头，400周期意味着读一次数据的时间可以做100次计算。\nGPU如何隐藏延迟\nCPU用复杂的乱序执行、预取来隐藏延迟。GPU用更简单粗暴的方法：大量线程+快速切换。\n时钟周期推演:周期1: Warp0发起load A[0]（需要400周期返回）周期2: Warp1发起load A[32]周期3: Warp2发起load A[64]...（继续切换执行其他warp）周期400: Warp0的数据到了，可以继续执行周期401: 切回Warp0执行计算\n只要有足够多的warp可以切换，计算单元就不会空闲。这就是延迟隐藏。\n延迟隐藏的数学\n假设：\n\n全局内存延迟400周期\n算术指令吞吐量1个/周期（每个调度器）\n每SM有4个调度器\n\n完全隐藏延迟需要的最小warp数：\n需要活跃warp数 = 延迟 / 吞吐量 = 400 / 1 = 400（每调度器）每SM需要 = 400 / 4 = 100 warp（理论最小值）\n实际上每SM最多64 warp（2048线程），所以全局内存延迟很难完全隐藏。这就是为什么要尽量用共享内存和寄存器。\n占用率（Occupancy）\n定义\n**占用率（Occupancy）**是&quot;SM上活跃warp数&quot;与&quot;SM最大支持warp数&quot;的比值：\n占用率 = 活跃Warp数 / SM最大Warp数\n例如，Ampere SM最多支持64 warp（2048线程）。如果实际有32 warp在运行：\n占用率 = 32 / 64 = 50%\n影响占用率的资源\n三大限制因素：\n1. 每block线程数\ndim3 block(1024);  // 每block 1024线程 = 32 warp// SM最多16 block，但...// SM最多2048线程，所以只能放2个这样的block// 活跃 = 2 × 32 = 64 warp，占用率100%dim3 block(64);    // 每block 64线程 = 2 warp// SM最多16 block，可以放16个// 活跃 = 16 × 2 = 32 warp，占用率50%\n2. 寄存器使用\n每SM寄存器数量有限（如65536个）。kernel用的寄存器越多，能同时运行的线程越少：\n假设kernel用64个寄存器/线程每SM可支持线程 = 65536 / 64 = 1024线程 = 32 warp占用率 = 32 / 64 = 50%假设kernel用32个寄存器/线程每SM可支持线程 = 65536 / 32 = 2048线程 = 64 warp占用率 = 100%\n3. 共享内存使用\n每SM共享内存有限（如96KB）。block用的共享内存越多，能同时运行的block越少：\n假设block用48KB共享内存每SM可运行block = 96 / 48 = 2个假设每block 256线程 = 8 warp活跃 = 2 × 8 = 16 warp占用率 = 16 / 64 = 25%\n计算占用率\n使用CUDA Occupancy Calculator或API：\n#include &lt;cuda_runtime.h&gt;int blockSize = 256;int minGridSize, gridSize;// 自动计算最优block大小cudaOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize,                                     myKernel, 0, 0);// 计算给定配置的占用率int numBlocks;cudaOccupancyMaxActiveBlocksPerMultiprocessor(&amp;numBlocks,                                                myKernel, blockSize, 0);int device;cudaGetDevice(&amp;device);cudaDeviceProp prop;cudaGetDeviceProperties(&amp;prop, device);float occupancy = (float)(numBlocks * blockSize) / prop.maxThreadsPerMultiProcessor;printf(&quot;占用率: %.2f%%\\n&quot;, occupancy * 100);\n占用率与性能\n高占用率不一定意味着高性能。这是常见误解。\n场景1：计算密集型kernel- 每线程用大量寄存器做复杂计算- 占用率可能只有25%- 但计算单元利用率高，性能好场景2：内存密集型kernel- 每线程操作简单，主要在读写内存- 需要高占用率来隐藏延迟- 50%占用率可能不够\n原则：\n\n内存受限kernel：提高占用率有帮助\n计算受限kernel：占用率够用就行，优先利用好计算资源\n最佳实践：从分析实际瓶颈入手，而不是盲目追求占用率\n\n资源限制汇总\n以Ampere架构为例：\n\n\n\n资源\n每SM限制\n每Block限制\n\n\n\n\n线程数\n2048\n1024\n\n\nBlock数\n16\n-\n\n\nWarp数\n64\n32\n\n\n寄存器\n65536\n65536\n\n\n共享内存\n可配置,最大164KB\n可配置,最大99KB\n\n\n\nBlock大小选择\n实用建议：\n\n128-256是安全起点：满足warp整数倍，不太大不太小\n必须是32的倍数：否则最后一个warp浪费线程\n考虑共享内存需求：block越大，共享内存分摊效率越高\n实测为王：最终还是要profile不同配置的性能\n\n// 不好：不是32的倍数dim3 block(100);  // 最后warp只有4个有效线程// 好：32的倍数dim3 block(128);  // 4个完整warp// 也好dim3 block(256);  // 8个完整warp\n编译器优化与调试\n查看寄存器使用\n编译时加--ptxas-options=-v：\nnvcc -O3 --ptxas-options=-v mykernel.cu -o mykernel\n输出：\nptxas info : Compiling entry function &#x27;mykernel&#x27;ptxas info : Function properties for mykernel    0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loadsptxas info : Used 32 registers, 336 bytes cmem[0]\n32个寄存器/线程，没有溢出到local memory。\n控制寄存器数量\n__global__ void __launch_bounds__(256, 4) myKernel(...) &#123;    // 提示编译器：每block 256线程，每SM至少4 block    // 编译器会据此优化寄存器分配&#125;\n或编译选项：\nnvcc -maxrregcount=32 mykernel.cu  # 限制每线程最多32寄存器\n权衡：限制寄存器可能导致溢出到local memory（很慢），需要平衡。\nNsight Compute分析\n使用NVIDIA的profiler分析实际瓶颈：\nncu --set full ./mykernel\n关注：\n\nWarp执行效率（分支发散）\n内存吞吐率\n计算吞吐率\n占用率\n\n这比猜测有效得多。\n实例分析：矩阵乘法的Block配置\n回顾第三章的矩阵乘法：\n__global__ void matMul(float *M, float *N, float *P, int width) &#123;    int row = blockIdx.y * blockDim.y + threadIdx.y;    int col = blockIdx.x * blockDim.x + threadIdx.x;        if (row &lt; width &amp;&amp; col &lt; width) &#123;        float sum = 0.0f;        for (int k = 0; k &lt; width; k++) &#123;            sum += M[row * width + k] * N[k * width + col];        &#125;        P[row * width + col] = sum;    &#125;&#125;\n配置选择：\n\n\n\nBlock大小\nWarp数\n分析\n\n\n\n\n8×8=64\n2\n太小，warp少，延迟隐藏不足\n\n\n16×16=256\n8\n合适，每SM可放多个block\n\n\n32×32=1024\n32\n接近限制，灵活性差\n\n\n\n16×16通常是二维问题的好选择。\n进一步优化（第5章会详细讲）：\n\n用共享内存做tiling\n减少全局内存访问\n算术强度从0.25提升到10+\n\n小结\n第四章揭示了GPU的内部机制：\n架构认识：SM是独立执行单元，多个block分配到SM共享资源。理解资源限制（寄存器、共享内存、线程数），就理解了为什么某些配置性能差。\nWarp本质：32线程一组，SIMT执行。所有优化都围绕warp展开——让warp内线程做相同的事（避免发散），让足够多的warp参与执行（隐藏延迟）。\n发散代价：控制流发散是性能杀手。按warp边界划分任务、用算术替代分支、重组数据，这些技巧很实用。\n延迟与占用率：高占用率帮助隐藏延迟，但不是越高越好。计算密集型kernel可能不需要那么高占用率。关键是分析实际瓶颈。\n调优思路：\n\nBlock大小选128-256，32的倍数\n检查寄存器使用，控制溢出\n用profiler分析，不要猜\n\n理解了这些硬件知识，第五章的共享内存（Shared Memory）优化就容易理解了。分块（Tiling）的本质就是利用共享内存减少全局内存访问，提高算术强度，充分利用计算单元。\n\n🚀 下一步\n\n📚 参考资料\n\nPMPP 第四版 Chapter 04\n第四章：计算架构和调度\n\n学习愉快！ 🎓\n\n\n本文 GitHub 仓库: https://github.com/psmarter/PMPP-Learning\n\n","categories":["知识分享"],"tags":["CUDA","GPU编程","并行计算","PMPP","GPU架构","Warp"]},{"title":"Python实战之Web开发-续","url":"/posts/71a5f1f6/","content":"用户账户\n用户添加主题\n在learning_log目录中创建forms.py文件，添加\nfrom django import formsfrom .models import Topicclass TopicForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating topics.&quot;&quot;&quot;    class Meta:        model = Topic        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field\n添加URL：path('new_topic/', views.new_topic, name='new_topic')\n创建视图函数new_topic\ndef new_topic(request):    &quot;&quot;&quot;Add a new topic.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = TopicForm()    else:        # POST data submitted; process data.        form = TopicForm(data=request.POST)        if form.is_valid():            new_topic = form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=new_topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_topic.html&#x27;, context)\n创建模板new_topic.html\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Add a new topic:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;\n链接到页面：&lt;a href = &quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt;\n代码解释：当用户在网页中点击 &lt;a href=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt; 这个链接时，浏览器会跳转到 /new_topic/。这个路径在 urls.py 中由 path('new_topic/', views.new_topic, name='new_topic') 映射到 views.new_topic 函数。\n当请求被送到这个视图函数时，Django 会调用 new_topic(request) 来处理。这个视图首先判断请求的方法是不是 POST。如果用户只是点击链接，还没提交表单，那么请求方法是 GET，程序会创建一个空的表单对象 form = TopicForm()，此时这个表单中没有预填数据，只是用于初次显示在网页上。\n如果用户已经在表单中输入了内容并点击了提交按钮，那么浏览器发送的是 POST 请求，此时视图就会执行 form = TopicForm(data=request.POST) 来从用户提交的数据构造一个表单实例。接着通过 form.is_valid() 检查数据是否合法（比如字段有没有漏填，格式是否正确）。如果验证通过，就执行 form.save()，这会自动创建一条新的 Topic 记录并保存到数据库中。接着用 redirect('learning_log:topic', topic_id=new_topic.id) 跳转到刚创建的主题详情页。\n不论是初次打开页面，还是提交失败（例如空表单或非法输入），视图最后都会调用 render(request, 'learning_log/new_topic.html', context) 来渲染模板，把表单对象传入 context 变量中。\n这个模板 new_topic.html 继承自 base.html，并在 &#123;% block content %&#125; 中放入了一段 HTML 表单。&lt;form action=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot; method=&quot;post&quot;&gt; 声明了该表单提交回自己；&#123;% csrf_token %&#125; 是 Django 要求添加的防跨站攻击标记；&#123;&#123; form.as_div &#125;&#125; 是将表单对象渲染为 HTML 元素。最后 &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt; 是提交按钮。\n添加条目\n代码如下\n# 新建formclass EntryForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating entries.&quot;&quot;&quot;    class Meta:        model = Entry        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field        widgets = &#123;&#x27;text&#x27;: forms.Textarea(attrs=&#123;&#x27;cols&#x27;: 80&#125;)&#125;  # Wider text area        # 添加URLpath(&#x27;new_entry/&lt;int:topic_id&gt;/&#x27;, views.new_entry, name=&#x27;new_entry&#x27;)# 添加视图def new_entry(request, topic_id):    &quot;&quot;&quot;Add a new entry for a particular topic.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = EntryForm()    else:        # POST data submitted; process data.        form = EntryForm(data=request.POST)        if form.is_valid():            new_entry = form.save(commit=False)            new_entry.topic = topic            new_entry.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic_id)    # Display a blank or invalid form.    context = &#123;&#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_entry.html&#x27;, context)\n&#123;# 新建模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Add a new entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Entry&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add a new entry&lt;/a&gt;    &lt;/p&gt;\n代码解释：这一套代码实现了在某个具体主题（Topic）下添加新学习内容（Entry）的功能。它包括一个基于模型的表单 EntryForm，用于生成输入框，主要针对 Entry 模型中的 text 字段，并通过 widgets 设置了一个宽一些的多行文本区域。URL 配置中使用了路径参数 &lt;int:topic_id&gt; 来标识具体主题，这样不同主题就能通过不同链接添加各自的学习记录。视图函数 new_entry 首先获取对应的 Topic 实例，然后根据请求方法判断是初次访问还是表单提交。如果是提交请求，就根据提交内容构造表单并校验，若通过验证，就先创建一个未保存的 Entry 实例，手动指定其 topic 属性，然后保存到数据库，并跳转回该主题的详情页。\n模板部分继承自基础模板 base.html，显示了当前主题的名称，并提供一个表单用于输入新条目。提交按钮下方还包含一个返回原主题页面的链接。最后那段 HTML 链接代码负责在主题详情页中显示“Add a new entry”按钮，点击即可跳转到添加页面。\n\n编辑条目\n代码如下\n# 添加URLpath(&#x27;edit_entry/&lt;int:entry_id&gt;/&#x27;, views.edit_entry, name=&#x27;edit_entry&#x27;)# 添加edit_entry函数def edit_entry(request, entry_id):    &quot;&quot;&quot;Edit an existing entry.&quot;&quot;&quot;    entry = Entry.objects.get(id=entry_id)    topic = entry.topic    if request.method != &#x27;POST&#x27;:        # Initial request; pre-fill form with the current entry.        form = EntryForm(instance=entry)    else:        # POST data submitted; process data.        form = EntryForm(instance=entry, data=request.POST)        if form.is_valid():            form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;entry&#x27;: entry, &#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/edit_entry.html&#x27;, context)\n&#123;# 添加html #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Edit entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Save Changes&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;&lt;li&gt;    &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;Edit entry&lt;/a&gt;    &lt;/p&gt;&lt;/li&gt;\n创建用户\n首先创建一个新的应用程序来管理账户相关的内容\npython .\\manage.py startapp accounts\n在INSTALLED_APPS中添加accounts，并包含accounts的URL：path('accounts/', include('accounts.urls'))\n在accounts中新建urls.py，添加以下内容\nfrom django.urls import path, includeapp_name = &#x27;accounts&#x27;urlpatterns = [    # Include the default auth URLs    path(&#x27;&#x27;, include(&#x27;django.contrib.auth.urls&#x27;)),]\n在templates中新建registration文件夹，添加login.html文件\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;  &#123;% if form.errors %&#125;    &lt;p&gt;Your username and password didn&#x27;t match. Please try again.&lt;/p&gt;  &#123;% endif %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Log in&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;\n随后在settings中添加成功登录后的重定向地址：LOGIN_REDIRECT_URL = 'learning_log:index'\n修改base.html如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt; -    &lt;a href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;Topics&lt;/a&gt; -     &#123;% if user.is_authenticated %&#125;        Hello, &#123;&#123; user.username &#125;&#125;! -        &#123;% else %&#125;        &lt;a href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;Log in&lt;/a&gt; -        &#123;% endif %&#125;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n此时就可以通过http://localhost:8000/accounts/login/来登录了，可以使用我们的管理员账号来测试（提前在管理界面退出）\n\n注销和注册用户\n注销账户\n在base.html中添加注销表单\n&#123;% if user.is_authenticated %&#125;  &lt;hr /&gt;  &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &lt;button name=&#x27;submit&#x27;&gt;Log out&lt;/button&gt;  &lt;/form&gt;&#123;% endif %&#125;\n如果账户登录，那么则在最下方显示一个注销按钮用于注销账户，注销后将页面链接到主页：LOGOUT_REDIRECT_URL = 'learning_log:index'\n注册账户\n# 添加URLpath(&#x27;register/&#x27;, views.register, name=&#x27;register&#x27;)# 创建视图函数def register(request):    &quot;&quot;&quot;Register a new user.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # Display blank registration form.        form = UserCreationForm()    else:        # Process completed form.        form = UserCreationForm(data=request.POST)        if form.is_valid():            new_user = form.save()            # Log the user in and then redirect to home page.            login(request, new_user)            return redirect(&#x27;learning_log:index&#x27;)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;registration/register.html&#x27;, context)\n&#123;# 创建模板 #&#125;&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Register&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接注册界面 #&#125;&lt;a href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register&lt;/a&gt; -\n当用户登录后，base.html 会显示一个“注销”按钮，它触发的是 accounts:logout 路由（即 Django 默认的登出视图），并通过 LOGOUT_REDIRECT_URL = 'learning_log:index' 设置注销后跳转回主页。\n对于注册功能，定义了一个新的 URL 路由 /accounts/register/，并在对应视图函数 register() 中使用 Django 提供的 UserCreationForm 构建注册表单。如果请求为 POST，则处理表单提交并保存用户数据，注册成功后自动登录该用户，并重定向到主页。否则显示一个空白或验证失败的注册表单。\n前端模板继承自 base.html，通过 &#123;% csrf_token %&#125; 加入安全标记，表单本体使用 &#123;&#123; form.as_div &#125;&#125; 渲染输入字段，点击“Register”按钮即可提交注册。\n创建用户数据\n在未登录的状态下，learning_log中的内容除了主页外，其余内容应该均不可访问，对此我们通过装饰器@login_required来限制未登录用户的访问，如果用户未登录，我们将其重定向到登录界面，在settings中添加LOGIN_URL = 'accounts:login'即可\n对于不同的用户，除了主页外，其他的内容应该只能访问自己的部分，我们将数据关联到用户，在Topic中添加owner = models.ForeignKey(User, on_delete=models.CASCADE)，将主题与用户关联。然后把数据库中的内容进行迁移，由于我们新增了owner字段，迁移时会提示我们选择哪一种方式，我们选择“1”让系统自动给我们添加一个默认值，然后将所有的内容迁移到管理账户中，即ID“1”\n\n虽然把主题全部与管理账户进行了关联，但是目前任何用户登录均可访问所有主题，在topics中添加topics = Topic.objects.filter(owner=request.user).order_by('date_added')，将不属于当前用户的所有Topic过滤掉，然后在topic和edit_entry中添加以下代码\nif topic.owner != request.user:    raise Http404\n从而防止用户通过网址直接访问他人的数据\n最后将新的topic关联到当前用户中，添加代码如下\nnew_topic = form.save(commit=False)new_topic.owner = request.usernew_topic.save()\n此时任何用户都可创建自己的账号并拥有自己独立的数据了\n样式更改\n我们的web已经具备基本的功能了，如创建主题、创建与之关联的条目，并且每个用户都有自己的数据而不必担心被其他人访问，但我们的界面还过于简陋，无法吸引用户，因此接下来我们将更改它的布局，使其更加美观\n首先安装django-bootstrap5，我们将使用其中的模板\npip install django-bootstrap5\n然后在INSTALLED_APPS中我们的应用和默认应用之间添加django_bootstrap5，接下来修改base.html\n&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Learning Log&lt;/title&gt;  &#123;% load django_bootstrap5 %&#125;  &#123;% bootstrap_css %&#125;  &#123;% bootstrap_javascript %&#125;&lt;/head&gt;&lt;body&gt;  &lt;nav class=&quot;navbar navbar-expand-md navbar-light bg-light mb-4 border&quot;&gt;    &lt;div class=&quot;container-fluid&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;          Learning Log&lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot;        data-bs-target=&quot;#navbarCollapse&quot; aria-controls=&quot;navbarCollapse&quot;        aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarCollapse&quot;&gt;        &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-md-0&quot;&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;              Topics&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt; &lt;!-- End of links on left side of navbar --&gt;        &lt;!-- Account-related links --&gt;        &lt;ul class=&quot;navbar-nav ms-auto mb-2 mb-md-0&quot;&gt;          &#123;% if user.is_authenticated %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;span class=&quot;navbar-text me-2&quot;&gt;Hello, &#123;&#123; user.username &#125;&#125;.                &lt;/span&gt;&lt;/li&gt;          &#123;% else %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;                  Register&lt;/a&gt;&lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;                  Log in&lt;/a&gt;&lt;/li&gt;          &#123;% endif %&#125;        &lt;/ul&gt; &lt;!-- End of account-related links --&gt;        &#123;% if user.is_authenticated %&#125;          &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;            &#123;% csrf_token %&#125;            &lt;button name=&#x27;submit&#x27; class=&#x27;btn btn-outline-secondary btn-sm&#x27;&gt;              Log out&lt;/button&gt;          &lt;/form&gt;        &#123;% endif %&#125;      &lt;/div&gt; &lt;!-- Closes collapsible parts of navbar --&gt;    &lt;/div&gt; &lt;!-- Closes navbar&#x27;s container --&gt;  &lt;/nav&gt; &lt;!-- End of navbar --&gt;  &lt;main class=&quot;container&quot;&gt;    &lt;div class=&quot;pb-2 mb-2 border-bottom&quot;&gt;      &#123;% block page_header %&#125;&#123;% endblock page_header %&#125;    &lt;/div&gt;    &lt;div&gt;      &#123;% block content %&#125;&#123;% endblock content %&#125;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;&lt;/html&gt;\n修改主页index.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;div class=&quot;p-3 mb-4 bg-light border rounded-3&quot;&gt;    &lt;div class=&quot;container-fluid py-4&quot;&gt;      &lt;h1 class=&quot;display-3&quot;&gt;Track your learning.&lt;/h1&gt;            &lt;p class=&quot;lead&quot;&gt;Make your own Learning Log, and keep a list of the      topics you&#x27;re learning about. Whenever you learn something new      about a topic, make an entry summarizing what you&#x27;ve learned.&lt;/p&gt;      &lt;a class=&quot;btn btn-primary btn-lg mt-1&quot;          href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register &amp;raquo;&lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;&#123;% endblock page_header %&#125;\n修改登录界面login.html的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% load django_bootstrap5 %&#125;&#123;% block page_header %&#125;  &lt;h2&gt;Log in to your account.&lt;/h2&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;% bootstrap_form form %&#125;    &#123;% bootstrap_button button_type=&quot;submit&quot; content=&quot;Log in&quot; %&#125;  &lt;/form&gt;&#123;% endblock content %&#125;\n修改页面topics的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;Topics&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;ul class=&quot;list-group border-bottom pb-2 mb-4&quot;&gt;    &#123;% for topic in topics %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;          &#123;&#123; topic.text &#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &#123;% empty %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;No topics have been added yet.&lt;/li&gt;    &#123;% endfor %&#125;  &lt;/ul&gt;  &lt;a href=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;&gt;Add a new topic&lt;/a&gt;&#123;% endblock content %&#125;\n修改页面topic条目的样式\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;&#123;&#123; topic.text &#125;&#125;&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add new entry&lt;/a&gt;  &lt;/p&gt;  &#123;% for entry in entries %&#125;    &lt;div class=&quot;card mb-3&quot;&gt;      &lt;!-- Card header with timestamp and edit link --&gt;      &lt;h4 class=&quot;card-header&quot;&gt;        &#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;        &lt;small&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;          edit entry&lt;/a&gt;&lt;/small&gt;      &lt;/h4&gt;      &lt;!-- Card body with entry text --&gt;      &lt;div class=&quot;card-body&quot;&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &#123;% empty %&#125;    &lt;p&gt;There are no entries for this topic yet.&lt;/p&gt;  &#123;% endfor %&#125;&#123;% endblock content %&#125;\n修改后的界面如下\n\n项目部署\n这部分内容主要就是把项目部署到远程服务器上，让其他人访问，全是配置，没啥意思，不搞了\n","categories":["Django开发"],"tags":["Python"]},{"title":"Python实战之Web开发","url":"/posts/1a56256/","content":"创建Django项目\n我使用Pycharm来创建Django项目，也可以自己手动创建虚拟环境等，配置如下，所有代码可点击这里查看\n\n运行，在浏览器输入http://localhost:8000/，显示如下表明项目创建正确\n\n创建应用程序\n终端输入python manage.py migrate创建数据库，用于将项目相关的信息存储，然后输入python manage.py startapp learning_log来创建应用程序，项目结构如下\n\n.venv/\n\nPython 虚拟环境目录。\n包含你项目安装的所有依赖（如 Django）。\n通常会在 .gitignore 中忽略它。\n\nmanage.py\n\n\n管理工具脚本，用于执行各种 Django 命令，如：\npython manage.py runserver      # 启动开发服务器python manage.py makemigrations # 创建迁移python manage.py migrate        # 应用迁移到数据库python manage.py createsuperuser # 创建管理员账户\n\n\n__init__.py\n\n让该目录成为 Python 包可为空\n\nsettings.py\n\nDjango 项目的配置文件\n包含数据库设置、应用注册、模板路径、静态文件配置、安全设置等\n\nurls.py\n\n\n项目级URL 路由入口\n\n\n将不同的 URL 请求分发给对应的 app 处理\n\n\n通常写法：\nfrom django.urls import path, includeurlpatterns = [    path(&#x27;admin/&#x27;, admin.site.urls),    path(&#x27;&#x27;, include(&#x27;learning_log.urls&#x27;)),  # 指向 app 的 url]\n\n\nwsgi.py\n\n用于部署到 WSGI 服务器\n生产环境使用\n\nasgi.py\n\n用于部署到 ASGI 服务器\n用于支持 WebSocket、异步视图\n\n__init__.py\n\n表示这是一个 Python 包\n\nadmin.py\n\n\n用于注册模型到 Django 管理后台（admin site）\n\n\n示例：\nfrom django.contrib import adminfrom .models import Entryadmin.site.register(Entry)\n\n\napps.py\n\n定义 app 的元信息，通常不需修改\n当你在 INSTALLED_APPS 中注册 app 时，这里也会用到\n\nmodels.py\n\n定义数据模型（Model）类\n每个模型对应数据库中的一张表\n\nviews.py\n\n视图函数，用来处理用户请求并返回响应\n例如返回 HTML 页面、JSON 数据等\n\ntests.py\n\n单元测试文件，可编写自动化测试\nDjango 内建测试框架基于 Python 的 unittest\n\nmigrations/\n\n\n自动生成的数据库迁移文件\n\n\n每当你修改模型（models.py）并运行：\npython manage.py makemigrations\n就会在此生成一个迁移脚本，用于记录数据库变更\n\n\ntemplates/\n\n存放 HTML 模板文件的目录\n用于 Django 的模板引擎渲染页面\n\n例如：\n你可以在 templates/ 中创建 index.html，然后在视图中渲染：\nfrom django.shortcuts import renderdef index(request):    return render(request, &#x27;index.html&#x27;)\ndb.sqlite3\n\n默认使用的 SQLite 数据库文件\n存储了你项目所有模型的数据内容\n\n\n\n\n文件/文件夹\n作用说明\n\n\n\n\n.venv/\n虚拟环境，包含依赖\n\n\nmanage.py\n管理命令脚本\n\n\nDjangoProject/settings.py\n项目配置\n\n\nDjangoProject/urls.py\nURL 路由入口\n\n\nDjangoProject/wsgi.py\n部署用 WSGI 接口\n\n\nlearning_log/\n自定义 app\n\n\nmodels.py\n定义数据库模型\n\n\nviews.py\n编写视图函数\n\n\nadmin.py\n注册后台模型\n\n\nmigrations/\n数据库变更记录\n\n\ntemplates/\nHTML 模板目录\n\n\ndb.sqlite3\nSQLite 数据库文件\n\n\n\n应用设置\n修改models.py文件如下\nfrom django.db import models# Create your models here.class Topic(models.Model):    &quot;&quot;&quot;A topic the user is learning about.&quot;&quot;&quot;    text = models.CharField(max_length=200)    date_added = models.DateTimeField(auto_now_add=True)    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        return self.text\n在settings.py的INSTALLED_APPS中添加learning_log，然后执行数据库迁移，如下\npython manage.py makemigrationspython manage.py migrate \n\n创建超级用户\n输入python manage.py createsuperuser来创建管理者，账户名、密码、邮箱自行设置，其中密码会被隐藏\n\n随后在admin.py文件中修改代码如下\nfrom django.contrib import adminfrom learning_log.models import Topic# Register your models here.admin.site.register(Topic)\n这段代码用于向管理网站注册Topic\n由于我在创建项目时没有勾选“启用Django admin”，因此这里需要对项目进行简单的更改\n\n\n将urls.py中注释的部分取消\n# from django.contrib import adminfrom django.urls import pathurlpatterns = [    #    path(&#x27;admin/&#x27;, admin.site.urls),]\n\n\n在settings.py的INSTALLED_APPS中添加django.contrib.admin\n\n\n访问http://localhost:8000/admin/，显示如下\n\n输入账户和密码，登录进去界面显示如下\n\nUser和Group是Django自动在管理网站添加的模型，而Topic是我们刚刚自己添加的。此时可以点击Topic，添加任意的主题\n定义Entry\n在models.py中添加如下代码\nclass Entry(models.Model):    &quot;&quot;&quot;Something specific learned about a topic.&quot;&quot;&quot;    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)    text = models.TextField()    date_added = models.DateTimeField(auto_now_add=True)    class Meta:        verbose_name_plural = &#x27;entries&#x27;    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        if len(self.text) &gt; 50:            return f&quot;&#123;self.text[:50]&#125;...&quot;        else:            return self.text\n这里主要说一下两个地方\n\n\ntopic = models.ForeignKey(Topic, on_delete=models.CASCADE)是将每一条 Entry 都关联一个 Topic，形成多对一的关系\n\n\n元信息配置（Meta）：默认 Django 会把模型名称小写加 “s” 做复数，这句是为了告诉 Django这个模型的复数名称设置为 entries，而不是默认的 Entrys\n\n\n由于修改了模型文件，因此我们需要再次迁移数据库，执行\npython manage.py makemigrations learning_logpython manage.py migrate \n然后在管理网站注册Entry：admin.site.register(Entry)（有关模型导入的问题这里不做叙述）\n进入管理网站后会发现多出了一个Entries条目，进入该条目，点击下拉框就可以选择对应的主题，如下图\n\n这时候我们就可以创建条目并将其与对应的主题相关联。不过，目前除了后台管理界面，我们还没任何可供用户访问的界面，下一步我们将尝试创建一个网页来让其他人访问\n创建网页\n使用Django创建网页主要分为三个步骤，定义URL、编写视图、编写模板，完成这三个部分的顺序通常无关紧要，每个人都可以按照个人喜好来实现\n映射URL\n当前http://localhost:8000返回默认的Django网站，下面进行修改，打开urls.py文件，在urlpatterns中添加path('', include('learning_log.urls')),表示我们导入应用learning_log中的url。然后在应用learning_log中添加urls.py文件，内容如下\nfrom django.urls import pathfrom . import viewsapp_name = &#x27;learning_log&#x27;urlpatterns = [    # Home page    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),]\n这段代码主要为当前 app 即（learning_log）配置 URL 路由，其中app_name = 'learning_log'，给这个 app 的 URL 配置一个命名空间，防止与其他 app 中的 URL 名称冲突，在模板中使用 &#123;% url 'learning_log:index' %&#125; 就能明确地调用这个 URL。urlpatterns 是 Django 查找 URL 的核心列表，每一个 path() 定义了一个 URL 与视图的映射。path('', views.index, name='index'),第一个参数是一个字符串用于正确的路由请求，这里表示匹配根路径，第二个参数表示当匹配到 / 时，调用 views.py 中的 index() 函数，第三个参数给这个 URL 取了一个名字叫 'index'，在模板中可以用 &#123;% url 'learning_log:index' %&#125; 来反向生成地址\n编写视图\n视图函数接受请求中的信息，准备好生成网页所需的数据，然后将其发送给浏览器。在前面我们调用了 views.py 中的 index() 函数，但该函数还未编写，打开views.py文件，添加代码如下\nfrom django.shortcuts import render# Create your views here.def index(request):    return render(request, &#x27;learning_log/index.html&#x27;)\n它接受一个 request 对象作为参数，这是 Django 在用户访问网页时自动传入的请求信息对象。函数的返回值是 render(request, 'learning_log/index.html')，表示让 Django 去找一个路径为 learning_log/index.html 的模板文件，并渲染它，默认的模板查找路径为app/templates/app_name/文件名.html\n编写模板\n模板定义网页的外观，每当访问网页时，Django都将填入相关的数据用于显示，我们的template文件夹位于根目录，所以无需在app目录中重新创建，但需要在settings.py的TEMPLATES中检查是否存在'DIRS': [BASE_DIR / 'templates']，以便正确检索html文件\n在template文件夹中创建learning_log文件夹并在其中创建index.html，添加代码如下\n&lt;p&gt;Learning Log&lt;/p&gt;&lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.&lt;/p&gt;\n这里添加了两个段落，运行访问界面如下\n\n创建其他网页\n创建父模板\n在index.html所在的目录中，创建一个base.html文件，这个模板将包含所有页面的通用元素，并将所有子模板都继承它，添加内容如下\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;\n&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;\n这段表示页面顶部的一个链接，点击后会跳转到名为 'learning_log:index' 的 URL 对应的页面。\n\n&#123;% url 'learning_log:index' %&#125; 是 Django 模板语言提供的 URL 反向解析标签。\n'learning_log' 是在 learning_log/urls.py 中定义的 app_name。\n'index' 是在 urlpatterns 中为首页设置的 name。\n\n所以最终这个标签会被渲染为：\n&lt;a href=&quot;/&quot;&gt;Learning Log&lt;/a&gt;\n如果将 index 页面映射到 /，那么这个链接就是返回首页的作用。\n&#123;% block content %&#125;&#123;% endblock content %&#125;\n这是 Django 模板语言中非常关键的部分，称为 模板块（template block），它用于定义“可扩展区域”。\n解释如下：\n\n&#123;% block content %&#125;` 是定义一个名为 `content` 的内容区块。\n- `&#123;% endblock content %&#125; 表示这个区块的结束。\n\n换句话说，子模板可以继承这个模板，并用自己的内容替换掉这个 block 区域，例如：\n&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;h2&gt;This is the home page!&lt;/h2&gt;&#123;% endblock content %&#125;\n创建子模板\n重写index.html文件，使其继承base.html，如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.    &lt;/p&gt;&#123;% endblock content %&#125;\n这里将index从base继承下来，使用&#123;% block content %&#125;`定义一个`content`并插入内容，使用`&#123;% endblock content %&#125;结束content块，里面内容将显示在界面上，此时通过修改父模板将修改所有继承它的界面，方便统一管理\n显示所有主题的页面\n首先定义URL，添加path('topics/',  views.topics, name='topics')，在视图中定义topics函数如下\ndef topics(request):    &quot;&quot;&quot;Show all topics.&quot;&quot;&quot;    topics = Topic.objects.order_by(&#x27;date_added&#x27;)    context = &#123;&#x27;topics&#x27;: topics&#125;    return render(request, &#x27;learning_log/topics.html&#x27;, context)\n将所有主题按照时间顺序排序并返回，然后创建topics.html，内容如下\n&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topics&lt;/p&gt;    &lt;ul&gt;        &#123;% for topic in topics %&#125;            &lt;li&gt;&#123;&#123; topic.text &#125;&#125;&lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No topics have been created yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;&#123;% endblock content %&#125;\n这里主要将topics中的内容通过无序列表的方式呈现出来。随后在base.html中添加连字符以及代码&lt;a href=&quot;&#123;% url 'learning_log:topics' %&#125;&quot;&gt;Topics&lt;/a&gt;，这将产生一个与Topics匹配的URL链接，访问http://localhost:8000/topics/，如下![image-20250712114413813](https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/Python实战之Web开发%2F2025-07-12-23-47-46-91b35a.png)\n显示特定主题\n我们已经创建了两次页面，对其基本流程应该有所了解了，后续关于URL、视图、模板相关的内容将进行简略，我们再次创建一个页面用于显示特定的主题及其所有的条目\n# URLpath(&#x27;topics/&lt;int:topic_id&gt;/&#x27;, views.topic, name=&#x27;topic&#x27;)# topic函数def topic(request, topic_id):    &quot;&quot;&quot;Show a single topic and all its entries.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    entries = topic.entry_set.order_by(&#x27;-date_added&#x27;)    context = &#123;&#x27;topic&#x27;: topic, &#x27;entries&#x27;: entries&#125;    return render(request, &#x27;learning_log/topic.html&#x27;, context)\n&#123;# 模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topic:&#123;&#123; topic.text &#125;&#125;&lt;/p&gt;        &lt;p&gt;Entries:&lt;/p&gt;    &lt;ul&gt;            &#123;% for entry in entries %&#125;            &lt;li&gt;                &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;                &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;            &lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No entries have been created for this topic yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% endblock content %&#125;\n在topic函数中先通过id获取到特定的主题，然后将主题中的条目降序排列，最后将Topic和Entries返回。模板主要把entries按照特定的格式显示，“|”表示过滤符，也就是将时间按照：January 1, 2025 23:00格式。linebreaks是将文本中的换行符转变为浏览器理解的内容。\n然后修改topics.html，将每个主题都映射为对应的链接\n&#123;% for topic in topics %&#125;    &lt;li&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic.text &#125;&#125;&lt;/a&gt;    &lt;/li&gt;\n运行之后在Topic页面点击主题，显示如下\n\n","categories":["Django开发"],"tags":["Python"]},{"title":"Python实战之外星人入侵《一》","url":"/posts/25297ba4/","content":"武装飞船\n由于不经常用Python写程序，最近在用Python写一个可视化工具时，惊觉发现自己的Python水平严重下滑，因此又重新拿起了《Python编程-从入门到实践》这本书。\n经过简单的复习，觉得还是有必要把书中的项目给练习一遍，同时也通过Blog记录一下我的实现过程，该篇文章以及后续系列将会讲解这本书中的“外星人入侵”项目，经过第十二、十三、十四章的阅读，我觉得在开始编程之前有必要先分析一下要实现的功能以及项目的整体架构，姑且就按照书上的顺序来吧。\n这里我们需要四个类，分别是主程序类AlienInvasion、子弹类Bullet、设置类Settings、飞船类Ship，主程序类主要用于初始化游戏界面，然后通过循环来更新游戏，子弹类和飞船类主要用于自身属性的初始化、显示和更新位置，设置类主要包含游戏的界面大小、飞船和子弹的移动速度等。整体结构大致如下\n\n游戏入口\n我的IDE是Pycharm，首先创建一个名为 Alien-Invasion-Project 并初始化了git仓库的项目，后续的所有开发代码都将放到我的Gitghub Alien-Invasion-Project 同名仓库中，有兴趣可以访问查看。这里我们首先安装开发需要用到的模块pygame，使用命令pip instal pygame即可，如下\n\n提示“Successfully ……”表明安装成功，也可使用书中的命令python -m pip install --user pygame来安装\n初步实现界面\n先创建一个alien_invasion.py文件，用来实现界面的初始化，然后创建AlienInvasion类，添加如下代码\nimport  pygameclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.screen = pygame.display.set_mode((800, 600))        pygame.display.set_caption(&quot;外星人来喽&quot;)    def run_game(self):        # 游戏主循环        while True:            passif __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\n这里我们通过pygame.init()来实现游戏环境的初始化，然后设置了一个800*600的游戏界面，再通过pygame.display.set_caption(&quot;外星人来喽&quot;)来设置游戏界面的Title，同时我们定义一个run_game函数用来进入游戏，这里添加了一个while的死循环，通过pass占位符来保持界面的显示，并在main里面完成游戏类的实例化和进入游戏中的循环，运行程序，如下图\n\n大致就是一个黑框框，里面什么都没有，由于我们只初始化了游戏界面的大小和标题，因此不会有其他的内容，同时各位应该也能注意到运行之后电脑很卡，这是因为我们在程序中添加了一个死循环，下面我们来对程序进行优化\n优化界面\n我们在其中添加事件处理程序来监听事件，首先导入系统模块sys，然后删除pass，在循环中添加如下代码\nfor event in pygame.event.get():    if event.type == pygame.QUIT:        pygame.quit()        sys.exit()\n这段程序表明我们一直在监听事件，如果有退出的事件发生，我们将调用pygame和系统的退出函数来结束游戏的运行，这时候运行代码，就不会卡了，同时点击X号也能正常退出\n下一步我们对游戏界面填充背景色，同时控制游戏的刷新的帧率\n添加成员变量bg_color，并在while循环中通过screen.fill()来绘制屏幕，然后使用pygame.display.flip()来使屏幕显示出来，运行结果如下\n\n帧率的控制主要通过限制循环中屏幕刷新的时间来实现，添加成员变量clock来定义时钟，然后在循环的末尾启动计时，我们这里设个90帧，代码如下\nclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.clock = pygame.time.Clock()        ……    def run_game(self):        # 游戏主循环        while True:            ……            # 控制游戏帧率            self.clock.tick(90)\n封装Settings类\n为了方便，我们可以把游戏设置相关的内容统一组织起来，放入单独的类中，比如屏幕大小，背景颜色等\n创建settings.py文件，并在其中添加Settings类，将屏幕大小，背景颜色甚至帧率等添加到类中，如下\nclass Settings:    def __init__(self):        self.screen_width = 800        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;\n在主程序创建Settings的实例，并用其中的属性替换掉原来的硬编码行为，这样便于我们理解和组织代码以及后续拓展开发\n创建Ship类\n这里我们要在游戏界面创建一个飞船，首先需要准备一张照片，创建文件夹imgs，将书中源码位置的图片复制到imgs下，并添加新文件ship.py，Ship类要加载图片显示，初始位置应当位于屏幕中心底部，并且支持左右移动，代码如下\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(&#x27;imgs/ship.bmp&#x27;)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += 3        if self.moving_left and self.rect.left &gt; 0:            self.x -= 3        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n突然发现写博客还是比较费时间的，这里就不过多解释了，完成Ship类之后就需要对主程序进行更改了，我们对原来的代码进行重构，因为要添加左右移动的消息，所以将while循环中的内容简化，尽可能的封装为函数模块，大致分为事件检测、事件执行、飞船更新、屏幕更新等\n事件检测：\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP:            self._check_keyup_events(event)\n判断消息类型，如果是退出，就结束游戏，如果是键盘按键按下或者是键盘按键松开，则执行对应的函数\n事件执行：\ndef _check_keydown_events(self, event):    &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = True    elif event.key == pygame.K_LEFT:        self.ship.moving_left = True    elif event.key == pygame.K_q:        pygame.quit()        sys.exit()\n如果键盘按下，则判断按下的是哪一个键，右键激活飞船的右移动标识，左键则激活左移动标识，如果是q键，同样执行退出，这是为了方便用户结束游戏而不用每次都点击右上角X号\ndef _check_keyup_events(self, event):    &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = False    elif event.key == pygame.K_LEFT:        self.ship.moving_left = False\n如果键盘松开，则根据松开的按键来结束对应的移动标识\n屏幕更新：\ndef _update_screen(self):    &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;    self.screen.fill(self.settings.bg_color)    self.ship.draw()    pygame.display.flip()\n综上，while循环目前应该包含的内容如下\nwhile True:    # 监听事件    self._check_events()    # 更新飞船位置    self.ship.update()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n运行\n\n这个时候我们的飞船就可以正常移动了\n创建Bullet类\n首先创建bullet.py文件，在其中创建Bullet类，为了便于管理子弹，我们采用群组的方式将其继承Sprite，Bullet类应当包含颜色、大小、速度等，同时绘制自身并更新位置，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        self.color = (60, 60, 60)        self.rect = pygame.Rect(0, 0, 3, 15)               self.speed = 4        self.rect.midtop = self.game.ship.rect.midtop()        self.y = float(self.rect.y)    def update(self):        self.y -= self.speed        self.rect.y = self.y    def draw(self):        pygame.draw.rect(self.game.screen, self.color, self.rect)\n更改主程序代码，以pygame.sprite.Group()的方式创建子弹群组，在按下键盘事件中添加空格的侦听，并添加发射子弹的函数，然后在主循环中添加更新子弹的函数，用于更新子弹的位置并删除超出屏幕的子弹，最后在刷新屏幕的函数中添加显示子弹的代码，主要添加内容如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)            def _fire_bullet(self):    &quot;&quot;&quot;发射子弹&quot;&quot;&quot;    if len(self.bullets) &lt; 6:        new_bullet = Bullet(self)        self.bullets.add(new_bullet)\n运行如下\n\n这样就可以正常发射子弹了。下面我们还需要对代码进行简单的修改，将子弹的相关配置放入Settings中\n代码优化\n跟设置相关的内容我们应该放在Settings类当中，同时尽可能的减少硬编码的行为，优化后的完整代码如下\nalien_invasion.py\nimport  pygameimport sysfrom settings import Settingsfrom ship import Shipfrom bullet import Bulletclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.settings = Settings()        self.clock = pygame.time.Clock()        self.screen = pygame.display.set_mode((self.settings.screen_width, self.settings.screen_height))        pygame.display.set_caption(self.settings.TITLE)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()    def run_game(self):        # 游戏主循环        while True:            # 监听事件            self._check_events()            # 更新飞船位置            self.ship.update()            # 更新子弹位置            self._update_bullets()            # 更新屏幕            self._update_screen()            # 控制游戏帧率            self.clock.tick(self.settings.FPS)    def _check_events(self):        &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)    def _check_keydown_events(self, event):        &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            pygame.quit()            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()    def _check_keyup_events(self, event):        &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    def _update_screen(self):        &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        for bullet in self.bullets.sprites():            bullet.draw()        self.ship.draw()        pygame.display.flip()    def _update_bullets(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.bullets.update()        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                self.bullets.remove(bullet)    def _fire_bullet(self):        &quot;&quot;&quot;发射子弹&quot;&quot;&quot;        if len(self.bullets) &lt; self.settings.bullet_limit:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)if __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()\nbullet.py\nimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 设置子弹的属性        self.color = self.game.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.game.settings.bullet_width, self.game.settings.bullet_height)        # 将子弹放在飞船的顶部        self.rect.midtop = self.game.ship.rect.midtop\t\t        # 子弹的y轴位置        self.y = float(self.rect.y)    def update(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.y -= self.game.settings.bullet_speed        self.rect.y = self.y    def draw(self):        &quot;&quot;&quot;绘制子弹&quot;&quot;&quot;        pygame.draw.rect(self.game.screen, self.color, self.rect)\nsettings.py\nclass Settings:    def __init__(self):        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;        self.screen_width = 1600        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;        # 飞船设置        self.ship_image_path = &#x27;imgs/ship.bmp&#x27;        self.ship_speed = 3        # 子弹设置        self.bullet_color = (60, 60, 60)        self.bullet_speed = 4        self.bullet_width = 3        self.bullet_height = 15        self.bullet_limit = 10\nship.py\nimport pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(self.game.settings.ship_image_path)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += self.game.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:            self.x -= self.game.settings.ship_speed        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《三》","url":"/posts/5821342e/","content":"添加Play按钮\n首先在Setting中添加如下代码\n# 按钮设置self.button_color = (0, 255, 0)self.button_width = 200self.button_height = 50self.button_text_color = (255, 255, 255)self.button_font = 48self.play_button_text = &quot;Play&quot;\n将按钮的相关属性加入到设置相关的类中，然后创建button.py文件，添加如下代码\nimport pygame.fontclass Button:    def __init__(self, game, msg):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.button_font)        self.rect = pygame.Rect(0, 0, self.game.settings.button_width, self.game.settings.button_height)        self.rect.center = self.game.screen.get_rect().center        self._pre_msg(msg)    def _pre_msg(self, msg):        &quot;&quot;&quot;将msg渲染为图像&quot;&quot;&quot;        self.msg_image = self.font.render(msg, True, self.game.settings.button_text_color, self.game.settings.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw(self):        &quot;&quot;&quot;绘制按钮&quot;&quot;&quot;        self.game.screen.fill(self.game.settings.button_color, self.rect)        self.game.screen.blit(self.msg_image, self.msg_image_rect)\n__init__()函数用于按钮的初始化，如按钮的大小、字体、位置等，_pre_msg()函数用于将字符串消息转换为图像并填充到矩形中，draw()函数用于绘制按钮\n接下来我们在主程序中将game_active设为False，从而为了显示按钮，然后添加按钮属性self.play_button = Button(self, self.settings.play_button_text)，接着在更新屏幕的地方判断如果游戏处于非活跃状态就显示按钮\nif not self.game_active:    self.play_button.draw()\n现在运行游戏\n\n开始游戏\n此时点击按钮并没有做出反应，因为我们还没有添加鼠标点击响应的事件，首先在_check_events中添加如下代码\nelif event.type == pygame.MOUSEBUTTONDOWN:    mouse_pos = pygame.mouse.get_pos()    self._check_play_button(mouse_pos)\n上述代码用于检测是否有鼠标按下，如果有则获取鼠标点击的位置，然后将变量传递给_check_play_button，现在我们添加该函数\ndef _check_play_button(self, mouse_pos):    &quot;&quot;&quot;响应Play按钮的点击事件&quot;&quot;&quot;    if self.play_button.rect.collidepoint(mouse_pos):        # 重置游戏状态        self.status.reset_status()        self.game_active = True        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 创建新的外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()\n一旦有点击事件的发生，我们就判断点击位置是否位于按钮中，如果是，则重置游戏状态并清空所有子弹和外星人，创建新的外星人和飞船，从而表明我们开启了新游戏，运行如下\n\n游戏优化\n当前游戏中还存在Bug，如果我们点击按钮所在区域，即便是按钮已经消失但仍会做出响应并重置游戏，因为我们的鼠标点击事件还会判断其点击位置与按钮位置重合，因此我们需要对判断做出优化\nif self.play_button.rect.collidepoint(mouse_pos) and not self.game_active:\n将_check_play_button函数中的if判断语句改为上述代码，从而防止其在游戏运行时仍会执行重置代码\n另外，玩游戏时我们应该将光标隐藏，在游戏结束时显示光标\n在_check_play_button的末尾添加pygame.mouse.set_visible(False)，游戏开始将光标隐藏，在_ship_hit的else块的末尾添加pygame.mouse.set_visible(True) ，游戏结束时将光标显示\n提升趣味性\n在Settings中添加如下代码\n    # 游戏速度设置    self.speed_scale = 1.1    self.init_settings()def init_settings(self):    &quot;&quot;&quot;初始化游戏的动态设置&quot;&quot;&quot;    self.ship_speed = 30    self.bullet_speed = 10    self.alien_speed = 10    self.alien_drop_speed = 10    self.alien_direction = 1def increase_speed(self):    &quot;&quot;&quot;提高游戏速度设置&quot;&quot;&quot;    self.ship_speed *= self.speed_scale    self.bullet_speed *= self.speed_scale    self.alien_speed *= self.speed_scale    self.alien_drop_speed *= self.speed_scale\nspeed_scale用于控制游戏增长的速度，init_settings用于初始化设置，increase_speed用于将相关参数增长从而提高游戏难度\n在_check_bullet_alien_collisions中，如果外星人全部被击落，我们就调用self.settings.increase_speed()增加游戏速度。当然每次开启新游戏时，应当将所有设置还原，在_check_play_button的if语块的第一行添加self.settings.init_settings()，这将使得新游戏的属性为初始化值\n记录分数\n在GameStatus中添加属性self.score = 0用于重置分数，在Settings中添加分数相关设置\n# 游戏分数设置self.score_text_color = (30, 30, 30)self.score_font = 48\n然后创建gamescore.py文件添加如下代码\nimport pygame.fontclass GameScore:    def __init__(self, game):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.score_font)        self.prep_score()    def prep_score(self):        &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;        score_str = str(self.game.status.score)        self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)        self.score_rect = self.score_image.get_rect()        self.score_rect.right = self.game.screen.get_rect().right - 20        self.score_rect.top = 20    def show_score(self):        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;        self.game.screen.blit(self.score_image, self.score_rect)\n在主程序中添加成员self.score = GameScore(self)，随后在更新屏幕函数中显示分数面板self.score.show_score()，此时运行游戏就能显示分数面板了\n更新得分\n在Settings的init_settings中添加self.alien_points = 50，用于表示每个外星人击落的初始得分，然后在主程序的_check_bullet_alien_collisions中添加\nif collisions:    for aliens in collisions.values():        self.status.score += self.settings.alien_points * len(aliens)    self.score.prep_score()\n表示每次击中一个外星人则对其进行加分，同时击落多个外星人也能同时记分，当然每次开始游戏我们也要重置分数，在_check_play_button中添加self.score.prep_score()，用新的分数来初始化记分面板\n对于不同速度的外星人，我们也应该增加其击落分数，在Settings中添加self.score_scale = 1.5表示外星人的分数增长速度，然后在increase_speed中添加self.alien_points = int(self.alien_points * self.score_scale)，更新新的外星人分数，最后再对分数进行取舍，在GameScore的prep_score中修改代码如下\ndef prep_score(self):    &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;    rounded_score = round(self.game.status.score, -1)    score_str = f&quot;&#123;rounded_score:,&#125;&quot;  # 使用逗号分隔千位    self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.score_rect = self.score_image.get_rect()    self.score_rect.right = self.game.screen.get_rect().right - 20    self.score_rect.top = 20\n表示我们通过round函数将分数取为10的整数倍，这样每个外星人的分数都是10的倍数了\n获取最高分\n在GameStatus添加新属性self.max_score = 0用来记录最高分，随后在GameScore中添加新函数\ndef prep_high_score(self):    &quot;&quot;&quot;将最高得分渲染为图像&quot;&quot;&quot;    high_score = round(self.game.status.max_score, -1)    high_score_str = f&quot;&#123;high_score:,&#125;&quot;    self.high_score_image = self.font.render(high_score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.high_score_rect = self.high_score_image.get_rect()    self.high_score_rect.centerx = self.game.screen.get_rect().centerx    self.high_score_rect.top = self.score_rect.top    def check_high_score(self):    &quot;&quot;&quot;检查是否达到了新的最高得分&quot;&quot;&quot;    if self.game.status.score &gt; self.game.status.max_score:        self.game.status.max_score = self.game.status.score        self.prep_high_score()\n这里将最高分渲染为图像并放置在屏幕正中央的上方，在__init__中调用prep_high_score，然后在show_score中将high_score_image显示出来，并在主程序中每当碰撞发生时就调用check_high_score判断当前分数是否超过了最高分，运行如下\n\n显示等级和飞船数\n在GameStatus的reset_status中添加self.level = 1，在GameScore的__init__添加函数self.prep_level()，代码如下\ndef prep_level(self):    &quot;&quot;&quot;将当前关卡渲染为图像&quot;&quot;&quot;    level_str = str(self.game.status.level)    self.level_image = self.font.render(level_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.level_rect = self.level_image.get_rect()    self.level_rect.right = self.score_rect.right    self.level_rect.top = self.score_rect.bottom + 10\n将等级渲染为图片并显示在得分的正下方，然后在show_score中添加self.game.screen.blit(self.level_image, self.level_rect)来显示图像，在主程序中清除所有外星人之后提升等级，代码如下\nif not self.aliens:    # 如果没有外星人了，重新创建外星人舰队    self._create_fleet()    self.bullets.empty()    self.settings.increase_speed()    # 提升关卡    self.status.level += 1    self.score.prep_level()\n最后在_check_play_button中重置等级，调用self.score.prep_level()即可，运行如下\n\n接下来我们要显示剩余飞船数，这里我们对飞船也要使用Sprite，更改Ship类如下\nclass Ship(Sprite):    def __init__(self, game):        super().__init__()\n将Ship继承自Sprite，在GameScore中添加函数prep_ships如下\ndef prep_ships(self):    &quot;&quot;&quot;显示剩余飞船数量&quot;&quot;&quot;    self.ships = Group()    for ship_number in range(self.game.status.ships_left):        ship = Ship(self.game)        ship.rect.x = 10 + ship_number * ship.rect.width        ship.rect.y = 10        self.ships.add(ship)\n这个函数用于根据剩余的飞船数量来创建飞船对象并调整位置，然后在初始化的函数中添加self.prep_ships()。下一步我们就要绘制飞船了，在show_score中添加self.ships.draw(self.game.screen)即可，然后在主程序的游戏开始和飞船被撞击的地方调用self.score.prep_ships()就能够正常加载和显示剩余飞船了，如下\n\n游戏Bug更改\n到上述部分我们就完成了书中的所有内容，但经过我的测试，这款游戏存在一定的Bug，看图\n\n是不是很奇怪？游戏还没有开始怎么就出现了一条横线？其实这是因为我们通过循环来侦听不同事件的发生，如果在游戏开始之前点击空格按钮，那么就会执行发射子弹的函数。但此时游戏状态并没有被激活，因此这条横线会停在这里，而且由于我们的子弹比较大，我们的飞船图像并不能完全遮盖子弹，所以就出现了这种现象，但从逻辑上来讲，如果我们不停按空格，程序应该每次都会执行空格所对应的响应，所以这里我们对其进行修改\ndef _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN and self.game_active:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP and self.game_active:            self._check_keyup_events(event)        elif event.type == pygame.MOUSEBUTTONDOWN:            mouse_pos = pygame.mouse.get_pos()            self._check_play_button(mouse_pos)\n上述代码主要增加了当键盘响应时游戏是否处于激活状态，如果游戏未激活则不响应任何按键，此时我们无论按键盘上的哪里，都不会再次出现上述的情况了，至此，该项目就完全结束了。源码访问点击这里\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Python实战之外星人入侵《二》","url":"/posts/153f977c/","content":"创建Alien类\n创建一个alien.py文件，并把书中源码的alien.bmp图片拷贝到我们的imgs文件夹中，代码如下\nimport pygamefrom pygame.sprite import Spriteclass Alien(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 加载外星人图片        self.image = pygame.image.load(&#x27;imgs/alien.bmp&#x27;)        self.rect = self.image.get_rect()        # 设置外星人初始位置        self.rect.x = self.rect.width        self.rect.y = self.rect.height        # 外星人当前的x轴位置        self.x = float(self.rect.x)\n创建Alien实例\n由于外星人通常是成批次出现，因此我们也要通过Sprite管理，如self.aliens = pygame.sprite.Group()，这里我们单独创建一个函数用于外星人的生成\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    self.aliens.add(alinen)\n然后在更新屏幕的函数中添加如下代码用于外星人在屏幕上的显示\nself.aliens.draw(self.screen)\n运行\n\n此时在屏幕的左上角已经出现了一个外星人\n创建Alien舰队\n上述我们在_create_fleet中只生成了一个外星人，下面进行修改来生成多行外星人，代码如下\ndef _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    alien_width = alinen.rect.width    alien_height = alinen.rect.height    current_x, current_y = alien_width, alien_height    # 计算屏幕可以容纳多少个外星人    while current_y &lt; (self.settings.screen_height - 3 * alien_height):        while current_x &lt; (self.settings.screen_width - 2 * alien_width):            self._create_alien(current_x, current_y)            current_x += 2 * alien_width        # 重置当前x位置，移动到下一行        current_y += 2 * alien_height        current_x = alien_widthdef _create_alien(self, current_x, current_y):    &quot;&quot;&quot;创建一个外星人&quot;&quot;&quot;    alien = Alien(self)    alien.x = current_x    alien.rect.x = current_x    alien.rect.y = current_y    self.aliens.add(alien)\n这里我们先生成一个实例，然后获取到它的宽度和高度并赋值为当前的x轴位置和y轴位置，内层循环用来生成一行外星人，从距离屏幕一个外星人的宽度开始，每隔一个外星人宽度创建一个实例，直到屏幕宽度不满足两个外星人的宽度为止，外层循环首先更新y轴位置，将其下移两个外星人的高度，然后初始化当前的x轴位置，再次创建一行，直到屏幕高度不满足三个外星人的高度位置为止，运行如下\n\n此时我们已经创建了一个外星人的舰队\n移动舰队\n在Setting中添加如下代码\n# 外星人设置self.alien_speed = 1self.alien_drop_speed = 10self.alien_direction = 1  # 1表示向右移动，-1表示向左移动\n分别表示外星人的水平速度、下降速度、水平方向\n然后在Alien中添加更新位置的函数\ndef update(self):    &quot;&quot;&quot;更新外星人位置&quot;&quot;&quot;    self.x += self.game.settings.alien_speed * self.game.settings.alien_direction    self.rect.x = self.x\n通过alien_direction来决定水平方向的移动，但这样只会让舰队朝着一个方向不停移动直到超出屏幕范围，在舰队即将到达屏幕边缘时，我们应该改变它的方向，让它朝着相反的方向移动，并下降一段距离。先添加边缘检测函数，如下\ndef check_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    screen_rect = self.game.screen.get_rect()    if self.rect.right &gt;= screen_rect.right or self.rect.left &lt;= 0:        return True    return False\n先获取屏幕大小，然后根据外星人所在的位置判断是否超出了屏幕边界，超了就返回True，否则返回就False\n随后我们在主程序添加检测函数，并在到达边缘时使其下降一段距离\ndef _check_fleet_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.check_edges():            self._change_fleet_direction()            breakdef _change_fleet_direction(self):    &quot;&quot;&quot;改变外星人舰队的方向&quot;&quot;&quot;    for alien in self.aliens.sprites():        alien.rect.y += self.settings.alien_drop_speed    self.settings.alien_direction *= -1\n对于每一个外星人我们都检测其是否超出了屏幕范围，然后改变所有外星人其移动方向，并下降一段距离，此时我们在更新外星人位置的函数中调用检测边界函数，运行结果如下\n\n射击外星人\n此时我们发射子弹，子弹并不能击落外星人，而是会直接穿过外星人，因为我们还没有做子弹和外星人的碰撞检测，下面我们来逐步实现这一过程\n检测子弹和外星人的碰撞\n要实现这个功能非常简单，我们只需要利用pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)这个函数即可，前两个参数分别表示子弹群组和外星人群组，后面两个参数表示碰撞后是否消失，True表明碰撞后子弹和外星人均消失。但这样还有个缺陷，就是我们把外星人全部击落之后，屏幕将没有外星人了，我们应该在打完所有外星人之后重新生成新的外星人舰队，代码如下\ndef _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)                self._check_bullet_alien_collisions()def _check_bullet_alien_collisions(self):    &quot;&quot;&quot;检查子弹与外星人碰撞&quot;&quot;&quot;    collisions = pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)    if not self.aliens:        # 如果没有外星人了，重新创建外星人舰队        self._create_fleet()        self.bullets.empty()\n我们在更新子弹的后面加入了调用检测碰撞的函数，并在所有外星人消失后重新生成新的外星人舰队，同时清除所有子弹，从而使我们继续游戏\n检测飞船和外星人的碰撞\n如果按照上述的逻辑，那么这个游戏将没有终止的时候，为此应该加入游戏结束的一些条件，比如我们的飞船和外星人发生了碰撞，在更新外星人的函数中添加代码如下\n# 检测外星人和飞船的碰撞if pygame.sprite.spritecollideany(self.ship, self.aliens):    print(&quot;飞船被外星人撞了！&quot;)\nspritecollideany(self.ship, self.aliens)函数接收一个精灵和一个编组，用于检测飞船是否有和外星人碰撞，如果发生碰撞，将打印&quot;飞船被外星人撞了！&quot;。通常来讲，我们不应当在飞船撞毁之后直接结束游戏，而是应该给予玩家多次机会，下面我们创建一个game_status.py文件，用于记录游戏信息，内容如下\nclass GameStatus:    def __init__(self, game):        &quot;&quot;&quot;初始化游戏状态&quot;&quot;&quot;        self.ships_left = None        self.game = game        self.reset_status()            def reset_status(self):        &quot;&quot;&quot;重置游戏状态&quot;&quot;&quot;        self.ships_left = self.game.settings.ship_limit\n同时在Settings中添加self.ship_limit = 3，表明飞船最多只有三次，ships_left则用来记录剩余的飞船数量\n下面我们对主程序进行修改，添加一个用于游戏状态表示的实例：self.status = GameStatus(self)，然后创建撞击后的响应函数，如下\ndef _ship_hit(self):    &quot;&quot;&quot;响应飞船被外星人撞击的事件&quot;&quot;&quot;    if self.status.ships_left &gt; 0:        # 减少剩余飞船数量        self.status.ships_left -= 1        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 重新创建外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()        # 暂停一段时间        sleep(1)    else:        print(&quot;游戏结束！&quot;)\n如果被撞击并且飞船数量大于0，则减少一个飞船数量并清空子弹和外星人，从而生成新的外星人和飞船。删除碰撞函数里print()函数，替换为_ship_hit()，并在Ship中添加如下函数\ndef center_ship(self):    &quot;&quot;&quot;将飞船放在屏幕底部中央&quot;&quot;&quot;    self.rect.midbottom = self.game.screen.get_rect().midbottom    self.x = float(self.rect.x)\n使新生成的飞船位于屏幕底部中心\n到达屏幕底部边缘\n如果外星人到达屏幕底部，我们同样应该跟碰撞一样响应，添加屏幕下边缘检测函数\ndef _check_alien_bottom(self):    &quot;&quot;&quot;检查外星人是否到达屏幕底部&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.rect.bottom &gt;= self.settings.screen_height:            self._ship_hit()            break\n检查每个外星人的底部是否超过了屏幕的高度，如果超过则调用_ship_hit()函数。在更新外星人的最后添加self._check_alien_bottom()，此时当外星人到达屏幕底部游戏也将重置\nGameOver\n细心一点可能会注意到，当我们死亡超过三次时，游戏仍然没有结束，事实上它永远也不会结束，因为我们在_ship_hit()函数中，当ships_left小于0时，只是调用了print(&quot;游戏结束！&quot;)，其他什么也没有做，因此ships_left只会越来越小，我们应该为其添加一个游戏标识，如果标识为False则终止某些部分的运行，从而实现游戏的结束。在主程序添加self.game_active = True，并将print(&quot;游戏结束！&quot;)替换为self.game_active = False，同时修改主循环如下\n# 游戏主循环while True:    # 监听事件    self._check_events()    if self.game_active:        # 更新飞船位置        self.ship.update()        # 更新子弹位置        self._update_bullets()        # 更新外星人位置        self._update_aliens()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)\n","categories":["Python实战之外星人入侵"],"tags":["Python"]},{"title":"Simulink调用外部Dll交互《三》","url":"/posts/ee275623/","content":"介绍\n本文主要实现了Simulink下模块化GUI与外部Dll数据交互的功能。首先将需要用到的交互接口封装，导出为C风格的函数，然后在模块中创建可视化界面并导入外部Dll，用于显示和操作数据，并在修改数据后通过接口保存到文件，如果成功，则与后续接口通信，调用求解器并显示结果\n导出交互接口\n// 参数交互EXPORT_API void LoadParametersFromIni(void* p, const char* filename);EXPORT_API int GetGlobalParameterCount(void* p);EXPORT_API const char* GetParameterName(void* p, int index);EXPORT_API double GetParameterValue(void* p, int index);EXPORT_API double GetParameterMin(void* p, int index);EXPORT_API double GetParameterMax(void* p, int index);EXPORT_API const char* GetParameterDescription(void* p, int index);EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath);\n//-------------参数交互用-------------------   EXPORT_API void LoadParametersFromIni(void* p, const char* filename) &#123;       if (!p || !filename) return;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       proc-&gt;LoadIniParametersToGlobalParameter(filename);  // 调用现有方法   &#125;   EXPORT_API int GetGlobalParameterCount(void* p) &#123;       if (!p) return 0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       return static_cast&lt;int&gt;(proc-&gt;m_vglobalParams.size());   &#125;   EXPORT_API const char* GetParameterName(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetName().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API double GetParameterValue(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetValue();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMin(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMin();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMax(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMax();       &#125;       return 0.0;   &#125;   EXPORT_API const char* GetParameterDescription(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetDescription().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath) &#123;       if (!p || !paramName || !projectPath) &#123;           return false;       &#125;       try &#123;           auto proc = static_cast&lt;CXXXProcessor*&gt;(p);           // 调用 C++ 类成员函数进行参数修改           return proc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);                   &#125;       catch (const std::exception&amp; e) &#123;           std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;           return false;       &#125;   &#125;\n这段代码主要是通过 C++ 的 EXPORT_API 宏将 CXXXProcessor 类的相关函数暴露为 API 接口，允许外部调用进行参数的读取、修改以及加载配置。\n1. EXPORT_API 宏\n每个函数前面都使用了 EXPORT_API 宏，这通常是为了将这些函数导出为 DLL 接口，让外部应用可以调用这些函数。这种做法常见于需要将 C++ 类和方法暴露给其他编程语言（如 Python 或 C#）的情况。EXPORT_API 一般在头文件中定义，并用来标记需要导出的函数。\n2. 参数校验\n在所有函数内部，第一步都是检查指针或参数是否为空或无效。例如：\nif (!p || !filename) return;\n这种做法可以确保在程序运行时避免因为传入无效参数而导致的崩溃，增强了代码的鲁棒性。\n3. static_cast 类型转换\n很多地方使用了 static_cast 来进行类型转换。比如：\nauto proc = static_cast&lt;CXXXProcessor*&gt;(p);\n这里 p 是一个 void* 类型的指针，指向 CXXXProcessor 类型的对象。static_cast 将 void* 转换成 CXXXProcessor* 类型，以便调用该类的成员函数。通过这种方式，可以在不暴露类内部实现的情况下，提供面向外部的 API 接口。\n4. 函数功能设计\n加载参数 (LoadParametersFromIni)\nproc-&gt;LoadIniParametersToGlobalParameter(filename);\n该函数的设计目的是加载指定的 .ini 配置文件，并将参数值导入到类内部的全局参数列表中。它的设计思想是将文件读取与内存中数据的存储解耦，便于后续的参数操作。\n参数获取函数\n包括：\n\nGetGlobalParameterCount：返回全局参数的数量。\nGetParameterName、GetParameterValue、GetParameterMin、GetParameterMax：返回指定参数的不同属性（名称、值、最小值、最大值）。\nGetParameterDescription：返回参数的描述信息。\n\n这些函数的设计方式非常直观，主要是通过访问类内部 m_vglobalParams 成员（一个存储参数的容器，如 std::vector）来返回相应的信息。每个函数都首先检查传入的索引是否有效，确保在访问数组或容器时不会越界。\n修改参数 (RewriteBWIIni_Param)\nproc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);\n此函数负责修改指定参数的值并将其更新回 .ini 配置文件中。它利用 CXXXProcessor 类中的现有方法 RewriteBWIIni_Param 来执行实际的修改操作。在设计上，这个函数有一个异常处理机制（try-catch 语句），用于捕获运行时可能出现的异常，防止程序崩溃。错误信息会通过 std::cerr 输出，便于调试。\n5. 数据封装与分离\n函数内部使用了 CXXXProcessor 类封装了所有参数相关的操作，外部调用者仅通过接口来操作这些数据。这样的封装设计符合面向对象编程（OOP）的原则，数据与操作方法分离，外部只关心接口而无需了解内部实现细节。\n\nm_vglobalParams 是存储所有全局参数的容器，封装了参数的读取、修改等操作。\nCXXXProcessor 类中提供了对参数的处理函数，如 LoadIniParametersToGlobalParameter 和 RewriteBWIIni_Param，而 API 函数仅暴露必要的接口给外部调用。\n\n6. 错误处理与返回值\n大多数函数都进行了参数校验和错误处理。比如 GetParameterName 和其他类似的获取参数信息的函数都返回 nullptr 或默认值（如 0.0），当输入无效时避免出现错误：\nif (!p || index &lt; 0) return nullptr;\nRewriteBWIIni_Param 函数则使用 try-catch 机制来捕获异常，确保在发生异常时能返回 false，并输出错误信息。\n7. 代码设计的一致性与可扩展性\n\n所有获取参数的函数（如 GetParameterName、GetParameterValue 等）具有一致的接口设计，参数索引作为输入，返回相关数据。这使得 API 易于扩展和维护，后期可以轻松增加更多的参数获取功能。\nRewriteBWIIni_Param 与加载参数的功能解耦，遵循了单一职责原则，使得每个函数都专注于自己的一部分工作，易于理解和测试。\n\nMatlab GUI实现\n将上个步骤的代码编译为Dll，并把其头文件、dll文件以及所有用到的其他dll拷贝到Matlab的运行环境下\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0        start_import_gui(block.BlockHandle);  % 传递块句柄给 GUI        block.Dwork(1).Data = 1;  % 设置 GUI 已启动标志    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        % 自动开始仿真，无需手动输入        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;  % 设置已启动标志    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            % 检查仿真是否正在运行，若正在运行则停止            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                % 如果仿真正在运行，取消仿真                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            % 如果没有仿真，或其他错误，则跳过            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(blockHandle)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.blockHandle = blockHandle;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end\n这段代码是一个用于在 Simulink 模型中调用自定义 S-Function 的实现，目的是在仿真过程中与图形用户界面 (GUI) 交互，导入和修改参数。\nS-Function 主体\n首先，sfun_callInterface 函数是 S-Function 的入口，调用了 setup 函数来进行初始化配置。setup 函数为 S-Function 设置了输入输出端口、采样时间、以及仿真相关的回调方法。\nsetup 函数\n在 setup 函数中，设置了 S-Function 的输入和输出端口配置。它没有输入端口，只有一个输出端口，并且输出的维度和数据类型进行了设定。该端口的采样模式为 Sample，表示输出数据为常规的样本数据。\n此外，SampleTimes 被设置为 [0 0]，这意味着该 S-Function 会立即执行并且不会进行周期性的采样。通过注册 PostPropagationSetup, InitializeConditions, Outputs, 和 Terminate 四个方法，定义了仿真生命周期内不同阶段的行为。\n最后，set_param 设置了 OpenFcn 触发，指向了 start_import_gui 函数，用于启动 GUI 界面。\nPostPropagationSetup 函数\n该函数用于声明 S-Function 中的 DWork（数据工作区）。DWork 是用来存储状态信息的地方。这里定义了三个 DWork 变量：\n\nguiLaunched 用于标识 GUI 是否已启动。\nconfirmationFlag 用于存储从 GUI 获取的确认状态。\nsimStarted 用于标记仿真是否已经启动。\n\n这些 DWork 变量的作用是确保 GUI 在需要时只启动一次，并且管理仿真状态，防止重复操作。\nInitCond 函数\nInitCond 函数在每次仿真开始时被调用，用来初始化 DWork 变量。在这里，所有的标志变量（guiLaunched, confirmationFlag, simStarted）都被初始化为 0，表示 GUI 尚未启动，确认标志为未设置，仿真尚未开始。\nOutputs 函数\nOutputs 函数是在仿真过程中持续被调用的，用来控制和更新仿真输出。首先，它获取了 GUI 启动状态、确认标志和仿真启动状态。如果 GUI 尚未启动，则调用 start_import_gui 函数启动 GUI 界面，并将 guiLaunched 标志设为 1。\n如果 GUI 已经启动，尝试从基础工作空间获取 confirmationFlag 变量的值。如果获取到有效值，则更新 DWork 中的 confirmationFlag。\n然后，函数检查确认标志的值：\n\n如果 confirmationFlag 为 1 且仿真尚未启动，则自动启动仿真，并将 simStarted 设为 1。\n如果 confirmationFlag 为 -1，表示取消，尝试停止正在运行的仿真。\n\nTerminate 函数\nTerminate 函数在仿真结束时调用，主要作用是清理基础工作空间中的标志变量 confirmationFlag，以防止在下次仿真中出现残留的状态信息。\nstart_import_gui 函数\nstart_import_gui 函数用于创建并显示 GUI 窗口。首先，它计算并设置窗口居中显示的坐标。然后，创建了一个图形界面，并在其中添加了以下元素：\n\n一个按钮用来触发数据导入。\n一个表格用来显示导入的数据。\n一个文本框用来显示当前选择的文件夹路径。\n“确认”和“取消”按钮，用来控制数据导入和取消操作。\n\n此外，在 GUI 初始化时加载了一个动态链接库（DLL），用于后续的参数导入和修改操作。\n调用Dll\n% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\nimport_data 函数\nimport_data 函数是在用户点击导入按钮时调用的。它弹出一个文件夹选择对话框，允许用户选择包含数据文件的文件夹。如果用户选择了文件夹并且其中包含 bwiparamtemp.ini 文件，程序会调用 DLL 函数读取该文件中的参数并将其显示在表格中。\nconfirm_action 函数\nconfirm_action 函数在用户点击“确认”按钮时被调用。它从表格中读取每个参数的名称和值，并将更新的参数通过 DLL 保存到指定路径的 .ini 文件中。如果参数值有变化，则执行更新操作。\n更新成功后，将 confirmationFlag 设置为 1，表示操作已完成，仿真可以开始。\ncancel_action 函数\ncancel_action 函数在用户点击“取消”按钮时调用。它将 confirmationFlag 设置为 -1，表示取消操作，然后关闭 GUI 窗口。\nclose_gui 函数\nclose_gui 函数用于关闭 GUI 窗口时调用。它会卸载已经加载的 DLL，并释放其他资源。\n总结\n这段代码实现了一个与 Simulink 模型交互的 GUI 系统，允许用户在仿真过程中导入和修改参数，启动或停止仿真。代码通过 S-Function 接口与 Simulink 仿真框架进行集成，并使用 MATLAB 图形界面元素提供用户交互界面。设计上使用了 DWork 数据工作区来存储和管理仿真状态，并通过回调函数实现不同阶段的功能。\n关于文件在不同运行环境下编码不同的问题\n\n其主要原因在于，Matlab的运行环境和Visual Studio不同，而封装的读写代码中用到了windows的API，该API会根据运行编译环境来选择不同的写入方式，而Matlab默认使用UTF-8，从而导致写入数据时中文出现乱码的情况，如下图\n\n如果不需要在多个环境下运行（如Unicode），我们可以固定写入方式，如读写均采用ANSI方式\nchar *CIniFile::ReadString(string &amp;m_Sec, string &amp;m_Ident, char *m_Def)&#123;\tGetPrivateProfileStringA(m_Sec.c_str(), m_Ident.c_str(), m_Def, Buffer, sizeof(Buffer), m_Name);\treturn Buffer;&#125;bool CIniFile::WriteString(const char *m_Sec, const char *m_Ident, const char *m_Val)&#123;\treturn (bool)WritePrivateProfileStringA(m_Sec, m_Ident, m_Val, m_Name);&#125;\n也可以使用开源替代库来替代原有的ini操作类，如SimpleIni，或者自己手动检测编码，手动写入，如下\nvoid CIniFile::detectEncoding() &#123;\tm_isUtf8 = false;\tm_hasUtf8BOM = false;\tunsigned char bom[3] = &#123; 0,0,0 &#125;;\tif (FILE* f = std::fopen(m_Name, &quot;rb&quot;)) &#123;\t\tstd::fread(bom, 1, 3, f);\t\tstd::fclose(f);\t\tif (bom[0] == 0xEF &amp;&amp; bom[1] == 0xBB &amp;&amp; bom[2] == 0xBF) &#123;\t\t\tm_isUtf8 = true;\t\t\tm_hasUtf8BOM = true;\t\t&#125;\t&#125;\t// 如果无 BOM：保守视为 MBCS/ANSI（如 GBK）；这样不会把老文件强转 UTF-8。&#125;bool CIniFile::saveInternal() &#123;\tif (!m_loaded) return false;\t// UTF-8 文件：是否写 BOM：保持与原文件一致\tconst bool addSig = (m_isUtf8 &amp;&amp; m_hasUtf8BOM);\t// 如果是 GB2312/GBK 编码，保存时不写 BOM\tif (!m_isUtf8) &#123;\t\tSI_Error rc = m_ini.SaveFile(m_Name, false); // No BOM for MBCS/ANSI\t\tif (rc &lt; 0) return false;\t&#125;\telse &#123;\t\t// 保存为 UTF-8 编码，并且根据原文件是否有 BOM 来决定是否加 BOM\t\tSI_Error rc = m_ini.SaveFile(m_Name, addSig);\t\tif (rc &lt; 0) return false;\t&#125;\tm_dirty = false;\treturn true;&#125;\n\n注意：如果非同一个项目，需要把所有用到的项目进行编译，并把运行需要的dll文件拷贝到Matlab环境下\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"Simulink调用外部Dll可视化《二》","url":"/posts/4e6df0d5/","content":"介绍\n这篇文章主要实现在Simulink中可视化的工作，由于自身求解工具的可视化代码采用C++编程，同时与项目耦合过多，难以独立摘出或通过Matlab重现，因此这里采用新建桥接工程将所有需要用到的可视化代码封装并导出\n封装Dll并导出C函数\n首先在VS中新建空项目工程并进行配置，主要是关于项目依赖、导出Dll相关，然后将所有可能用到的代码进行简化和封装，我这里采用的类进行管理，由于跟项目相关不进行展示，新建XXXBridgeDLL.h和XXXBridgeDLL.cpp用于导出C接口供Matlab调用，内容如下\n#pragma once#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    EXPORT_API void* CreateProcessor();    EXPORT_API void DeleteProcessor(void* p);    EXPORT_API int  ReadXXXDat(void* p, const char* folder, int* pNumPts);        EXPORT_API int   GetPointCount(void* p);                      /* 返回总点数         */    EXPORT_API int   CopyX_mm(void* p, double* out, int max);  /* 轴向坐标 (mm)     */    EXPORT_API int   CopyPower(void* p, double* out, int max);  /* 输出功率 (W)      */    EXPORT_API int   CopyGain(void* p, double* out, int max);  /* 增益 (dB)         */    EXPORT_API int   CopyEff(void* p, double* out, int max);  /* 效率 (%)          */#ifdef __cplusplus&#125;#endif\n这段代码是一个 C/C++ 动态链接库（DLL）的头文件（.h），用于定义向外部导出的一组函数接口。\n\nDLL 导出宏定义部分\n#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif\n\n作用：用于在不同编译阶段切换导出/导入。\n\n如果编译的是 DLL 本身（定义了 XXXBRIDGEDLL_EXPORTS），则 EXPORT_API 展开为 __declspec(dllexport)，导出符号；\n如果是使用 DLL 的客户端程序，则展开为 __declspec(dllimport)，用于导入符号。\n\n\n\n\nextern &quot;C&quot; 块\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif...#ifdef __cplusplus&#125;#endif\n\n使得这些函数按照 C语言方式 进行链接（不进行 C++ 名字改编 / name mangling），以便在 C/C++/Python/MATLAB 等跨语言调用时保持接口兼容。\n\n\n导出的函数接口\nEXPORT_API void* CreateProcessor();\n\n创建一个处理器对象，返回一个 void* 指针（通常是一个类的实例地址）。\n\nEXPORT_API void DeleteProcessor(void* p);\n\n删除处理器对象，释放资源。\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pNumPts);\n\n从指定文件夹读取数据，p 是处理器对象指针，folder 是数据路径，pNumPts 用于返回读取到的点数。\n\n\n数据访问函数（数据从内存复制出来）\nEXPORT_API int GetPointCount(void* p);\n\n获取数据点总数。\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max);\n\n复制轴向坐标数据（单位：mm）到 out 指针所指向的数组，max 是允许写入的最大点数。\n\nEXPORT_API int CopyPower(void* p, double* out, int max);\n\n复制输出功率数据（单位：瓦特）。\n\nEXPORT_API int CopyGain(void* p, double* out, int max);\n\n复制增益数据（单位：dB）。\n\nEXPORT_API int CopyEff(void* p, double* out, int max);\n\n复制电子效率数据（单位：百分比）。\n\n这个 DLL 接口提供了一个基于文件夹读取仿真结果（XXX仿真输出），并通过一系列函数获取：\n\n坐标（X）\n功率（Power）\n增益（Gain）\n效率（Eff）\n\n#define XXXBRIDGEDLL_EXPORTS#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125; extern &quot;C&quot; &#123;    EXPORT_API void* CreateProcessor() &#123; return new CXXXProcessor(); &#125;    EXPORT_API void  DeleteProcessor(void* p) &#123; delete static_cast&lt;CXXXProcessor*&gt;(p); &#125;    EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;        if (!p || !folder || !pts) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        bool ok = proc-&gt;ReadXXXDat(folder);        *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;        return ok;    &#125;    EXPORT_API int GetPointCount(void* p) &#123;        return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;    &#125;    EXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;        if (!p || !out || max &lt;= 0) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);        for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;        return n;    &#125;    EXPORT_API int CopyPower(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);    &#125;    EXPORT_API int CopyGain(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);    &#125;    EXPORT_API int CopyEff(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);    &#125;&#125;\n这段代码是 XXXBridgeDLL.dll 的 实现部分（C++源文件），与之前的头文件 XXXBridgeDLL.h 搭配使用，向外部程序提供接口来访问 XXX 仿真数据\n\n文件头部设置\n#define XXXBRIDGEDLL_EXPORTS\n\n定义此宏意味着当前正在编译 DLL，因此头文件中的 EXPORT_API 会变成 __declspec(dllexport)，导出接口。\n\n\n#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;\n\n引入头文件和 STL 库。CXXXProcessor 是处理器类，核心功能由它实现，接口只是封装。\n\n\n匿名命名空间 copyVector\nnamespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125;\n\n作用：通用的向 double* out 中复制数据的函数模板。\nSRC_GETTER 是一个 Lambda，返回某个 vector&lt;double&gt; 的引用。\n使用匿名命名空间是为了限定作用域（防止链接冲突）。\n\n\n导出接口（extern &quot;C&quot;）\n\nCreateProcessor\n\nEXPORT_API void* CreateProcessor() &#123;    return new CXXXProcessor();&#125;\n\n返回新建的处理器对象（指针以 void* 形式传出，保持 C 接口风格）。\n\n\nDeleteProcessor\n\nEXPORT_API void DeleteProcessor(void* p) &#123;    delete static_cast&lt;CXXXProcessor*&gt;(p);&#125;\n\n释放 CreateProcessor() 创建的对象。\n\n\nReadXXXDat\n\nEXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;    if (!p || !folder || !pts) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    bool ok = proc-&gt;ReadXXXDat(folder);    *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;    return ok;&#125;\n\n调用 CXXXProcessor::ReadXXXDat(folder) 加载文件夹中的数据。\n加载成功后将数据点数写入 pts。\nm_vdpX 是轴向坐标数组。\n\n\nGetPointCount\n\nEXPORT_API int GetPointCount(void* p) &#123;    return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;&#125;\n\n返回总的数据点数（坐标数量）。\n\n\nCopyX_mm\n\nEXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;    if (!p || !out || max &lt;= 0) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);    for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;    return n;&#125;\n\n将轴向坐标 m_vdpX（单位：米）转换为毫米（乘以 1000）并复制到 out 缓冲区。\n\n\nCopyPower, CopyGain, CopyEff\n\nEXPORT_API int CopyPower(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);&#125;\n\n通过 copyVector 模板复制 PowerOut 数据。\n\nEXPORT_API int CopyGain(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);&#125;\n\n复制增益（Gain）数据。\n\nEXPORT_API int CopyEff(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);&#125;\n\n复制效率（Eff）数据。\n\n\n模块用途概览\n\n\n\n函数名\n功能描述\n\n\n\n\nCreateProcessor\n创建处理器对象\n\n\nDeleteProcessor\n释放处理器对象\n\n\nReadXXXDat\n从指定目录读取 XXX 数据文件\n\n\nGetPointCount\n获取总数据点数\n\n\nCopyX_mm\n获取轴向坐标（单位 mm）\n\n\nCopyPower\n获取输出功率（单位 W）\n\n\nCopyGain\n获取增益（单位 dB）\n\n\nCopyEff\n获取电子效率（单位 %）\n\n\n\n编译成功后会在指定目录生成dll文件，把dll文件和导出函数头文件放到Matlab的工作目录下供其使用\nMatlab及Simulink调用Dll\n在Matlab中新建m文件，内容如下\n% 0. 环境与路径dll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);endp   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;% --- 指针缓冲区 ---xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);x    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;% --- 绘图 ---figure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);% --- 清理 ---calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n这段 MATLAB 代码演示了如何通过调用 C++ 动态链接库 XXXBridgeDLL.dll 来读取 XXX 仿真数据，并绘制输出功率、增益和效率随轴向位置变化的曲线\n\n1. 加载 DLL 与设置路径\ndll = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\\Matlab\\bin\\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);end\n\n设置 DLL 文件路径、头文件路径和数据文件夹路径。\n如果 DLL 尚未加载，则调用 loadlibrary 加载 DLL 并注册其接口函数。\n\n\n2. 创建处理器并读取数据\np   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;\n\n创建处理器实例 p（C++ 对象的指针）。\n申请一个 int32 类型的指针 nPt 用于返回数据点数量。\n调用 ReadXXXDat 从 dir 文件夹读取仿真数据。\n将数据点个数保存在 N 中。\n\n\n3. 分配输出缓冲区并复制数据\nxPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);\n\n为四类数据创建指针缓冲区，长度为 N。\n通过调用 DLL 中的接口函数将数据从 C++ 内部复制到 MATLAB 缓冲区中。\n\n\n4. 将指针值转换为 MATLAB 向量\nx    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;\n\n将指针对象中的数据取出，转换为 MATLAB 可用的数组。\n\n\n5. 绘制仿真结果曲线\nfigure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);\n\n打开一个新图像窗口，将三种数据绘制在三个子图中：\n\n输出功率 vs. 坐标\n增益 vs. 坐标\n效率 vs. 坐标\n\n\n\n\n6. 清理资源\ncalllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);\n\n释放处理器对象 p。\n卸载 DLL，释放系统资源。\n\n这段代码实现了：\n\n加载 DLL 并创建处理器。\n调用 C++ 函数读取 XXX 仿真数据。\n将结果复制到 MATLAB 并绘图。\n使用完后清理资源，避免内存泄漏。\n\n运行效果如下\n\n与求解工具链接\n现在的可视化模块只是通过硬编码的方式读取指定文件，下面需要把求解工具和可视化链接，通过求解工具输出的参数来进行泛型可视化\n修改现有的调用求解工具S Function代码\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\n这段代码是一个 Level-2 MATLAB S-Function，用于在 Simulink 中检测输入信号的 上升沿（从0变为1），然后异步启动一个外部 EXE 程序（XXX.exe），并轮询进程状态，完成后自动停止仿真。\n\n\n\n步骤\n说明\n\n\n\n\n①\n输入信号从 0 → 1，触发启动 XXX.exe\n\n\n②\n启动进程，记录 PID 和运行状态\n\n\n③\n每 0.5 秒轮询一次，判断进程是否结束\n\n\n④\n若 EXE 正常退出，则输出状态为 2，仿真停止；否则输出 -1 并停止\n\n\n⑤\n清理进程资源，防止残留\n\n\n\n\n调用工具代码解释\n\n顶部函数入口\n\nfunction sfun_callXXX(block)    setup(block);end\n\nS-Function 的主函数入口，调用 setup() 注册接口。\n\n\nsetup(block)：配置端口、采样、方法等\n\nblock.NumInputPorts  = 1;  % 输入1个信号（控制启动）block.NumOutputPorts = 1;  % 输出当前状态（0, 1, 2, -1）block.SampleTimes = [0.5 0];  % 每 0.5 秒执行一次block.RegBlockMethod(...)    % 注册各阶段的回调函数set_param(..., &#x27;StopTime&#x27;, &#x27;inf&#x27;);  % 设置仿真不主动终止\n\nPostProp：声明离散状态（DWork）\n\nblock.NumDworks = 3;names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;\n\nprevU：上一时刻输入值（检测上升沿用）\nexeState：执行状态（0=未启动，1=运行中，2=正常退出，-1=错误）\npid：外部进程 PID\n\n\nInitCond：初始化 DWork 数据\n\nblock.Dwork(1).Data = 0;  % 上一时刻输入值block.Dwork(2).Data = 0;  % exeStateblock.Dwork(3).Data = 0;  % pid\n\nOutputs(block)：主逻辑处理区\n\nu = block.InputPort(1).Data;\n上升沿触发：启动外部 EXE\nif u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0    [ok, procObj, pid, exeState] = launchExe(...);end\n运行中：轮询状态（每次采样调用）\nif exeState == 1    [exeState, pid] = pollProcessExitStatus(...);    if exeState == 2 || exeState == -1        stopSimulation(block);  % 进程完成 → 停止仿真    endend\n输出当前状态并保存状态数据\nblock.OutputPort(1).Data = exeState;\n\nTerminate：终止残留进程（防挂后台）\n\nif ~isempty(procObj)    terminateProcess(procObj);end\n内部 helper 函数说明\nlaunchExe(exePath, paramPath)\n\n启动 XXX.exe\n参数格式是 '1|1|参数路径'\n返回是否成功、进程对象、PID、状态\n\npollProcessExitStatus(procObj, pid)\n\n检查进程是否已退出\n如果异常，也尝试通过 PID 判断\n根据 ExitCode 判断：\n\n0 → 正常结束（返回状态 2）\n非 0 → 异常（状态 -1）\n\n\n\nisProcAlive(pid)\n\n尝试通过 PID 检查进程是否还活着\n\nterminateProcess(procObj)\n\n如果进程还在运行，则强制结束并释放资源\n\nstopSimulation(block)\n\n调用 Simulink 命令强制停止整个仿真\n\n状态码含义总结\n\n\n\n状态码\n含义\n\n\n\n\n0\n初始未启动\n\n\n1\n正在运行 EXE\n\n\n2\nEXE 正常退出\n\n\n-1\n启动或执行异常\n\n\n\n修改M文件\n将调用dll的Matlab代码改为S Function的方式，并通过1→2来进行触发，代码如下\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)end\n这段代码实现了一个 MATLAB Level-2 S-Function，主要功能是当输入信号为 2 时触发外部 DLL（XXXBridgeDLL.dll）的数据读取和处理，之后进行数据的可视化。\n总体功能流程\n\n输入信号：该 S-Function 监听一个输入信号 u。\n脉冲触发：当信号 u == 2 且前一时刻 prevU != 2 时，触发读取数据。\n调用 DLL：加载外部 DLL (XXXBridgeDLL.dll)，读取 XXX 仿真数据。\n数据处理与绘图：读取坐标、功率、增益和效率数据，并绘制图形。\n清理资源：在操作完成后，清理 DLL 资源。\n\n代码分解\n\nsfun_callXXXProcess(block)\n\nfunction sfun_callXXXProcess(block)    setup(block);end\n\n这是 S-Function 的入口函数，调用 setup(block) 设置仿真模块的基本配置。\n\n\nsetup(block): 配置端口、采样时间与方法\n\nfunction setup(block)    block.NumInputPorts  = 1;  % 一个输入端口    block.NumOutputPorts = 0;  % 无输出端口    block.SampleTimes        = [0.5 0];  % 每 0.5 秒触发一次    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;  % 默认的仿真状态兼容性    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);end\n\n配置输入端口和采样时间（每 0.5 秒触发一次）。\n注册方法：PostPropagationSetup、InitializeConditions、Outputs 和 Terminate。\n\n\nPostProp(block): 声明 DWork 状态变量\n\nfunction PostProp(block)    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevU&#x27;;  % 存储上一时刻的输入信号    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;  % double 类型    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end\n\n声明一个名为 prevU 的 DWork 变量，用于保存前一时刻的输入信号值。\n\n\nInitCond(block): 初始化 DWork 数据\n\nfunction InitCond(block)    block.Dwork(1).Data = 0;  % 初始化 `prevU` 为 0end\n\n初始化时，prevU 设置为 0，表示初始状态。\n\n\nOutputs(block): 主逻辑处理区\n\nfunction Outputs(block)    u = block.InputPort(1).Data;  % 获取当前输入信号    prevU = block.Dwork(1).Data;  % 获取前一时刻的输入信号    if u == 2 &amp;&amp; prevU ~= 2        % 读取 XXX 数据        dll = &#x27;.\\bin\\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);  % 加载 DLL        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);  % 创建处理器对象        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);  % 读取数据        N = nPt.Value;  % 获取数据点数量        % 初始化指针缓冲区        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        % 从 DLL 中复制数据到指针        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;, p, effPtr, N);        % 获取数据        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % 绘图        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % 清理资源        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end\n\n当 u == 2 时，调用 XXXBridgeDLL.dll 进行数据读取，获取 x（坐标）、pow（功率）、gain（增益）和 eff（效率）数据。\n使用 figure 绘制三张子图，显示输出功率、增益和效率随坐标的变化。\n在操作完成后，清理 DLL 资源。\n\n\nTerminate(~): 清理\n\nfunction Terminate(~)end\n\n在仿真结束时，Terminate 函数被调用，但在这个实现中没有进行额外操作。\n\n工作流程\n\n输入信号：当输入信号为 2 时，触发外部 EXE 进程。\n调用 DLL：通过 XXXBridgeDLL.dll 读取 XXX 仿真数据。\n数据处理与绘图：读取数据并绘制输出功率、增益和效率曲线。\n清理：仿真结束后清理 DLL 资源。\n\n运行示例\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"Simulink调用外部工具仿真《一》","url":"/posts/51a3b25e/","content":"该项目旨在使用Simulink来完成某些计算和仿真，计算工具采用自己的求解器，因此Simulink在这里的作用主要为模拟输入输出接口和触发信号，后续可能会引入优化器来对参数进行优化，本篇作为开头，主要介绍如何使用Simulink调用外部工具。\n创建m文件\n首先打开Matlab，指定工作路径，在命令行窗口输入edit sfun_callXXX从而在当前路径下创建sfun_callXXX.m文件，输入下述代码\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);endfunction setup(block)    % 一个输入端口：触发信号（1 表示触发执行）    block.NumInputPorts = 1;    block.SetPreCompInpPortInfoToDynamic;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    % 一个输出端口：执行状态    block.NumOutputPorts = 1;    block.SetPreCompOutPortInfoToDynamic;    block.OutputPort(1).Dimensions   = 1;    block.OutputPort(1).DatatypeID   = 0;    block.OutputPort(1).Complexity   = &#x27;Real&#x27;;    % 一个 Dwork 变量：用于保存上一个输入（用于边沿检测）    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevInput&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;    % 每 1 秒调用一次    block.SampleTimes = [1.0 0.0];    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.InitializeConditions = @InitConditions;    block.Outputs              = @Output;endfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值：输入未触发endfunction Output(block)    u = block.InputPort(1).Data;    prev = block.Dwork(1).Data;    % 只在输入从 0 → 1 的跳变时执行    if u == 1 &amp;&amp; prev == 0        % 配置路径        exePath = &#x27;I:\\XXX.exe&#x27;;        paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;        % 检查 EXE 是否存在        if ~isfile(exePath)            warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);            block.OutputPort(1).Data = -2;            block.Dwork(1).Data = u;            return;        end        % 检查参数路径是否存在        if ~isfolder(paramPath)            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);            block.OutputPort(1).Data = -3;            block.Dwork(1).Data = u;            return;        end        % 构造命令        exePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];        paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];        args = [&#x27;1|1|&#x27; paramPathQuoted];        cmd = [exePathQuoted &#x27; &#x27; args];        disp([&#x27;[XXX] 正在执行: &#x27; cmd]);        % 执行命令        status = system(cmd);        if status == 0            block.OutputPort(1).Data = 1;  % 成功        else            block.OutputPort(1).Data = -1; % 执行失败        end    else        block.OutputPort(1).Data = 0;  % 无触发    end    % 更新 Dwork 状态    block.Dwork(1).Data = u;end\n该函数的主要作用是在 Simulink 中通过输入触发器调用外部程序 XXX.exe，实现如下特性：\n\n支持多次触发执行，但只在输入信号从 0 到 1 的上升沿执行\n执行结果通过输出端口返回状态码：\n\n1 → 执行成功；\n-1 → 执行失败；\n-2 → EXE 路径不存在；\n-3 → 参数路径不存在；\n0 → 没有触发。\n\n\n\n主函数部分\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);end\n这是主入口函数，Simulink 在加载该 S-Function 时会调用这个函数。block 是代表这个 S-Function 块的对象，包含输入输出、状态等所有接口\nfunction setup(block)\nblock.NumInputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;  % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;\n设置只有 1 个输入端口，类型为 double 实数，输入数据是一个触发信号，为 1 表示要执行 XXX.exe\nblock.NumOutputPorts = 1;block.SetPreCompOutPortInfoToDynamic;block.OutputPort(1).Dimensions   = 1;block.OutputPort(1).DatatypeID   = 0;block.OutputPort(1).Complexity   = &#x27;Real&#x27;;\n也只有 1 个输出端口，用于输出执行状态\nblock.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;block.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;\nDwork 是 S-Function 中的离散状态变量，在仿真期间保留，这里用来保存上一时刻的输入值，从而判断是否出现了 0→1 的跳变（上升沿）\nblock.SampleTimes = [1.0 0.0];block.SimStateCompliance = &#x27;DefaultSimState&#x27;;block.InitializeConditions = @InitConditions;block.Outputs              = @Output;\nSampleTimes = [1.0 0.0] → 每 1 秒调用一次 Output 函数，注册初始化函数和主输出函数\n初始化函数 InitConditions\nfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值设为0，表示“未触发”end\n初始化 Dwork 状态变量，表示开始时没有任何触发信号\n主执行函数 Output\nfunction Output(block)\nu = block.InputPort(1).Data;prev = block.Dwork(1).Data;\nu 是当前输入值，prev 是上一个采样时刻的输入值，用于检测跳变\nif u == 1 &amp;&amp; prev == 0\n\n只有从 0 → 1 的跳变，才执行外部命令\n如果持续为 1，不会重复执行\n\nexePath = &#x27;...XXX.exe&#x27;;paramPath = &#x27;...指定输入&#x27;;\nexePath 是要调用的外部可执行文件路径，paramPath 是输入数据或配置文件的路径\nif ~isfile(exePath)    warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);    block.OutputPort(1).Data = -2;    block.Dwork(1).Data = u;    return;endif ~isfolder(paramPath)    warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);    block.OutputPort(1).Data = -3;    block.Dwork(1).Data = u;    return;end\n\n如果 EXE 不存在 → 返回 -2\n如果参数目录不存在 → 返回 -3\n\nexePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];args = [&#x27;1|1|&#x27; paramPathQuoted];cmd = [exePathQuoted &#x27; &#x27; args];disp([&#x27;[XXX] 正在执行: &#x27; cmd]);\n\n\n把路径加引号是为了防止路径中有空格报错\n\n\n执行命令类似于（根据自己的可执行文件进行修改，这里的1|1|是参数需要）\n&quot;I:\\...\\XXX.exe&quot; 1|1|&quot;C:\\Users\\...\\指定输入&quot;\n\n\nstatus = system(cmd);if status == 0    block.OutputPort(1).Data = 1;  % 成功else    block.OutputPort(1).Data = -1; % 失败end\n\nsystem(cmd) 用于调用系统命令\n如果返回值为 0，表示执行成功 → 输出 1\n否则 → 输出 -1\n\nelse    block.OutputPort(1).Data = 0;  % 无触发，不执行end\n\n输入无变化或不是上升沿时，输出 0\n\nblock.Dwork(1).Data = u;\n\n用当前输入值覆盖 Dwork，供下一次仿真调用使用\n\n\n\n\n输出值\n含义\n\n\n\n\n1\n成功执行 XXX.exe\n\n\n-1\n执行失败\n\n\n-2\n找不到 EXE\n\n\n-3\n参数目录不存在\n\n\n0\n无触发（未上升沿）\n\n\n\n代码流程概览\n\n\n\n阶段\nSimulink 触发\n函数\n功能描述\n\n\n\n\n模块加载时\nSimulink 加载模型\nsfun_callXXX() → setup()\n初始化输入输出端口、采样时间、Dwork 状态变量等\n\n\n仿真开始时\n点击仿真按钮 Run\nInitializeConditions()\n将 prevInput 初始化为 0\n\n\n每个仿真步\n每秒调用一次\nOutput()\n检测输入信号是否跳变为 1，如果是就执行 XXX.exe\n\n\n\n在Simulink中使用S Function\n在命令行窗口输入simulink或直接点击菜单面板“Simulink”来打开Simulink仿真工具，新建空白模型\n\n将该模型保存到当前目录下（与上述.m文件相同），在库浏览器中依次将Constant、Level-2 MATLAB S-Function（不能直接选S-Function，因为我们的代码是针对Level 2的）、Display模块拖入，并连接如下\n\n双击S-Function模块，将 S-function name 设为 sfun_callXXX，确认之后提示出错。\n这里的主要原因为MATLAB Level-2 S-Function 的 Dwork 区只能在 PostPropagationSetup() 阶段设置，而目前把 NumDworks 和 Dwork 配置写在了 setup() 里，这是不允许的，修改如下\nfunction sfun_callXXX(block)% Level-2 MATLAB S-Function：检测 0→1 边沿并调用 XXX.exe    setup(block);end%-----------------------------------------------------------%function setup(block)%% 1. 端口block.NumInputPorts  = 1;block.NumOutputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.SetPreCompOutPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;   % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;block.OutputPort(1).Dimensions = 1;block.OutputPort(1).DatatypeID = 0;block.OutputPort(1).Complexity = &#x27;Real&#x27;;%% 2. 采样时间（每 1 s 执行一次）block.SampleTimes = [1 0];%% 3. S-Function 状态机合规block.SimStateCompliance = &#x27;DefaultSimState&#x27;;%% 4. 注册回调 —— 用 RegBlockMethod（关键）block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostPropSetup);block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitConditions);block.RegBlockMethod(&#x27;Outputs&#x27;,              @Output);end%-----------------------------------------------------------%function PostPropSetup(block)%% Dwork 在此阶段声明block.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;  % doubleblock.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;end%-----------------------------------------------------------%function InitConditions(block)%% 仿真开始时：prevInput 置零block.Dwork(1).Data = 0;end%-----------------------------------------------------------%function Output(block)%% 边沿检测 + 执行外部 EXEu    = block.InputPort(1).Data;prev = block.Dwork(1).Data;if u == 1 &amp;&amp; prev == 0    % 路径设定    exePath   = &#x27;I:\\XXX.exe&#x27;;    paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX&#x27;;    % -------- 路径检查（兼容旧版 MATLAB：用 exist） --------    if exist(exePath,&#x27;file&#x27;) ~= 2        warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath);        block.OutputPort(1).Data = -2;    elseif exist(paramPath,&#x27;dir&#x27;) ~= 7        warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);        block.OutputPort(1).Data = -3;    else        % 构造命令        cmd = [&#x27;&quot;&#x27; exePath &#x27;&quot; 1|1|&quot;&#x27; paramPath &#x27;&quot;&#x27;];        disp([&#x27;[XXX] 执行: &#x27; cmd]);        status = system(cmd);        block.OutputPort(1).Data = double(status == 0) * 2 - 1;  % 1 成功 /-1 失败    endelse    block.OutputPort(1).Data = 0;                                % 未触发end% 更新上周期输入block.Dwork(1).Data = u;end\n运行仿真，观察到Display显示为1表明正确调用执行，为了方便截图，我把Display换为Scope，观察如下\n\n第一秒，输入从0→1 调用exe成功并输出1，第二秒没有跳变发生，输出为0\nSimulink 对该 S-Function 模块的调用时序如下\n\n\n\n时间\n执行\n来自 S-Function 的函数调用\n说明\n\n\n\n\n0s\n初始化\nsetup() → InitializeConditions()\n初始化端口、状态变量（prevInput=0）\n\n\n每秒\n仿真步\nOutput() 被调用一次\n判断输入信号是否从 0→1 变化，若是就调用 EXE\n\n\n\n假设输入信号如下\n\n\n\n步数\n输入 u\nprevInput\n是否执行 EXE？\n输出值\n\n\n\n\n1\n0\n0\n否\n0\n\n\n2\n1\n0\n是（跳变）\n1 / -1\n\n\n3\n1\n1\n否\n0\n\n\n4\n0\n1\n否\n0\n\n\n5\n1\n0\n是（跳变）\n1 / -1\n\n\n\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"VSCode插件开发-文件统计功能","url":"/posts/57a69459/","content":"修改package.json\n在开发 VS Code 插件时，package.json 是整个插件的“说明书”。这里以一个简单的功能为例进行测试\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;],&quot;main&quot;: &quot;./out/extension.js&quot;,&quot;contributes&quot;: &#123;  &quot;commands&quot;: [    &#123;      &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,      &quot;title&quot;: &quot;File State&quot;,      &quot;category&quot;: &quot;Code Auto Test&quot;    &#125;  ],  &quot;menus&quot;: &#123;    &quot;editor/context&quot;: [      &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ],    &quot;explorer/context&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ]  &#125;&#125;\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;]\n\n意义：插件不会在 VS Code 启动时就加载，而是在用户执行命令 code-auto-test.getFileState 时激活。\n优势：提升启动性能，遵循 VS Code 插件的延迟加载机制。\n\n指定插件的主入口\n&quot;main&quot;: &quot;./out/extension.js&quot;\n\n指向插件的主模块，通常是 TypeScript 编译后的文件。\nextension.js 中通常包含 activate(context) 和 deactivate() 函数，用于插件的生命周期管理。\n\n注册自定义命令\n&quot;commands&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;title&quot;: &quot;File State&quot;,    &quot;category&quot;: &quot;Code Auto Test&quot;  &#125;]\n\ncommand：命令的唯一标识符，供代码调用。\ntitle：在命令面板（Ctrl+Shift+P）中的显示名称。\ncategory：命令分类，显示为 &quot;Code Auto Test: File State&quot;。\n\n执行位置包括：\n\n命令面板\n上下文菜单（通过 menus 配置）\n\n集成到右键菜单中\n编辑器右键菜单\n&quot;editor/context&quot;: [  &#123;    &quot;when&quot;: &quot;editorFocus&quot;,    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：当编辑器中有焦点时，在右键菜单的“导航”区域显示。\nwhen: 上下文条件，这里为 editorFocus 表示编辑器有焦点时才显示。\n\n资源管理器右键菜单\n&quot;explorer/context&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]\n\n插入位置：资源管理器（文件树）右键菜单中。\n可用于对选中的文件/文件夹执行操作。\n\n通过这段简单的配置，我们实现了一个功能完整的 VS Code 插件功能点：\n\n\n\n功能\n实现方式\n\n\n\n\n延迟激活\nactivationEvents 指定命令触发激活\n\n\n注册命令\ncontributes.commands\n\n\n集成编辑器右键菜单\nmenus.editor/context\n\n\n集成资源管理器右键菜单\nmenus.explorer/context\n\n\n\n这套模式是编写 VS Code 插件的基础，适用于各种需要通过右键或命令面板触发逻辑的场景，比如自动测试、代码分析、格式化工具等。\n修改extension.ts\n查看文件状态的命令实现（extension.ts）\n我们前面在 package.json 中注册了命令 code-auto-test.getFileState，接下来在插件主入口文件中进行具体实现。\n文件路径：src/extension.ts\n// 引入 VS Code 扩展 APIimport * as vscode from &#x27;vscode&#x27;;import * as fs from &#x27;fs&#x27;;// 插件激活时触发export function activate(context: vscode.ExtensionContext) &#123;\tconsole.log(&#x27;插件已激活：code-auto-test&#x27;);\t// 注册 getFileState 命令\tconst disposable = vscode.commands.registerCommand(&#x27;code-auto-test.getFileState&#x27;, (uri: vscode.Uri) =&gt; &#123;\t\t// 获取文件路径\t\tconst filePath = uri.fsPath;\t\t// 异步获取文件信息\t\tfs.stat(filePath, (err, stats) =&gt; &#123;\t\t\tif (err) &#123;\t\t\t\tvscode.window.showErrorMessage(`获取文件信息失败: $&#123;err.message&#125;`);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 判断是否为文件夹\t\t\tif (stats.isDirectory()) &#123;\t\t\t\tvscode.window.showWarningMessage(&#x27;检测的是文件夹，不是文件，请重新选择！&#x27;);\t\t\t\treturn;\t\t\t&#125;\t\t\t// 若是普通文件，显示基本信息\t\t\tif (stats.isFile()) &#123;\t\t\t\tconst size = stats.size;\t\t\t\tconst createTime = stats.birthtime.toLocaleString();\t\t\t\tconst modifyTime = stats.mtime.toLocaleString();\t\t\t\tvscode.window.showInformationMessage(\t\t\t\t\t` 文件大小: $&#123;size&#125; 字节\\n 创建时间: $&#123;createTime&#125;\\n 修改时间: $&#123;modifyTime&#125;`,\t\t\t\t\t&#123; modal: true &#125;\t\t\t\t);\t\t\t&#125;\t\t&#125;);\t\t// 调试用：同步读取 stat 信息输出日志\t\ttry &#123;\t\t\tconst statsSync = fs.statSync(filePath);\t\t\tconsole.log(&#x27;statSync:&#x27;, statsSync);\t\t\tconsole.log(&#x27;isFile:&#x27;, statsSync.isFile());\t\t&#125; catch (err) &#123;\t\t\tconsole.error(&#x27;statSync 读取失败:&#x27;, err);\t\t&#125;\t&#125;);\t// 将命令加入插件上下文中\tcontext.subscriptions.push(disposable);&#125;// 插件被卸载时触发export function deactivate() &#123;&#125;\n\n\n\n功能点\n说明\n\n\n\n\nvscode.Uri\n命令参数自动传入，支持从资源管理器中点击文件触发命令。\n\n\nfs.stat()\n异步获取文件状态，包含文件大小、创建时间、修改时间等。\n\n\nfs.statSync()\n同步版本，用于调试或日志输出。\n\n\nvscode.window.showInformationMessage(..., &#123; modal: true &#125;)\n使用模态窗口展示信息，确保用户注意查看。\n\n\n\n在编辑器中右键文件：\n\n显示：File State\n点击后弹出文件大小、创建时间、修改时间\n\n在资源管理器中右键文件：\n\n同样支持显示该命令\n若选中文件夹则给出提示\n\n\n通过 package.json + extension.ts，我们构建了一个结构完整、功能清晰的 VS Code 插件，具备以下特征：\n\n延迟激活（按需加载）\n支持右键菜单调用\n使用原生 Node.js 文件系统 API 获取信息\n弹出信息提示（用户交互友好）\n\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"关于Clash开启TUN无法联网的问题","url":"/posts/78c6fb80/","content":"之前我一直在用 Clash for Windows 科学上网。后来为了使用 Google 的反重力（Antigravity）软件，需要开启 TUN 模式，但我这边出现了一个非常折磨人的问题：只要一打开 TUN，就直接断网。\n这期间我在网上翻了无数帖子、试了无数“玄学设置”，都没能根治。中间还换过同门的一款 CFW（确实能开 TUN 正常用），但它有一个新毛病：会随机掉网——有时一瞬间，有时持续十几秒，尤其在和 AI 对话时，断一下就可能导致长回答直接中断，反复重试也很浪费时间。\n于是我决定换到口碑更好、且仍在维护的 Clash Verge Rev。结果安装后发现：开启 TUN 依然无法联网。这让我意识到：问题不在某一款软件，而在我的网络环境/路由策略上。\n直到某次我无意间翻日志，看到了“不太一样”的提示（大意是内核选择的出口接口/路由不对），我才突然反应过来——\n\n\n我的以太网（Ethernet）连的是内网。\n如果系统默认把“以太网”当成更优先的出口，Clash 开启 TUN 后把流量按默认路由丢给以太网，那怎么可能访问公网？\n\n所以真正要解决的不是“怎么调 Clash”，而是：\n让系统默认出口走 WLAN（Wi-Fi），而不是以太网。\n下面记录两种我亲测有效的方案。\n\n症状表现\n\n\nClash Verge Rev（或其他支持 TUN 的客户端）开启 TUN 后：\n\n浏览器打不开网页 / 全局断网\n或日志里出现 IP/路由相关报错（比如出口接口选择异常、路由不可达等）\n\n\n关闭 TUN 一切恢复正常\n\n\n根因：默认路由/接口优先级选错了\nWindows 在多网卡并存时，会根据 接口跃点数（Interface Metric）、路由表等规则决定默认出口。\n如果你的 以太网优先级高于 Wi-Fi，系统就可能优先走以太网默认路由——而你这条以太网只通内网，不通公网，于是“看起来像是 TUN 把网搞没了”。\n\n方案一：禁用以太网（有副作用）\n适用场景：你暂时不需要访问内网服务，只想立刻恢复公网。\n操作步骤\n\nWin + R 输入 ncpa.cpl 回车（打开“网络连接”）\n找到 以太网（Ethernet） → 右键 → 禁用\n再打开 Clash 的 TUN，通常就能直接联网\n\n缺点\n\n禁用后 无法访问内网资源（例如内网服务器、NAS、实验室网段等）\n需要内网时还得手动启用回来\n\n\n方案二：提升 WLAN 优先级（推荐）\n核心思路：把 Wi-Fi 的 Metric 调小（优先级更高），把 以太网的 Metric 调大（优先级更低）。\n这样默认出口走 Wi-Fi，但你访问内网网段时，依然可以走以太网（只要路由存在）。\n方法 A：图形界面修改（稳定、直观）\n\n建议 IPv4 和 IPv6 都改一下，避免某些环境下“IPv6 先走错”。\n\n\n\nWin + R → 输入 ncpa.cpl\n\n\n\n右键 Wi-Fi → 属性\n\n\n\n双击 Internet 协议版本 4 (TCP/IPv4) → “高级…”\n\n\n\n\n取消勾选 自动跃点数（Automatic metric）\n\n\n在“接口跃点数”填一个较小值，例如：5 或 10\n\n\n\nIPv6（TCP/IPv6）同样操作一遍（可选但推荐）\n\n\n\n\n右键 以太网 → 属性\n\n操作同上\n\n\n同样进入 IPv4/IPv6 高级设置\n取消自动跃点数\n设置一个较大的值，例如：50 / 100\n\n\n\n修改后一般无需重启，断开重连 Wi-Fi/以太网或重启 Clash 即可。\n\n方法 B：命令行修改（适合记录/脚本化）\n以管理员身份打开 PowerShell，然后：\n# 查看当前接口与跃点数Get-NetIPInterface | Sort-Object InterfaceMetric | Format-Table ifIndex,InterfaceAlias,AddressFamily,InterfaceMetric# 把 Wi-Fi 提高优先级（metric 更小）Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv4 -InterfaceMetric 5Set-NetIPInterface -InterfaceAlias &quot;WLAN&quot; -AddressFamily IPv6 -InterfaceMetric 5# 把 Ethernet 降低优先级（metric 更大）Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv4 -InterfaceMetric 50Set-NetIPInterface -InterfaceAlias &quot;以太网&quot; -AddressFamily IPv6 -InterfaceMetric 50\n\n这是我修改后的配置\n\n注意：不同机器网卡名称可能不是 WLAN / 以太网，以你 Get-NetIPInterface 里看到的 InterfaceAlias 为准。\n\n进阶：用 Proxifier 给 AI 工具做应用级代理，减少对话断连\n即便把 TUN 问题解决了，我还遇到过 AI 工具网络不稳定、对话偶发中断 的情况。很多 AI 客户端/IDE 插件并不总是“乖乖走系统代理”，或者在网络切换时连接更容易抖动。\n我的做法是：不用全局折腾，把 AI 相关进程强制走 Clash 的本地 SOCKS5 代理（应用级代理），让它们的网络路径更一致，从而减少断连。\n下面以我当前配置为例：\n1）在 Proxifier 添加 Clash 的 SOCKS5 代理\n打开 Proxifier：\n\n\nProfile → Proxy Servers... → Add...\n或点击图中位置\n\n\n\n\n按如下填写：\n\n\nAddress：127.0.0.1\n\n\nPort：7897\n\n\nProtocol：SOCKS Version 5\n\n\nAuthentication 不用勾（一般 Clash 本地不需要）\n\n\n\n\n\n点 Check 测试连通性，确认 OK\n\n\n\n\n提醒：7897 是我这边 Clash 的 SOCKS 端口，你的端口以 Clash/Verge 的端口设置为准。\n\n2）新增一条“AI”规则，只代理指定程序\n\n\nProfile → Proxification Rules... → Add...\n或点击图中位置\n\n\n\n\nName：AI（勾选 Enabled）\n\n\nApplications：填入需要强制走代理的程序：\n\nantigravity.exe; language_server_windows_x64.exe; cursor.exe\n\n\n\nTarget hosts：留空（表示不限制域名）\n\n\nTarget ports：Any\n\n\nAction：选择刚才创建的代理\n\nProxy SOCKS5 127.0.0.1\n\n\n\n最后把 AI 规则放到 Default 规则之上（规则是从上往下匹配的），避免被默认规则抢先匹配。\n\n\n3）效果\n\n只有 AI 相关进程走代理\n内网/其他软件照常走直连或按你自己的规则走\n对话连接更稳定：不会因为某些程序绕过系统代理而“时通时不通”，也更不容易在长对话时突然断掉\n\n","categories":["Clash"],"tags":["Clash","Proxifier","Tun"]},{"title":"关于Simulink中参数传递的解决方案","url":"/posts/fcf42186/","content":"介绍\n本文主要对之前的Simulink工作进行优化，前面通过S Function一共实现了三个模块，分别为参数交互模块、调用求解模块和数据展示模块。但后续两个模块的代码中都采用了硬编码的方式来指定文件夹的路径，事实上后续两个模块的文件夹路径与第一个模块选中的文件夹是同一个路径，因此为了减少因为硬编码而导致的路径错误，我们将修改代码，把第一个模块选中的文件夹传递给后续的模块，这里将会使用Simulink的封装功能\n如何传递模块参数\n核心问题：传递文件夹路径\n目前，sfun_callXXX.m 和 sfun_callXXXProcess.m 中的文件路径是硬编码的，这降低了灵活性。\n% sfun_callXXX.mparamPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;% sfun_callXXXProcess.mdir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;\n最佳的解决方案是利用 Simulink 的 Mask Parameters (模块参数) 来接收路径，然后由第一个 S-Function (sfun_callInterface) 在用户确认路径后，通过编程方式设置这些参数。\n\n在 Simulink 模型中，右键点击 sfun_callXXX 模块，选择 Mask &gt; Create Mask。\n在 Mask Editor 窗口中，进入 Parameters &amp; Dialog 选项卡。\n在左侧面板添加一个 Edit 参数。\n在右侧的 Parameter Properties 中，设置:\n\nPrompt: 求解器参数路径\nName: paramPath\nEvaluate：取消勾选\n\n\n点击 OK 或 Apply 保存 Mask。\n对 sfun_callXXXProcess 模块重复以上步骤，但将参数 Name 设置为 dataDir。\n再次右键点击该模块，选择 Block Parameters (S-function)。\n在打开的对话框中，找到一个名为 S-function parameters 的输入框。\n在这个输入框里，填入你的 变量名 (paramPath 或 dataDir)。\n点击 OK 或 Apply。\n为另一个 S-Function 模块重复上述步骤。\n\n\n这个操作的目的是建立 Mask 和 S-Function 代码之间的连接。当你在 Mask 界面输入路径时，该路径字符串会存入名为 paramPath 的变量中。然后，通过将 paramPath填入 “S-function parameters” 字段，这个变量的值就被传递给了 S-Function 内部，代码 block.DialogPrm(1).Data 才能成功地接收到这个路径。\n现在，修改这两个 S-Function，让它们从刚刚创建的 Mask Parameter 中读取路径，而不是使用硬编码的字符串。\n修改 sfun_callXXX.m:\n\n\n在 setup 函数中，声明该模块有一个 Mask Parameter。\nfunction setup(block)    % ... (I/O 配置)    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    % ... (SampleTime 等其他配置)end\n\n\n在 Outputs 函数中，用 block.DialogPrm(1).Data 替换硬编码的路径。\nfunction Outputs(block)    % ...    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行    paramPath = block.DialogPrm(1).Data;    % &lt;--- 添加这一行    % ...end\n\n\n修改 sfun_callXXXProcess.m:\n\n\n同样，在 setup 函数中声明 Mask Parameter。\nfunction setup(block)    % ...    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    block.SampleTimes        = [0.5 0];    % ...end\n\n\n在 Outputs 函数中，替换硬编码的路径。\nfunction Outputs(block)    % ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\...&#x27;; % &lt;--- 删除或注释掉这一行        dir = block.DialogPrm(1).Data;    % &lt;--- 添加这一行        % ...    end    % ...end\n\n\n最后，修改第一个 S-Function 的 GUI 确认回调函数 (confirm_action)，让它在用户点击“确认”时，自动将选定的文件夹路径写入另外两个模块的 Mask Parameter。\n为此，需要在 Simulink 模型中为 sfun_callXXX 和 sfun_callXXXProcess 模块指定一个清晰的、可编程访问的名称。例如，将它们分别命名为 XXX_Launcher 和 XXX_Processor。如图所示\n\n修改 sfun_callInterface.m 中的 confirm_action 函数:\n% sfun_callInterface.mfunction confirm_action(fig)    % ... (前面的代码保持不变)    % --- 新增代码：获取模型名称和设置其他模块的参数 ---    try        blockHandle = fig.UserData.blockHandle;        modelName = bdroot(blockHandle); % 获取顶层模型的名称                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);    catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % 释放处理器并返回，防止在出错时继续执行        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        return;    end    % --- 新增代码结束 ---    % ... (释放处理器、设置 confirmationFlag 和关闭 GUI 的代码保持不变)        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end\n小结: 通过以上三步，完成了下述工作：\n\nsfun_callInterface 的 GUI 捕获用户选择的路径。\n当用户点击“确认”时，该模块通过 set_param 函数，将路径动态地写入 XXX_Launcher 和 XXX_Processor 模块的 Mask 中。\n这两个模块在运行时，从自己的 Mask Parameter 中读取路径，从而实现了动态配置，完全避免了硬编码。\n\n\n注意：上述代码仍会出现问题，具体来说是modelName无法被识别，后续我将附上全部修改代码，这里不做展示\n\n\n加载/卸载Dll的优化\n此时多个模块正在加载和卸载同一个DLL (BWIBridgeDLL.dll)。这种做法效率低下，并且可以被简化。最佳实践是在整个仿真生命周期内将DLL作为共享资源进行管理：在仿真开始时加载一次，在仿真终止时卸载一次。\n1. 修改 sfun_callInterface.m\n该模块应负责加载DLL，并确保它在仿真期间保持加载状态。\n在 close_gui 函数中，删除卸载DLL的那一行代码。GUI不再需要管理DLL的卸载，这个任务将交给仿真的终止阶段来处理。\n原始代码 (sfun_callInterface.m):\nfunction close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end\n建议修改:\nfunction close_gui(fig)    % DLL 不再在这里卸载。它将由仿真流程中最后一个S-Function模块的    % Terminate 函数来处理。    delete(fig);end\n2. 修改 sfun_callXXXProcess.m\n该模块应负责在仿真结束时卸载DLL。其 Outputs 函数也应简化，直接使用已加载的库。\na. 在 Outputs 函数中:\n移除 loadlibrary 和 unloadlibrary 调用。现在代码应该假设DLL已经被第一个模块加载了。为保险起见，可以添加一个 libisloaded 检查。\n原始代码 (sfun_callXXXProcess.m):\nfunction Outputs(block)    % ... (前面的代码) ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        dir = block.DialogPrm(1).Data;        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        % ... (调用库的逻辑) ...                % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % ... (剩余的代码) ...end\n建议修改:\nfunction Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        % ... (其余逻辑保持不变) ...        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary 调用已从此函数中移除。    end    block.Dwork(1).Data = u;end\nb. 在 Terminate 函数中:\n此函数在仿真停止时会执行一次。这是卸载DLL的理想位置。\n原始代码 (sfun_callXXXProcess.m):\nfunction Terminate(~)end\n建议修改:\nfunction Terminate(~)    fprintf(&#x27;[XXX] Simulation terminated. Unloading BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n经过修改之后，我们的代码理论上只会在仿真开始时加载Dll，在仿真结束后卸载Dll，避免中间过程对Dll的反复调用\n隐含问题\n在sfun_callXXX.m的代码中，还存在着一个潜在的重要问题，我们使用了如下代码\n%— 持久变量：进程句柄 —————————————persistent procObj\n这是一个持久变量，用来检测进程的状态，当我们使用了不止于一个sfun_callXXX模块时，所有模块将共享这个变量，如果我们在第一个模块中启动一个.exe进程，并将其句柄存入 procObj。紧接着，第二个模块启动另一个.exe进程，并将其句柄覆盖到同一个 procObj 变量中。此时，第一个进程的句柄就丢失了。系统将无法再轮询或终止第一个进程，从而导致逻辑错误和进程失控。简单来说，当前的设计只适用于模型中只有一个XXX_Launcher模块的情况。一旦需要多个，就会立即出错。\n目前这个问题还没有解决，后续如果遇到了，会在该系列文章中提供解决方案\n最后附上全部代码\nfunction sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);         % 这里的双击回调函数并不能正常使用，如要使用，可能要把start_import_gui及相关代码作为独立的文件和函数end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0                % --- 确保 modelName 永远是字符串 ---        rootSystem = bdroot(block.BlockHandle); % 获取顶层模型，结果可能是句柄或名称                modelName = &#x27;&#x27;; % 初始化        if isnumeric(rootSystem) &amp;&amp; ishandle(rootSystem)            % 如果返回的是数字句柄，则通过句柄获取名称            modelName = get_param(rootSystem, &#x27;Name&#x27;);        elseif ischar(rootSystem)            % 如果返回的是字符串名称，则直接使用            modelName = rootSystem;        end        % 添加一个安全检查，如果获取名称失败则报错并停止        if isempty(modelName)            errordlg(&#x27;无法获取 Simulink 模型名称，GUI 无法启动。&#x27;, &#x27;严重错误&#x27;);            % 在这种严重错误下，停止仿真可能更安全            set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);            return; % 提前退出函数        end        % --- 修复结束 ---                start_import_gui(modelName);        block.Dwork(1).Data = 1;    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(modelName)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.modelName  = modelName;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;    try        % 从 UserData 获取模型名称字符串        modelName = fig.UserData.modelName; % &lt;--- 修改点                % 检查 modelName 是否有效 (例如，不是空的)        if isempty(modelName) || ~ischar(modelName)            error(&#x27;未能获取有效的模型名称。&#x27;); % 抛出一个错误        end                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);            catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % ... (释放处理器并返回)        return;    end        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    % if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)    %     unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    % end    % 清理其他资源如果需要    delete(fig);end\nfunction sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    block.NumDialogPrms  = 1;     %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\\Solver\\XXX.exe&#x27;;    % paramPath = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;    paramPath = block.DialogPrm(1).Data;     %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            fprintf(&#x27;[XXX] PID=%d 已退出\\n&#x27;, block.Dwork(3).Data)            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end\nfunction sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.NumDialogPrms  = 1;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\\n&#x27;);            return;        end        % --- 读取数据并绘图 ---        % dll = &#x27;.\\bin\\BWIBridgeDLL.dll&#x27;;        % hdr = &#x27;.\\bin\\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\\Users\\pc\\Desktop\\XXX_互作用-helix-非线性特征仿真实例\\注波互作用1\\指定输入&#x27;;        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt);        if ~result            fprintf(&#x27;读取失败&#x27;)            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);            unloadlibrary(&#x27;BWIBridgeDLL&#x27;)        end;        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)    fprintf(&#x27;[XXX] Simulation 终止. 卸载 BWIBridgeDLL.\\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend\n","categories":["Simulink仿真"],"tags":["Simulink","Matlab"]},{"title":"创建VS Code插件","url":"/posts/7d850c90/","content":"本人打算创建一个VS Code插件用于调试代码，拟结合AI用于生成测试用例，分析代码等\n环境准备\n安装Node.is\nVS Code 插件开发使用 JavaScript / TypeScript 编写，需要 Node.js 来运行开发脚本和构建流程\n官网：https://nodejs.org\n安装后验证是否成功\nnode -v\n\n安装脚手架\n这里会用到yo和generator-code\nyo 是 Yeoman 的命令行工具，是一个用于快速生成项目脚手架的工具，类似于项目生成器\ngenerator-code 是一个 Yeoman 生成器插件，专门用于生成 VS Code 插件项目 的脚手架。\n全局安装yo和generator-code\nnpm i -g yo generator-code\n我这里已经安装过了，输出如下\n\n创建VS Code插件项目\n新建工程\n在你需要创建插件的目录下输入\nyo code\n执行如下\n\n\n[!NOTE]\n这里将会依次问你如下几个问题\n\n选择你的插件类型\n插件的名字\n插件的唯一标识\n插件的描述\n是否需要git仓库\n打包工具选择\n选择包管理工具\n\n\n我的配置如图\n\n选择完成之后出现如下内容\n\n然后可以选择打开新建的工程或者直接跳过，这里选择第一个，打开之后项目结构如图所示，其中最重要的文件是package.json和extension.js，到这里一个VS Code的框架算是基本完成了。\n\n目录介绍\n\n[!NOTE]\n.vscode: 里面的文件是用来测试插件或者测试代码的一些文件。\nnode_modules: 第三方依赖。\nsrc/test：测试文件。\nsrc/extension.ts：插件的主文件\n\npackage.json文件\n该文件是vscode扩展的清单文件，具体可以看文档：发布内容配置\n&#123;  &quot;name&quot;: &quot;code-auto-test&quot;,\t// 插件名  &quot;displayName&quot;: &quot;code-auto-test&quot;,\t// 应用市场显示的名字  &quot;description&quot;: &quot;自动执行代码测试&quot;,\t// 插件描述  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;engines&quot;: &#123;    &quot;vscode&quot;: &quot;^1.101.0&quot;  &#125;,  &quot;categories&quot;: [    &quot;Other&quot;\t// 扩展类别  ],   // 激活事件组，在那些事件情况下被激活  &quot;activationEvents&quot;: [],   // 插件的主入口文件  &quot;main&quot;: &quot;./out/extension.js&quot;,  &quot;contributes&quot;: &#123;     // 命令    &quot;commands&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.helloWorld&quot;,        &quot;title&quot;: &quot;Hello World&quot;      &#125;    ]  &#125;,  &quot;scripts&quot;: &#123;    &quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,    &quot;compile&quot;: &quot;tsc -p ./&quot;,    &quot;watch&quot;: &quot;tsc -watch -p ./&quot;,    &quot;pretest&quot;: &quot;npm run compile &amp;&amp; npm run lint&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;test&quot;: &quot;vscode-test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@types/vscode&quot;: &quot;^1.101.0&quot;,    &quot;@types/mocha&quot;: &quot;^10.0.10&quot;,    &quot;@types/node&quot;: &quot;20.x&quot;,    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.31.1&quot;,    &quot;@typescript-eslint/parser&quot;: &quot;^8.31.1&quot;,    &quot;eslint&quot;: &quot;^9.25.1&quot;,    &quot;typescript&quot;: &quot;^5.8.3&quot;,    &quot;@vscode/test-cli&quot;: &quot;^0.0.10&quot;,    &quot;@vscode/test-electron&quot;: &quot;^2.5.2&quot;  &#125;&#125;\nextension.js文件\n入口文件，即package.json中main字段对应的文件，文件中有导出两个方法：activate和deactivate\n测试\n在package.json文件中添加激活事件\n&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.helloWorld&quot;],\n终端进入项目\ncd code-auto-testnpm installnpm run compile\n这会将 src/extension.ts 编译到 out/extension.js，为插件运行做好准备\nF5运行插件，会启动扩展宿主环境，打开任意文件夹，按下ctrl+shift+p 并输入helloworld\n\n确认选择Hello World，右下角出现如图内容表明运行成功\n\n先到这吧，累了😮‍💨\n","categories":["VSCode插件"],"tags":["VSCode","插件"]},{"title":"Ascend C算子开发能力认证（中级）","url":"/posts/9e1eacb0/","content":"认证要求\n实现Ascend C算子Sigmoid,算子命名为SigmoidCustom,编写其kernel侧代码、host侧代码,并完成aclnn算子调用测试。\n相关算法:\nsigmoid(x)=1/(1+exp(−x))sigmoid(x) = 1/(1 + exp(-x))\nsigmoid(x)=1/(1+exp(−x))\n\n实现流程\n环境初始配置\n由于华为的ModelAtrs平台每次重启会把环境中除work目录之外的内容全部清除，因此每次需要重新设置环境，执行\nbash init_env.shsource ~/.bashrcsource /home/ma-user/Ascend/ascend-toolkit/set_env.shchmod +x -R *\n上述命令依次用于下载包、配置环境变量以及脚本权限等\n代码编写\n从认证平台下载压缩包，解压之后包含SigmoidCustom和AclNNInvocation两个文件夹，SigmoidCustom中的内容主要完成代码编写、编译运行等，AclNNInvocation用于实现调用、测试等\n文件主要内容如下\n\nHost测实现\n首先在sigmoid_custom_tiling.h完成tiling结构体设计，在代码的注释后添加如下内容\nTILING_DATA_FIELD_DEF(uint32_t, totalLength);TILING_DATA_FIELD_DEF(uint32_t, tileNum);\n然后在sigmoid_custom.cpp中的注释后添加\nuint32_t totalLength = context-&gt;GetInputShape(0)-&gt;GetOriginShape().GetShapeSize();context-&gt;SetBlockDim(BLOCK_DIM);tiling.set_totalLength(totalLength);tiling.set_tileNum(TILE_NUM);tiling.SaveToBuffer(context-&gt;GetRawTilingData()-&gt;GetData(), context-&gt;GetRawTilingData()-&gt;GetCapacity());context-&gt;GetRawTilingData()-&gt;SetDataSize(tiling.GetDataSize());size_t *currentWorkspace = context-&gt;GetWorkspaceSizes(1);currentWorkspace[0] = 0;return ge::GRAPH_SUCCESS;\nDevice测实现\n这里的代码稍微复杂，需要用户自行实现核函数的初始化、内存迁移、算法实现等，完整代码如下\n#include &quot;kernel_operator.h&quot;using namespace AscendC;constexpr int32_t BUFFER_NUM = 2;class KernelSigmoid &#123;public:    __aicore__ inline KernelSigmoid() &#123;&#125;    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, uint32_t totalLength, uint32_t tileNum)    &#123;        //考生补充初始化代码        this-&gt;blockLength = totalLength / AscendC::GetBlockNum();        this-&gt;tileNum = tileNum;        this-&gt;tileLength = this-&gt;blockLength / tileNum / BUFFER_NUM;        xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        yGm.SetGlobalBuffer((__gm__ DTYPE_Y *)y + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        pipe.InitBuffer(inQueueX, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(outQueueY, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer1, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer2, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer3, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer4, this-&gt;tileLength * sizeof(half));    &#125;    __aicore__ inline void Process()    &#123;        //考生补充对“loopCount”的定义，注意对Tiling的处理        int32_t loopCount = this-&gt;tileNum * BUFFER_NUM;        for (int32_t i = 0; i &lt; loopCount; i++) &#123;            CopyIn(i);            Compute(i);            CopyOut(i);        &#125;    &#125;private:    __aicore__ inline void HighPrecisionReciprocal(LocalTensor&lt;half&gt;&amp; dst,                                               const LocalTensor&lt;half&gt;&amp; src,                                               int32_t length,                                               int iterations = 2)    &#123;        LocalTensor&lt;half&gt; tmp = tmpBuffer4.Get&lt;half&gt;();        half two = 2.0h,negone=-1.0h;        // 初始近似值 (可以使用硬件Reciprocal的初始值)        AscendC::Reciprocal(dst, src, length);        // 牛顿迭代: x_&#123;n+1&#125; = x_n * (2 - a * x_n)        for (int i = 0; i &lt; iterations; ++i) &#123;            AscendC::Mul(tmp, src, dst, length);    // tmp = a * x_n            AscendC::Muls(tmp, tmp, negone, length);   // tmp = 2 - a * x_n            AscendC::Adds(tmp, tmp, two, length);            AscendC::Mul(dst, dst, tmp, length);     // x_&#123;n+1&#125; = x_n * tmp        &#125;    &#125;    __aicore__ inline void CopyIn(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();        AscendC::DataCopy(xLocal, xGm[progress * this-&gt;tileLength], this-&gt;tileLength);        inQueueX.EnQue(xLocal);    &#125;    __aicore__ inline void Compute(int32_t progress)    &#123;        //考生补充算子计算代码        LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;();        LocalTensor&lt;half&gt; yLocal = outQueueY.AllocTensor&lt;half&gt;();                LocalTensor&lt;half&gt; tmp1 = tmpBuffer1.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp2 = tmpBuffer2.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp3 = tmpBuffer3.Get&lt;half&gt;();                half one=1.0,negone=-1.0;        AscendC::Muls(tmp1, xLocal, negone, this-&gt;tileLength);        AscendC::Exp(tmp2, tmp1, this-&gt;tileLength);        AscendC::Adds(tmp3, tmp2, one, this-&gt;tileLength);                HighPrecisionReciprocal(yLocal,tmp3,this-&gt;tileLength,2);        outQueueY.EnQue&lt;half&gt;(yLocal);        inQueueX.FreeTensor(xLocal);    &#125;    __aicore__ inline void CopyOut(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; yLocal = outQueueY.DeQue&lt;half&gt;();        AscendC::DataCopy(yGm[progress * this-&gt;tileLength], yLocal, this-&gt;tileLength);        outQueueY.FreeTensor(yLocal);    &#125;private:    TPipe pipe;    //create queue for input, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;    //create queue for output, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueY;    GlobalTensor&lt;half&gt; xGm;    GlobalTensor&lt;half&gt; yGm;    //考生补充自定义成员变量    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;    uint32_t blockLength;    uint32_t tileNum;    uint32_t tileLength;&#125;;extern &quot;C&quot; __global__ __aicore__ void sigmoid_custom(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling) &#123;    GET_TILING_DATA(tiling_data, tiling);    KernelSigmoid op;    //补充init和process函数调用内容    op.Init(x, y, tiling_data.totalLength, tiling_data.tileNum);    op.Process();&#125;\n代码解释\n一个自定义算子的生命周期\n在深入代码之前，我们先理解一下从编写到执行，这个 SigmoidCustom 算子经历了什么：\n\n\n开发阶段: 您编写了算子定义、Tiling 逻辑和 Kernel 实现这几个文件。\n\n\n编译阶段: 使用 CANN 提供的工具链进行编译。编译器会分别处理 Host 端代码（编译成标准的 CPU 可执行指令）和 Device 端代码（编译成 AI Core 能理解的 CUBE 指令）。同时，OP_ADD(SigmoidCustom) 宏会将算子的元信息（如输入输出、Tiling 函数地址等）注册到昇腾的算子库中。\n\n\n图构建与下发阶段: 当用户在一个神经网络模型（例如用 MindSpore 或 PyTorch）中调用 SigmoidCustom 时，前端框架会将模型转换为昇腾的计算图（Graph）。图编译器（Graph Engine, GE）会解析这个图，当遇到 SigmoidCustom 节点时，它会：\na.  调用 InferShape 和 InferDataType 函数，在不运行实际计算的情况下，静态推断出这个节点输出的形状和数据类型，以便为整个网络预先分配好内存。\nb.  调用 TilingFunc 函数，根据当前节点的输入张量大小，生成具体的任务切分方案（即 TilingData）。\nc.  将编译好的 Kernel CUBE 指令和 TilingData 打包成一个任务，下发给 NPU 的任务调度器（Task Scheduler）。\n\n\n执行阶段: NPU 的任务调度器根据 TilingData 中的 blockDim 信息，唤醒指定数量的 AI Core。每个被唤醒的 AI Core 都会接收到 Kernel CUBE 指令和 TilingData 的一份拷贝，然后从 sigmoid_custom 这个 __global__ 入口函数开始，独立地执行计算任务。\n\n\nHost 端代码深度解析 (CPU 侧)\nHost 端代码的核心目标是**“定义规则”和“制定计划”**，它不参与实际的数值计算。\n1.1 算子接口定义\n这部分代码是 SigmoidCustom 算子与 CANN 框架交互的“接口”或“驱动”。框架本身不知道你这个算子具体怎么算，但通过这个定义，它知道了如何使用你。\n\nthis-&gt;Input(&quot;x&quot;)... 和 this-&gt;Output(&quot;y&quot;)...: 这不仅仅是定义了输入输出的名称，更重要的是定义了数据依赖关系。图编译器根据这个关系来构建计算图的拓扑结构，决定算子执行的先后顺序。\n.DataType(&#123;ge::DT_FLOAT16&#125;).Format(&#123;ge::FORMAT_ND&#125;): 这是算子的能力声明。它告诉框架：“我能处理 FP16 类型的数据，并且不关心输入的具体维度（ND 格式）。” 如果上游算子的输出格式不匹配，图编译器会自动插入一个转置（Transpose）或类型转换（Cast）算子来适配。\nthis-&gt;SetInferShape(ge::InferShape): 这是一个至关重要的静态分析钩子。在模型编译时，真实的输入数据还不存在，但其形状（Shape）是已知的。框架会调用 InferShape 函数，让算子根据输入的 Shape &quot;预言&quot;自己输出的 Shape。对于 Sigmoid 这种 Element-wise（逐元素）操作，输出形状与输入形状完全相同，所以实现很简单：*y_shape = *x1_shape;。这使得框架可以在运行前就规划好整个模型的内存布局。\nthis-&gt;AICore().SetTiling(optiling::TilingFunc): 这是将**“计划制定者”**（Tiling 函数）与算子本身绑定的关键。框架知道，每当需要执行这个算子时，都应该去调用 TilingFunc 来获取详细的执行计划。\n\n1.2 Tiling 函数\nTiling 函数是 Host 端的智慧所在，它在 CPU 上运行，为即将开始的 Device 端计算制定精密的作战计划。\n\ngert::TilingContext\\* context: context 对象是框架传递给 Tiling 函数的**“情报手册”**。它包含了关于当前任务的所有上下文信息，最主要的就是 context-&gt;GetInputShape(0)，它让 Tiling 函数知道了待处理的数据有多大。\n核心决策:\n\n总览全局: uint32_t totalLength = ...GetShapeSize() 获取了总工作量。\n分配兵力: context-&gt;SetBlockDim(BLOCK_DIM) 决定了要动用多少个 AI Core（这里硬编码为8）。这是一个关键的并行策略决策。如果 totalLength 很小，可能只用一个 AI Core 更高效（避免多核通信开销）；如果 totalLength 巨大，则可以用满所有可用的 Core。\n制定指令:\n\ntiling.set_totalLength(totalLength): 把全局信息写入“指令书” (TilingData)。\ntiling.set_tileNum(TILE_NUM): 决定每个 AI Core 内部的流水线深度或切分粒度。这个值会影响性能，需要根据计算量和数据搬运量的比例（计算访存比）来权衡。TILE_NUM 越大，tileLength 就越小，数据搬运更频繁，但每个计算任务的延迟也更低，有利于流水线隐藏延迟。\n\n\n\n\n信息传递: tiling.SaveToBuffer(...) 将填满信息的 TilingData 结构体序列化为一段连续的内存块。这段内存块将和编译好的 Kernel 代码一起被发送到 Device 端，成为每个 AI Core 执行任务的依据。\n\nDevice 端代码深度解析 (AI Core 侧)\nDevice 端代码是**“一线士兵”**，它们根据 Host 发来的计划，在自己的阵地（AI Core）上高效地执行计算。\n2.1 内存模型与数据并行 (SPMD)\n\nGM_ADDR x, GM_ADDR y: GM_ADDR 是 Global Memory Address 的缩写，代表全局内存中的一个地址。x 和 y 是输入和输出张量在全局内存中的起始地址。\nSPMD (Single Program, Multiple Data): 这是 AI Core 的核心工作模式。所有被唤醒的 AI Core 都执行同一份程序代码（Single Program），但处理的数据各不相同（Multiple Data）。\nAscendC::GetBlockIdx(): 这是实现 SPMD 的关键。该函数返回当前 AI Core 的唯一ID（从0到 blockDim-1）。\nxGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), ...): 这行代码是数据划分的精髓。\n\n(__gm__ DTYPE_X *)x: 将全局内存地址 x 转换为一个指向 FP16 类型的指针。\n... + this-&gt;blockLength * AscendC::GetBlockIdx(): 计算偏移量。\n\n对于 ID=0 的 Core，偏移量是 blockLength * 0 = 0，它处理从 x 开始的数据。\n对于 ID=1 的 Core，偏移量是 blockLength * 1，它处理紧接着第一块的数据。\n…\n\n\n通过这种方式，totalLength 的数据被完美地分割成了 blockDim 份，每个 AI Core 都只关心自己负责的那一段，实现了无冲突的数据并行。\n\n\n\n2.2 本地内存与流水线 (TPipe, TQue)\nAI Core 的性能源泉在于其内部极速的本地内存（LM）和向量计算单元。流水线的目标就是让计算单元永远不要因为等待数据而停工。\n\nTPipe, TQue: 这不是硬件，而是 Ascend C 提供的软件抽象，用于简化对硬件 DMA（数据搬运单元）和本地内存的管理。\nInitBuffer: 在 Init 方法中，pipe.InitBuffer(inQueueX, BUFFER_NUM, ...) 相当于在本地内存中划分出 BUFFER_NUM (即2) 块独立的区域，并由 inQueueX 这个队列对象来管理。\n双缓冲 (Double Buffering) 详解: BUFFER_NUM=2 构成了双缓冲。想象有两块缓冲区 A 和 B：\n\nCopyIn: 调用 inQueueX.AllocTensor&lt;half&gt;() 会从空闲的缓冲区队列中取出一个（比如A），然后 DataCopy 指令启动 DMA 将 GM 数据拷贝到 A。完成后 inQueueX.EnQue(A) 将 A 标记为“已填充，可供计算”。\nCompute: 调用 inQueueX.DeQue&lt;half&gt;() 会从“已填充”队列中取出一个（比如A），然后计算单元对 A 中的数据进行计算。\n重叠执行: 当计算单元正在处理 A 的数据时，CopyIn 阶段可以同时向另一个空闲的缓冲区 B 中拷贝下一批数据。当 A 计算完成，B 也正好拷贝完成，计算单元可以马不停蹄地开始处理 B，而 DMA 则开始将 A 的计算结果写回 GM。\n\n\nfor 循环的流水线建立过程:\n\n迭代 i=0: CopyIn(0) 开始（数据块0从GM-&gt;LM），Compute(0) 和 CopyOut(0) 等待。\n迭代 i=1: CopyIn(1) 开始（数据块1从GM-&gt;LM），同时 Compute(0) 开始（处理数据块0）。CopyOut(1) 等待。\n迭代 i=2: CopyIn(2) 开始，Compute(1) 开始，CopyOut(0) 开始（将数据块0的结果从LM-&gt;GM）。至此，三级流水线完全建立，DMA的读、计算单元、DMA的写三个硬件部件都在满负荷工作。\n\n\n\n2.3 向量计算与硬件指令\n\nAscendC::Muls, AscendC::Exp, AscendC::Adds: 这些函数被称为内置函数（Intrinsics）。它们在编译时会被直接映射为 AI Core 的一条或多条向量指令。\n例如，AscendC::Exp(tmp2, tmp1, this-&gt;tileLength) 不是一个循环，而是一条指令。它告诉向量计算单元：“对 tmp1 指向的 tileLength 个半精度浮点数，逐个执行指数运算，并将结果存放到 tmp2 中”。这种 SIMD（单指令多数据） 的处理方式是 AI Core 性能的根本来源。\n\n2.4 数值计算优化\n\n问题: 硬件通常提供速度快但精度有限的近似计算指令，比如求倒数。对于某些需要高精度的算法，这可能导致误差累积。\n解决方案: 牛顿-拉弗森迭代法是一种经典的数值分析方法，可以用来求方程的根。对于求 1/a，相当于求方程 f(x) = 1/x - a 的根。\n代码映射:\n\nAscendC::Reciprocal(dst, src, length);: 使用硬件指令得到一个初始近似值 x_0 (即 dst)。src 是 a。\nAscendC::Mul(tmp, src, dst, length);: 计算 a * x_n，结果存入 tmp。\nAscendC::Muls(tmp, tmp, negone, length);: 变为 - (a * x_n)。\nAscendC::Adds(tmp, tmp, two, length);: 变为 2 - a * x_n。\nAscendC::Mul(dst, dst, tmp, length);: 计算 x_n * (2 - a * x_n)，得到 x_&#123;n+1&#125;，并覆盖回 dst。\n\n\n这个 for 循环每迭代一次，结果的精度就会翻倍。迭代2次就能获得非常高的精度，这体现了算法与硬件结合的优化思想。\n\n运行测试\n在运行之前，首先检查CMakePresets.json文件中的ASCEND_COMPUTE_UNIT和ASCEND_CANN_PACKAGE_PATH是否正确，如下\n&quot;ASCEND_COMPUTE_UNIT&quot;: &#123;    &quot;type&quot;: &quot;STRING&quot;,    &quot;value&quot;: &quot;ascend310b;ascend910b&quot;&#125;,&quot;ASCEND_CANN_PACKAGE_PATH&quot;: &#123;    &quot;type&quot;: &quot;PATH&quot;,    &quot;value&quot;: &quot;/home/ma-user/Ascend/ascend-toolkit/latest&quot;&#125;,\n然后检查SigmoidCustom中的AICore是否设置正确，如下\nthis-&gt;AICore().AddConfig(&quot;ascend910b&quot;)              .AddConfig(&quot;ascend310b&quot;);\n如果上述设置没有问题，就可以进行编译测试了\n运行编译\nbash build.sh\n编译之后会得到build_out目录，运行其中的安装包\ncd build_out./custom_opp_ubuntu_aarch64.run\n最后到AclNNInvocation中运行测试\nbash run.sh\n检验脚本会调用py脚本，分别用numpy和我们写的算子计算答案，然后对比误差，如果代码没有问题会给出测试成功的提示。由于华为云提供的这个环境属实有点贵，因此我就不再开机测试并截图了，大家自行操作\n随后按照认证要求将SigmoidCustom打包提交即可，测试通过后会获得认证证书，如下\n\n","categories":["华为算子挑战赛"],"tags":["Ascend C","算子开发"]},{"title":"常见数据结构-优先队列","url":"/posts/5beb8088/","content":"优先队列详解：数据结构中的「VIP通道」\n\n掌握优先队列，轻松解决 Top K 和动态数据流问题\n\n\n什么是优先队列\n优先队列（Priority Queue）是一种特殊的队列，其中每个元素都有一个「优先级」，出队时总是优先级最高的元素先出队。\n\n核心特点：不是先进先出（FIFO），而是按优先级出队\n\n形象理解\n想象你在机场登机：\n普通队列：先到先登机优先队列：VIP/头等舱先登机，然后才是经济舱\n底层实现：堆（Heap）\n优先队列通常用堆来实现：\ngraph TD\n    subgraph 最大堆\n        A[9] --&gt; B[7]\n        A --&gt; C[8]\n        B --&gt; D[3]\n        B --&gt; E[5]\n        C --&gt; F[6]\n        C --&gt; G[2]\n    end\n    \n    style A fill:#FF6B6B\n\n\n\n操作\n时间复杂度\n说明\n\n\n\n\n插入\nO(log n)\n上浮调整\n\n\n取出堆顶\nO(log n)\n下沉调整\n\n\n查看堆顶\nO(1)\n不需要调整\n\n\n建堆\nO(n)\n从下往上调整\n\n\n\n\nC++ 中的优先队列\n基本语法\n#include &lt;queue&gt;// 最大堆（默认）priority_queue&lt;int&gt; maxHeap;// 最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n常用操作\npriority_queue&lt;int&gt; pq;pq.push(5);     // 插入元素pq.top();       // 查看堆顶（不删除）pq.pop();       // 删除堆顶pq.empty();     // 是否为空pq.size();      // 元素个数\n自定义比较器\n// 方法1：使用 lambdaauto cmp = [](int a, int b) &#123; return a &gt; b; &#125;;  // 最小堆priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; pq(cmp);// 方法2：存储 pairauto cmp = [](pair&lt;int,int&gt;&amp; a, pair&lt;int,int&gt;&amp; b) &#123;    return a.second &gt; b.second;  // 按 second 的最小堆&#125;;priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; pq(cmp);// 方法3：自定义结构体struct Compare &#123;    bool operator()(int a, int b) &#123;        return a &gt; b;  // 最小堆    &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq;\n\n注意：C++ 优先队列的比较器与 sort 相反！return a &gt; b 表示最小堆\n\n\n典型应用场景\ngraph LR\n    A[优先队列] --&gt; B[Top K 问题]\n    A --&gt; C[合并 K 个有序结构]\n    A --&gt; D[数据流统计]\n    A --&gt; E[贪心算法]\n    A --&gt; F[堆排序]\n    \n    B --&gt; B1[第K大元素]\n    B --&gt; B2[前K个高频元素]\n    \n    C --&gt; C1[合并K个链表]\n    C --&gt; C2[合并K个数组]\n    \n    D --&gt; D1[数据流中位数]\n    D --&gt; D2[滑动窗口最大值]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n    style D fill:#DDA0DD\n\n经典问题详解\n1. 数组中的第K个最大元素\n\nLeetCode 215: 在未排序的数组中找到第 k 个最大的元素\n\n问题分析\n输入：[3, 2, 1, 5, 6, 4], k = 2输出：5排序后：[1, 2, 3, 4, 5, 6]第2大：5\n解法选择\n\n\n\n方法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n\n排序\nO(n log n)\nO(1)\n简单直接\n\n\n最小堆\nO(n log k)\nO(k)\nk 远小于 n\n\n\n快速选择\nO(n) 平均\nO(1)\n一次性查询\n\n\n\n代码实现\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    // 最小堆    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;        for (int num : nums) &#123;        minHeap.push(num);        // 保持堆大小为 k        if (minHeap.size() &gt; k) &#123;            minHeap.pop();  // 移除最小的        &#125;    &#125;        return minHeap.top();  // 堆顶就是第 k 大&#125;\n原理图解\nk = 2数组：[3, 2, 1, 5, 6, 4]step 1: push 3 → [3]step 2: push 2 → [2, 3]step 3: push 1 → [1, 2, 3] → pop → [2, 3]step 4: push 5 → [2, 3, 5] → pop → [3, 5]step 5: push 6 → [3, 5, 6] → pop → [5, 6]step 6: push 4 → [4, 5, 6] → pop → [5, 6]堆顶 = 5 = 第2大\n\n2. 前K个高频元素\n\nLeetCode 347: 给定一个非空的整数数组，返回其中出现频率前 k 高的元素\n\n问题分析\n输入：nums = [1,1,1,2,2,3], k = 2输出：[1, 2]\n两步走策略\ngraph LR\n    A[统计频率] --&gt; B[维护 Top K]\n    \n    A --&gt; A1[&quot;哈希表 O(n)&quot;]\n    B --&gt; B1[&quot;最小堆 O(n log k)&quot;]\n代码实现\nvector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;    // Step 1: 统计频率    unordered_map&lt;int, int&gt; freq;    for (int num : nums) &#123;        freq[num]++;    &#125;        // Step 2: 最小堆维护 Top K    auto cmp = [](pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123;        return a.second &gt; b.second;  // 按频率，小的在堆顶    &#125;;    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);        for (auto&amp; [num, count] : freq) &#123;        minHeap.push(&#123;num, count&#125;);        if (minHeap.size() &gt; k) &#123;            minHeap.pop();  // 移除频率最低的        &#125;    &#125;        // Step 3: 收集结果    vector&lt;int&gt; result;    while (!minHeap.empty()) &#123;        result.push_back(minHeap.top().first);        minHeap.pop();    &#125;        return result;&#125;\n\n3. 合并K个升序链表\n\nLeetCode 23: 给你一个链表数组，每个链表都已经按升序排列，请将所有链表合并到一个升序链表中\n\n问题分析\n输入：[[1,4,5], [1,3,4], [2,6]]输出：[1,1,2,3,4,4,5,6]\n解法对比\n\n\n\n方法\n时间复杂度\n说明\n\n\n\n\n逐一合并\nO(kn)\n简单但慢\n\n\n分治合并\nO(n log k)\n类似归并排序\n\n\n优先队列\nO(n log k)\n每次取最小\n\n\n\n代码实现（数组模拟）\nvector&lt;int&gt; mergeKSortedArrays(vector&lt;vector&lt;int&gt;&gt;&amp; arrays) &#123;    vector&lt;int&gt; result;        // 最小堆：&#123;值, 数组索引, 元素索引&#125;    auto cmp = [](auto&amp; a, auto&amp; b) &#123;        return get&lt;0&gt;(a) &gt; get&lt;0&gt;(b);    &#125;;    priority_queue&lt;tuple&lt;int,int,int&gt;, vector&lt;tuple&lt;int,int,int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);        // 初始化：加入每个数组的第一个元素    for (int i = 0; i &lt; arrays.size(); ++i) &#123;        if (!arrays[i].empty()) &#123;            minHeap.push(&#123;arrays[i][0], i, 0&#125;);        &#125;    &#125;        while (!minHeap.empty()) &#123;        auto [val, arrIdx, elemIdx] = minHeap.top();        minHeap.pop();        result.push_back(val);                // 加入该数组的下一个元素        if (elemIdx + 1 &lt; arrays[arrIdx].size()) &#123;            minHeap.push(&#123;arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1&#125;);        &#125;    &#125;        return result;&#125;\n过程图解\narrays: [[1,4,5], [1,3,4], [2,6]]初始堆：[(1,0,0), (1,1,0), (2,2,0)]        堆顶 = 1Step 1: pop (1,0,0) → result=[1] → push (4,0,1)Step 2: pop (1,1,0) → result=[1,1] → push (3,1,1)Step 3: pop (2,2,0) → result=[1,1,2] → push (6,2,1)...最终：[1,1,2,3,4,4,5,6]\n\n4. 数据流的中位数\n\nLeetCode 295: 设计一个支持以下两种操作的数据结构：添加数字、返回中位数\n\n核心思路：对顶堆\n使用两个堆：\n\n最大堆：存储较小的一半\n最小堆：存储较大的一半\n\ngraph LR\n    subgraph 较小的一半\n        A[最大堆]\n    end\n    \n    subgraph 较大的一半\n        B[最小堆]\n    end\n    \n    A --&gt;|堆顶| C[中位数]\n    B --&gt;|堆顶| C\n    \n    style A fill:#87CEEB\n    style B fill:#90EE90\n    style C fill:#FFE4B5\n核心约束\n\n最大堆的所有元素 ≤ 最小堆的所有元素\n两堆大小差不超过 1\n\n代码实现\nclass MedianFinder &#123;private:    priority_queue&lt;int&gt; maxHeap;  // 较小的一半    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 较大的一半    public:    void addNum(int num) &#123;        // Step 1: 先加入最大堆        maxHeap.push(num);                // Step 2: 最大堆的最大值移到最小堆        minHeap.push(maxHeap.top());        maxHeap.pop();                // Step 3: 平衡大小        if (minHeap.size() &gt; maxHeap.size()) &#123;            maxHeap.push(minHeap.top());            minHeap.pop();        &#125;    &#125;        double findMedian() &#123;        if (maxHeap.size() &gt; minHeap.size()) &#123;            return maxHeap.top();        &#125;        return (maxHeap.top() + minHeap.top()) / 2.0;    &#125;&#125;;\n插入过程演示\n添加 [1, 2, 3]add(1):  maxHeap.push(1) → maxHeap: [1]  move to minHeap → minHeap: [1]  balance → maxHeap: [1], minHeap: []  add(2):  maxHeap.push(2) → maxHeap: [2,1]  move to minHeap → maxHeap: [1], minHeap: [2]  (已平衡)add(3):  maxHeap.push(3) → maxHeap: [3,1]  move to minHeap → maxHeap: [1], minHeap: [2,3]  balance → maxHeap: [2,1], minHeap: [3]  中位数 = maxHeap.top() = 2\n\n5. 最后一块石头的重量\n\nLeetCode 1046: 每次选出最重的两块石头碰撞，返回最后剩下的石头重量\n\n代码实现\nint lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());        while (maxHeap.size() &gt; 1) &#123;        int stone1 = maxHeap.top(); maxHeap.pop();        int stone2 = maxHeap.top(); maxHeap.pop();                if (stone1 != stone2) &#123;            maxHeap.push(stone1 - stone2);        &#125;    &#125;        return maxHeap.empty() ? 0 : maxHeap.top();&#125;\n\n6. K个最接近原点的点\n\nLeetCode 973: 找出 K 个距离原点最近的点\n\n代码实现\nvector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;    // 最大堆：距离大的在堆顶    auto cmp = [](pair&lt;int,int&gt;&amp; a, pair&lt;int,int&gt;&amp; b) &#123;        return a.first &lt; b.first;    &#125;;    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; maxHeap(cmp);        for (int i = 0; i &lt; points.size(); ++i) &#123;        int dist = points[i][0]*points[i][0] + points[i][1]*points[i][1];        maxHeap.push(&#123;dist, i&#125;);        if (maxHeap.size() &gt; k) &#123;            maxHeap.pop();  // 移除距离最大的        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; result;    while (!maxHeap.empty()) &#123;        result.push_back(points[maxHeap.top().second]);        maxHeap.pop();    &#125;    return result;&#125;\n\n7. 堆排序\n\n利用堆的性质进行排序\n\n算法步骤\n\n建堆：将数组构建成最大堆\n排序：依次将堆顶（最大值）与末尾交换，然后调整堆\n\ngraph TD\n    subgraph 建堆\n        A[无序数组] --&gt; B[最大堆]\n    end\n    \n    subgraph 排序\n        B --&gt; C[堆顶与末尾交换]\n        C --&gt; D[缩小堆范围]\n        D --&gt; E[调整堆]\n        E --&gt;|重复| C\n    end\n    \n    E --&gt; F[有序数组]\n代码实现\nvoid heapSort(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();        // 建堆：从最后一个非叶子节点开始    for (int i = n/2 - 1; i &gt;= 0; --i) &#123;        heapify(nums, n, i);    &#125;        // 排序    for (int i = n - 1; i &gt; 0; --i) &#123;        swap(nums[0], nums[i]);  // 堆顶与末尾交换        heapify(nums, i, 0);      // 调整堆    &#125;&#125;void heapify(vector&lt;int&gt;&amp; nums, int n, int i) &#123;    int largest = i;    int left = 2 * i + 1;    int right = 2 * i + 2;        if (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;        largest = left;    &#125;    if (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;        largest = right;    &#125;        if (largest != i) &#123;        swap(nums[i], nums[largest]);        heapify(nums, n, largest);    &#125;&#125;\n复杂度分析\n\n时间：O(n log n)\n空间：O(1) 原地排序\n稳定性：不稳定\n\n\nTop K 问题总结\n选择合适的堆\n\n\n\n问题\n堆类型\n原因\n\n\n\n\n第 K 大元素\n最小堆\n堆顶是第 K 大\n\n\n第 K 小元素\n最大堆\n堆顶是第 K 小\n\n\n前 K 大元素\n最小堆\n淘汰堆顶（最小的）\n\n\n前 K 小元素\n最大堆\n淘汰堆顶（最大的）\n\n\n\n口诀\n\n求大用小，求小用大\n\n\n求最大的 K 个 → 用最小堆\n求最小的 K 个 → 用最大堆\n\n\n优先队列 vs 其他数据结构\n\n\n\n数据结构\n插入\n删除堆顶\n查找最值\n任意查找\n\n\n\n\n无序数组\nO(1)\nO(n)\nO(n)\nO(n)\n\n\n有序数组\nO(n)\nO(1)\nO(1)\nO(log n)\n\n\n优先队列\nO(log n)\nO(log n)\nO(1)\n❌\n\n\n平衡树\nO(log n)\nO(log n)\nO(log n)\nO(log n)\n\n\n\n\n思维导图\ngraph TD\n    A[优先队列] --&gt; B[基础操作]\n    A --&gt; C[经典问题]\n    A --&gt; D[高级应用]\n    \n    B --&gt; B1[push/pop/top]\n    B --&gt; B2[自定义比较器]\n    B --&gt; B3[最大堆/最小堆]\n    \n    C --&gt; C1[Top K 问题]\n    C --&gt; C2[合并 K 个链表]\n    C --&gt; C3[数据流中位数]\n    \n    D --&gt; D1[任务调度]\n    D --&gt; D2[Dijkstra 最短路]\n    D --&gt; D3[Huffman 编码]\n    \n    style A fill:#FFE4B5\n    style C1 fill:#87CEEB\n    style C2 fill:#90EE90\n    style C3 fill:#DDA0DD\n\n总结\n核心要点\n\n优先队列 = 堆：底层用堆实现，O(log n) 插入删除\n求大用小：需要最大的 K 个，用最小堆\n对顶堆：维护动态中位数的经典技巧\n堆排序：O(n log n)，原地排序\n\n常见模式\n\n\n\n模式\n典型问题\n关键点\n\n\n\n\n固定大小堆\n第 K 大\n堆大小保持 K\n\n\n对顶堆\n数据流中位数\n两个堆，一大一小\n\n\n多路归并\n合并 K 个链表\n每次取最小的那条\n\n\n贪心 + 堆\n任务调度\n优先处理某种特性的任务\n\n\n\n代码模板\n// Top K 问题模板priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 最小堆for (int num : nums) &#123;    minHeap.push(num);    if (minHeap.size() &gt; k) &#123;        minHeap.pop();    &#125;&#125;// minHeap.top() 就是第 K 大\n推荐阅读：\n\nLeetCode 优先队列专题\n《算法导论》第6章：堆排序\n\n","categories":["数据结构"],"tags":["C++","LeetCode","优先队列","堆","数据结构","算法设计"]},{"title":"常见数据结构-堆","url":"/posts/60d62905/","content":"堆详解：树的形，数组的心\n\n深入理解堆的内部原理和手写实现\n\n\n什么是堆\n堆（Heap）是一种特殊的完全二叉树，满足堆性质：每个节点的值都大于等于（或小于等于）其子节点的值。\n\n核心特点：用数组存储的完全二叉树，动态维护最值\n\n两种堆\ngraph LR\n    A[堆] --&gt; B[最大堆 Max Heap]\n    A --&gt; C[最小堆 Min Heap]\n    \n    B --&gt; B1[父节点 ≥ 子节点]\n    B --&gt; B2[根节点最大]\n    \n    C --&gt; C1[父节点 ≤ 子节点]\n    C --&gt; C2[根节点最小]\n    \n    style A fill:#FFE4B5\n    style B fill:#FF6B6B\n    style C fill:#87CEEB\n最大堆示例\n     9            数组表示：[9, 7, 8, 3, 5, 6, 2]   /   \\            7     8         索引关系： / \\   / \\        - 父节点 i3   5 6   2       - 左子节点 2i + 1                  - 右子节点 2i + 2\n最小堆示例\n     1            数组表示：[1, 3, 2, 7, 5, 6, 8]   /   \\            3     2         特点： / \\   / \\        - 完全二叉树7   5 6   8       - 父 ≤ 子\n\n为什么用数组存储\n完全二叉树的性质\n完全二叉树可以用数组紧凑存储，不浪费空间：\n        0      /   \\     1     2    / \\   / \\   3   4 5   6数组：[0, 1, 2, 3, 4, 5, 6]\n索引计算公式\n对于索引为 i 的节点：\n\n\n\n关系\n公式\n说明\n\n\n\n\n父节点\n(i - 1) / 2\n向下取整\n\n\n左子节点\n2 * i + 1\n-\n\n\n右子节点\n2 * i + 2\n-\n\n\n是否有左子\n2 * i + 1 &lt; size\n判断是否越界\n\n\n是否有右子\n2 * i + 2 &lt; size\n判断是否越界\n\n\n最后非叶子\nsize / 2 - 1\n建堆时的起点\n\n\n\n\n记忆技巧：从 0 开始索引，左子 = 2i+1，右子 = 2i+2\n\n\n堆的核心操作\n1. 上浮（Sift Up）\n使用场景：插入新元素后，恢复堆性质\n原理：新元素与父节点比较，若违反堆性质则交换，重复直到根节点或满足条件\n最大堆插入 10：步骤1: 插入到末尾          步骤2: 与父节点比较         9                        9       /   \\                    /   \\      7     8       →          10    8     / \\   / \\                / \\   / \\    3   5 6   2  10          3   5 6   2  7                ↑                         ↑            新插入                     上浮一次步骤3: 继续比较            步骤4: 完成         10                      10       /   \\                    /   \\      9     8       →          9     8     / \\   / \\                / \\   / \\    3   5 6   2  7           3   5 6   2  7    ↑                          上浮到根\n代码实现：\nvoid siftUp(vector&lt;int&gt;&amp; heap, int index) &#123;    while (index &gt; 0) &#123;        int parent = (index - 1) / 2;                // 最大堆：子节点 &gt; 父节点时上浮        if (heap[index] &gt; heap[parent]) &#123;            swap(heap[index], heap[parent]);            index = parent;        &#125; else &#123;            break;        &#125;    &#125;&#125;\n时间复杂度：O(log n)，最多上浮 h 层（h 为树高）\n\n2. 下沉（Sift Down）\n使用场景：删除堆顶后，恢复堆性质\n原理：用最后一个元素替换堆顶，然后与较大的子节点比较，若违反堆性质则交换，重复直到叶子节点或满足条件\n最大堆删除堆顶：步骤1: 用末尾替换堆顶      步骤2: 与子节点比较         9                        2       /   \\                    /   \\      7     8       →          7     8     / \\   / \\                / \\   /     3   5 6   2              3   5 6         删除 ↑                ↓              2              下沉步骤3: 交换并继续          步骤4: 完成         7                        8       /   \\                    /   \\      2     8       →          7     6     / \\   /                  / \\   /     3   5 6                  3   5 2        ↓                                    继续下沉                     稳定\n代码实现：\nvoid siftDown(vector&lt;int&gt;&amp; heap, int index, int size) &#123;    while (2 * index + 1 &lt; size) &#123;  // 有左子节点        int left = 2 * index + 1;        int right = 2 * index + 2;        int largest = index;                // 找出父、左子、右子中最大的        if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123;            largest = left;        &#125;        if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123;            largest = right;        &#125;                // 如果父节点最大，说明已满足堆性质        if (largest == index) &#123;            break;        &#125;                swap(heap[index], heap[largest]);        index = largest;    &#125;&#125;\n时间复杂度：O(log n)\n\n3. 插入（Insert）\n步骤：\n\n将新元素添加到数组末尾\n上浮调整\n\nvoid insert(vector&lt;int&gt;&amp; heap, int value) &#123;    heap.push_back(value);      // 添加到末尾    siftUp(heap, heap.size() - 1);  // 上浮&#125;\n时间复杂度：O(log n)\n\n4. 删除堆顶（Extract Max/Min）\n步骤：\n\n记录堆顶元素\n用最后一个元素替换堆顶\n删除最后一个元素\n下沉调整\n\nint extractMax(vector&lt;int&gt;&amp; heap) &#123;    if (heap.empty()) &#123;        throw runtime_error(&quot;Heap is empty&quot;);    &#125;        int maxValue = heap[0];          // 记录最大值    heap[0] = heap.back();           // 用末尾替换堆顶    heap.pop_back();                 // 删除末尾        if (!heap.empty()) &#123;        siftDown(heap, 0, heap.size());  // 下沉    &#125;        return maxValue;&#125;\n时间复杂度：O(log n)\n\n5. 建堆（Build Heap）\n方法1：自顶向下\n逐个插入元素，每次插入后上浮调整。\nvector&lt;int&gt; buildHeapTopDown(vector&lt;int&gt;&amp; arr) &#123;    vector&lt;int&gt; heap;    for (int num : arr) &#123;        insert(heap, num);  // O(log n) 插入    &#125;    return heap;&#125;\n时间复杂度：O(n log n)\n\n方法2：自底向上（更优）\n将数组看作完全二叉树，从最后一个非叶子节点开始，依次下沉调整。\n原数组：[3, 2, 1, 7, 8, 4, 5]步骤1：找最后非叶子节点 = size/2-1 = 2（值为1）         3       /   \\      2     1     / \\   / \\    7   8 4   5步骤2：从索引2开始下沉         3       /   \\      2     5     / \\   / \\    7   8 4   1步骤3：处理索引1         3       /   \\      8     5     / \\   / \\    7   2 4   1步骤4：处理索引0（根节点）         8       /   \\      7     5     / \\   / \\    3   2 4   1完成！最大堆构建完成\n代码实现：\nvoid buildHeap(vector&lt;int&gt;&amp; heap) &#123;    int n = heap.size();        // 从最后一个非叶子节点开始，向前遍历    for (int i = n / 2 - 1; i &gt;= 0; --i) &#123;        siftDown(heap, i, n);    &#125;&#125;\n时间复杂度：O(n) 🎯\n为什么是 O(n) 而不是 O(n log n)？\n虽然每次下沉最坏是 O(log n)，但实际上：\n\n叶子节点不需要下沉（占一半）\n倒数第二层最多下沉 1 层（占 1/4）\n倒数第三层最多下沉 2 层（占 1/8）\n…\n\n总时间 = n/2 × 0 + n/4 × 1 + n/8 × 2 + … = O(n)\n\n完整的堆类实现\nclass MaxHeap &#123;private:    vector&lt;int&gt; heap;        void siftUp(int index) &#123;        while (index &gt; 0) &#123;            int parent = (index - 1) / 2;            if (heap[index] &gt; heap[parent]) &#123;                swap(heap[index], heap[parent]);                index = parent;            &#125; else &#123;                break;            &#125;        &#125;    &#125;        void siftDown(int index) &#123;        int size = heap.size();        while (2 * index + 1 &lt; size) &#123;            int left = 2 * index + 1;            int right = 2 * index + 2;            int largest = index;                        if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123;                largest = left;            &#125;            if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123;                largest = right;            &#125;                        if (largest == index) break;                        swap(heap[index], heap[largest]);            index = largest;        &#125;    &#125;    public:    MaxHeap() &#123;&#125;        MaxHeap(vector&lt;int&gt; arr) : heap(arr) &#123;        // 建堆        for (int i = heap.size() / 2 - 1; i &gt;= 0; --i) &#123;            siftDown(i);        &#125;    &#125;        void insert(int value) &#123;        heap.push_back(value);        siftUp(heap.size() - 1);    &#125;        int extractMax() &#123;        if (heap.empty()) &#123;            throw runtime_error(&quot;Heap is empty&quot;);        &#125;                int maxValue = heap[0];        heap[0] = heap.back();        heap.pop_back();                if (!heap.empty()) &#123;            siftDown(0);        &#125;                return maxValue;    &#125;        int getMax() const &#123;        if (heap.empty()) &#123;            throw runtime_error(&quot;Heap is empty&quot;);        &#125;        return heap[0];    &#125;        int size() const &#123;        return heap.size();    &#125;        bool empty() const &#123;        return heap.empty();    &#125;&#125;;\n\n堆排序详解\n算法思路\n利用堆的性质进行排序：\n\n建堆：O(n)\n排序：依次取出堆顶（最大值），放到数组末尾\n\n原数组：[3, 2, 1, 7, 8, 4, 5]步骤1：建最大堆[8, 7, 5, 3, 2, 4, 1] ↑ 最大值步骤2：堆顶与末尾交换[1, 7, 5, 3, 2, 4 | 8] ↑              已排序步骤3：缩小堆范围并下沉调整[7, 3, 5, 1, 2, 4 | 8] ↑              已排序步骤4：重复[4, 3, 5, 1, 2 | 7, 8][5, 3, 4, 1, 2 | 7, 8]...[1, 2, 3, 4, 5, 7, 8]  完成！\n代码实现\nvoid heapSort(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();        // 1. 建堆（从最后一个非叶子节点开始）    for (int i = n / 2 - 1; i &gt;= 0; --i) &#123;        heapify(nums, n, i);    &#125;        // 2. 排序（依次取出堆顶）    for (int i = n - 1; i &gt; 0; --i) &#123;        swap(nums[0], nums[i]);   // 堆顶与末尾交换        heapify(nums, i, 0);       // 调整堆    &#125;&#125;void heapify(vector&lt;int&gt;&amp; nums, int n, int i) &#123;    int largest = i;    int left = 2 * i + 1;    int right = 2 * i + 2;        if (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;        largest = left;    &#125;    if (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;        largest = right;    &#125;        if (largest != i) &#123;        swap(nums[i], nums[largest]);        heapify(nums, n, largest);    &#125;&#125;\n复杂度分析\n\n时间复杂度：O(n log n)\n\n建堆：O(n)\nn-1 次调整，每次 O(log n)\n\n\n空间复杂度：O(1) 原地排序\n稳定性：❌ 不稳定\n\n堆排序的优缺点\n\n\n\n优点\n缺点\n\n\n\n\n✅ 时间复杂度稳定\n❌ 不稳定排序\n\n\n✅ 原地排序，空间 O(1)\n❌ 缓存不友好\n\n\n✅ 不依赖输入分布\n❌ 实际性能不如快排\n\n\n\n\n堆 vs 其他数据结构\n操作复杂度对比\n\n\n\n数据结构\n插入\n删除最值\n查看最值\n查找任意元素\n\n\n\n\n堆\nO(log n)\nO(log n)\nO(1)\nO(n)\n\n\n无序数组\nO(1)\nO(n)\nO(n)\nO(n)\n\n\n有序数组\nO(n)\nO(1)\nO(1)\nO(log n)\n\n\n平衡二叉搜索树\nO(log n)\nO(log n)\nO(log n)\nO(log n)\n\n\n\n堆的优势场景\ngraph LR\n    A[什么时候用堆？] --&gt; B[需要频繁获取最值]\n    A --&gt; C[不需要查找任意元素]\n    A --&gt; D[动态数据流]\n    A --&gt; E[Top K 问题]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n    style E fill:#87CEEB\n\n经典应用场景\n1. Top K 问题\n// 第 K 大元素int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 最小堆        for (int num : nums) &#123;        minHeap.push(num);        if (minHeap.size() &gt; k) &#123;            minHeap.pop();        &#125;    &#125;        return minHeap.top();&#125;\n2. 合并 K 个有序链表/数组\nvector&lt;int&gt; mergeKSorted(vector&lt;vector&lt;int&gt;&gt;&amp; arrays) &#123;    auto cmp = [](tuple&lt;int,int,int&gt;&amp; a, tuple&lt;int,int,int&gt;&amp; b) &#123;        return get&lt;0&gt;(a) &gt; get&lt;0&gt;(b);  // 最小堆    &#125;;    priority_queue&lt;tuple&lt;int,int,int&gt;, vector&lt;tuple&lt;int,int,int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);        // 初始化：每个数组的第一个元素    for (int i = 0; i &lt; arrays.size(); ++i) &#123;        if (!arrays[i].empty()) &#123;            minHeap.push(&#123;arrays[i][0], i, 0&#125;);        &#125;    &#125;        vector&lt;int&gt; result;    while (!minHeap.empty()) &#123;        auto [val, arrIdx, elemIdx] = minHeap.top();        minHeap.pop();        result.push_back(val);                // 加入下一个元素        if (elemIdx + 1 &lt; arrays[arrIdx].size()) &#123;            minHeap.push(&#123;arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1&#125;);        &#125;    &#125;        return result;&#125;\n3. 数据流中位数\nclass MedianFinder &#123;private:    priority_queue&lt;int&gt; maxHeap;  // 较小的一半    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;  // 较大的一半    public:    void addNum(int num) &#123;        maxHeap.push(num);        minHeap.push(maxHeap.top());        maxHeap.pop();                if (minHeap.size() &gt; maxHeap.size()) &#123;            maxHeap.push(minHeap.top());            minHeap.pop();        &#125;    &#125;        double findMedian() &#123;        if (maxHeap.size() &gt; minHeap.size()) &#123;            return maxHeap.top();        &#125;        return (maxHeap.top() + minHeap.top()) / 2.0;    &#125;&#125;;\n\n最大堆 vs 最小堆\n何时使用？\ngraph TD\n    A[选择堆类型] --&gt; B&#123;需要什么？&#125;\n    \n    B --&gt;|最大值| C[最大堆]\n    B --&gt;|最小值| D[最小堆]\n    \n    C --&gt; E[直接获取]\n    D --&gt; F[直接获取]\n    \n    style A fill:#FFE4B5\n    style C fill:#FF6B6B\n    style D fill:#87CEEB\nTop K 问题口诀\n\n求大用小，求小用大\n\n\n\n\n问题\n使用的堆\n原因\n\n\n\n\n第 K 大元素\n最小堆\n保留最大的 K 个\n\n\n第 K 小元素\n最大堆\n保留最小的 K 个\n\n\n前 K 大\n最小堆\n淘汰小的，保留大的\n\n\n前 K 小\n最大堆\n淘汰大的，保留小的\n\n\n\n代码转换\n// 最大堆（默认）priority_queue&lt;int&gt; maxHeap;// 最小堆（需要指定比较器）priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;// 自定义比较器auto cmp = [](int a, int b) &#123; return a &gt; b; &#125;;  // 最小堆priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; customHeap(cmp);\n\n堆的变种\n1. 二叉堆（Binary Heap）\n我们刚才讲的就是二叉堆，最常用。\n2. 斐波那契堆（Fibonacci Heap）\n\n优点：合并操作 O(1)\n缺点：实现复杂，常数因子大\n应用：Dijkstra、Prim 算法的优化版本\n\n3. 二项堆（Binomial Heap）\n\n特点：多个二项树组成\n应用：理论研究\n\n\n常见陷阱与技巧\n陷阱1：索引计算错误\n// ❌ 错误：从1开始索引int parent = i / 2;      // 不适用于从0开始的数组// ✅ 正确：从0开始索引int parent = (i - 1) / 2;int left = 2 * i + 1;int right = 2 * i + 2;\n陷阱2：比较器方向搞反\n// C++ priority_queue 的比较器与 sort 相反！// 最小堆（堆顶最小）auto cmp = [](int a, int b) &#123; return a &gt; b; &#125;;  // 注意是 &gt;// 最大堆（堆顶最大）auto cmp = [](int a, int b) &#123; return a &lt; b; &#125;;  // 注意是 &lt;\n技巧1：建堆优化\n// ❌ 低效：逐个插入 O(n log n)for (int num : nums) &#123;    minHeap.push(num);&#125;// ✅ 高效：批量建堆 O(n)priority_queue&lt;int&gt; maxHeap(nums.begin(), nums.end());\n技巧2：记住口诀\n\n求大用小，求小用大\n父节点 = (i-1)/2\n左子 = 2i+1，右子 = 2i+2\n\n\n思维导图\ngraph TD\n    A[堆] --&gt; B[基本概念]\n    A --&gt; C[核心操作]\n    A --&gt; D[应用场景]\n    A --&gt; E[经典算法]\n    \n    B --&gt; B1[完全二叉树]\n    B --&gt; B2[数组存储]\n    B --&gt; B3[最大堆/最小堆]\n    \n    C --&gt; C1[上浮 O log n]\n    C --&gt; C2[下沉 O log n]\n    C --&gt; C3[插入 O log n]\n    C --&gt; C4[删除堆顶 O log n]\n    C --&gt; C5[建堆 O n]\n    \n    D --&gt; D1[Top K 问题]\n    D --&gt; D2[优先队列]\n    D --&gt; D3[堆排序]\n    D --&gt; D4[数据流统计]\n    \n    E --&gt; E1[堆排序]\n    E --&gt; E2[Dijkstra]\n    E --&gt; E3[Huffman编码]\n    \n    style A fill:#FFE4B5\n    style C fill:#87CEEB\n    style D fill:#90EE90\n\n总结\n核心要点\n\n堆 = 完全二叉树 + 数组存储\n两个关键操作：上浮、下沉\n建堆优化：自底向上 O(n)\nTop K 口诀：求大用小，求小用大\n\n时间复杂度总结\n\n\n\n操作\n时间复杂度\n备注\n\n\n\n\n插入\nO(log n)\n上浮\n\n\n删除堆顶\nO(log n)\n下沉\n\n\n查看堆顶\nO(1)\n直接访问\n\n\n建堆\nO(n)\n自底向上\n\n\n堆排序\nO(n log n)\nn 次删除堆顶\n\n\n\n代码模板\n// 最大堆核心操作class MaxHeap &#123;    // 上浮    void siftUp(int i) &#123;        while (i &gt; 0 &amp;&amp; heap[i] &gt; heap[(i-1)/2]) &#123;            swap(heap[i], heap[(i-1)/2]);            i = (i - 1) / 2;        &#125;    &#125;        // 下沉    void siftDown(int i) &#123;        while (2*i+1 &lt; size) &#123;            int j = 2*i+1;  // 左子            if (j+1 &lt; size &amp;&amp; heap[j+1] &gt; heap[j]) j++;  // 右子更大            if (heap[i] &gt;= heap[j]) break;            swap(heap[i], heap[j]);            i = j;        &#125;    &#125;&#125;;\n推荐练习：\n\nLeetCode 215 - 数组中的第K个最大元素\nLeetCode 347 - 前K个高频元素\nLeetCode 295 - 数据流的中位数\nLeetCode 23 - 合并K个升序链表\n\n推荐阅读：\n\n《算法导论》第6章：堆排序\nLeetCode 堆专题\n\n","categories":["数据结构"],"tags":["C++","LeetCode","堆","数据结构","算法设计"]},{"title":"常见算法-KMP","url":"/posts/d26e9827/","content":"KMP 字符串匹配算法详解：从原理到实现\n\n深入理解 KMP 算法的核心思想，掌握高效字符串匹配的关键技术\n\n\n引言\nKMP（Knuth-Morris-Pratt）算法是计算机科学中最经典的字符串匹配算法之一，由 Donald Knuth、Vaughan Pratt 和 James H. Morris 在 1977 年共同发明。该算法通过预处理模式串，避免了暴力匹配中的重复比较，将时间复杂度从 O(m×n) 优化到 O(m+n)。\n适用场景：\n\n文本编辑器的查找功能\nDNA 序列匹配\n网络数据包检测\n编译器词法分析\n\n\n问题背景\n字符串匹配问题定义\n给定两个字符串：\n\n主串（文本串）：需要被搜索的字符串，长度为 n\n模式串（模板串）：要查找的子串，长度为 m\n\n目标：在主串中找到第一次出现模式串的位置。\n主串：  ABABDABACDABABCABAB模式串：      ABABCABAB\n\n暴力匹配的局限性\n暴力算法流程\nint bruteForce(const string&amp; text, const string&amp; pattern) &#123;    int n = text.size();    int m = pattern.size();        for (int i = 0; i &lt;= n - m; i++) &#123;        int j = 0;        while (j &lt; m &amp;&amp; text[i + j] == pattern[j]) &#123;            j++;        &#125;        if (j == m) return i;  // 找到匹配    &#125;    return -1;  // 未找到&#125;\n暴力匹配的问题\n主串：  A B A B A B C模式串：A B A B C步骤1：  A B A B A B C        A B A B C        ✓ ✓ ✓ ✓ ✗ (第5位失配)步骤2：  A B A B A B C          A B A B C          ✗ (第1位就失配，浪费！)步骤3：  A B A B A B C            A B A B C            ✓ ✓ ✓ ✓ ✓ (成功)\n问题：失配后，模式串从头开始，主串回退，导致重复比较。\ngraph TD\n    A[主串位置 i] --&gt; B&#123;text i == pattern j?&#125;\n    B --&gt;|是| C[i++, j++]\n    B --&gt;|否| D[i 回退到 i-j+1]\n    D --&gt; E[j 重置为 0]\n    E --&gt; F[重新匹配]\n时间复杂度：O(m×n)，最坏情况下每个位置都要尝试完整匹配。\n\nKMP 核心思想\n关键洞察\n当失配发生时，我们已经知道了前面已经匹配的部分，可以利用这些信息避免回退。\n主串：  A B A B A B C模式串：A B A B C        ✓ ✓ ✓ ✓ ✗已知：前4个字符 &quot;ABAB&quot; 已匹配观察：模式串的前缀 &quot;AB&quot; 等于已匹配部分的后缀 &quot;AB&quot;结论：可以直接将模式串滑动到对齐位置，无需回退主串指针\nKMP 的两大创新\n\n主串指针不回退：i 只向前移动，永不后退\n模式串智能跳转：通过 next 数组确定失配后模式串应该跳到哪里\n\ngraph LR\n    A[失配发生] --&gt; B[查询 next 数组]\n    B --&gt; C[模式串跳转]\n    C --&gt; D[继续匹配]\n    D --&gt; E&#123;匹配成功?&#125;\n    E --&gt;|是| F[完成]\n    E --&gt;|否| B\n\nNext 数组详解\nNext 数组的定义\nnext[i] 表示：模式串中以位置 i 结尾的子串的最长相等前后缀的长度。\n模式串：A B A B C A B A B索引：  0 1 2 3 4 5 6 7 8next：  0 0 1 2 0 1 2 3 4\n解释：\n\nnext[0] = 0：单个字符没有前后缀\nnext[1] = 0：AB 没有相等的前后缀\nnext[2] = 1：ABA 的最长相等前后缀是 A（长度1）\nnext[3] = 2：ABAB 的最长相等前后缀是 AB（长度2）\nnext[4] = 0：ABABC 没有相等的前后缀\nnext[7] = 3：ABABCAB 的最长相等前后缀是 AB（长度2）… 等等\n\n前缀和后缀的概念\n字符串：A B C D前缀：A, AB, ABC     (不包含最后一个字符)后缀：D, CD, BCD     (不包含第一个字符)\nNext 数组的构建\n核心思想：利用已经计算出的 next 值来计算新的值（动态规划思想）。\nvector&lt;int&gt; buildNext(const string&amp; pattern) &#123;    int n = pattern.size();    vector&lt;int&gt; next(n);    next[0] = 0;  // 第一个字符的 next 值为 0        int j = 0;  // j 表示当前最长相等前后缀的长度        for (int i = 1; i &lt; n; i++) &#123;        // 如果不匹配，回退 j        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) &#123;            j = next[j - 1];        &#125;                // 如果匹配，增加前后缀长度        if (pattern[i] == pattern[j]) &#123;            j++;        &#125;                next[i] = j;    &#125;        return next;&#125;\n构建过程示例\n模式串：ABABCABAB\ni=0: pattern[0]=&#x27;A&#x27;     next[0] = 0i=1: pattern[1]=&#x27;B&#x27;, pattern[0]=&#x27;A&#x27;     不匹配，j=0     next[1] = 0i=2: pattern[2]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;     匹配！j=1     next[2] = 1i=3: pattern[3]=&#x27;B&#x27;, pattern[1]=&#x27;B&#x27;     匹配！j=2     next[3] = 2i=4: pattern[4]=&#x27;C&#x27;, pattern[2]=&#x27;A&#x27;     不匹配，j回退到next[1]=0     pattern[4]=&#x27;C&#x27;, pattern[0]=&#x27;A&#x27;     不匹配，j=0     next[4] = 0i=5: pattern[5]=&#x27;A&#x27;, pattern[0]=&#x27;A&#x27;     匹配！j=1     next[5] = 1... (以此类推)\n最终结果：\n\n\n\n索引\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n字符\nA\nB\nA\nB\nC\nA\nB\nA\nB\n\n\nnext\n0\n0\n1\n2\n0\n1\n2\n3\n4\n\n\n\ngraph TD\n    A[开始: i=1, j=0] --&gt; B&#123;pattern i == pattern j?&#125;\n    B --&gt;|是| C[j++]\n    C --&gt; D[next i = j]\n    D --&gt; E[i++]\n    \n    B --&gt;|否| F&#123;j &gt; 0?&#125;\n    F --&gt;|是| G[j = next j-1]\n    G --&gt; B\n    F --&gt;|否| H[next i = 0]\n    H --&gt; E\n    \n    E --&gt; I&#123;i &lt; n?&#125;\n    I --&gt;|是| B\n    I --&gt;|否| J[完成]\n\n算法实现\n完整实现\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class KMP &#123;public:    // 构建 next 数组    vector&lt;int&gt; buildNext(const string&amp; pattern) &#123;        int n = pattern.size();        vector&lt;int&gt; next(n);        if (n == 0) return next;                next[0] = 0;        int j = 0;                for (int i = 1; i &lt; n; i++) &#123;            // 失配时回退            while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) &#123;                j = next[j - 1];            &#125;                        // 匹配时前进            if (pattern[i] == pattern[j]) &#123;                j++;            &#125;                        next[i] = j;        &#125;                return next;    &#125;        // KMP 搜索    int search(const string&amp; text, const string&amp; pattern) &#123;        int n = text.size();        int m = pattern.size();                if (m == 0) return 0;        if (n &lt; m) return -1;                vector&lt;int&gt; next = buildNext(pattern);        int j = 0;  // 模式串指针                for (int i = 0; i &lt; n; i++) &#123;  // 主串指针            // 失配时，模式串回退            while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) &#123;                j = next[j - 1];            &#125;                        // 匹配时，模式串前进            if (text[i] == pattern[j]) &#123;                j++;            &#125;                        // 完全匹配            if (j == m) &#123;                return i - m + 1;  // 返回起始位置            &#125;        &#125;                return -1;  // 未找到    &#125;&#125;;int main() &#123;    KMP kmp;        string text = &quot;ABABDABACDABABCABAB&quot;;    string pattern = &quot;ABABCABAB&quot;;        int pos = kmp.search(text, pattern);        if (pos != -1) &#123;        cout &lt;&lt; &quot;在位置 &quot; &lt;&lt; pos &lt;&lt; &quot; 找到模式串&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;主串：&quot; &lt;&lt; text &lt;&lt; endl;        cout &lt;&lt; &quot;匹配：&quot; &lt;&lt; string(pos, &#x27; &#x27;) &lt;&lt; pattern &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;未找到模式串&quot; &lt;&lt; endl;    &#125;        return 0;&#125;\n输出：\n在位置 10 找到模式串主串：ABABDABACDABABCABAB匹配：          ABABCABAB\n\n复杂度分析\n时间复杂度\n\n\n构建 next 数组：O(m)\n\n外层循环：遍历模式串 m 个字符\n内层 while 循环：j 最多回退 m 次（均摊分析）\n\n\n\n匹配过程：O(n)\n\n外层循环：遍历主串 n 个字符\n内层 while 循环：j 最多回退 n 次（均摊分析）\n\n\n\n总时间复杂度：O(m + n)\n空间复杂度\nO(m)：需要存储 next 数组。\n与暴力算法对比\n\n\n\n算法\n时间复杂度\n空间复杂度\n主串指针\n\n\n\n\n暴力匹配\nO(m×n)\nO(1)\n会回退\n\n\nKMP\nO(m+n)\nO(m)\n不回退\n\n\n\n性能提升：\n对于长度为 1000 的主串和长度为 100 的模式串：\n\n暴力：最坏 100,000 次比较\nKMP：最多 1,100 次比较\n\n\n总结\n核心要点\n\nKMP 的本质：利用已匹配信息，避免无效回退\nNext 数组：记录最长相等前后缀，是算法的核心\n时间复杂度：O(m+n)，主串指针不回退\n适用场景：单模式串匹配，需要高效查找\n\n优缺点对比\n优点：\n\n✓ 时间复杂度优秀：O(m+n)\n✓ 主串指针不回退，适合流式处理\n✓ 易于理解和实现\n\n缺点：\n\n✗ 需要额外空间：O(m)\n✗ 多模式匹配需要多次调用\n✗ 对于短模式串，可能不如暴力快（常数因子）\n\n与其他算法对比\n\n\n\n算法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n\n暴力\nO(m×n)\nO(1)\n短串、简单场景\n\n\nKMP\nO(m+n)\nO(m)\n单模式、长串\n\n\nBM\nO(n/m)\nO(m)\n长模式串\n\n\nAC自动机\nO(n+m+k)\nO(m×字符集)\n多模式匹配\n\n\n\n扩展阅读\n\nKMP 算法原始论文\nBoyer-Moore 算法\nAho-Corasick 自动机（多模式匹配）\nSunday 算法\n\n","categories":["算法"],"tags":["C++","LeetCode","数据结构","KMP","字符串匹配","动态规划"]},{"title":"常见算法-Kadane","url":"/posts/251a1af2/","content":"引言\nKadane算法是解决最大子数组和问题的经典动态规划算法，由计算机科学家Jay Kadane于1984年提出。该算法以极其简洁的代码实现了O(n)的最优时间复杂度，是动态规划空间优化的典范。\n\n问题背景\n最大子数组和问题\n\nLeetCode 53: 给定一个整数数组，找到具有最大和的连续子数组，返回其最大和。\n\n示例：\n输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6\n应用场景\n\n股票交易：找到最佳买卖时机的最大利润\n信号处理：在噪声中找到最强信号段\n生物信息学：DNA序列分析\n数据分析：找到业务指标的最佳表现时段\n\n\n算法演变\n方法1: 暴力枚举\n枚举所有可能的子数组：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxSum = INT_MIN;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        for (int j = i; j &lt; nums.size(); ++j) &#123;            int sum = 0;            for (int k = i; k &lt;= j; ++k) &#123;                sum += nums[k];            &#125;            maxSum = max(maxSum, sum);        &#125;    &#125;    return maxSum;&#125;\n时间复杂度：O(n³)\n问题：三层循环，效率极低\n方法2: 优化暴力\n利用前缀和优化：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxSum = INT_MIN;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        int sum = 0;        for (int j = i; j &lt; nums.size(); ++j) &#123;            sum += nums[j];  // 累加，避免重复计算            maxSum = max(maxSum, sum);        &#125;    &#125;    return maxSum;&#125;\n时间复杂度：O(n²)\n问题：仍然较慢\n方法3: 分治算法\n如之前在DivideAndConqer.cpp中实现：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    // 分成左右两半，递归求解    // 考虑跨越中点的情况&#125;\n时间复杂度：O(n log n)\n优势：比O(n²)快，适合理解分治思想\n方法4: Kadane算法\n最优解法：\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n时间复杂度：O(n)\n空间复杂度：O(1)\n完美！\n\nKadane算法原理\n核心思想\n对于数组中的每个位置，我们只需要做一个决定：\n\n当前元素应该加入之前的子数组，还是从当前元素重新开始？\n\n对于位置 i：maxEndingHere[i] = max(nums[i], maxEndingHere[i-1] + nums[i])                   ↑           ↑                重新开始    加入之前的子数组\n状态定义\n\nmaxEndingHere：以当前位置结尾的最大子数组和\nmaxSoFar：全局最大子数组和\n\n决策过程可视化\n数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]位置0: maxEndingHere = -2, maxSoFar = -2       [-2]位置1: maxEndingHere = max(1, -2+1) = 1 (重新开始)       maxSoFar = 1       [1]位置2: maxEndingHere = max(-3, 1-3) = -2 (继续)       maxSoFar = 1       [1, -3]位置3: maxEndingHere = max(4, -2+4) = 4 (重新开始)       maxSoFar = 4       [4]位置4: maxEndingHere = max(-1, 4-1) = 3 (继续)       maxSoFar = 4       [4, -1]位置5: maxEndingHere = max(2, 3+2) = 5 (继续)       maxSoFar = 5       [4, -1, 2]位置6: maxEndingHere = max(1, 5+1) = 6 (继续)       maxSoFar = 6       [4, -1, 2, 1] ← 答案！位置7: maxEndingHere = max(-5, 6-5) = 1 (继续)       maxSoFar = 6位置8: maxEndingHere = max(4, 1+4) = 5 (继续)       maxSoFar = 6\ngraph LR\n    A[-2] --&gt;|重新开始| B[1]\n    B --&gt;|继续| C[-3]\n    C --&gt;|重新开始| D[4]\n    D --&gt;|继续| E[-1]\n    E --&gt;|继续| F[2]\n    F --&gt;|继续| G[1]\n    G --&gt;|继续| H[-5]\n    H --&gt;|继续| I[4]\n    \n    style D fill:#FFE4B5\n    style E fill:#FFE4B5\n    style F fill:#FFE4B5\n    style G fill:#90EE90\n为什么这样做是对的？\n关键洞察：\n如果 maxEndingHere[i-1] &lt; 0，那么加上它只会让结果变小，不如重新开始！\n如果前面的和是负数：  -5 + 3 = -2  (不如直接从3开始)  如果前面的和是正数：  5 + 3 = 8   (应该继续)\n\n代码实现\n基础版本\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    if (nums.empty()) return 0;        int maxEndingHere = nums[0];  // 以当前位置结尾的最大和    int maxSoFar = nums[0];       // 全局最大和        for (int i = 1; i &lt; nums.size(); ++i) &#123;        // 核心决策        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n动态规划视角\n// 等价的DP写法（更占空间）int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; dp(n);  // dp[i] = 以i结尾的最大子数组和        dp[0] = nums[0];    int maxSum = dp[0];        for (int i = 1; i &lt; n; ++i) &#123;        dp[i] = max(nums[i], dp[i-1] + nums[i]);        maxSum = max(maxSum, dp[i]);    &#125;        return maxSum;&#125;\n观察：dp[i]只依赖于dp[i-1]，所以可以用一个变量代替数组！\n返回子数组位置\nstruct SubarrayInfo &#123;    int sum;    int start;    int end;&#125;;SubarrayInfo maxSubArrayWithIndices(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];    int start = 0, end = 0;    int tempStart = 0;        for (int i = 1; i &lt; nums.size(); ++i) &#123;        if (nums[i] &gt; maxEndingHere + nums[i]) &#123;            maxEndingHere = nums[i];            tempStart = i;  // 重新开始，更新起始位置        &#125; else &#123;            maxEndingHere = maxEndingHere + nums[i];        &#125;                if (maxEndingHere &gt; maxSoFar) &#123;            maxSoFar = maxEndingHere;            start = tempStart;            end = i;        &#125;    &#125;        return &#123;maxSoFar, start, end&#125;;&#125;\n\n正确性证明\n归纳法证明\n基础情况：一个元素时，算法显然正确。\n归纳假设：假设对于前i-1个元素，算法正确。\n归纳步骤：对于第i个元素：\n\n\n如果maxEndingHere[i-1] + nums[i] &gt; nums[i]\n\n说明前面的子数组对当前有贡献\n应该继续\n\n\n\n如果maxEndingHere[i-1] + nums[i] &lt;= nums[i]\n\n说明前面的子数组拖后腿\n应该重新开始\n\n\n\n因此，算法在每一步都做出了最优决策。\n反例分析\n错误想法：遇到负数就重新开始？\n数组：[5, -2, 3]错误：遇到-2就重新开始 → 最大和 = 5正确：5 + (-2) + 3 = 6\nKadane的优势：它考虑的是&quot;累积贡献&quot;，而不是单个元素的正负。\n\n变种问题\n1. 环形数组的最大子数组和\n\nLeetCode 918: 环形子数组的最大和\n\n思路：环形数组的最大子数组只有两种情况：\n\n不跨越边界：正常Kadane算法\n跨越边界：总和 - 最小子数组和\n\nint maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;    int totalSum = 0;    int maxSum = INT_MIN, minSum = INT_MAX;    int maxEndingHere = 0, minEndingHere = 0;        for (int num : nums) &#123;        totalSum += num;                // 最大子数组        maxEndingHere = max(num, maxEndingHere + num);        maxSum = max(maxSum, maxEndingHere);                // 最小子数组        minEndingHere = min(num, minEndingHere + num);        minSum = min(minSum, minEndingHere);    &#125;        // 特殊情况：所有元素都是负数    if (maxSum &lt; 0) return maxSum;        return max(maxSum, totalSum - minSum);&#125;\n可视化：\n数组：[5, -3, 5]情况1 (不跨越)：[5, -3, 5] → 和 = 7情况2 (跨越)：[5] + [5] → 和 = 10 ✓计算：总和 - 最小子数组和 = 7 - (-3) = 10\n2. 乘积最大子数组\n\nLeetCode 152: 乘积最大子数组\n\n关键：负数 × 负数 = 正数，需要同时维护最大值和最小值！\nint maxProduct(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int minEndingHere = nums[0];    int result = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        int num = nums[i];        int tempMax = maxEndingHere;                // 可能：当前元素、最大值×当前、最小值×当前        maxEndingHere = max(&#123;num, maxEndingHere * num, minEndingHere * num&#125;);        minEndingHere = min(&#123;num, tempMax * num, minEndingHere * num&#125;);                result = max(result, maxEndingHere);    &#125;        return result;&#125;\n示例：\n数组：[2, 3, -2, 4]i=0: max=2,  min=2,  result=2i=1: max=6,  min=3,  result=6   (2×3)i=2: max=-2, min=-12, result=6  (6×-2 vs 3×-2)i=3: max=4,  min=-48, result=6  (-12×-2 才是最大的中间结果，但4最后才来)答案[2,3]的乘积=6\n3. 股票买卖最佳时机\n\nLeetCode 121: 买卖股票的最佳时机\n\n转换：最大利润 = 最大子数组和（差分数组）\nint maxProfit(vector&lt;int&gt;&amp; prices) &#123;    if (prices.size() &lt; 2) return 0;        int minPrice = prices[0];    int maxProfit = 0;        for (int i = 1; i &lt; prices.size(); ++i) &#123;        maxProfit = max(maxProfit, prices[i] - minPrice);        minPrice = min(minPrice, prices[i]);    &#125;        return maxProfit;&#125;\nKadane视角：\n// 将价格数组转换为差分数组vector&lt;int&gt; diff;for (int i = 1; i &lt; prices.size(); ++i) &#123;    diff.push_back(prices[i] - prices[i-1]);&#125;// 然后在diff上运行Kadane算法\n\n性能对比\n时间复杂度对比\n\n\n\n方法\n时间复杂度\n空间复杂度\n\n\n\n\n暴力枚举\nO(n³)\nO(1)\n\n\n优化暴力\nO(n²)\nO(1)\n\n\n分治算法\nO(n log n)\nO(log n)\n\n\nKadane算法\nO(n)\nO(1)\n\n\n\n为什么Kadane最优？\n\n单次遍历：只需要扫描数组一次\n常数空间：只用两个变量\n无递归：没有函数调用开销\n缓存友好：顺序访问，利用CPU缓存\n\n\n总结\n核心要点\n\nKadane算法是最大子数组和的最优解\n时间O(n)，空间O(1)\n动态规划的空间优化经典例子\n关键在于理解&quot;何时重新开始&quot;\n\n算法模板\nint kadane(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n记忆口诀\n\n加入或重启，两者取大；\n全局最优，随时更新。\n\n扩展学习\n相关算法：\n\n最大子矩阵和：二维Kadane\n最长递增子序列：类似的DP思想\n股票买卖系列：状态机DP\n\n\n推荐练习：\n\nLeetCode 53 - 最大子数组和\nLeetCode 152 - 乘积最大子数组\nLeetCode 918 - 环形子数组的最大和\n\n","categories":["算法"],"tags":["C++","LeetCode","动态规划","Kadane","最大子数组和","贪心"]},{"title":"常见算法-一维动态规划","url":"/posts/a92afa11/","content":"一维动态规划：化繁为简的智慧\n\n记住过去，才能更好地面对未来\n\n\n什么是动态规划\n动态规划（Dynamic Programming，DP）是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。\n\n核心思想：将一个问题拆分成若干子问题，保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。\n\n形象理解\n想象你在爬楼梯：\n到第10层有多少种走法？暴力：枚举所有可能的走法（指数级复杂度）动态规划：- 到第10层 = 从第9层走1步 + 从第8层走2步- 到第9层 = 从第8层走1步 + 从第7层走2步- ...只需要记住前面的结果！\n\nDP的核心要素\n三大特征\ngraph LR\n    A[动态规划] --&gt; B[最优子结构]\n    A --&gt; C[重叠子问题]\n    A --&gt; D[无后效性]\n    \n    B --&gt; B1[最优解包含子问题最优解]\n    C --&gt; C1[子问题会重复出现]\n    D --&gt; D1[当前状态不受未来影响]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n    style C fill:#87CEEB\n四个步骤\n\n定义状态：dp[i] 表示什么含义\n状态转移方程：dp[i] 如何从之前的状态推导\n初始化：边界条件\n计算顺序：从小到大还是从大到小\n\n\n经典问题详解\n1. 爬楼梯（LeetCode 70）\n\n假设你正在爬楼梯，需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到楼顶？\n\n问题分析\nn = 3方法1: 1步 + 1步 + 1步方法2: 1步 + 2步方法3: 2步 + 1步共3种方法\nDP思路\n到达第 n 阶的方法数 = 到达第 n-1 阶的方法数 + 到达第 n-2 阶的方法数为什么？- 从第 n-1 阶走1步到达第 n 阶- 从第 n-2 阶走2步到达第 n 阶\n状态定义\ndp[i]：到达第 i 阶的方法数\n状态转移方程\ndp[i] = dp[i-1] + dp[i-2]\n这不就是斐波那契数列吗！\n代码实现\n// 方法1：DP数组int climbStairs(int n) &#123;    if (n &lt;= 2) return n;        vector&lt;int&gt; dp(n + 1);    dp[1] = 1;    dp[2] = 2;        for (int i = 3; i &lt;= n; ++i) &#123;        dp[i] = dp[i-1] + dp[i-2];    &#125;        return dp[n];&#125;// 方法2：空间优化（滚动变量）int climbStairs(int n) &#123;    if (n &lt;= 2) return n;        int prev2 = 1, prev1 = 2;        for (int i = 3; i &lt;= n; ++i) &#123;        int current = prev1 + prev2;        prev2 = prev1;        prev1 = current;    &#125;        return prev1;&#125;\n时间复杂度：O(n)\n空间复杂度：O(n) → 优化后 O(1)\n执行过程\nn = 5i=3: dp[3] = dp[2] + dp[1] = 2 + 1 = 3i=4: dp[4] = dp[3] + dp[2] = 3 + 2 = 5i=5: dp[5] = dp[4] + dp[3] = 5 + 3 = 8答案：8种方法\n\n2. 打家劫舍（LeetCode 198）\n\n你是一个专业的小偷，沿着一条街有若干房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n问题分析\n输入：[2,7,9,3,1]输出：12解释：偷窃1号房屋(2)，3号房屋(9)，5号房屋(1) = 2 + 9 + 1 = 12不能偷相邻的房屋！\nDP思路\n对于第 i 间房屋，有两个选择：\n1. 偷第 i 间：获得 nums[i] + dp[i-2]（不能偷第 i-1 间）2. 不偷第 i 间：保持 dp[i-1]选最大的！\n状态定义\ndp[i]：考虑前 i 间房屋，能偷到的最大金额\n状态转移方程\ndp[i] = max(dp[i-1], dp[i-2] + nums[i])         ↑           ↑       不偷第i间    偷第i间\n代码实现\n// 方法1：DP数组int rob(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n == 0) return 0;    if (n == 1) return nums[0];        vector&lt;int&gt; dp(n);    dp[0] = nums[0];    dp[1] = max(nums[0], nums[1]);        for (int i = 2; i &lt; n; ++i) &#123;        dp[i] = max(dp[i-1], dp[i-2] + nums[i]);    &#125;        return dp[n-1];&#125;// 方法2：空间优化int rob(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n == 0) return 0;    if (n == 1) return nums[0];        int prev2 = nums[0];    int prev1 = max(nums[0], nums[1]);        for (int i = 2; i &lt; n; ++i) &#123;        int current = max(prev1, prev2 + nums[i]);        prev2 = prev1;        prev1 = current;    &#125;        return prev1;&#125;\n执行过程\nnums = [2, 7, 9, 3, 1]i=0: dp[0] = 2i=1: dp[1] = max(2, 7) = 7i=2: dp[2] = max(7, 2+9) = 11i=3: dp[3] = max(11, 7+3) = 11i=4: dp[4] = max(11, 11+1) = 12答案：12\n可视化决策：\n房屋：  [2]  [7]  [9]  [3]  [1]决策：   √    √    √    ✗    √       偷   偷   偷   不偷  偷2 + 9 + 1 = 12（不能偷7和3，因为相邻）\n\n3. 最大子数组和（LeetCode 53）- Kadane算法\n\n给定一个整数数组，找到具有最大和的连续子数组。\n\n状态定义\ndp[i]：以第 i 个元素结尾的最大子数组和\n状态转移方程\ndp[i] = max(nums[i], dp[i-1] + nums[i])         ↑            ↑      重新开始      继续累加\n代码实现\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int maxEndingHere = nums[0];    int maxSoFar = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);        maxSoFar = max(maxSoFar, maxEndingHere);    &#125;        return maxSoFar;&#125;\n详见之前的 Kadane算法博客\n\n4. 买卖股票的最佳时机（LeetCode 121）\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。你只能选择某一天买入并在未来某一天卖出，计算你所能获取的最大利润。\n\n问题分析\n输入：[7,1,5,3,6,4]输出：5解释：第2天买入(1)，第5天卖出(6)，利润 = 6-1 = 5\n方法1：保存最低价格\nint maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int minPrice = INT_MAX;    int maxProfit = 0;        for (int price : prices) &#123;        minPrice = min(minPrice, price);        maxProfit = max(maxProfit, price - minPrice);    &#125;        return maxProfit;&#125;\n方法2：DP视角\ndp[i]：第 i 天卖出能获得的最大利润\nint maxProfit(vector&lt;int&gt;&amp; prices) &#123;    if (prices.empty()) return 0;        int minPrice = prices[0];    int maxProfit = 0;        for (int i = 1; i &lt; prices.size(); ++i) &#123;        maxProfit = max(maxProfit, prices[i] - minPrice);        minPrice = min(minPrice, prices[i]);    &#125;        return maxProfit;&#125;\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n5. 最长递增子序列（LeetCode 300）\n\n给定一个无序的整数数组，找到其中最长递增子序列的长度。\n\n问题分析\n输入：[10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，长度为4\nDP思路\n对于每个位置 i，考虑所有 j &lt; i 的情况：- 如果 nums[j] &lt; nums[i]，可以接在后面- 取所有可能中最长的\n状态定义\ndp[i]：以 nums[i] 结尾的最长递增子序列长度\n状态转移方程\ndp[i] = max(dp[j] + 1), 其中 0 &lt;= j &lt; i 且 nums[j] &lt; nums[i]\n代码实现\nint lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n == 0) return 0;        vector&lt;int&gt; dp(n, 1);  // 初始化为1，每个元素自己构成一个序列    int maxLen = 1;        for (int i = 1; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; i; ++j) &#123;            if (nums[j] &lt; nums[i]) &#123;                dp[i] = max(dp[i], dp[j] + 1);            &#125;        &#125;        maxLen = max(maxLen, dp[i]);    &#125;        return maxLen;&#125;\n时间复杂度：O(n²)\n空间复杂度：O(n)\n执行过程\nnums = [10, 9, 2, 5, 3, 7, 101, 18]i=0: dp[0]=1  [10]i=1: dp[1]=1  [9]i=2: dp[2]=1  [2]i=3: dp[3]=2  [2,5]  (从2接上)i=4: dp[4]=2  [2,3]  (从2接上)i=5: dp[5]=3  [2,5,7] 或 [2,3,7]i=6: dp[6]=4  [2,5,7,101] 或 [2,3,7,101]i=7: dp[7]=4  [2,5,7,18] 或 [2,3,7,18]答案：4\n优化：贪心+二分（O(n log n)）\nint lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; tails;  // tails[i]: 长度为i+1的递增子序列的最小末尾元素        for (int num : nums) &#123;        auto it = lower_bound(tails.begin(), tails.end(), num);                if (it == tails.end()) &#123;            tails.push_back(num);        &#125; else &#123;            *it = num;        &#125;    &#125;        return tails.size();&#125;\n\n6. 分割等和子集（LeetCode 416）\n\n给定一个只包含正整数的非空数组，是否可以将这个数组分割成两个子集，使得两个子集的元素和相等？\n\n问题分析\n输入：[1,5,11,5]输出：true解释：数组可以分割成 [1,5,5] 和 [11]\n转化为01背包问题\n问题转化：能否找到子集，和为总和的一半？总和 = 22目标：找到和为11的子集\n状态定义\ndp[i]：是否可以凑出和为 i\n状态转移方程\ndp[i] = dp[i] || dp[i - nums[j]]         ↑           ↑      不选nums[j]  选nums[j]\n代码实现\nbool canPartition(vector&lt;int&gt;&amp; nums) &#123;    int sum = 0;    for (int num : nums) &#123;        sum += num;    &#125;        if (sum % 2 != 0) return false;  // 奇数无法平分        int target = sum / 2;    vector&lt;bool&gt; dp(target + 1, false);    dp[0] = true;  // 和为0总是可以（不选任何元素）        for (int num : nums) &#123;        // 从后往前遍历，避免重复使用同一元素        for (int i = target; i &gt;= num; --i) &#123;            dp[i] = dp[i] || dp[i - num];        &#125;    &#125;        return dp[target];&#125;\n时间复杂度：O(n × sum)\n空间复杂度：O(sum)\n执行过程\nnums = [1, 5, 11, 5], target = 11初始：dp[0] = true处理1：dp[1] = true      [T, T, F, F, F, F, F, F, F, F, F, F]处理5：dp[5] = true, dp[6] = dp[6] || dp[1] = true      [T, T, F, F, F, T, T, F, F, F, F, F]处理11：dp[11] = true, dp[16]越界忽略       [T, T, F, F, F, T, T, F, F, F, F, T]处理5：dp[11]已经是true      [T, T, F, F, F, T, T, F, F, F, T, T]答案：dp[11] = true\n\n7. 单词拆分（LeetCode 139）\n\n给定一个非空字符串和一个包含非空单词的列表，判定字符串是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n问题分析\n输入：s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出：true解释：&quot;leetcode&quot; 可以拆分成 &quot;leet code&quot;\n状态定义\ndp[i]：字符串前 i 个字符能否拆分成字典中的单词\n状态转移方程\ndp[i] = dp[j] &amp;&amp; (s[j:i] 在字典中), 其中 0 &lt;= j &lt; i\n代码实现\nbool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;    unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());    int n = s.size();        vector&lt;bool&gt; dp(n + 1, false);    dp[0] = true;  // 空字符串可以拆分        for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 0; j &lt; i; ++j) &#123;            if (dp[j] &amp;&amp; wordSet.count(s.substr(j, i - j))) &#123;                dp[i] = true;                break;  // 找到一种拆分方式即可            &#125;        &#125;    &#125;        return dp[n];&#125;\n时间复杂度：O(n² × m)，m为平均单词长度\n空间复杂度：O(n)\n执行过程\ns = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]i=0: dp[0] = truei=1: &quot;l&quot; 不在字典 → dp[1] = falsei=2: &quot;le&quot; 不在字典 → dp[2] = falsei=3: &quot;lee&quot; 不在字典 → dp[3] = falsei=4: &quot;leet&quot; 在字典 &amp;&amp; dp[0]=true → dp[4] = truei=5: &quot;eetc&quot; 等都不在字典 → dp[5] = false...i=8: &quot;code&quot; 在字典 &amp;&amp; dp[4]=true → dp[8] = true答案：true\n\n8. 完全平方数（LeetCode 279）\n\n给定正整数 n，找到若干个完全平方数使得它们的和等于 n，返回和为 n 的完全平方数的最少数量。\n\n问题分析\n输入：n = 12输出：3解释：12 = 4 + 4 + 4\n状态定义\ndp[i]：和为 i 的完全平方数的最少数量\n状态转移方程\ndp[i] = min(dp[i - j*j] + 1), 其中 j*j &lt;= i\n代码实现\nint numSquares(int n) &#123;    vector&lt;int&gt; dp(n + 1, INT_MAX);    dp[0] = 0;        for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j * j &lt;= i; ++j) &#123;            dp[i] = min(dp[i], dp[i - j*j] + 1);        &#125;    &#125;        return dp[n];&#125;\n时间复杂度：O(n × √n)\n空间复杂度：O(n)\n执行过程\nn = 12i=0: dp[0] = 0i=1: dp[1] = dp[0] + 1 = 1  (1 = 1²)i=2: dp[2] = dp[1] + 1 = 2  (2 = 1² + 1²)i=3: dp[3] = dp[2] + 1 = 3  (3 = 1² + 1² + 1²)i=4: dp[4] = dp[0] + 1 = 1  (4 = 2²)...i=12: dp[12] = min(dp[11]+1, dp[8]+1, dp[3]+1)            = min(4, 2, 4) = 3            (12 = 4 + 4 + 4)答案：3\n\n空间优化技巧\n滚动数组\n当 dp[i] 只依赖于 dp[i-1] 和 dp[i-2] 时：\n// 原始版本 O(n)vector&lt;int&gt; dp(n);for (int i = 2; i &lt; n; ++i) &#123;    dp[i] = dp[i-1] + dp[i-2];&#125;// 优化版本 O(1)int prev2 = ..., prev1 = ...;for (int i = 2; i &lt; n; ++i) &#123;    int current = prev1 + prev2;    prev2 = prev1;    prev1 = current;&#125;\n01背包空间优化\n// 二维DPvector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(sum, false));// 优化为一维（从后往前遍历）vector&lt;bool&gt; dp(sum, false);for (int num : nums) &#123;    for (int i = sum; i &gt;= num; --i) &#123;  // 从后往前        dp[i] = dp[i] || dp[i - num];    &#125;&#125;\n\nDP问题分类\n线性DP\ngraph LR\n    A[线性DP] --&gt; B[爬楼梯]\n    A --&gt; C[打家劫舍]\n    A --&gt; D[最大子数组和]\n    A --&gt; E[最长递增子序列]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n特点：问题按某种顺序排列，状态转移有明确方向\n背包DP\ngraph LR\n    A[背包DP] --&gt; B[分割等和子集]\n    A --&gt; C[零钱兑换]\n    A --&gt; D[完全平方数]\n    \n    style A fill:#87CEEB\n特点：选或不选的问题\n序列DP\ngraph LR\n    A[序列DP] --&gt; B[单词拆分]\n    A --&gt; C[解码方法]\n    \n    style A fill:#DDA0DD\n特点：字符串、序列相关\n\n思维导图\ngraph TD\n    A[一维DP] --&gt; B[核心要素]\n    A --&gt; C[经典问题]\n    A --&gt; D[优化技巧]\n    \n    B --&gt; B1[状态定义]\n    B --&gt; B2[状态转移方程]\n    B --&gt; B3[初始化]\n    B --&gt; B4[计算顺序]\n    \n    C --&gt; C1[爬楼梯]\n    C --&gt; C2[打家劫舍]\n    C --&gt; C3[最长递增子序列]\n    C --&gt; C4[背包问题]\n    \n    D --&gt; D1[滚动数组]\n    D --&gt; D2[空间优化]\n    D --&gt; D3[记忆化搜索]\n    \n    style A fill:#FFE4B5\n    style C fill:#90EE90\n    style D fill:#87CEEB\n\n解题套路\n1. 识别DP问题\n信号词：\n\n最大/最小值\n有多少种方法\n是否可能\n最长/最短\n\n2. 解题步骤\n1. 定义状态   - dp[i] 表示什么？   - 通常是&quot;前i个&quot;或&quot;以i结尾&quot;2. 找状态转移方程   - 当前状态如何从之前的状态推导？   - 画图、列举小例子3. 初始化   - dp[0] 或 dp[1] 的值   - 边界条件4. 确定计算顺序   - 从小到大还是从大到小？   - 一维还是多维遍历？5. 返回结果   - 通常是 dp[n] 或 max(dp)\n3. 空间优化思路\n如果 dp[i] 只依赖于有限个之前的状态：→ 用滚动变量代替数组如果是背包类问题：→ 从后往前遍历，一维数组即可\n\n总结\n核心要点\n\nDP = 记忆化递归：避免重复计算\n状态定义最关键：定义清楚了就成功一半\n画图找规律：小例子推导状态转移方程\n空间可优化：滚动数组降低空间复杂度\n\n代码模板\n// 一维DP通用模板int solve(/* 输入参数 */) &#123;    // 1. 状态定义    vector&lt;int&gt; dp(n + 1);        // 2. 初始化    dp[0] = ...;        // 3. 状态转移    for (int i = 1; i &lt;= n; ++i) &#123;        for (/* 枚举决策 */) &#123;            dp[i] = /* 转移方程 */;        &#125;    &#125;        // 4. 返回结果    return dp[n];&#125;\n推荐题目\n入门级：\n\nLeetCode 70 - 爬楼梯\nLeetCode 198 - 打家劫舍\nLeetCode 53 - 最大子数组和\n\n进阶级：\n\nLeetCode 300 - 最长递增子序列\nLeetCode 139 - 单词拆分\nLeetCode 279 - 完全平方数\n\n高级：\n\nLeetCode 416 - 分割等和子集\nLeetCode 322 - 零钱兑换\nLeetCode 152 - 乘积最大子数组\n\n推荐阅读：\n\n动态规划套路详解 - labuladong\n《算法导论》第15章：动态规划\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","动态规划","DP"]},{"title":"常见算法-二分查找","url":"/posts/e84ddac/","content":"写在前面\n二分查找应该是我刷LeetCode时最早接触的算法之一，当时觉得挺简单的——不就是折半查找嘛。结果真正写起来才发现，left、right、mid这些边界条件一不小心就写错，要么死循环，要么漏掉元素。后来才意识到，二分查找看似简单，其实细节很多。\n这篇文章我会按照自己的理解，把二分查找从基础到变种都梳理一遍。\n\n二分查找是什么\n最基础的二分查找就是在有序数组中找一个目标值，每次通过比较中间元素，排除一半的搜索空间。\n举个例子，在 [1, 3, 5, 7, 9, 11, 13] 中找 7：\n第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，找到了！\n如果找 8 呢：\n第1次: 范围 [1,3,5,7,9,11,13]，中间是 7，8 &gt; 7，去右边找第2次: 范围 [9,11,13]，中间是 11，8 &lt; 11，去左边找第3次: 范围 [9]，9 != 8，找不到\n简单来说就是：每次排除一半，直到找到或者范围为空。\n时间复杂度 O(log n)，这也是二分查找的魅力所在——数据量越大，优势越明显。100万条数据，最多查20次。\n\n基础模板\n我自己用的最多的是左闭右闭区间的写法，也就是 [left, right]。\nint binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;  // 注意是 n-1        while (left &lt;= right) &#123;  // 注意是 &lt;=        int mid = left + (right - left) / 2;  // 防溢出                if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;  // 去右半边        &#125; else &#123;            right = mid - 1;  // 去左半边        &#125;    &#125;        return -1;  // 没找到&#125;\n几个细节\n\n\n为什么是 right = nums.size() - 1？\n因为我们用的是闭区间 [left, right]，右边界要包含最后一个元素。\n\n\n为什么循环条件是 left &lt;= right？\n当 left == right 时，区间 [left, right] 还有一个元素没检查，所以要用 &lt;=。\n\n\n为什么是 mid = left + (right - left) / 2？\n如果写成 (left + right) / 2，当 left 和 right 都很大时可能溢出。虽然LeetCode数据范围一般不会溢出，但这是个好习惯。\n\n\n为什么是 left = mid + 1 而不是 mid？\n因为 nums[mid] 已经检查过了，不是目标值，所以可以排除。\n\n\n\n左闭右开写法\n有些人喜欢用左闭右开区间 [left, right)，也就是右边界不包含。\nint binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();  // 注意是 n（不包含）        while (left &lt; right) &#123;  // 注意是 &lt;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;  // 注意是 mid，不是 mid - 1        &#125;    &#125;        return -1;&#125;\n说实话，我一开始也纠结用哪种写法。后来发现，选一个用熟就行，关键是理解区间的含义，不要混用。\n\n变种1：查找左边界\n有时候数组中有重复元素，我们要找第一个等于 target 的位置。\n比如 [1, 2, 2, 2, 3] 中找 2 的左边界，应该返回索引 1。\nint searchLeft(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    int result = -1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            result = mid;     // 记录位置            right = mid - 1;  // 继续向左找        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n核心思路：找到 target 后不立即返回，而是继续向左缩小范围。\n\n变种2：查找右边界\n同理，找最后一个等于 target 的位置。\n[1, 2, 2, 2, 3] 中找 2 的右边界，应该返回索引 3。\nint searchRight(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    int result = -1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) &#123;            result = mid;    // 记录位置            left = mid + 1;  // 继续向右找        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n\n变种3：找第一个大于等于target的位置\n这个在实际应用中很常见，比如查找插入位置。\nint lowerBound(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;  // nums[mid] &gt;= target，可能是答案        &#125;    &#125;        return left;&#125;\n注意：这里我用的是左闭右开写法 [left, right)，因为这样写起来比较简洁。\n如果数组是 [1, 3, 5, 7]，target = 4，返回索引 2（也就是 5 的位置）。\n\n变种4：找第一个大于target的位置\nint upperBound(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] &lt;= target) &#123;  // 注意是 &lt;=            left = mid + 1;        &#125; else &#123;            right = mid;        &#125;    &#125;        return left;&#125;\n\n实战题目\nLeetCode 704 - 二分查找\n最基础的题，直接套模板就行。\nint search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) return mid;        else if (nums[mid] &lt; target) left = mid + 1;        else right = mid - 1;    &#125;        return -1;&#125;\n\nLeetCode 35 - 搜索插入位置\n给定一个排序数组和目标值，如果找到返回索引，否则返回它应该被插入的位置。\nint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size();        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid;        &#125;    &#125;        return left;&#125;\n其实就是找第一个 &gt;= target 的位置（lower_bound）。\n\nLeetCode 34 - 在排序数组中查找元素的第一个和最后一个位置\n这题就是找左右边界的综合应用。\nvector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;    if (nums.empty()) return &#123;-1, -1&#125;;        int left = searchLeft(nums, target);    if (left == -1) return &#123;-1, -1&#125;;  // 没找到        int right = searchRight(nums, target);    return &#123;left, right&#125;;&#125;\n\nLeetCode 69 - x 的平方根\n计算并返回 x 的平方根（只保留整数部分）。\n这题其实是在 [0, x] 中找最后一个满足 i * i &lt;= x 的数。\nint mySqrt(int x) &#123;    if (x == 0) return 0;        int left = 1, right = x;    int result = 0;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (mid &lt;= x / mid) &#123;  // 避免溢出            result = mid;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return result;&#125;\n小技巧：用 mid &lt;= x / mid 代替 mid * mid &lt;= x，避免整数溢出。\n\nLeetCode 33 - 搜索旋转排序数组\n这题有点意思，数组被旋转了，比如 [4,5,6,7,0,1,2]。\n核心思路：虽然整体无序，但肯定有一半是有序的。先判断哪半边有序，再判断 target 在不在有序的那半边。\nint search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;                if (nums[mid] == target) return mid;                // 左半边有序        if (nums[left] &lt;= nums[mid]) &#123;            // target 在左半边            if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        // 右半边有序        else &#123;            // target 在右半边            if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;    &#125;        return -1;&#125;\n\nLeetCode 153 - 寻找旋转排序数组中的最小值\n还是旋转数组，这次是找最小值。\nint findMin(vector&lt;int&gt;&amp; nums) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                // 右半边无序，最小值在右边        if (nums[mid] &gt; nums[right]) &#123;            left = mid + 1;        &#125;        // 左半边无序或全部有序，最小值在左边（包括mid）        else &#123;            right = mid;        &#125;    &#125;        return nums[left];&#125;\n\n二分答案\n除了在数组中二分查找，还有一类题是二分答案。也就是答案有一定范围，通过二分猜答案，然后验证是否可行。\n经典例题：LeetCode 875 - 爱吃香蕉的珂珂\n珂珂有 N 堆香蕉，第 i 堆有 piles[i] 根香蕉。她可以决定每小时吃香蕉的速度 K（根/小时）。每小时她会选择一堆香蕉，吃 K 根（如果这堆不够 K 根，她会吃完这堆就停下来）。\n问：在 H 小时内吃完所有香蕉，最小的 K 是多少？\n思路：K 的范围是 [1, max(piles)]，我们可以二分 K 的值。对于每个 K，检查能否在 H 小时内吃完。\nint minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;    int left = 1;    int right = *max_element(piles.begin(), piles.end());        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;                // 检查能否在 h 小时内吃完        long long hours = 0;        for (int pile : piles) &#123;            hours += (pile + mid - 1) / mid;  // 向上取整        &#125;                if (hours &lt;= h) &#123;            right = mid;  // 可以吃完，尝试更小的速度        &#125; else &#123;            left = mid + 1;  // 吃不完，需要更快的速度        &#125;    &#125;        return left;&#125;\n小技巧：(pile + mid - 1) / mid 是向上取整的技巧，等价于 ceil(pile / mid)。\n\n容易踩的坑\n\n\n循环条件写错\nleft &lt;= right 还是 left &lt; right？取决于区间定义。记住：闭区间用 &lt;=，半开区间用 &lt;。\n\n\n边界更新写错\nleft = mid 还是 left = mid + 1？记住：已经检查过 mid 了，要排除就用 +1 或 -1。\n\n\n死循环\n如果边界更新不当，可能导致 left 和 right 永远无法相遇。比如用 left &lt; right 但更新时用 right = mid，当 left = mid - 1 时就会死循环。\n\n\n溢出问题\n写成 (left + right) / 2 在理论上可能溢出，虽然LeetCode一般不会卡这个。\n\n\n边界条件遗漏\n数组为空、target 不在范围内等特殊情况要单独处理。\n\n\n\n总结\n二分查找虽然看起来简单，但要写对还是需要细心。我的建议是：\n\n选定一种写法（闭区间或半开区间），熟练掌握它\n理解区间不变量：每次循环后，答案一定在 [left, right] 区间内\n多刷题：变种题做多了，自然就有感觉了\n\n常见的二分查找题型：\n\n基础二分：LeetCode 704\n查找边界：LeetCode 34\n旋转数组：LeetCode 33, 153\n二分答案：LeetCode 875, 1011, 410\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","分治","二分查找","搜索"]},{"title":"常见算法-位运算","url":"/posts/3609144b/","content":"位运算：在二进制世界里翩翩起舞\n\n当别人还在用加减乘除时，你已经在用与或非异或了\n\n\n什么是位运算\n位运算（Bit Manipulation）是直接对整数在内存中的二进制位进行操作的运算方式。相比普通的算术运算，位运算在某些场景下速度更快、更节省空间。\n\n核心特点：直接操作二进制位，效率极高\n\n为什么要学位运算？\ngraph LR\n    A[位运算的优势] --&gt; B[速度快]\n    A --&gt; C[省空间]\n    A --&gt; D[技巧性强]\n    A --&gt; E[面试常考]\n    \n    B --&gt; B1[CPU直接支持]\n    C --&gt; C1[用位表示状态]\n    D --&gt; D1[巧妙解决问题]\n    E --&gt; E1[考察基本功]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n    style D fill:#87CEEB\n\n基础位运算符\n六大运算符\n\n\n\n运算符\n名称\n说明\n示例\n\n\n\n\n&amp;\n按位与\n两位都为1才为1\n5 &amp; 3 = 1\n\n\n|\n按位或\n有一位为1就为1\n5 | 3 = 7\n\n\n^\n按位异或\n相同为0，不同为1\n5 ^ 3 = 6\n\n\n~\n按位取反\n0变1，1变0\n~5 = -6\n\n\n&lt;&lt;\n左移\n向左移位，右边补0\n5 &lt;&lt; 1 = 10\n\n\n&gt;&gt;\n右移\n向右移位，左边补符号位\n5 &gt;&gt; 1 = 2\n\n\n\n运算符详解\n1. 按位与（&amp;）\n规则：两位都为1才为1    5:  0101  &amp; 3:  0011  ————————————    1:  0001应用：- 判断奇偶：n &amp; 1（最低位为1是奇数）- 清零特定位- 提取特定位\n2. 按位或（|）\n规则：有一位为1就为1    5:  0101  | 3:  0011  ————————————    7:  0111应用：- 设置特定位为1- 合并标志位\n3. 按位异或（^）★\n规则：相同为0，不同为1    5:  0101  ^ 3:  0011  ————————————    6:  0110神奇性质：1. a ^ a = 0（自己异或自己等于0）2. a ^ 0 = a（任何数异或0等于自己）3. 交换律：a ^ b = b ^ a4. 结合律：a ^ b ^ c = a ^ (b ^ c)\n4. 按位取反（~）\n规则：0变1，1变0  ~5:  ~0101 = 1010（补码表示为-6）注意：涉及到补码，负数表示\n5. 左移（&lt;&lt;）\n规则：向左移n位，相当于乘以2^n5 &lt;&lt; 1:  0101 &lt;&lt; 1 = 1010 (10)5 &lt;&lt; 2:  0101 &lt;&lt; 2 = 10100 (20)规律：n &lt;&lt; k = n * 2^k\n6. 右移（&gt;&gt;）\n规则：向右移n位，相当于除以2^n5 &gt;&gt; 1:  0101 &gt;&gt; 1 = 0010 (2)5 &gt;&gt; 2:  0101 &gt;&gt; 2 = 0001 (1)规律：n &gt;&gt; k = n / 2^k（向下取整）\n\n常见位运算技巧\n1. 判断奇偶\n// 传统方法if (n % 2 == 0) &#123; /* 偶数 */ &#125;// 位运算（更快）if ((n &amp; 1) == 0) &#123; /* 偶数 */ &#125;if (n &amp; 1) &#123; /* 奇数 */ &#125;\n原理：二进制最低位为0是偶数，为1是奇数\n4: 0100 &amp; 1 = 0 (偶数)5: 0101 &amp; 1 = 1 (奇数)\n\n2. 交换两个数（不用临时变量）\n// 传统方法int temp = a;a = b;b = temp;// 位运算（无需临时变量）a = a ^ b;b = a ^ b;  // b = (a^b) ^ b = aa = a ^ b;  // a = (a^b) ^ a = b\n原理：利用异或的性质 a ^ b ^ b = a\n\n3. 获取/设置/清除特定位\n// 获取第k位（从0开始）int getBit(int n, int k) &#123;    return (n &gt;&gt; k) &amp; 1;&#125;// 设置第k位为1int setBit(int n, int k) &#123;    return n | (1 &lt;&lt; k);&#125;// 清除第k位（设为0）int clearBit(int n, int k) &#123;    return n &amp; ~(1 &lt;&lt; k);&#125;// 切换第k位（0变1，1变0）int toggleBit(int n, int k) &#123;    return n ^ (1 &lt;&lt; k);&#125;\n示例：\nn = 5 (0101)getBit(5, 2) = (0101 &gt;&gt; 2) &amp; 1 = 01 &amp; 1 = 1setBit(5, 1) = 0101 | 0010 = 0111 = 7clearBit(5, 0) = 0101 &amp; ~0001 = 0101 &amp; 1110 = 0100 = 4toggleBit(5, 1) = 0101 ^ 0010 = 0111 = 7\n\n4. 清除最低位的1\n// 清除最右边的1int clearLowestBit(int n) &#123;    return n &amp; (n - 1);&#125;\n原理图解：\nn = 12:  1100n-1 = 11: 1011n &amp; (n-1): 1100 &amp; 1011 = 1000 = 8         清除了最右边的1\n应用：统计1的个数（Brian Kernighan算法）\n\n5. 获取最低位的1\n// 只保留最右边的1int getLowestBit(int n) &#123;    return n &amp; (-n);&#125;\n原理：\nn = 12:   0...01100-n:       1...10100（补码）n &amp; (-n): 0...00100 = 4\n应用：树状数组（Fenwick Tree）\n\n6. 判断是否为2的幂\nbool isPowerOfTwo(int n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125;\n原理：2的幂只有一个1\n2:  0010 &amp; 0001 = 0000 ✓4:  0100 &amp; 0011 = 0000 ✓6:  0110 &amp; 0101 = 0100 ✗8:  1000 &amp; 0111 = 0000 ✓\n\n7. 统计1的个数\n// 方法1：Brian Kernighan算法（推荐）int countOnes(int n) &#123;    int count = 0;    while (n) &#123;        n &amp;= (n - 1);  // 清除最右边的1        count++;    &#125;    return count;&#125;// 方法2：逐位检查int countOnes2(int n) &#123;    int count = 0;    while (n) &#123;        count += (n &amp; 1);        n &gt;&gt;= 1;    &#125;    return count;&#125;// 方法3：C++内置函数int countOnes3(int n) &#123;    return __builtin_popcount(n);&#125;\n效率对比：\n\n方法1：O(k)，k为1的个数\n方法2：O(32)\n方法3：编译器优化，最快\n\n\n经典LeetCode问题\n1. 只出现一次的数字（LeetCode 136）\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n示例：\n输入：[2,2,1]输出：1输入：[4,1,2,1,2]输出：4\n解法：异或\nint singleNumber(vector&lt;int&gt;&amp; nums) &#123;    int result = 0;    for (int num : nums) &#123;        result ^= num;    &#125;    return result;&#125;\n原理：\na ^ a = 0a ^ 0 = a交换律和结合律[4,1,2,1,2]= 4 ^ 1 ^ 2 ^ 1 ^ 2= 4 ^ (1 ^ 1) ^ (2 ^ 2)= 4 ^ 0 ^ 0= 4\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n2. 位1的个数（LeetCode 191）\n\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。\n\n示例：\n输入：11 (0000...1011)输出：3\n解法：Brian Kernighan算法\nint hammingWeight(uint32_t n) &#123;    int count = 0;    while (n) &#123;        n &amp;= (n - 1);  // 清除最右边的1        count++;    &#125;    return count;&#125;\n过程演示：\nn = 11 (1011)第1次：n = 1011      n-1 = 1010      n &amp; (n-1) = 1010, count=1第2次：n = 1010      n-1 = 1001      n &amp; (n-1) = 1000, count=2第3次：n = 1000      n-1 = 0111      n &amp; (n-1) = 0000, count=3结束，返回3\n\n3. 2的幂（LeetCode 231）\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\nbool isPowerOfTwo(int n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125;\n原理：\n2的幂只有一个1：2:   00104:   01008:   1000非2的幂有多个1：3:   00116:   0110\n\n4. 颠倒二进制位（LeetCode 190）\n\n颠倒给定的 32 位无符号整数的二进制位。\n\n示例：\n输入：43261596 (00000010100101000001111010011100)输出：964176192 (00111001011110000010100101000000)\n解法：逐位翻转\nuint32_t reverseBits(uint32_t n) &#123;    uint32_t result = 0;    for (int i = 0; i &lt; 32; ++i) &#123;        result = (result &lt;&lt; 1) | (n &amp; 1);  // 取n最低位，加到result末尾        n &gt;&gt;= 1;                            // n右移    &#125;    return result;&#125;\n过程演示：\nn = 1011 (只看4位)i=0: result = 0, n=1011     result = (0 &lt;&lt; 1) | 1 = 1     n = 0101i=1: result = 1, n=0101     result = (1 &lt;&lt; 1) | 1 = 11     n = 0010i=2: result = 11, n=0010     result = (11 &lt;&lt; 1) | 0 = 110     n = 0001i=3: result = 110, n=0001     result = (110 &lt;&lt; 1) | 1 = 1101     n = 0000结果：1101（原数1011的翻转）\n\n5. 只出现一次的数字III（LeetCode 260）\n\n给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。\n\n示例：\n输入：[1,2,1,3,2,5]输出：[3,5]\n解法：分组异或\nvector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;    // 步骤1：全部异或，得到两个单独数字的异或结果    int xorResult = 0;    for (int num : nums) &#123;        xorResult ^= num;    &#125;        // 步骤2：找到xorResult中任意一个为1的位    // 这一位在两个数字中不同    int rightmostBit = xorResult &amp; (-xorResult);        // 步骤3：根据这一位分组    int num1 = 0, num2 = 0;    for (int num : nums) &#123;        if (num &amp; rightmostBit) &#123;            num1 ^= num;        &#125; else &#123;            num2 ^= num;        &#125;    &#125;        return &#123;num1, num2&#125;;&#125;\n原理图解：\n[1,2,1,3,2,5]步骤1：全部异或1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 0011 ^ 0101 = 0110步骤2：找最右边的10110 &amp; (-0110) = 0010步骤3：按第2位分组第2位为0：1(0001), 1(0001), 3(0011), 5(0101)第2位为1：2(0010), 2(0010)组1异或：1 ^ 1 ^ 3 ^ 5 = 3 ^ 5 = 6... 错了？应该是：第2位为1：2(0010), 2(0010)第2位为0：1(0001), 1(0001), 3(0011), 5(0101)重新分析：rightmostBit = 0010第2位为1：2, 2 → 异或 = 0第2位为0：1, 1, 3, 5 → 异或 = 3 ^ 5不对，让我重新理解：按照这一位把所有数分成两组，每组内成对的会消掉，剩下各自的单独数字\n\n6. 比特位计数（LeetCode 338）\n\n给定一个非负整数 num，对于范围 [0, num] 中的每个数字，计算其二进制表达式中 1 的个数。\n\n示例：\n输入：5输出：[0,1,1,2,1,2]解释：0: 0000 → 0个11: 0001 → 1个12: 0010 → 1个13: 0011 → 2个14: 0100 → 1个15: 0101 → 2个1\n解法1：动态规划 + 最低位\nvector&lt;int&gt; countBits(int n) &#123;    vector&lt;int&gt; result(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        result[i] = result[i &gt;&gt; 1] + (i &amp; 1);    &#125;    return result;&#125;\n原理：\ni的1的个数 = (i/2)的1的个数 + i的最低位例如：6 (110) = 3 (11) 向右移一位 + 0 (最低位)        = 2个1 + 0 = 27 (111) = 3 (11) 向右移一位 + 1 (最低位)        = 2个1 + 1 = 3\n解法2：动态规划 + 清除最低位\nvector&lt;int&gt; countBits(int n) &#123;    vector&lt;int&gt; result(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        result[i] = result[i &amp; (i - 1)] + 1;    &#125;    return result;&#125;\n原理：\ni的1的个数 = (i清除最低位后)的1的个数 + 16 (110) = 4 (100) 清除最低位 + 1        = 1个1 + 1 = 2\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n7. 汉明距离（LeetCode 461）\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n示例：\n输入：x = 1, y = 4输出：2解释：1: 00014: 0100不同位：2个\n解法：异或 + 计数\nint hammingDistance(int x, int y) &#123;    int xorResult = x ^ y;  // 不同的位为1    int count = 0;        while (xorResult) &#123;        xorResult &amp;= (xorResult - 1);  // 清除最右边的1        count++;    &#125;        return count;&#125;\n\n高级技巧\n1. 子集生成（状态压缩）\n用位运算生成集合的所有子集：\nvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;vector&lt;int&gt;&gt; result;        // 遍历0到2^n-1的所有数字    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;        vector&lt;int&gt; subset;        for (int i = 0; i &lt; n; ++i) &#123;            // 检查第i位是否为1            if (mask &amp; (1 &lt;&lt; i)) &#123;                subset.push_back(nums[i]);            &#125;        &#125;        result.push_back(subset);    &#125;        return result;&#125;\n原理：\nnums = [1,2,3]用3位二进制表示：000: []001: [1]010: [2]011: [1,2]100: [3]101: [1,3]110: [2,3]111: [1,2,3]\n\n2. N皇后位运算优化\n使用位运算优化N皇后问题的状态表示：\nvoid solveNQueens(int row, int cols, int diag1, int diag2, int n) &#123;    if (row == n) &#123;        // 找到一个解        return;    &#125;        // 可放置的位置：未被占用的列和对角线    int available = ((1 &lt;&lt; n) - 1) &amp; ~(cols | diag1 | diag2);        while (available) &#123;        int position = available &amp; (-available);  // 取最右边的1                // 放置皇后        solveNQueens(row + 1,                      cols | position,                     (diag1 | position) &lt;&lt; 1,                     (diag2 | position) &gt;&gt; 1,                     n);                // 移除这个位置        available &amp;= (available - 1);    &#125;&#125;\n优势：\n\n用整数表示状态，节省空间\n位运算速度快\n\n\n位运算口诀\n常用技巧记忆\n1. 判断奇偶：n &amp; 12. 乘以2：n &lt;&lt; 13. 除以2：n &gt;&gt; 14. 交换不用临时变量：a ^= b; b ^= a; a ^= b;5. 清除最右边的1：n &amp; (n-1)6. 获取最右边的1：n &amp; (-n)7. 判断2的幂：n &amp; (n-1) == 0\n异或的神奇性质\n自己异或自己等于0：a ^ a = 0任何数异或0等于自己：a ^ 0 = a满足交换律和结合律\n\n总结\n核心要点\n\n异或是王者：大多数位运算题目的核心\nn &amp; (n-1)：清除最右边的1，超级实用\n状态压缩：用位表示集合状态\n效率优势：位运算比普通运算快\n\n常用模板\n// 1. 统计1的个数int countOnes(int n) &#123;    int count = 0;    while (n) &#123;        n &amp;= (n - 1);        count++;    &#125;    return count;&#125;// 2. 判断2的幂bool isPowerOfTwo(int n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125;// 3. 获取/设置/清除第k位int getBit(int n, int k) &#123; return (n &gt;&gt; k) &amp; 1; &#125;int setBit(int n, int k) &#123; return n | (1 &lt;&lt; k); &#125;int clearBit(int n, int k) &#123; return n &amp; ~(1 &lt;&lt; k); &#125;// 4. 异或找单独数字int findSingle(vector&lt;int&gt;&amp; nums) &#123;    int result = 0;    for (int num : nums) &#123;        result ^= num;    &#125;    return result;&#125;\n推荐题目\n入门级：\n\nLeetCode 136 - 只出现一次的数字\nLeetCode 191 - 位1的个数\nLeetCode 231 - 2的幂\n\n进阶级：\n\nLeetCode 338 - 比特位计数\nLeetCode 260 - 只出现一次的数字III\nLeetCode 461 - 汉明距离\n\n高级：\n\nLeetCode 78 - 子集（位运算解法）\nLeetCode 698 - 划分为k个相等的子集（状态压缩）\n\n推荐阅读：\n\n位运算技巧总结\n《Hacker’s Delight》\n\n","categories":["算法"],"tags":["C++","LeetCode","位运算","二进制","算法技巧"]},{"title":"常见算法-分治","url":"/posts/f7223eb4/","content":"分治算法详解：化繁为简的行为艺术\n\n掌握分治思想，轻松解决复杂问题\n\n\n什么是分治算法\n分治（Divide and Conquer）是一种重要的算法设计思想，其核心是：\n\n将一个复杂的问题分解成若干个规模较小但结构相似的子问题，递归地解决这些子问题，然后将子问题的解合并得到原问题的解。\n\n形象理解\n想象你需要统计一本厚书的总字数：\n方法1：一页一页数（暴力）方法2：分治  ├── 把书分成两半  ├── 分别数每一半的字数（递归）  └── 两半字数相加（合并）\n适用条件\n分治算法适用于具有以下特征的问题：\n\n可分解性：问题可以分解成若干个规模较小的相同问题\n子问题独立：子问题之间相互独立，不包含公共子问题\n可合并性：子问题的解可以合并为原问题的解\n存在基准情况：当问题规模足够小时，可以直接求解\n\ngraph TD\n    A[原问题] --&gt; B[子问题1]\n    A --&gt; C[子问题2]\n    A --&gt; D[子问题...]\n    \n    B --&gt; E[解1]\n    C --&gt; F[解2]\n    D --&gt; G[解...]\n    \n    E --&gt; H[合并]\n    F --&gt; H\n    G --&gt; H\n    H --&gt; I[最终解]\n    \n    style A fill:#FFE4B5\n    style I fill:#90EE90\n\n分治三步曲\n核心框架\nResult divideAndConquer(Problem problem) &#123;    // 1. 基准情况：问题足够小，直接求解    if (problem.size &lt;= threshold) &#123;        return directSolve(problem);    &#125;        // 2. 分解：将问题分成子问题    subProblems = divide(problem);        // 3. 递归：解决每个子问题    for (subProblem : subProblems) &#123;        subResults.push_back(divideAndConquer(subProblem));    &#125;        // 4. 合并：将子问题的解合并    return combine(subResults);&#125;\n三步详解\n\n\n\n步骤\n名称\n作用\n关键点\n\n\n\n\n1\nDivide（分）\n将问题分解为子问题\n如何划分？划分几份？\n\n\n2\nConquer（治）\n递归解决子问题\n基准情况是什么？\n\n\n3\nCombine（合）\n合并子问题的解\n如何高效合并？\n\n\n\n时间复杂度通用公式\nT(n)=aT(n/b)+f(n)T(n) = aT(n/b) + f(n)\nT(n)=aT(n/b)+f(n)\n\naaa：子问题数量\nbbb：子问题规模缩小的倍数\nf(n)f(n)f(n)：分解和合并的代价\n\n\n经典问题详解\n1. 归并排序\n\nLeetCode 912: 排序数组\n\n问题分析\n将一个无序数组排序成有序数组。\n分治思路\n原数组：[38, 27, 43, 3, 9, 82, 10]               分解（Divide）         ↓[38, 27, 43, 3]    [9, 82, 10]      ↓                 ↓[38, 27] [43, 3]   [9, 82] [10]   ↓       ↓         ↓      ↓[38][27] [43][3]  [9][82]  [10]   ↓       ↓         ↓      ↓   解决（Conquer）- 单元素已有序         ↓      合并（Combine）         ↓[27, 38] [3, 43]  [9, 82]  [10]      ↓                ↓[3, 27, 38, 43]   [9, 10, 82]            ↓   [3, 9, 10, 27, 38, 43, 82]\n代码实现\nvoid mergeSort(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; temp(nums.size());    mergeSortHelper(nums, temp, 0, nums.size() - 1);&#125;void mergeSortHelper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right) &#123;    if (left &gt;= right) return;  // 基准情况        int mid = left + (right - left) / 2;        // 分解 + 递归    mergeSortHelper(nums, temp, left, mid);    mergeSortHelper(nums, temp, mid + 1, right);        // 合并    merge(nums, temp, left, mid, right);&#125;void merge(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int mid, int right) &#123;    for (int i = left; i &lt;= right; ++i) &#123;        temp[i] = nums[i];    &#125;        int i = left, j = mid + 1, k = left;    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        if (temp[i] &lt;= temp[j]) &#123;            nums[k++] = temp[i++];        &#125; else &#123;            nums[k++] = temp[j++];        &#125;    &#125;        while (i &lt;= mid) nums[k++] = temp[i++];    while (j &lt;= right) nums[k++] = temp[j++];&#125;\n复杂度分析\n\n时间：T(n)=2T(n/2)+O(n)=O(nlog⁡n)T(n) = 2T(n/2) + O(n) = O(n \\log n)T(n)=2T(n/2)+O(n)=O(nlogn)\n空间：O(n)O(n)O(n) 临时数组\n\n为什么用归并排序？\n✅ 稳定排序：相等元素的相对顺序不变\n✅ 时间稳定：最好、最坏、平均都是 O(nlog⁡n)O(n \\log n)O(nlogn)\n✅ 适合链表：不需要随机访问\n✅ 适合外排序：大文件排序\n\n2. 快速排序\n\nLeetCode 912: 排序数组（另一种解法）\n\n分治思路\n原数组：[64, 34, 25, 12, 22, 11, 90]选择 pivot = 22（随机选择）      分区（Partition）             ↓[12, 11] [22] [64, 34, 25, 90]  &lt; 22    =      &gt; 22    ↓             ↓  递归排序      递归排序    ↓             ↓[11, 12]     [25, 34, 64, 90]         ↓    合并（无需操作，已有序）         ↓[11, 12, 22, 25, 34, 64, 90]\n代码实现\nvoid quickSort(vector&lt;int&gt;&amp; nums) &#123;    quickSortHelper(nums, 0, nums.size() - 1);&#125;void quickSortHelper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left &gt;= right) return;        int pivotIndex = partition(nums, left, right);        quickSortHelper(nums, left, pivotIndex - 1);    quickSortHelper(nums, pivotIndex + 1, right);&#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    // 随机选择pivot，避免最坏情况    int randomIndex = left + rand() % (right - left + 1);    swap(nums[randomIndex], nums[right]);        int pivot = nums[right];    int i = left - 1;        for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            swap(nums[++i], nums[j]);        &#125;    &#125;        swap(nums[i + 1], nums[right]);    return i + 1;&#125;\n复杂度分析\n\n时间：平均 O(nlog⁡n)O(n \\log n)O(nlogn)，最坏 O(n2)O(n^2)O(n2)\n空间：O(log⁡n)O(\\log n)O(logn) 递归栈\n\n快排 vs 归并\n\n\n\n特性\n快速排序\n归并排序\n\n\n\n\n平均时间\nO(nlog⁡n)O(n \\log n)O(nlogn)\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\n最坏时间\nO(n2)O(n^2)O(n2)\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\n空间复杂度\nO(log⁡n)O(\\log n)O(logn)\nO(n)O(n)O(n)\n\n\n稳定性\n❌ 不稳定\n✅ 稳定\n\n\n原地排序\n✅ 是\n❌ 否\n\n\n实际性能\n更快（缓存友好）\n略慢\n\n\n\n\n3. 最大子数组和\n\nLeetCode 53: 最大子数组和\n\n问题描述\n给定一个整数数组，找到具有最大和的连续子数组。\n输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6\n分治思路\n最大子数组只可能在三个位置：\n\n完全在左半部分\n完全在右半部分\n跨越中点\n\n数组：[-2, 1, -3, 4, -1, 2, 1, -5, 4]              ↓ mid      左半部分  |  右半部分                左边最大：1    右边最大：4 跨越中点最大：4 + (-1) + 2 + 1 = 6  最终答案：max(1, 4, 6) = 6\ngraph TD\n    A[整个数组] --&gt; B[左半部分]\n    A --&gt; C[右半部分]\n    A --&gt; D[跨越中点]\n    \n    B --&gt; E[递归求解]\n    C --&gt; F[递归求解]\n    D --&gt; G[线性扫描]\n    \n    E --&gt; H[取最大值]\n    F --&gt; H\n    G --&gt; H\n    \n    H --&gt; I[返回结果]\n    \n    style D fill:#FFE4B5\n    style H fill:#90EE90\n代码实现\nint maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    return maxSubArrayHelper(nums, 0, nums.size() - 1);&#125;int maxSubArrayHelper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left == right) return nums[left];  // 基准情况        int mid = left + (right - left) / 2;        int leftMax = maxSubArrayHelper(nums, left, mid);    int rightMax = maxSubArrayHelper(nums, mid + 1, right);    int crossMax = maxCrossing(nums, left, mid, right);        return max(&#123;leftMax, rightMax, crossMax&#125;);&#125;int maxCrossing(vector&lt;int&gt;&amp; nums, int left, int mid, int right) &#123;    // 从中点向左扩展    int leftSum = INT_MIN, sum = 0;    for (int i = mid; i &gt;= left; --i) &#123;        sum += nums[i];        leftSum = max(leftSum, sum);    &#125;        // 从中点向右扩展    int rightSum = INT_MIN;    sum = 0;    for (int i = mid + 1; i &lt;= right; ++i) &#123;        sum += nums[i];        rightSum = max(rightSum, sum);    &#125;        return leftSum + rightSum;&#125;\n复杂度分析\n\n时间：T(n)=2T(n/2)+O(n)=O(nlog⁡n)T(n) = 2T(n/2) + O(n) = O(n \\log n)T(n)=2T(n/2)+O(n)=O(nlogn)\n空间：O(log⁡n)O(\\log n)O(logn) 递归栈\n\n\n注意：这道题有更优的 O(n)O(n)O(n) 动态规划解法，但分治解法是理解分治思想的好例子。\n\n\n4. 快速幂\n\nLeetCode 50: Pow(x, n)\n\n问题描述\n实现 pow(x, n)，即计算 x 的 n 次幂。\n暴力 vs 分治\n计算 2^10：暴力：2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2  (10次乘法)分治：  2^10 = 2^5 × 2^5  2^5 = 2^2 × 2^2 × 2  2^2 = 2 × 2只需要 4 次乘法！\n分治思路\nxn={xn/2×xn/2n 是偶数xn/2×xn/2×xn 是奇数x^n = \\begin{cases} x^{n/2} \\times x^{n/2} &amp; n \\text{ 是偶数} \\\\ x^{n/2} \\times x^{n/2} \\times x &amp; n \\text{ 是奇数} \\end{cases}\nxn={xn/2×xn/2xn/2×xn/2×x​n 是偶数n 是奇数​\n代码实现\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;    return fastPow(x, n);&#125;double fastPow(double x, long long n) &#123;    if (n == 0) return 1.0;  // 基准情况        double half = fastPow(x, n / 2);  // 分治        if (n % 2 == 0) &#123;        return half * half;           // 偶数    &#125; else &#123;        return half * half * x;       // 奇数    &#125;&#125;\n迭代版本（更优）\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;        double result = 1.0;    while (n &gt; 0) &#123;        if (n &amp; 1) &#123;        // n是奇数            result *= x;        &#125;        x *= x;             // x = x^2        n &gt;&gt;= 1;            // n = n / 2    &#125;    return result;&#125;\n复杂度分析\n\n时间：O(log⁡n)O(\\log n)O(logn)\n空间：递归 O(log⁡n)O(\\log n)O(logn)，迭代 O(1)O(1)O(1)\n\n\n5. 第K大元素\n\nLeetCode 215: 数组中的第K个最大元素\n\n问题描述\n找出数组中第 k 大的元素。\n输入：[3, 2, 1, 5, 6, 4], k = 2输出：5\n分治思路：快速选择\n利用快排的 partition 思想，每次可以确定一个元素的最终位置：\n数组：[3, 2, 1, 5, 6, 4]，找第2大（即第5小）Partition后（假设pivot=4）：[3, 2, 1] [4] [5, 6]  0,1,2    3   4,5pivot在位置3，第5小应该在位置4所以在右半部分继续找\n代码实现\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    int targetIndex = nums.size() - k;    return quickSelect(nums, 0, nums.size() - 1, targetIndex);&#125;int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    if (left == right) return nums[left];        int pivotIndex = partition(nums, left, right);        if (pivotIndex == k) &#123;        return nums[k];    &#125; else if (pivotIndex &lt; k) &#123;        return quickSelect(nums, pivotIndex + 1, right, k);    &#125; else &#123;        return quickSelect(nums, left, pivotIndex - 1, k);    &#125;&#125;\n复杂度分析\n\n时间：平均 O(n)O(n)O(n)，最坏 O(n2)O(n^2)O(n2)\n空间：O(1)O(1)O(1)\n\n为什么平均是 O(n)？\nT(n)=T(n/2)+O(n)=O(n)+O(n/2)+O(n/4)+...=O(2n)=O(n)T(n) = T(n/2) + O(n) = O(n) + O(n/2) + O(n/4) + ... = O(2n) = O(n)\nT(n)=T(n/2)+O(n)=O(n)+O(n/2)+O(n/4)+...=O(2n)=O(n)\n与快排不同，快速选择只需要递归一侧！\n\n6. 逆序对计数\n\n剑指Offer 51: 数组中的逆序对\n\n问题描述\n在数组中，如果前面的数大于后面的数，则这两个数构成一个逆序对。\n输入：[7, 5, 6, 4]输出：5解释：(7,5), (7,6), (7,4), (5,4), (6,4)\n分治思路\n利用归并排序的过程统计逆序对：\n[7, 5, 6, 4]     ↓ 分解[7, 5] [6, 4]  ↓       ↓[7][5] [6][4]  ↓       ↓ 合并时统计[5,7]   [4,6]  ← 统计了 (7,5), (6,4)     ↓ 合并时统计[4, 5, 6, 7]   ← 统计了 (7,4), (7,6), (5,4)关键：当右边元素先被放入时，左边剩余的都是逆序对\n代码实现\nint countInversions(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; temp(nums.size());    return countHelper(nums, temp, 0, nums.size() - 1);&#125;int countHelper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right) &#123;    if (left &gt;= right) return 0;        int mid = left + (right - left) / 2;    int count = 0;        count += countHelper(nums, temp, left, mid);    count += countHelper(nums, temp, mid + 1, right);    count += mergeAndCount(nums, temp, left, mid, right);        return count;&#125;int mergeAndCount(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp,                   int left, int mid, int right) &#123;    for (int i = left; i &lt;= right; ++i) &#123;        temp[i] = nums[i];    &#125;        int i = left, j = mid + 1, k = left, count = 0;        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        if (temp[i] &lt;= temp[j]) &#123;            nums[k++] = temp[i++];        &#125; else &#123;            nums[k++] = temp[j++];            count += (mid - i + 1);  // 关键：左边剩余都是逆序对        &#125;    &#125;        while (i &lt;= mid) nums[k++] = temp[i++];    while (j &lt;= right) nums[k++] = temp[j++];        return count;&#125;\n复杂度分析\n\n时间：O(nlog⁡n)O(n \\log n)O(nlogn)\n空间：O(n)O(n)O(n)\n\n\n分治 vs 递归 vs 动态规划\n三者关系\ngraph TD\n    A[递归] --&gt; B[分治]\n    A --&gt; C[动态规划]\n    \n    B --&gt; D[子问题独立]\n    C --&gt; E[子问题重叠]\n    \n    D --&gt; F[直接递归求解]\n    E --&gt; G[记忆化/自底向上]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n对比表\n\n\n\n特性\n递归\n分治\n动态规划\n\n\n\n\n本质\n实现技术\n算法思想\n算法思想\n\n\n子问题\n-\n独立\n重叠\n\n\n求解方式\n自顶向下\n自顶向下\n自底向上/记忆化\n\n\n典型问题\n阶乘\n归并排序\n斐波那契\n\n\n\n如何选择？\n\n分治：子问题独立，无重复计算\n动态规划：子问题重叠，需要记忆化\n\n\n复杂度分析：主定理\n主定理公式\n对于递归式 T(n)=aT(n/b)+f(n)T(n) = aT(n/b) + f(n)T(n)=aT(n/b)+f(n)，设 c=log⁡bac = \\log_b ac=logb​a：\n\n若 f(n)=O(nc−ϵ)f(n) = O(n^{c-\\epsilon})f(n)=O(nc−ϵ)，则 T(n)=Θ(nc)T(n) = \\Theta(n^c)T(n)=Θ(nc)\n若 f(n)=Θ(nc)f(n) = \\Theta(n^c)f(n)=Θ(nc)，则 T(n)=Θ(nclog⁡n)T(n) = \\Theta(n^c \\log n)T(n)=Θ(nclogn)\n若 f(n)=Ω(nc+ϵ)f(n) = \\Omega(n^{c+\\epsilon})f(n)=Ω(nc+ϵ)，则 T(n)=Θ(f(n))T(n) = \\Theta(f(n))T(n)=Θ(f(n))\n\n常见情况\n\n\n\n递归式\n算法\n时间复杂度\n\n\n\n\nT(n)=2T(n/2)+O(n)T(n) = 2T(n/2) + O(n)T(n)=2T(n/2)+O(n)\n归并排序\nO(nlog⁡n)O(n \\log n)O(nlogn)\n\n\nT(n)=2T(n/2)+O(1)T(n) = 2T(n/2) + O(1)T(n)=2T(n/2)+O(1)\n二分查找\nO(log⁡n)O(\\log n)O(logn)\n\n\nT(n)=T(n/2)+O(n)T(n) = T(n/2) + O(n)T(n)=T(n/2)+O(n)\n快速选择\nO(n)O(n)O(n)\n\n\nT(n)=T(n/2)+O(1)T(n) = T(n/2) + O(1)T(n)=T(n/2)+O(1)\n二分幂\nO(log⁡n)O(\\log n)O(logn)\n\n\n\n\n思维导图\ngraph TD\n    A[分治算法] --&gt; B[排序问题]\n    A --&gt; C[搜索问题]\n    A --&gt; D[数学问题]\n    A --&gt; E[统计问题]\n    \n    B --&gt; B1[归并排序]\n    B --&gt; B2[快速排序]\n    \n    C --&gt; C1[二分查找]\n    C --&gt; C2[第K大元素]\n    \n    D --&gt; D1[快速幂]\n    D --&gt; D2[大整数乘法]\n    \n    E --&gt; E1[逆序对]\n    E --&gt; E2[最大子数组]\n    \n    style A fill:#FFE4B5\n    style B1 fill:#87CEEB\n    style B2 fill:#87CEEB\n    style C1 fill:#90EE90\n    style D1 fill:#DDA0DD\n\n总结\n核心要点\n\n分治三步曲：分解 → 递归 → 合并\n适用条件：子问题独立、可合并、存在基准情况\n时间分析：使用主定理\n优化方向：合并操作是关键\n\n分治模板\nResult divideAndConquer(Problem problem) &#123;    // 1. 基准情况    if (isBaseCase(problem)) &#123;        return solve(problem);    &#125;        // 2. 分解    subProblems = divide(problem);        // 3. 递归解决    for (sub : subProblems) &#123;        subResults.push_back(divideAndConquer(sub));    &#125;        // 4. 合并    return combine(subResults);&#125;\n常见问题分类\n\n\n\n类型\n问题\n合并方式\n\n\n\n\n排序\n归并、快排\n双指针合并\n\n\n搜索\n二分查找\n直接返回\n\n\n数学\n快速幂\n乘法\n\n\n统计\n逆序对\n计数累加\n\n\n优化\n最大子数组\n取最大值\n\n\n\n推荐阅读：\n\n《算法导论》第4章：分治策略\nLeetCode 分治专题\n\n","categories":["算法"],"tags":["C++","LeetCode","归并排序","算法设计","分治","快速排序"]},{"title":"常见算法-回溯","url":"/posts/97ccf2e3/","content":"引言\n回溯算法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。当探索到某一步时，发现原先的选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为&quot;回溯点&quot;。\n回溯算法的本质：穷举所有可能，然后选出我们想要的答案。\n适用场景：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n排列问题：N个数按一定规则全排列，有几种排列方式\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n棋盘问题：N皇后，数独等等\n\n\n什么是回溯算法\n形象化理解\n想象你在一个迷宫中寻找出口：\n入口 → 岔路1 → 岔路2 → 死路 ✗     ↓     回退到岔路2     ↓     岔路2 → 岔路3 → 出口 ✓\n这就是回溯：尝试 → 失败 → 回退 → 再尝试\n决策树可视化\n回溯算法可以抽象为决策树的遍历过程：\ngraph TD\n    A[开始] --&gt; B[选择1]\n    A --&gt; C[选择2]\n    A --&gt; D[选择3]\n    B --&gt; E[选择1.1]\n    B --&gt; F[选择1.2]\n    C --&gt; G[选择2.1]\n    C --&gt; H[选择2.2]\n    \n    style E fill:#90EE90\n    style H fill:#90EE90\n    style F fill:#FFB6C1\n    style G fill:#FFB6C1\n\n绿色节点：满足条件的解\n粉色节点：不满足条件，需要回溯\n\n\n回溯框架模板\n通用模板\nvoid backtrack(路径, 选择列表) &#123;    if (满足结束条件) &#123;        result.push_back(路径);        return;    &#125;        for (选择 : 选择列表) &#123;        if (不满足条件) continue;  // 剪枝                做选择;        backtrack(路径, 选择列表);  // 递归        撤销选择;  // 回溯    &#125;&#125;\n三要素\n\n路径（Path）：已经做出的选择\n选择列表（Choices）：当前可以做的选择\n结束条件（End Condition）：到达决策树底层，无法再做选择的条件\n\ngraph LR\n    A[开始] --&gt; B&#123;满足结束条件?&#125;\n    B --&gt;|是| C[保存结果]\n    B --&gt;|否| D[遍历选择列表]\n    D --&gt; E&#123;是否有效?&#125;\n    E --&gt;|否| F[剪枝跳过]\n    E --&gt;|是| G[做选择]\n    G --&gt; H[递归调用]\n    H --&gt; I[撤销选择]\n    I --&gt; D\n    F --&gt; D\n    C --&gt; J[返回]\n    I --&gt; K&#123;还有选择?&#125;\n    K --&gt;|是| D\n    K --&gt;|否| J\n\n核心思想\n回溯三步曲\n\n做选择：将当前元素加入路径\n递归：基于当前选择继续探索\n撤销选择：将当前元素从路径中移除，尝试其他选择\n\n// 伪代码示例path.push_back(choice);      // 1. 做选择backtrack(path, choices);    // 2. 递归path.pop_back();             // 3. 撤销选择\n关键特性\n\n时间换空间：通过回溯避免存储所有中间状态\n深度优先搜索（DFS）：本质上是DFS的一种实现\n剪枝优化：提前排除不可能的分支，提高效率\n\n\n经典问题详解\n1. 全排列问题\n\nLeetCode 46: 给定一个不含重复数字的数组 nums，返回其所有可能的全排列。\n\n示例：\n输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n决策树\n                 []       /          |          \\     [1]         [2]         [3]    /   \\       /   \\       /   \\ [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]   |     |     |     |     |     |[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]\n实现\nvoid permuteBacktrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path,                       vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 终止条件：路径长度等于数组长度    if (path.size() == nums.size()) &#123;        result.push_back(path);        return;    &#125;        for (int i = 0; i &lt; nums.size(); ++i) &#123;        if (used[i]) continue;  // 剪枝：已使用的元素跳过                // 做选择        path.push_back(nums[i]);        used[i] = true;                // 递归        permuteBacktrack(nums, path, used, result);                // 撤销选择        path.pop_back();        used[i] = false;    &#125;&#125;\n执行过程示例\n输入: [1, 2, 3]步骤1: path=[], 选择1       path=[1], used=[T,F,F]步骤2: path=[1], 选择2       path=[1,2], used=[T,T,F]步骤3: path=[1,2], 选择3       path=[1,2,3], used=[T,T,T]       ✓ 找到一个解！步骤4: 回溯，撤销3       path=[1,2], used=[T,T,F]步骤5: 回溯，撤销2       path=[1], used=[T,F,F]步骤6: path=[1], 选择3       path=[1,3], used=[T,F,T]       ... (继续)\n时间复杂度：O(n × n!)\n空间复杂度：O(n)\n\n2. N皇后问题\n\nLeetCode 51: 在 n×n 的棋盘上放置 n 个皇后，使得它们不能相互攻击。\n\n规则：皇后可以攻击同一行、同一列、同一对角线上的棋子。\n可视化\n4皇后的一个解：. Q . .     行0. . . Q     行1Q . . .     行2. . Q .     行3\n决策树\ngraph TD\n    A[行0: 选择列] --&gt; B[列0]\n    A --&gt; C[列1]\n    A --&gt; D[列2]\n    A --&gt; E[列3]\n    \n    C --&gt; F[行1: 列3]\n    F --&gt; G[行2: 列1]\n    G --&gt; H[行3: 列2 ✓]\n    \n    B --&gt; I[行1: 检查...✗]\n    D --&gt; J[行1: 检查...✗]\n实现\nvoid nQueensBacktrack(vector&lt;string&gt;&amp; board, int row,                       vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    // 终止条件：所有行都放置了皇后    if (row == board.size()) &#123;        result.push_back(board);        return;    &#125;        int n = board[row].size();    for (int col = 0; col &lt; n; ++col) &#123;        if (!isValidQueen(board, row, col)) &#123;            continue;  // 剪枝：不合法位置        &#125;                // 做选择        board[row][col] = &#x27;Q&#x27;;                // 递归        nQueensBacktrack(board, row + 1, result);                // 撤销选择        board[row][col] = &#x27;.&#x27;;    &#125;&#125;bool isValidQueen(vector&lt;string&gt;&amp; board, int row, int col) &#123;    int n = board.size();        // 检查列    for (int i = 0; i &lt; row; ++i) &#123;        if (board[i][col] == &#x27;Q&#x27;) return false;    &#125;        // 检查左上对角线    for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;        if (board[i][j] == &#x27;Q&#x27;) return false;    &#125;        // 检查右上对角线    for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123;        if (board[i][j] == &#x27;Q&#x27;) return false;    &#125;        return true;&#125;\n时间复杂度：O(n!)\n空间复杂度：O(n²)\n\n3. 组合总和\n\nLeetCode 39: 给定一个无重复元素的数组 candidates 和一个目标数 target，找出所有可以使数字和为 target 的组合。\n\n示例：\n输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]\n决策树\n                        []         /       |        |        \\       [2]      [3]      [6]      [7]✓      / | \\     / \\       |  [2,2] ...  [3,3] ...  [6,?]   / \\[2,2,2] [2,2,3]✓\n实现\nvoid combinationBacktrack(vector&lt;int&gt;&amp; candidates, int target, int start,                          vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 终止条件    if (target == 0) &#123;        result.push_back(path);        return;    &#125;        for (int i = start; i &lt; candidates.size(); ++i) &#123;        if (candidates[i] &gt; target) break;  // 剪枝：超过目标                // 做选择        path.push_back(candidates[i]);                // 递归（可重复使用，所以传入 i）        combinationBacktrack(candidates, target - candidates[i], i, path, result);                // 撤销选择        path.pop_back();    &#125;&#125;\n关键点：\n\n可以重复使用同一元素，所以递归时传入 i 而不是 i+1\n排序后可以提前剪枝\n\n\n4. 子集问题\n\nLeetCode 78: 给定一个整数数组 nums，返回该数组所有可能的子集。\n\n示例：\n输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n决策树\n                 []✓       /          |          \\     [1]✓        [2]✓        [3]✓    /   \\          \\ [1,2]✓ [1,3]✓   [2,3]✓   |[1,2,3]✓\n关键：每个节点都是一个有效子集！\n实现\nvoid subsetsBacktrack(vector&lt;int&gt;&amp; nums, int start,                      vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;    // 每个节点都是一个子集    result.push_back(path);        for (int i = start; i &lt; nums.size(); ++i) &#123;        // 做选择        path.push_back(nums[i]);                // 递归        subsetsBacktrack(nums, i + 1, path, result);                // 撤销选择        path.pop_back();    &#125;&#125;\n时间复杂度：O(n × 2ⁿ)\n空间复杂度：O(n)\n\n5. 括号生成\n\nLeetCode 22: 生成所有由 n 对括号组成的有效组合。\n\n示例：\n输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]\n约束条件\n\n左括号数量 ≤ n\n右括号数量 ≤ 左括号数量\n\n决策树\n                        &quot;&quot;              /                    \\            &quot;(&quot;                    ❌ &quot;)&quot; (违反规则2)       /         \\    &quot;((&quot;        &quot;()&quot;   /   \\       /   \\&quot;(((&quot;  &quot;(()&quot; &quot;()&quot;  &quot;())&quot;❌\n实现\nvoid parenthesisBacktrack(int n, int left, int right,                          string&amp; path, vector&lt;string&gt;&amp; result) &#123;    // 终止条件    if (path.size() == 2 * n) &#123;        result.push_back(path);        return;    &#125;        // 添加左括号    if (left &lt; n) &#123;        path.push_back(&#x27;(&#x27;);        parenthesisBacktrack(n, left + 1, right, path, result);        path.pop_back();    &#125;        // 添加右括号（剪枝）    if (right &lt; left) &#123;        path.push_back(&#x27;)&#x27;);        parenthesisBacktrack(n, left, right + 1, path, result);        path.pop_back();    &#125;&#125;\n时间复杂度：O(4ⁿ / √n)（卡特兰数）\n空间复杂度：O(n)\n\n剪枝优化技巧\n剪枝是提高回溯算法效率的关键！\n1. 提前终止\nif (当前状态已经不可能产生有效解) &#123;    return;  // 直接返回，不继续递归&#125;\n示例：组合总和中，如果当前和已经超过目标值\nif (candidates[i] &gt; target) break;  // 剪枝\n2. 排序优化\n先排序，可以更早地剪枝\nsort(candidates.begin(), candidates.end());\n3. 避免重复\n使用 used 数组或 start 索引避免重复计算\n// 全排列：used数组if (used[i]) continue;// 组合问题：start索引for (int i = start; i &lt; nums.size(); ++i)\n4. 对称性剪枝\n利用问题的对称性减少搜索空间\n// N皇后：只搜索一半，另一半通过对称获得if (row == 0 &amp;&amp; col &gt; n / 2) break;\n剪枝效果对比\ngraph LR\n    A[无剪枝] --&gt;|搜索空间| B[10000节点]\n    C[有剪枝] --&gt;|搜索空间| D[100节点]\n    \n    style B fill:#FFB6C1\n    style D fill:#90EE90\n\n复杂度分析\n时间复杂度\n回溯算法的时间复杂度通常取决于：\n\n决策树的深度：递归的层数\n每层的选择数量：for循环的次数\n\n\n\n\n问题\n时间复杂度\n说明\n\n\n\n\n全排列\nO(n × n!)\nn层，每层最多n个选择\n\n\nN皇后\nO(n!)\n每行选择递减\n\n\n组合\nO(2ⁿ)\n每个元素选或不选\n\n\n子集\nO(n × 2ⁿ)\n2ⁿ个子集，复制需要O(n)\n\n\n\n空间复杂度\n主要考虑：\n\n递归栈深度：O(深度)\n路径存储：O(路径长度)\n\n通常为 O(n) 或 O(树的高度)\n\n常见LeetCode题目\n入门级\n\nLeetCode 78 - 子集\nLeetCode 77 - 组合\nLeetCode 46 - 全排列\n\n中级\n\nLeetCode 39 - 组合总和\nLeetCode 22 - 括号生成\nLeetCode 131 - 分割回文串\n\n高级\n\nLeetCode 51 - N皇后\nLeetCode 37 - 解数独\nLeetCode 126 - 单词接龙 II\n\n\n回溯 vs DFS vs BFS\n对比表\n\n\n\n特性\n回溯\nDFS\nBFS\n\n\n\n\n本质\n带剪枝的DFS\n深度优先搜索\n广度优先搜索\n\n\n数据结构\n递归栈\n栈/递归\n队列\n\n\n路径记录\n显式维护\n可选\n可选\n\n\n空间复杂度\nO(h)\nO(h)\nO(w)\n\n\n应用场景\n所有解\n单个解\n最短路径\n\n\n\n\nh = 树的高度, w = 树的宽度\n\n\n总结\n核心要点\n\n回溯 = 穷举 + 剪枝\n三要素：路径、选择列表、结束条件\n三步曲：做选择 → 递归 → 撤销选择\n优化关键：剪枝！剪枝！剪枝！\n\n经典模板\nvoid backtrack(参数) &#123;    if (终止条件) &#123;        存储结果;        return;    &#125;        for (选择 : 选择列表) &#123;        if (剪枝条件) continue;                做选择;        backtrack(新参数);        撤销选择;    &#125;&#125;\n性能优化 Tips\n\n排序预处理：便于剪枝\n使用引用传参：减少复制开销\n位运算优化 used 数组：节省空间\n记忆化搜索：避免重复计算子问题\n\n\n回溯算法是解决复杂搜索问题的利器。虽然时间复杂度较高，但通过巧妙的剪枝优化，可以在实际应用中取得很好的效果。掌握回溯算法，你将拥有解决大部分组合、排列、搜索类问题的能力！\n\n推荐阅读：\n\n代码随想录 - 回溯算法\nLeetCode 精选回溯题目\n\n","categories":["算法"],"tags":["C++","LeetCode","回溯","DFS","递归","剪枝"]},{"title":"常见算法-多维动态规划","url":"/posts/d6a5396e/","content":"多维动态规划：在更高维度思考\n\n当一个维度不够用时,就多加一个维度!\n\n\n什么是多维动态规划\n多维动态规划是动态规划的扩展,使用多个维度的状态来描述问题。如果说一维DP是一条线,那么二维DP就是一个平面,三维DP则是一个立体空间。\n\n核心思想:当问题需要多个参数才能描述清楚状态时,就需要使用多维DP\n\n形象理解\n想象你在玩一个游戏:\n一维DP: 在一条路上前进,只需要记录&quot;到达第i个位置&quot;二维DP: 在一个网格中移动,需要记录&quot;到达坐标(i,j)&quot;三维DP: 在多个物品中选择,需要记录&quot;前i个物品,容量为j,价值为k&quot;\n就像从一维数轴进化到二维平面,再到三维空间!\n\n从一维到多维的思维跃迁\n维度增加的必要性\ngraph TD\n    A[问题复杂度] --&gt; B&#123;一个参数够吗?&#125;\n    B --&gt;|够| C[一维DP]\n    B --&gt;|不够| D&#123;两个参数够吗?&#125;\n    D --&gt;|够| E[二维DP]\n    D --&gt;|不够| F[三维/更高维DP]\n    \n    style A fill:#FFE4B5\n    style E fill:#90EE90\n    style F fill:#87CEEB\n什么时候用多维DP?\n\n\n\n场景\n维度\n示例\n\n\n\n\n路径问题\n二维\n网格中的最短路径\n\n\n双序列匹配\n二维\n最长公共子序列\n\n\n背包问题\n二维/三维\n01背包、多重背包\n\n\n区间问题\n二维\n戳气球、合并石头\n\n\n状态机问题\n多维\n买卖股票\n\n\n\n\n二维DP经典问题\n1. 不同路径 (LeetCode 62)\n\n一个机器人位于一个 m×n 网格的左上角,每次只能向下或向右移动,问到达右下角有多少条不同的路径?\n\n问题分析\n网格: 3×7起点: (0,0)终点: (2,6)每次只能: 向右 或 向下\n可视化理解\n起点→ □ □ □ □ □ □      □ □ □ □ □ □      □ □ □ □ □ ← 终点到达(i,j)的方式 = 从(i-1,j)向下 + 从(i,j-1)向右\n状态定义\ndp[i][j]: 到达位置(i,j)的不同路径数\n状态转移方程\ndp[i][j] = dp[i-1][j] + dp[i][j-1]            ↑            ↑          从上方来    从左方来\n代码实现\n// 方法1: 二维DP数组int uniquePaths(int m, int n) &#123;    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));        // 第一行和第一列都只有一种走法    for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            dp[i][j] = dp[i-1][j] + dp[i][j-1];        &#125;    &#125;        return dp[m-1][n-1];&#125;// 方法2: 空间优化 - 滚动数组int uniquePaths(int m, int n) &#123;    vector&lt;int&gt; dp(n, 1);        for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            dp[j] = dp[j] + dp[j-1];                    ↑        ↑                  上方     左方        &#125;    &#125;        return dp[n-1];&#125;\n时间复杂度: O(m×n)\n空间复杂度: O(m×n) → 优化后 O(n)\n执行过程\nm=3, n=7初始状态 (第一行和第一列都是1):1  1  1  1  1  1  11  ?  ?  ?  ?  ?  ?1  ?  ?  ?  ?  ?  ?计算过程:1  1  1   1   1   1   11  2  3   4   5   6   71  3  6  10  15  21  28      ↑    dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3答案: 28种路径\n\n2. 最小路径和 (LeetCode 64)\n\n给定一个包含非负整数的 m×n 网格,找到一条从左上角到右下角的路径,使得路径上的数字总和最小\n\n问题分析\n输入:1  3  11  5  14  2  1输出: 7路径: 1→3→1→1→1 = 7\n状态定义\ndp[i][j]: 从(0,0)到(i,j)的最小路径和\n状态转移方程\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])                          ↑             ↑                        从上方来      从左方来\n代码实现\nint minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int m = grid.size();    int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));        // 初始化起点    dp[0][0] = grid[0][0];        // 初始化第一列    for (int i = 1; i &lt; m; ++i) &#123;        dp[i][0] = dp[i-1][0] + grid[i][0];    &#125;        // 初始化第一行    for (int j = 1; j &lt; n; ++j) &#123;        dp[0][j] = dp[0][j-1] + grid[0][j];    &#125;        // 状态转移    for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);        &#125;    &#125;        return dp[m-1][n-1];&#125;\n时间复杂度: O(m×n)\n空间复杂度: O(m×n)\n执行过程\ngrid:1  3  11  5  14  2  1DP过程:1  4  5     ← 第一行: 累加↓2  7  6     ← dp[1][1] = 5 + min(4,2) = 7↓6  8  7     ← dp[2][2] = 1 + min(6,8) = 7       ↑      答案最小路径和: 7\n\n3. 最长公共子序列 (LeetCode 1143)\n\n给定两个字符串,求它们的最长公共子序列长度\n\n问题分析\ntext1 = &quot;abcde&quot;text2 = &quot;ace&quot;最长公共子序列: &quot;ace&quot; (长度为3)\n双序列DP的精髓\n这是典型的双序列匹配问题,需要同时追踪两个序列的位置!\n状态定义\ndp[i][j]: text1前i个字符 与 text2前j个字符 的最长公共子序列长度\n状态转移方程\nif (text1[i-1] == text2[j-1]):    dp[i][j] = dp[i-1][j-1] + 1else:    dp[i][j] = max(dp[i-1][j], dp[i][j-1])                    ↑            ↑                跳过text1[i]  跳过text2[j]\n可视化理解\n    &quot;&quot;  a  c  e&quot;&quot;   0  0  0  0a    0  1  1  1  ← text1[0]=&#x27;a&#x27; == text2[0]=&#x27;a&#x27;, dp[1][1]=1b    0  1  1  1c    0  1  2  2  ← text1[2]=&#x27;c&#x27; == text2[1]=&#x27;c&#x27;, dp[3][2]=2d    0  1  2  2e    0  1  2  3  ← text1[4]=&#x27;e&#x27; == text2[2]=&#x27;e&#x27;, dp[5][3]=3\n代码实现\nint longestCommonSubsequence(string text1, string text2) &#123;    int m = text1.size();    int n = text2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));        for (int i = 1; i &lt;= m; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (text1[i-1] == text2[j-1]) &#123;                // 字符匹配,长度+1                dp[i][j] = dp[i-1][j-1] + 1;            &#125; else &#123;                // 字符不匹配,取较大值                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);            &#125;        &#125;    &#125;        return dp[m][n];&#125;\n时间复杂度: O(m×n)\n空间复杂度: O(m×n)\n完整执行过程\ntext1 = &quot;abcde&quot;text2 = &quot;ace&quot;DP表:      &quot;&quot;  a  c  e  &quot;&quot;   0  0  0  0  a    0  1  1  1  b    0  1  1  1  c    0  1  2  2  d    0  1  2  2  e    0  1  2  3关键步骤:- dp[1][1]: &#x27;a&#x27;==&#x27;a&#x27;, dp[1][1]=dp[0][0]+1=1- dp[3][2]: &#x27;c&#x27;==&#x27;c&#x27;, dp[3][2]=dp[2][1]+1=2- dp[5][3]: &#x27;e&#x27;==&#x27;e&#x27;, dp[5][3]=dp[4][2]+1=3答案: 3\n\n4. 编辑距离 (LeetCode 72)\n\n给定两个单词,计算从一个单词转换成另一个单词所需的最少操作数。允许的操作:插入、删除、替换\n\n问题分析\nword1 = &quot;horse&quot;word2 = &quot;ros&quot;操作序列:horse → rorse (替换 h→r)rorse → rose  (删除 r)rose  → ros   (删除 e)共3步\n状态定义\ndp[i][j]: word1前i个字符 转换为 word2前j个字符 的最少操作数\n状态转移方程\nif (word1[i-1] == word2[j-1]):    dp[i][j] = dp[i-1][j-1]  // 字符相同,不需要操作else:    dp[i][j] = 1 + min(&#123;        dp[i-1][j],    // 删除word1[i]        dp[i][j-1],    // 插入word2[j]        dp[i-1][j-1]   // 替换word1[i]为word2[j]    &#125;)\n代码实现\nint minDistance(string word1, string word2) &#123;    int m = word1.size();    int n = word2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));        // 初始化:空串转换需要的操作数    for (int i = 0; i &lt;= m; ++i) &#123;        dp[i][0] = i;  // 删除所有字符    &#125;    for (int j = 0; j &lt;= n; ++j) &#123;        dp[0][j] = j;  // 插入所有字符    &#125;        for (int i = 1; i &lt;= m; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (word1[i-1] == word2[j-1]) &#123;                dp[i][j] = dp[i-1][j-1];            &#125; else &#123;                dp[i][j] = 1 + min(&#123;                    dp[i-1][j],      // 删除                    dp[i][j-1],      // 插入                    dp[i-1][j-1]     // 替换                &#125;);            &#125;        &#125;    &#125;        return dp[m][n];&#125;\n时间复杂度: O(m×n)\n空间复杂度: O(m×n)\n执行过程\nword1 = &quot;horse&quot;word2 = &quot;ros&quot;DP表:      &quot;&quot;  r  o  s  &quot;&quot;   0  1  2  3  h    1  1  2  3  o    2  2  1  2  r    3  2  2  2  s    4  3  3  2  e    5  4  4  3              ↑            答案关键步骤:- dp[2][2]: &#x27;o&#x27;==&#x27;o&#x27;, dp[2][2]=dp[1][1]=1- dp[3][1]: &#x27;r&#x27;==&#x27;r&#x27;, dp[3][1]=dp[2][0]=2- dp[4][3]: &#x27;s&#x27;==&#x27;s&#x27;, dp[4][3]=dp[3][2]=2答案: 3步\n\n5. 买卖股票的最佳时机III (LeetCode 123)\n\n给定一个数组,最多可以完成两笔交易,求最大利润\n\n问题分析\n这是一个状态机DP问题,需要追踪:\n\n当前第几天\n当前处于什么状态(持有/不持有股票)\n完成了几次交易\n\n状态定义\nbuy1[i]:  第i天,第一次买入后的最大利润sell1[i]: 第i天,第一次卖出后的最大利润buy2[i]:  第i天,第二次买入后的最大利润sell2[i]: 第i天,第二次卖出后的最大利润\n状态转移方程\nbuy1[i]  = max(buy1[i-1], -prices[i])sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])\n状态转移图\ngraph LR\n    A[初始] --&gt;|买入| B[持有1]\n    B --&gt;|卖出| C[完成1笔]\n    C --&gt;|买入| D[持有2]\n    D --&gt;|卖出| E[完成2笔]\n    \n    style A fill:#FFE4B5\n    style C fill:#90EE90\n    style E fill:#87CEEB\n代码实现\nint maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n == 0) return 0;        // 初始化    int buy1 = -prices[0], sell1 = 0;    int buy2 = -prices[0], sell2 = 0;        for (int i = 1; i &lt; n; ++i) &#123;        buy1 = max(buy1, -prices[i]);        sell1 = max(sell1, buy1 + prices[i]);        buy2 = max(buy2, sell1 - prices[i]);        sell2 = max(sell2, buy2 + prices[i]);    &#125;        return sell2;&#125;\n时间复杂度: O(n)\n空间复杂度: O(1)\n执行过程\nprices = [3,3,5,0,0,3,1,4]Day 0: buy1=-3, sell1=0, buy2=-3, sell2=0Day 1: buy1=-3, sell1=0, buy2=-3, sell2=0Day 2: buy1=-3, sell1=2, buy2=-1, sell2=2Day 3: buy1=-3, sell1=2, buy2=2, sell2=2Day 4: buy1=-3, sell1=2, buy2=2, sell2=2Day 5: buy1=-3, sell1=2, buy2=2, sell2=5Day 6: buy1=-3, sell1=2, buy2=2, sell2=5Day 7: buy1=-3, sell1=2, buy2=2, sell2=6答案: 6 (在0买入,在3卖出,再在3买入,在4卖出)\n\n三维DP问题\n01背包问题 (经典)\n\n有n个物品和一个容量为W的背包,每个物品有重量w[i]和价值v[i],每个物品只能选一次,求最大价值\n\n问题分析\n物品: [(重量,价值)]物品1: (2, 3)物品2: (3, 4)物品3: (4, 5)背包容量: 5最优方案: 选物品1和2,价值=7\n状态定义\ndp[i][j]: 前i个物品,容量为j时的最大价值\n状态转移方程\ndp[i][j] = max(    dp[i-1][j],              // 不选第i个物品    dp[i-1][j-w[i]] + v[i]   // 选第i个物品)\n代码实现\n// 二维DPint knapsack(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;    int n = w.size();    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(W + 1, 0));        for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= W; ++j) &#123;            // 不选第i个物品            dp[i][j] = dp[i-1][j];                        // 如果能选第i个物品            if (j &gt;= w[i-1]) &#123;                dp[i][j] = max(dp[i][j], dp[i-1][j-w[i-1]] + v[i-1]);            &#125;        &#125;    &#125;        return dp[n][W];&#125;// 空间优化:一维DP (从后向前遍历)int knapsack(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;    int n = w.size();    vector&lt;int&gt; dp(W + 1, 0);        for (int i = 0; i &lt; n; ++i) &#123;        // 必须从后向前,否则会重复使用同一物品        for (int j = W; j &gt;= w[i]; --j) &#123;            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);        &#125;    &#125;        return dp[W];&#125;\n时间复杂度: O(n×W)\n空间复杂度: O(n×W) → 优化后 O(W)\n为什么要从后向前?\n从前向后:dp[2] = dp[2-w[0]] + v[0]  // 使用了w[0]dp[4] = dp[4-w[0]] + v[0]  // 又使用了w[0]! ❌重复使用从后向前:dp[4] = dp[4-w[0]] + v[0]  // 使用旧的dp[2]dp[2] = dp[2-w[0]] + v[0]  // 使用旧的dp[0]✓ 每个物品只用一次\n\n最长回文子序列 (LeetCode 516)\n\n给定一个字符串,找到其中最长的回文子序列长度\n\n问题分析\n输入: &quot;bbbab&quot;输出: 4解释: 最长回文子序列是 &quot;bbbb&quot;\n区间DP思想\n这是区间DP的典型问题,需要思考:\n\n子串[i,j]的答案\n如何从更小的区间推导\n\n状态定义\ndp[i][j]: 字符串[i,j]区间内的最长回文子序列长度\n状态转移方程\nif (s[i] == s[j]):    dp[i][j] = dp[i+1][j-1] + 2else:    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n代码实现\nint longestPalindromeSubseq(string s) &#123;    int n = s.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));        // 单个字符都是回文    for (int i = 0; i &lt; n; ++i) &#123;        dp[i][i] = 1;    &#125;        // 从长度2开始枚举    for (int len = 2; len &lt;= n; ++len) &#123;        for (int i = 0; i + len - 1 &lt; n; ++i) &#123;            int j = i + len - 1;                        if (s[i] == s[j]) &#123;                dp[i][j] = dp[i+1][j-1] + 2;            &#125; else &#123;                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);            &#125;        &#125;    &#125;        return dp[0][n-1];&#125;\n时间复杂度: O(n²)\n空间复杂度: O(n²)\n执行过程\ns = &quot;bbbab&quot;DP表 (下三角未使用):      0  1  2  3  4  0   1  2  3  4  4  1   -  1  2  3  3  2   -  -  1  2  2  3   -  -  -  1  1  4   -  -  -  -  1计算顺序 (按长度递增):len=1: 对角线全为1len=2: dp[0][1], dp[1][2], dp[2][3], dp[3][4]len=3: dp[0][2], dp[1][3], dp[2][4]len=4: dp[0][3], dp[1][4]len=5: dp[0][4]答案: dp[0][4] = 4 (&quot;bbbb&quot;)\n\n多维DP优化技巧\n1. 滚动数组\n当dp[i][j]只依赖dp[i-1][…]时:\n// 原始: O(m×n)空间vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));// 优化: O(n)空间vector&lt;int&gt; prev(n), curr(n);for (int i = 0; i &lt; m; ++i) &#123;    for (int j = 0; j &lt; n; ++j) &#123;        curr[j] = ...;  // 使用prev[j]等    &#125;    swap(prev, curr);&#125;\n2. 倒序遍历 (01背包)\n// ❌ 正序会重复使用for (int j = 0; j &lt;= W; ++j) &#123;    dp[j] = max(dp[j], dp[j-w] + v);&#125;// ✓ 倒序避免重复for (int j = W; j &gt;= w; --j) &#123;    dp[j] = max(dp[j], dp[j-w] + v);&#125;\n3. 状态压缩\n某些问题可以用位运算压缩状态:\n// 例如:旅行商问题 (TSP)// dp[state][i]: 访问状态为state,当前在城市i的最短距离// state用二进制表示: 101表示访问了城市0和2\n\n多维DP问题分类\n路径问题\ngraph LR\n    A[路径问题] --&gt; B[不同路径]\n    A --&gt; C[最小路径和]\n    A --&gt; D[地下城游戏]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n特点: 在网格中移动,dp[i][j]表示到达(i,j)的状态\n双序列匹配\ngraph LR\n    A[双序列] --&gt; B[最长公共子序列]\n    A --&gt; C[编辑距离]\n    A --&gt; D[不同的子序列]\n    \n    style A fill:#87CEEB\n特点: 两个字符串/数组,dp[i][j]表示处理到第i和第j个字符\n区间DP\ngraph LR\n    A[区间DP] --&gt; B[最长回文子序列]\n    A --&gt; C[戳气球]\n    A --&gt; D[合并石头]\n    \n    style A fill:#DDA0DD\n特点: dp[i][j]表示区间[i,j]的答案,按区间长度递增计算\n背包DP\ngraph LR\n    A[背包DP] --&gt; B[01背包]\n    A --&gt; C[完全背包]\n    A --&gt; D[多重背包]\n    \n    style A fill:#F0E68C\n特点: 选或不选,dp[i][j]表示前i个物品,容量为j的最优解\n\n解题思路总结\n步骤1: 确定维度\n问题需要几个参数描述?- 1个参数 → 一维DP- 2个参数 → 二维DP- 更多 → 三维/更高维DP\n步骤2: 定义状态\ndp[i][j] 代表什么含义?常见定义:- dp[i][j]: 到达(i,j)的...- dp[i][j]: 前i个...前j个...的...- dp[i][j]: 区间[i,j]的...\n步骤3: 找状态转移\n当前状态从哪些状态转移而来?常见转移:- 最优化: max/min- 计数: 累加- 判断: 逻辑或/与\n步骤4: 初始化\n确定边界条件:- dp[0][0] = ?- dp[i][0] = ?- dp[0][j] = ?\n步骤5: 确定计算顺序\n保证计算dp[i][j]时,依赖的状态已经计算:- 从小到大 (大多数情况)- 按长度递增 (区间DP)- 倒序 (01背包)\n\n常见陷阱与技巧\n陷阱1: 索引混淆\n// ❌ 数组越界dp[i][j] = dp[i-1][j-1] + 1;  // 当i=0或j=0时越界// ✓ 正确处理for (int i = 1; i &lt;= m; ++i) &#123;    for (int j = 1; j &lt;= n; ++j) &#123;        // 使用i-1, j-1访问原数组        if (text1[i-1] == text2[j-1]) &#123;            dp[i][j] = dp[i-1][j-1] + 1;        &#125;    &#125;&#125;\n陷阱2: 初始化错误\n// ❌ 忘记初始化边界vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));// ✓ 正确初始化vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));// 或者显式处理第一行第一列\n陷阱3: 遍历顺序错误\n// ❌ 01背包正序遍历for (int j = 0; j &lt;= W; ++j) &#123;  // 会重复使用物品    dp[j] = max(dp[j], dp[j-w] + v);&#125;// ✓ 倒序遍历for (int j = W; j &gt;= w; --j) &#123;    dp[j] = max(dp[j], dp[j-w] + v);&#125;\n技巧1: 画表格辅助思考\n对于双序列问题,画出DP表格:      &quot;&quot;  a  c  e  &quot;&quot;   0  0  0  0  a    0  ?  ?  ?  b    0  ?  ?  ?  c    0  ?  ?  ?思考每个?如何填\n技巧2: 从简单例子入手\n不要一开始就想复杂情况:1. 先考虑n=1, n=2的情况2. 找规律,推导状态转移3. 验证边界条件\n技巧3: 记住经典模板\n// 双序列模板for (int i = 1; i &lt;= m; ++i) &#123;    for (int j = 1; j &lt;= n; ++j) &#123;        if (条件) &#123;            dp[i][j] = ...;        &#125; else &#123;            dp[i][j] = ...;        &#125;    &#125;&#125;// 区间DP模板for (int len = 2; len &lt;= n; ++len) &#123;    for (int i = 0; i + len - 1 &lt; n; ++i) &#123;        int j = i + len - 1;        dp[i][j] = ...;    &#125;&#125;\n\n思维导图\ngraph TD\n    A[多维DP] --&gt; B[问题类型]\n    A --&gt; C[核心技巧]\n    A --&gt; D[优化方法]\n    \n    B --&gt; B1[路径问题]\n    B --&gt; B2[双序列匹配]\n    B --&gt; B3[区间DP]\n    B --&gt; B4[背包DP]\n    \n    C --&gt; C1[确定维度]\n    C --&gt; C2[定义状态]\n    C --&gt; C3[状态转移]\n    C --&gt; C4[初始化]\n    \n    D --&gt; D1[滚动数组]\n    D --&gt; D2[倒序遍历]\n    D --&gt; D3[状态压缩]\n    \n    style A fill:#FFE4B5\n    style B fill:#90EE90\n    style C fill:#87CEEB\n    style D fill:#DDA0DD\n\n总结\n核心要点\n\n多维DP = 多个参数描述状态\n二维是最常见的: 路径、双序列、背包\n画表格: 辅助理解状态转移\n注意边界: 初始化和索引处理\n空间优化: 滚动数组、倒序遍历\n\n代码模板\n// 二维DP模板 (双序列)int solve(string s1, string s2) &#123;    int m = s1.size(), n = s2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));        // 初始化第一行和第一列    for (int i = 0; i &lt;= m; ++i) dp[i][0] = ...;    for (int j = 0; j &lt;= n; ++j) dp[0][j] = ...;        // 状态转移    for (int i = 1; i &lt;= m; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (s1[i-1] == s2[j-1]) &#123;                dp[i][j] = dp[i-1][j-1] + ...;            &#125; else &#123;                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);            &#125;        &#125;    &#125;        return dp[m][n];&#125;// 01背包模板 (空间优化)int knapsack(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;    vector&lt;int&gt; dp(W + 1, 0);        for (int i = 0; i &lt; n; ++i) &#123;        for (int j = W; j &gt;= w[i]; --j) &#123;  // 倒序!            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);        &#125;    &#125;        return dp[W];&#125;// 区间DP模板int solve(string s) &#123;    int n = s.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));        // 初始化单个元素    for (int i = 0; i &lt; n; ++i) &#123;        dp[i][i] = 1;    &#125;        // 按长度递增    for (int len = 2; len &lt;= n; ++len) &#123;        for (int i = 0; i + len - 1 &lt; n; ++i) &#123;            int j = i + len - 1;                        if (s[i] == s[j]) &#123;                dp[i][j] = dp[i+1][j-1] + 2;            &#125; else &#123;                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);            &#125;        &#125;    &#125;        return dp[0][n-1];&#125;\n推荐练习:\n\nLeetCode 62 - 不同路径\nLeetCode 64 - 最小路径和\nLeetCode 1143 - 最长公共子序列\nLeetCode 72 - 编辑距离\nLeetCode 516 - 最长回文子序列\nLeetCode 322 - 零钱兑换\n\n推荐阅读:\n\n《算法导论》第15章:动态规划\n动态规划专题详解\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","动态规划","多维DP"]},{"title":"常见算法-快速选择","url":"/posts/c68751d1/","content":"快速选择：不完全排序的艺术\n\n当你只需要找到第K大的元素时，为什么要把整个数组都排序呢?\n\n\n什么是快速选择\n快速选择（QuickSelect）是一种从无序数组中找到第K小（或第K大）元素的选择算法。它基于快速排序的分区思想，但不需要完全排序。\n\n核心思想：每次分区后，pivot元素的位置就是它在有序数组中的最终位置\n\n形象理解\n想象你要在班级里找出第3名：\n普通方法：给全班排序，然后取第3名 → O(n log n)快速选择：每次排除一半不可能的人 → O(n)\n就像打擂台赛，每轮淘汰一半选手，不需要完整排序就能找到冠军！\n\n算法原理\n核心思想\n快速选择利用快速排序的 partition（分区） 操作：\ngraph TD\n    A[选择pivot] --&gt; B[分区操作]\n    B --&gt; C&#123;pivot位置 vs 目标位置&#125;\n    C --&gt;|相等| D[找到目标，返回]\n    C --&gt;|pivot靠左| E[在右半部分继续]\n    C --&gt;|pivot靠右| F[在左半部分继续]\n    E --&gt; A\n    F --&gt; A\n    \n    style D fill:#90EE90\n    style A fill:#FFE4B5\n分区操作详解\nPartition将数组分为三部分：\n[小于pivot的元素] | [pivot] | [大于pivot的元素]     区域1         位置p       区域2\n关键性质：分区后，pivot元素在它最终排序位置上\n\n算法步骤图解\n示例：找第2大元素\n数组：[3, 2, 1, 5, 6, 4]目标：第2大 = 第5小（索引4）步骤1: 选择pivot=4，分区[3, 2, 1] [4] [5, 6]  0,1,2    3   4,5         ↑ pivot在位置3步骤2: 目标在位置4，pivot在位置3       目标 &gt; pivot，在右半部分继续       [5, 6]步骤3: 选择pivot=5，分区[5] [6] 4   5 ↑ pivot在位置4步骤4: pivot位置 = 目标位置 = 4       找到答案：5 ✓\n完整过程可视化\n原数组：[3, 2, 1, 5, 6, 4]找第2大第1轮 Partition (pivot=4):Before: [3, 2, 1, 5, 6, 4]After:  [3, 2, 1, 4, 5, 6]                   ↑                位置3，目标在右边第2轮 Partition (pivot=6):  Range:  [5, 6]After:  [5, 6]            ↑         位置5，目标在左边第3轮 Partition (pivot=5):单元素：5         ↑      位置4，找到！\n\n代码实现\n基础版本\nint quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    // 基准情况：只有一个元素    if (left == right) &#123;        return nums[left];    &#125;        // 分区操作    int pivotIndex = partition(nums, left, right);        // 判断pivot位置    if (pivotIndex == k) &#123;        return nums[k];           // 找到目标    &#125; else if (pivotIndex &lt; k) &#123;        return quickSelect(nums, pivotIndex + 1, right, k);  // 在右边    &#125; else &#123;        return quickSelect(nums, left, pivotIndex - 1, k);   // 在左边    &#125;&#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    // 随机选择pivot，避免最坏情况    int randomIndex = left + rand() % (right - left + 1);    swap(nums[randomIndex], nums[right]);        int pivot = nums[right];    int i = left - 1;  // i指向小于pivot区域的最后一个位置        for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            ++i;            swap(nums[i], nums[j]);        &#125;    &#125;        // 将pivot放到正确位置    swap(nums[i + 1], nums[right]);    return i + 1;&#125;\n找第K大元素\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    // 第k大 = 第(n-k)小（从0开始索引）    int targetIndex = nums.size() - k;    return quickSelect(nums, 0, nums.size() - 1, targetIndex);&#125;\nPartition过程详解\n数组: [3, 2, 1, 5, 6, 4]pivot = 4 (选择最后一个元素)初始: i = -1      [3, 2, 1, 5, 6, 4]       j              pivotj=0: nums[0]=3 &lt;= 4 ✓     i++, swap(nums[0], nums[0])     [3, 2, 1, 5, 6, 4]      i,jj=1: nums[1]=2 &lt;= 4 ✓     i++, swap(nums[1], nums[1])     [3, 2, 1, 5, 6, 4]         i,jj=2: nums[2]=1 &lt;= 4 ✓     i++, swap(nums[2], nums[2])     [3, 2, 1, 5, 6, 4]            i,jj=3: nums[3]=5 &gt; 4 ✗     不交换     [3, 2, 1, 5, 6, 4]            i  jj=4: nums[4]=6 &gt; 4 ✗     不交换     [3, 2, 1, 5, 6, 4]            i     j最后: swap(nums[i+1], nums[right])     [3, 2, 1, 4, 6, 5]               ↑            pivot位置=3\n\n复杂度分析\n时间复杂度\n\n\n\n情况\n复杂度\n说明\n\n\n\n\n平均\nO(n)\n每次减半搜索空间\n\n\n最好\nO(n)\n每次分区都在中间\n\n\n最坏\nO(n²)\n每次分区都在边界\n\n\n\n为什么平均是 O(n)？\n第1轮：处理 n 个元素第2轮：处理 n/2 个元素第3轮：处理 n/4 个元素...总时间 = n + n/2 + n/4 + ... ≈ 2n = O(n)\n这是一个几何级数！\ngraph LR\n    A[n个元素] --&gt; B[n/2个元素]\n    B --&gt; C[n/4个元素]\n    C --&gt; D[n/8个元素]\n    D --&gt; E[...]\n    \n    style A fill:#FF6B6B\n    style B fill:#FFB6C1\n    style C fill:#FFE4B5\n与快速排序对比\n\n\n\n算法\n时间复杂度（平均）\n说明\n\n\n\n\n快速排序\nO(n log n)\n两边都要递归\n\n\n快速选择\nO(n)\n只递归一边\n\n\n\n关键区别：快速选择只需要递归一侧，快速排序需要递归两侧！\n\n优化技巧\n1. 随机化Pivot\n问题：固定选择pivot（如最后一个元素）在有序数组中会退化为O(n²)\n解决：随机选择pivot\nint randomIndex = left + rand() % (right - left + 1);swap(nums[randomIndex], nums[right]);\n2. 三数取中法\n从首、中、尾三个位置选择中位数作为pivot\nint getMidPivot(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    int mid = left + (right - left) / 2;        // 将三个数的中位数移到right位置    if (nums[left] &gt; nums[mid]) swap(nums[left], nums[mid]);    if (nums[left] &gt; nums[right]) swap(nums[left], nums[right]);    if (nums[mid] &gt; nums[right]) swap(nums[mid], nums[right]);        swap(nums[mid], nums[right]);    return right;&#125;\n3. 迭代版本（避免递归栈溢出）\nint quickSelectIterative(vector&lt;int&gt;&amp; nums, int k) &#123;    int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;        int pivotIndex = partition(nums, left, right);                if (pivotIndex == k) &#123;            return nums[k];        &#125; else if (pivotIndex &lt; k) &#123;            left = pivotIndex + 1;  // 在右边        &#125; else &#123;            right = pivotIndex - 1; // 在左边        &#125;    &#125;        return nums[k];&#125;\n\n经典应用\n1. 第K大元素（LeetCode 215）\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    int targetIndex = nums.size() - k;    return quickSelect(nums, 0, nums.size() - 1, targetIndex);&#125;\n示例：\n输入：[3,2,1,5,6,4], k=2输出：5解释：第2大的元素是5\n\n2. 数组中的第K个最大元素（扩展）\n找出数组中前K大的元素\nvector&lt;int&gt; topKLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    // 找到第k大元素的位置    int targetIndex = nums.size() - k;    quickSelect(nums, 0, nums.size() - 1, targetIndex);        // 返回从targetIndex开始的所有元素    return vector&lt;int&gt;(nums.begin() + targetIndex, nums.end());&#125;\n\n3. 寻找中位数\ndouble findMedian(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();        if (n % 2 == 1) &#123;        // 奇数个元素        return quickSelect(nums, 0, n - 1, n / 2);    &#125; else &#123;        // 偶数个元素        int mid1 = quickSelect(nums, 0, n - 1, n / 2 - 1);        int mid2 = quickSelect(nums, 0, n - 1, n / 2);        return (mid1 + mid2) / 2.0;    &#125;&#125;\n\n快速选择 vs 其他方法\n对比表\n\n\n\n方法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n\n快速选择\nO(n) 平均\nO(1)\n一次性查询\n\n\n排序\nO(n log n)\nO(1)\n多次查询\n\n\n堆\nO(n log k)\nO(k)\nK很小时\n\n\n计数排序\nO(n + m)\nO(m)\n数值范围小\n\n\n\n选择建议\ngraph TD\n    A&#123;需要什么？&#125; --&gt; B[只查询一次]\n    A --&gt; C[多次查询]\n    A --&gt; D[K很小]\n    \n    B --&gt; E[快速选择 O n]\n    C --&gt; F[排序 O n log n]\n    D --&gt; G[堆 O n log k]\n    \n    style E fill:#90EE90\n    style B fill:#FFE4B5\n\n实战案例\n案例1：找数组中的第K个最大元素\n// LeetCode 215class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int targetIndex = nums.size() - k;        return quickSelect(nums, 0, nums.size() - 1, targetIndex);    &#125;    private:    int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;        if (left == right) return nums[left];                int pivotIndex = partition(nums, left, right);                if (pivotIndex == k) &#123;            return nums[k];        &#125; else if (pivotIndex &lt; k) &#123;            return quickSelect(nums, pivotIndex + 1, right, k);        &#125; else &#123;            return quickSelect(nums, left, pivotIndex - 1, k);        &#125;    &#125;        int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        int randomIndex = left + rand() % (right - left + 1);        swap(nums[randomIndex], nums[right]);                int pivot = nums[right];        int i = left - 1;                for (int j = left; j &lt; right; ++j) &#123;            if (nums[j] &lt;= pivot) &#123;                swap(nums[++i], nums[j]);            &#125;        &#125;                swap(nums[i + 1], nums[right]);        return i + 1;    &#125;&#125;;\n\n案例2：找出数组中位数\nclass Solution &#123;public:    double findMedian(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();                if (n % 2 == 1) &#123;            return quickSelect(nums, 0, n - 1, n / 2);        &#125; else &#123;            // 需要找两个中间元素            int left = quickSelect(nums, 0, n - 1, n / 2 - 1);            int right = quickSelect(nums, 0, n - 1, n / 2);            return (left + right) / 2.0;        &#125;    &#125;    private:    int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;        if (left == right) return nums[left];                int pivotIndex = partition(nums, left, right);                if (pivotIndex == k) &#123;            return nums[k];        &#125; else if (pivotIndex &lt; k) &#123;            return quickSelect(nums, pivotIndex + 1, right, k);        &#125; else &#123;            return quickSelect(nums, left, pivotIndex - 1, k);        &#125;    &#125;        int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        int randomIndex = left + rand() % (right - left + 1);        swap(nums[randomIndex], nums[right]);                int pivot = nums[right];        int i = left - 1;                for (int j = left; j &lt; right; ++j) &#123;            if (nums[j] &lt;= pivot) &#123;                swap(nums[++i], nums[j]);            &#125;        &#125;                swap(nums[i + 1], nums[right]);        return i + 1;    &#125;&#125;;\n\n常见陷阱与技巧\n陷阱1：索引转换错误\n// ❌ 错误：直接使用kreturn quickSelect(nums, 0, nums.size() - 1, k);// ✅ 正确：第k大 = 第(n-k)小int targetIndex = nums.size() - k;return quickSelect(nums, 0, nums.size() - 1, targetIndex);\n陷阱2：忘记随机化\n// ❌ 危险：固定选择最后一个元素int pivot = nums[right];// ✅ 安全：随机选择pivotint randomIndex = left + rand() % (right - left + 1);swap(nums[randomIndex], nums[right]);int pivot = nums[right];\n技巧1：记住partition模板\nint partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    // 随机pivot    int random = left + rand() % (right - left + 1);    swap(nums[random], nums[right]);        int pivot = nums[right];    int i = left - 1;  // 关键：从left-1开始        for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            swap(nums[++i], nums[j]);        &#125;    &#125;        swap(nums[i + 1], nums[right]);    return i + 1;&#125;\n技巧2：口诀记忆\n\n“找大减K，找小用K”\n\n\n找第K大：targetIndex = n - k\n找第K小：targetIndex = k - 1（从0开始索引）\n\n\n思维导图\ngraph TD\n    A[快速选择] --&gt; B[核心思想]\n    A --&gt; C[关键操作]\n    A --&gt; D[应用场景]\n    A --&gt; E[优化技巧]\n    \n    B --&gt; B1[基于快排分区]\n    B --&gt; B2[只递归一侧]\n    B --&gt; B3[O n 平均复杂度]\n    \n    C --&gt; C1[Partition分区]\n    C --&gt; C2[比较pivot位置]\n    C --&gt; C3[递归/迭代]\n    \n    D --&gt; D1[第K大元素]\n    D --&gt; D2[中位数]\n    D --&gt; D3[TopK问题]\n    \n    E --&gt; E1[随机化pivot]\n    E --&gt; E2[三数取中]\n    E --&gt; E3[迭代版本]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style D fill:#90EE90\n\n总结\n核心要点\n\n快速选择 = 快排分区 + 单侧递归\n平均O(n)复杂度：比完全排序快\n随机化pivot：避免最坏情况\n索引转换：第K大 = 第(n-k)小\n\n代码模板\n// 快速选择模板int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    if (left == right) return nums[left];        int pivotIndex = partition(nums, left, right);        if (pivotIndex == k) &#123;        return nums[k];    &#125; else if (pivotIndex &lt; k) &#123;        return quickSelect(nums, pivotIndex + 1, right, k);    &#125; else &#123;        return quickSelect(nums, left, pivotIndex - 1, k);    &#125;&#125;// Partition模板int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    int random = left + rand() % (right - left + 1);    swap(nums[random], nums[right]);        int pivot = nums[right];    int i = left - 1;        for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            swap(nums[++i], nums[j]);        &#125;    &#125;        swap(nums[i + 1], nums[right]);    return i + 1;&#125;\n推荐练习：\n\nLeetCode 215 - 数组中的第K个最大元素\nLeetCode 973 - 最接近原点的K个点\nLeetCode 347 - 前K个高频元素\n\n推荐阅读：\n\n《算法导论》第9章：中位数和顺序统计量\n快速选择算法详解\n\n","categories":["算法"],"tags":["C++","LeetCode","算法设计","分治","快速选择"]},{"title":"常见算法-数学技巧","url":"/posts/e33b4520/","content":"数学算法：编程中的数学魔法\n\n当算法遇上数学，简洁而优雅\n\n\n引言\n在算法世界里，数学不仅仅是公式和定理，更是解决问题的强大工具。很多看似复杂的问题，只要找到背后的数学规律，往往能用寥寥几行代码优雅地解决。\n本文涵盖：\n\n质数与因数分解\n最大公约数与最小公倍数\n快速幂与模运算\n数学规律与找规律问题\n组合数学基础\n\n\n一、质数相关\n1.1 判断质数\n\n质数：大于1的自然数中，只能被1和自己整除的数\n\n方法1：试除法（基础）\nbool isPrime(int n) &#123;    if (n &lt;= 1) return false;    if (n == 2) return true;    if (n % 2 == 0) return false;  // 排除偶数        for (int i = 3; i * i &lt;= n; i += 2) &#123;  // 只检查奇数        if (n % i == 0) return false;    &#125;    return true;&#125;\n优化点：\n\n只需检查到√n\n跳过偶数，只检查奇数\n\n时间复杂度：O(√n)\n为什么只需要检查到√n？\n假设 n = a × b如果 a 和 b 都大于√n：  a × b &gt; √n × √n = n（矛盾！）  所以必有一个因数 ≤ √n例子：36 = 6 × 6    如果存在因数，必有一个 ≤ 6\n\n1.2 埃拉托斯特尼筛法（Sieve of Eratosthenes）\n\nLeetCode 204：统计所有小于非负整数 n 的质数的数量\n\n问题分析\n输入：n = 10输出：4解释：小于10的质数有 2, 3, 5, 7\n算法思路：筛法\n从2开始，标记2的所有倍数为合数从3开始，标记3的所有倍数为合数从5开始，标记5的所有倍数为合数...剩下未被标记的就是质数\n可视化过程\nn = 20初始：[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]标记2的倍数：  [2, 3, ✗, 5, ✗, 7, ✗, 9, ✗, 11, ✗, 13, ✗, 15, ✗, 17, ✗, 19]   4,6,8,10,12,14,16,18被标记标记3的倍数：  [2, 3, ✗, 5, ✗, 7, ✗, ✗, ✗, 11, ✗, 13, ✗, ✗, ✗, 17, ✗, 19]   9,15也被标记标记5的倍数：  [2, 3, ✗, 5, ✗, 7, ✗, ✗, ✗, 11, ✗, 13, ✗, ✗, ✗, 17, ✗, 19]   （10,15,20已经被标记过了）质数：2, 3, 5, 7, 11, 13, 17, 19\n代码实现\nint countPrimes(int n) &#123;    if (n &lt;= 2) return 0;        vector&lt;bool&gt; isPrime(n, true);    isPrime[0] = isPrime[1] = false;        // 只需要从2遍历到√n    for (int i = 2; i * i &lt; n; ++i) &#123;        if (isPrime[i]) &#123;            // 标记i的所有倍数为合数            // 优化：从i*i开始，因为i*(i-1)已经被更小的质数标记过了            for (int j = i * i; j &lt; n; j += i) &#123;                isPrime[j] = false;            &#125;        &#125;    &#125;        // 统计质数个数    int count = 0;    for (int i = 2; i &lt; n; ++i) &#123;        if (isPrime[i]) count++;    &#125;        return count;&#125;\n时间复杂度：O(n log log n)\n空间复杂度：O(n)\n优化技巧\n// 优化1：从i*i开始标记for (int j = i * i; j &lt; n; j += i)// 优化2：跳过偶数for (int i = 3; i * i &lt; n; i += 2)\n\n1.3 分解质因数\n\n将一个正整数分解成质数的乘积\n\n问题示例\n输入：12输出：2^2 × 3 = [2, 2, 3]输入：315输出：3^2 × 5 × 7 = [3, 3, 5, 7]\n代码实现\nvector&lt;int&gt; primeFactorization(int n) &#123;    vector&lt;int&gt; factors;        // 处理因数2    while (n % 2 == 0) &#123;        factors.push_back(2);        n /= 2;    &#125;        // 处理奇数因数    for (int i = 3; i * i &lt;= n; i += 2) &#123;        while (n % i == 0) &#123;            factors.push_back(i);            n /= i;        &#125;    &#125;        // 如果n大于1，说明n本身是质数    if (n &gt; 1) &#123;        factors.push_back(n);    &#125;        return factors;&#125;\n示例执行：\nn = 60处理2：60 / 2 = 30, 30 / 2 = 15       factors = [2, 2]处理3：15 / 3 = 5       factors = [2, 2, 3]处理5：5是质数，直接加入       factors = [2, 2, 3, 5]结果：60 = 2^2 × 3 × 5\n\n二、最大公约数（GCD）与最小公倍数（LCM）\n2.1 最大公约数（GCD）\n\n两个或多个整数共有约数中最大的一个\n\n欧几里得算法（辗转相除法）\n数学原理：\ngcd(a, b) = gcd(b, a % b)gcd(a, 0) = a\n可视化：\ngcd(48, 18)= gcd(18, 48 % 18)= gcd(18, 12)= gcd(12, 18 % 12)= gcd(12, 6)= gcd(6, 12 % 6)= gcd(6, 0)= 6\n代码实现\n// 递归版本int gcd(int a, int b) &#123;    return b == 0 ? a : gcd(b, a % b);&#125;// 迭代版本int gcd(int a, int b) &#123;    while (b != 0) &#123;        int temp = b;        b = a % b;        a = temp;    &#125;    return a;&#125;// C++17标准库#include &lt;numeric&gt;int result = std::gcd(a, b);\n时间复杂度：O(log min(a, b))\n\n2.2 最小公倍数（LCM）\n\n两个或多个整数公有的倍数中最小的一个\n\n数学关系\nlcm(a, b) = (a × b) / gcd(a, b)\n代码实现\nlong long lcm(int a, int b) &#123;    // 先除后乘，避免溢出    return (long long)a / gcd(a, b) * b;&#125;// C++17标准库#include &lt;numeric&gt;long long result = std::lcm(a, b);\n注意：要防止整数溢出！\n\n2.3 应用：简化分数\nstruct Fraction &#123;    int numerator;    // 分子    int denominator;  // 分母        void simplify() &#123;        int g = gcd(abs(numerator), abs(denominator));        numerator /= g;        denominator /= g;                // 确保分母为正        if (denominator &lt; 0) &#123;            numerator = -numerator;            denominator = -denominator;        &#125;    &#125;&#125;;\n示例：\n12/18 简化：gcd(12, 18) = 612/6 = 2, 18/6 = 3结果：2/3\n\n三、快速幂与模运算\n3.1 快速幂（LeetCode 50）\n\n计算 x^n，要求时间复杂度 O(log n)\n\n暴力方法\n// O(n)double pow(double x, int n) &#123;    double result = 1;    for (int i = 0; i &lt; n; ++i) &#123;        result *= x;    &#125;    return result;&#125;\n问题：n很大时太慢\n快速幂（分治）\n核心思想：\nx^8 = (x^4)^2 = ((x^2)^2)^2x^n = (x^(n/2))^2        (n为偶数)x^n = x × (x^(n/2))^2     (n为奇数)\n示例：\n计算 2^10：2^10 = (2^5)^22^5 = 2 × (2^2)^22^2 = (2^1)^22^1 = 2反向计算：2^1 = 22^2 = 2 × 2 = 42^5 = 2 × 4^2 = 2 × 16 = 322^10 = 32^2 = 1024只需要4次乘法！（暴力需要9次）\n代码实现（递归版）\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;    return fastPow(x, n);&#125;double fastPow(double x, long long n) &#123;    if (n == 0) return 1.0;        double half = fastPow(x, n / 2);        if (n % 2 == 0) &#123;        return half * half;    &#125; else &#123;        return half * half * x;    &#125;&#125;\n代码实现（迭代版，推荐）\ndouble myPow(double x, long long n) &#123;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;        double result = 1.0;    double current = x;        while (n &gt; 0) &#123;        if (n &amp; 1) &#123;  // n是奇数            result *= current;        &#125;        current *= current;  // current = x^(2^i)        n &gt;&gt;= 1;    &#125;        return result;&#125;\n时间复杂度：O(log n)\n\n3.2 模运算下的快速幂\n\nLeetCode 1969：超级次方\n\n模运算性质\n(a × b) % p = ((a % p) × (b % p)) % p(a + b) % p = ((a % p) + (b % p)) % p\n代码实现\nconst int MOD = 1e9 + 7;long long powMod(long long x, long long n, long long mod) &#123;    long long result = 1;    x %= mod;  // 先取模        while (n &gt; 0) &#123;        if (n &amp; 1) &#123;            result = (result * x) % mod;        &#125;        x = (x * x) % mod;        n &gt;&gt;= 1;    &#125;        return result;&#125;\n应用：计算大数的幂次，防止溢出\n\n四、数学规律问题\n4.1 阶乘末尾零的个数（LeetCode 172）\n\n给定一个整数 n，返回 n! 结果尾数中零的数量\n\n分析\n末尾的0来自于 2 × 5，因子2的数量总是比5多，所以只需要数5的个数。\n示例：\n5! = 120 → 1个0（一个5）10! = 3628800 → 2个0（两个5：5和10）25! → 至少6个0（5,10,15,20,25×2）\n数5的个数\nn / 5：有多少个5的倍数n / 25：有多少个25的倍数（额外贡献一个5）n / 125：有多少个125的倍数（额外贡献一个5）...\n代码实现\nint trailingZeroes(int n) &#123;    int count = 0;    while (n &gt; 0) &#123;        n /= 5;        count += n;    &#125;    return count;&#125;\n示例：\nn = 25第1轮：n = 25 / 5 = 5, count = 5第2轮：n = 5 / 5 = 1, count = 6第3轮：n = 1 / 5 = 0, 结束答案：6个0\n时间复杂度：O(log n)\n\n4.2 数字1的个数（LeetCode 233）\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的次数\n\n问题示例\n输入：n = 13输出：6解释：1, 10, 11(2个), 12, 13 → 共6个1\n数位DP思路\n按位统计：个位、十位、百位…各有多少个1\n对于 n = 234，统计十位上1的个数：当十位为1时，可能的数字：- 010-019（百位为0）- 110-119（百位为1）- 210-219（百位为2）共：3 × 10 = 30个但234的十位是3（≠1），所以不需要特殊处理\n代码实现\nint countDigitOne(int n) &#123;    long long count = 0;    long long factor = 1;  // 当前位的权重        while (factor &lt;= n) &#123;        long long higher = n / (factor * 10);  // 高位数字        long long cur = (n / factor) % 10;     // 当前位数字        long long lower = n % factor;          // 低位数字                if (cur == 0) &#123;            count += higher * factor;        &#125; else if (cur == 1) &#123;            count += higher * factor + lower + 1;        &#125; else &#123;            count += (higher + 1) * factor;        &#125;                factor *= 10;    &#125;        return count;&#125;\n\n4.3 丑数（LeetCode 264）\n\n丑数是只包含质因数 2, 3, 5 的正整数\n\n问题\n输入：n = 10输出：12解释：1,2,3,4,5,6,8,9,10,12是前10个丑数\n动态规划（三指针）\n思路：\n每个丑数都是之前的丑数 × 2、× 3 或 × 5 得到的用三个指针分别维护\n代码实现\nint nthUglyNumber(int n) &#123;    vector&lt;int&gt; dp(n);    dp[0] = 1;        int p2 = 0, p3 = 0, p5 = 0;        for (int i = 1; i &lt; n; ++i) &#123;        int next2 = dp[p2] * 2;        int next3 = dp[p3] * 3;        int next5 = dp[p5] * 5;                dp[i] = min(&#123;next2, next3, next5&#125;);                // 去重        if (dp[i] == next2) p2++;        if (dp[i] == next3) p3++;        if (dp[i] == next5) p5++;    &#125;        return dp[n - 1];&#125;\n过程演示：\n初始：dp[0] = 1i=1: next2=2, next3=3, next5=5 → dp[1]=2, p2++i=2: next2=3, next3=3, next5=5 → dp[2]=3, p2++, p3++i=3: next2=4, next3=6, next5=5 → dp[3]=4, p2++i=4: next2=6, next3=6, next5=5 → dp[4]=5, p5++i=5: next2=6, next3=6, next5=10 → dp[5]=6, p2++, p3++...丑数序列：1, 2, 3, 4, 5, 6, 8, 9, 10, 12...\n\n五、组合数学\n5.1 帕斯卡三角形（LeetCode 118）\n\n杨辉三角/帕斯卡三角形\n\n可视化\n         1       1   1     1   2   1   1   3   3   1 1   4   6   4   11   5  10  10   5   1\n规律：\n每个数 = 左上方的数 + 右上方的数C(n, k) = C(n-1, k-1) + C(n-1, k)\n代码实现\nvector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;    vector&lt;vector&lt;int&gt;&gt; triangle;        for (int i = 0; i &lt; numRows; ++i) &#123;        vector&lt;int&gt; row(i + 1, 1);                for (int j = 1; j &lt; i; ++j) &#123;            row[j] = triangle[i-1][j-1] + triangle[i-1][j];        &#125;                triangle.push_back(row);    &#125;        return triangle;&#125;\n\n5.2 组合数计算\n\n计算 C(n, k) = n! / (k! × (n-k)!)\n\n方法1：递推公式\nint combination(int n, int k) &#123;    if (k &gt; n) return 0;    if (k == 0 || k == n) return 1;        // C(n, k) = C(n-1, k-1) + C(n-1, k)    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, 0));        for (int i = 0; i &lt;= n; ++i) &#123;        dp[i][0] = 1;        if (i &lt;= k) dp[i][i] = 1;    &#125;        for (int i = 2; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt; i &amp;&amp; j &lt;= k; ++j) &#123;            dp[i][j] = dp[i-1][j-1] + dp[i-1][j];        &#125;    &#125;        return dp[n][k];&#125;\n方法2：直接计算（防溢出）\nlong long combination(int n, int k) &#123;    if (k &gt; n - k) k = n - k;  // 利用对称性        long long result = 1;    for (int i = 0; i &lt; k; ++i) &#123;        result = result * (n - i) / (i + 1);  // 边乘边除，防溢出    &#125;        return result;&#125;\n\n六、其他数学技巧\n6.1 判断完全平方数\nbool isPerfectSquare(int num) &#123;    if (num &lt; 0) return false;        long long x = sqrt(num);    return x * x == num;&#125;// 二分查找版本bool isPerfectSquare(int num) &#123;    long long left = 0, right = num;        while (left &lt;= right) &#123;        long long mid = left + (right - left) / 2;        long long square = mid * mid;                if (square == num) &#123;            return true;        &#125; else if (square &lt; num) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;        return false;&#125;\n\n6.2 整数反转（LeetCode 7）\nint reverse(int x) &#123;    int result = 0;        while (x != 0) &#123;        int digit = x % 10;        x /= 10;                // 检查溢出        if (result &gt; INT_MAX / 10 || (result == INT_MAX / 10 &amp;&amp; digit &gt; 7)) &#123;            return 0;        &#125;        if (result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; digit &lt; -8)) &#123;            return 0;        &#125;                result = result * 10 + digit;    &#125;        return result;&#125;\n\n6.3 回文数（LeetCode 9）\nbool isPalindrome(int x) &#123;    // 负数和末尾为0的数（除了0本身）不是回文    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;        return false;    &#125;        int reversed = 0;    while (x &gt; reversed) &#123;        reversed = reversed * 10 + x % 10;        x /= 10;    &#125;        // 奇数位：x == reversed / 10    // 偶数位：x == reversed    return x == reversed || x == reversed / 10;&#125;\n\n总结\n核心要点\n\n质数判断：试除法 O(√n)，埃氏筛法 O(n log log n)\nGCD：欧几里得算法 O(log min(a,b))\n快速幂：分治思想，O(log n)\n找规律：观察数学性质，降低复杂度\n\n常用模板\n// 判断质数bool isPrime(int n) &#123;    if (n &lt;= 1) return false;    if (n == 2) return true;    if (n % 2 == 0) return false;    for (int i = 3; i * i &lt;= n; i += 2) &#123;        if (n % i == 0) return false;    &#125;    return true;&#125;// 最大公约数int gcd(int a, int b) &#123;    return b == 0 ? a : gcd(b, a % b);&#125;// 快速幂long long quickPow(long long x, long long n) &#123;    long long result = 1;    while (n &gt; 0) &#123;        if (n &amp; 1) result *= x;        x *= x;        n &gt;&gt;= 1;    &#125;    return result;&#125;// 模运算快速幂long long powMod(long long x, long long n, long long mod) &#123;    long long result = 1;    x %= mod;    while (n &gt; 0) &#123;        if (n &amp; 1) result = (result * x) % mod;        x = (x * x) % mod;        n &gt;&gt;= 1;    &#125;    return result;&#125;\n推荐题目\n入门级：\n\nLeetCode 9 - 回文数\nLeetCode 7 - 整数反转\nLeetCode 204 - 计数质数\n\n进阶级：\n\nLeetCode 50 - Pow(x, n)\nLeetCode 172 - 阶乘后的零\nLeetCode 264 - 丑数 II\n\n高级：\n\nLeetCode 233 - 数字1的个数\nLeetCode 829 - 连续整数求和\n\n推荐阅读：\n\n《具体数学》- Graham, Knuth, Patashnik\n数论基础 - 维基百科\n\n","categories":["算法"],"tags":["C++","LeetCode","算法技巧","数学","质数","最大公约数"]},{"title":"常见题型-N皇后","url":"/posts/f508052b/","content":"N皇后问题完全解析：从暴力到极致优化\n\n深度剖析经典回溯问题，掌握从基础到高级的优化技巧\n\n问题描述\nN皇后问题是一个经典的回溯算法问题，也是LeetCode上的热门题目。\n问题定义\n在 n×n 的国际象棋棋盘上放置 n 个皇后，使得它们不能相互攻击。\n攻击规则\n皇后可以攻击：\n\n同一行的所有位置\n同一列的所有位置\n同一对角线的所有位置（左上-右下、右上-左下）\n\n示例\n4皇后问题的解：\n解法1:          解法2:. Q . .        . . Q .. . . Q        Q . . .Q . . .        . . . Q. . Q .        . Q . .\n\n问题分析\n关键观察\n\n\n每行只能放一个皇后\n\nn个皇后放在n行，每行恰好一个\n所以我们可以逐行放置皇后\n\n\n\n每列只能放一个皇后\n\n需要记录哪些列已经被占用\n\n\n\n每条对角线只能放一个皇后\n\n主对角线（左上→右下）：特点是 row - col 值相同\n副对角线（右上→左下）：特点是 row + col 值相同\n\n\n\n对角线索引计算\n棋盘示例 (n=4):主对角线 (row - col):        副对角线 (row + col):-3 -2 -1  0                  0  1  2  3-2 -1  0  1                  1  2  3  4-1  0  1  2                  2  3  4  5 0  1  2  3                  3  4  5  6为避免负数，主对角线索引 = row - col + n - 1\n可视化理解\ngraph TD\n    A[N皇后问题] --&gt; B[逐行放置]\n    B --&gt; C[检查冲突]\n    C --&gt; D[列冲突]\n    C --&gt; E[主对角线冲突]\n    C --&gt; F[副对角线冲突]\n    \n    D --&gt; G[cols数组]\n    E --&gt; H[diag1数组]\n    F --&gt; I[diag2数组]\n    \n    style A fill:#FFE4B5\n    style C fill:#87CEEB\n\n解题思路演变\n思路1: 暴力穷举\n尝试所有可能的放置方法：\nn个皇后，每个皇后有 n² 个位置总共需要检查 (n²)! 种组合 → 天文数字！\n问题：完全不可行\n思路2: 优化穷举\n既然每行只能放一个皇后：\n第1个皇后有 n 种选择第2个皇后有 n 种选择...总共 n^n 种组合\n问题：仍然很大（8皇后就是 8⁸ = 16,777,216）\n思路3: 回溯 + 剪枝 ✓\n核心思想：\n\n逐行放置皇后（每行只选一列）\n放置前检查是否合法\n如果不合法，剪枝（不继续递归）\n如果合法，继续下一行\n回溯时撤销选择\n\ngraph TD\n    A[行0] --&gt; B[尝试列0]\n    A --&gt; C[尝试列1]\n    A --&gt; D[尝试列2]\n    \n    B --&gt; E[行1: 列2合法]\n    B --&gt; F[行1: 列3合法]\n    \n    C --&gt; G[行1: ✗ 冲突]\n    \n    E --&gt; H[行2: 继续...]\n    F --&gt; I[行2: 继续...]\n    \n    style G fill:#FFB6C1\n    style H fill:#90EE90\n    style I fill:#90EE90\n\n解法一：基础回溯\n核心代码\nclass NQueens &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));        backtrack(board, 0, result);        return result;    &#125;    private:    void backtrack(vector&lt;string&gt;&amp; board, int row,                    vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;        int n = board.size();                // 终止条件：所有行都放置了皇后        if (row == n) &#123;            result.push_back(board);            return;        &#125;                // 在当前行的每一列尝试放置皇后        for (int col = 0; col &lt; n; ++col) &#123;            // 剪枝：检查是否合法            if (!isValid(board, row, col)) &#123;                continue;            &#125;                        // 做选择            board[row][col] = &#x27;Q&#x27;;                        // 递归            backtrack(board, row + 1, result);                        // 撤销选择            board[row][col] = &#x27;.&#x27;;        &#125;    &#125;        bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123;        int n = board.size();                // 检查列        for (int i = 0; i &lt; row; ++i) &#123;            if (board[i][col] == &#x27;Q&#x27;) return false;        &#125;                // 检查左上对角线        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;            if (board[i][j] == &#x27;Q&#x27;) return false;        &#125;                // 检查右上对角线        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123;            if (board[i][j] == &#x27;Q&#x27;) return false;        &#125;                return true;    &#125;&#125;;\n执行过程示例（4皇后）\n步骤1: row=0, col=0. . . .  →  Q . . .. . . .     . . . .. . . .     . . . .. . . .     . . . .步骤2: row=1, 尝试col=0 ✗ (同列)        row=1, 尝试col=1 ✗ (对角线)        row=1, 尝试col=2 ✓Q . . .. . Q .. . . .. . . .步骤3: row=2, 尝试col=0 ✗ (对角线)        row=2, 尝试col=1 ✗ (对角线)        row=2, 尝试col=2 ✗ (同列)        row=2, 尝试col=3 ✗ (对角线)        → 回溯到row=1，尝试col=3步骤4: row=1, col=3Q . . .. . . Q. . . .. . . .步骤5: row=2, col=1Q . . .. . . Q. Q . .. . . .步骤6: row=3, col=2 ✓Q . . .. . . Q. Q . .. . Q .  ← 找到第一个解！\n复杂度分析\n\n\n时间复杂度：O(n!)\n\n第1行有n种选择\n第2行最多n-1种（剪掉1列）\n…\n近似 n!\n\n\n\n空间复杂度：O(n²)\n\n递归深度 O(n)\n棋盘存储 O(n²)\n\n\n\n\n解法二：标记数组优化\n优化思路\n问题：基础解法中，isValid() 函数时间复杂度为 O(n)\n优化：使用三个标记数组，将合法性检查优化到 O(1)\n核心思想\nvector&lt;bool&gt; cols(n);          // cols[i] = true 表示第i列已占用vector&lt;bool&gt; diag1(2*n-1);     // 主对角线标记vector&lt;bool&gt; diag2(2*n-1);     // 副对角线标记\n索引计算\n对于位置 (row, col):- 列索引: col- 主对角线索引: row - col + n - 1- 副对角线索引: row + col\n代码实现\nvoid backtrackOptimized(vector&lt;string&gt;&amp; board, int row,                       vector&lt;bool&gt;&amp; cols,                       vector&lt;bool&gt;&amp; diag1,                       vector&lt;bool&gt;&amp; diag2,                       vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    int n = board.size();        if (row == n) &#123;        result.push_back(board);        return;    &#125;        for (int col = 0; col &lt; n; ++col) &#123;        int d1 = row - col + n - 1;  // 主对角线        int d2 = row + col;          // 副对角线                // O(1) 检查        if (cols[col] || diag1[d1] || diag2[d2]) &#123;            continue;        &#125;                // 做选择        board[row][col] = &#x27;Q&#x27;;        cols[col] = diag1[d1] = diag2[d2] = true;                // 递归        backtrackOptimized(board, row + 1, cols, diag1, diag2, result);                // 撤销选择        board[row][col] = &#x27;.&#x27;;        cols[col] = diag1[d1] = diag2[d2] = false;    &#125;&#125;\n对角线索引可视化\n4×4棋盘的对角线索引：主对角线 (row - col + 3):    副对角线 (row + col):┌─────────────────┐         ┌─────────────────┐│ 3 │ 2 │ 1 │ 0 │         │ 0 │ 1 │ 2 │ 3 │├─────────────────┤         ├─────────────────┤│ 4 │ 3 │ 2 │ 1 │         │ 1 │ 2 │ 3 │ 4 │├─────────────────┤         ├─────────────────┤│ 5 │ 4 │ 3 │ 2 │         │ 2 │ 3 │ 4 │ 5 │├─────────────────┤         ├─────────────────┤│ 6 │ 5 │ 4 │ 3 │         │ 3 │ 4 │ 5 │ 6 │└─────────────────┘         └─────────────────┘相同索引的格子在同一对角线上\n优势\n✅ 合法性检查从 O(n) 降到 O(1)\n✅ 整体性能提升 2-3倍\n✅ 代码更简洁清晰\n\n解法三：位运算优化\n核心思想\n使用整数的二进制位来表示状态，而不是数组：\n例如 8 皇后问题：cols = 0b00101000  表示第3列和第5列已占用       ││││││││       ││││││└─ 第0列       ││││└─── 第2列       │││└──── 第3列 ✓       ││└───── 第4列       │└────── 第5列 ✓       └─────── 第6列\n位运算技巧\n1. 获取可用位置\n// 假设：// cols  = 0b00101000  (列占用)// diag1 = 0b00010100  (主对角线占用)// diag2 = 0b01000010  (副对角线占用)int occupied = cols | diag1 | diag2;  // 所有占用位置// occupied = 0b01111110int available = ~occupied &amp; ((1 &lt;&lt; n) - 1);  // 可用位置// available = 0b10000001\n2. 提取最低位的1\nint position = available &amp; (-available);// 获取最右边的可用位置例如：available = 0b10100     -available = 0b01100  (补码)     position   = 0b00100  (只保留最低位)\n3. 清除最低位的1\navailable = available &amp; (available - 1);// 清除已处理的位置，继续处理下一个例如：available = 0b10100     available - 1 = 0b10011     新available = 0b10000\n完整实现\nvoid backtrackBitwise(int row, int cols, int diag1, int diag2,                      int n, vector&lt;int&gt;&amp; queens,                      vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;    if (row == n) &#123;        result.push_back(generateBoard(queens, n));        return;    &#125;        // 计算可用位置    int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));        while (available) &#123;        // 提取最低位        int position = available &amp; (-available);                // 清除最低位        available &amp;= (available - 1);                // 计算列号        int col = __builtin_ctz(position);  // Count Trailing Zeros        queens[row] = col;                // 递归        backtrackBitwise(row + 1,                        cols | position,        // 标记列                        (diag1 | position) &lt;&lt; 1, // 对角线左移                        (diag2 | position) &gt;&gt; 1, // 对角线右移                        n, queens, result);    &#125;&#125;\n关键点解析\n对角线的移位操作\n当前行: row下一行: row + 1主对角线: 向左移动1格 → 左移 &lt;&lt; 1副对角线: 向右移动1格 → 右移 &gt;&gt; 1示例（4皇后，第0行第1列）:row=0:    . Q . .          diag1 = 0b0010          diag2 = 0b0010row=1:    主对角线向左          . X Q .          diag1 = 0b0100                    副对角线向右          Q . X .          diag2 = 0b0001\ngraph LR\n    A[row 0] --&gt;|diag1 &lt;&lt; 1| B[row 1]\n    A --&gt;|diag2 &gt;&gt; 1| C[row 1]\n    \n    style A fill:#FFE4B5\n    style B fill:#87CEEB\n    style C fill:#90EE90\n优势\n✅ 速度最快（位运算是CPU原生操作）\n✅ 空间效率高（3个整数 vs 3个数组）\n✅ 适合高级优化\n❌ 代码可读性较低\n❌ 仅适用于 n ≤ 32（int大小限制）\n\n性能对比\n实测数据（8皇后）\n\n\n\n解法\n时间\n相对速度\n空间\n\n\n\n\n基础回溯\n1000 μs\n1.0x\nO(n²)\n\n\n标记数组优化\n350 μs\n2.9x\nO(n)\n\n\n位运算优化\n180 μs\n5.6x\nO(n)\n\n\n\n不同规模的解数量\n\n\n\nn\n解的数量\n基础回溯\n位运算\n\n\n\n\n4\n2\n&lt; 1 ms\n&lt; 1 ms\n\n\n8\n92\n10 ms\n2 ms\n\n\n10\n724\n120 ms\n18 ms\n\n\n12\n14,200\n2.5 s\n350 ms\n\n\n\n性能曲线\ngraph LR\n    A[n=4] --&gt;|基础| B[0.5ms]\n    A --&gt;|优化| C[0.2ms]\n    A --&gt;|位运算| D[0.1ms]\n    \n    E[n=8] --&gt;|基础| F[10ms]\n    E --&gt;|优化| G[3.5ms]\n    E --&gt;|位运算| H[1.8ms]\n    \n    I[n=12] --&gt;|基础| J[2.5s]\n    I --&gt;|优化| K[850ms]\n    I --&gt;|位运算| L[350ms]\n    \n    style D fill:#90EE90\n    style H fill:#90EE90\n    style L fill:#90EE90\n\nLeetCode实战\nLeetCode 51: N-Queens\n要求：返回所有不同的N皇后问题的解\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));        vector&lt;bool&gt; cols(n, false);        vector&lt;bool&gt; diag1(2 * n - 1, false);        vector&lt;bool&gt; diag2(2 * n - 1, false);                backtrack(board, 0, cols, diag1, diag2, result);        return result;    &#125;    private:    void backtrack(vector&lt;string&gt;&amp; board, int row,                   vector&lt;bool&gt;&amp; cols,                   vector&lt;bool&gt;&amp; diag1,                   vector&lt;bool&gt;&amp; diag2,                   vector&lt;vector&lt;string&gt;&gt;&amp; result) &#123;        int n = board.size();        if (row == n) &#123;            result.push_back(board);            return;        &#125;                for (int col = 0; col &lt; n; ++col) &#123;            int d1 = row - col + n - 1;            int d2 = row + col;                        if (cols[col] || diag1[d1] || diag2[d2]) continue;                        board[row][col] = &#x27;Q&#x27;;            cols[col] = diag1[d1] = diag2[d2] = true;                        backtrack(board, row + 1, cols, diag1, diag2, result);                        board[row][col] = &#x27;.&#x27;;            cols[col] = diag1[d1] = diag2[d2] = false;        &#125;    &#125;&#125;;\n提交结果：\n\n✅ 执行时间: 击败 95%\n✅ 内存消耗: 击败 90%\n\n\nLeetCode 52: N-Queens II\n要求：只返回解的数量\n优化：不需要存储棋盘，只计数\nclass Solution &#123;public:    int totalNQueens(int n) &#123;        return backtrack(0, 0, 0, 0, n);    &#125;    private:    int backtrack(int row, int cols, int diag1, int diag2, int n) &#123;        if (row == n) return 1;                int count = 0;        int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));                while (available) &#123;            int position = available &amp; (-available);            available &amp;= (available - 1);                        count += backtrack(row + 1,                             cols | position,                             (diag1 | position) &lt;&lt; 1,                             (diag2 | position) &gt;&gt; 1,                             n);        &#125;                return count;    &#125;&#125;;\n提交结果：\n\n✅ 执行时间: 击败 99%\n✅ 内存消耗: 击败 95%\n\n\n进阶技巧\n1. 对称性剪枝\n利用棋盘的对称性，只搜索一半的解：\nvoid backtrack(/* ... */) &#123;    if (row == 0) &#123;        // 第一行只搜索前半部分        for (int col = 0; col &lt; n / 2 + (n % 2); ++col) &#123;            // ...        &#125;    &#125; else &#123;        // 其他行正常搜索        for (int col = 0; col &lt; n; ++col) &#123;            // ...        &#125;    &#125;&#125;// 最后结果数量 *= 2（如果n为偶数）\n2. 记忆化搜索\n对于重复计算的子问题，可以缓存结果：\nunordered_map&lt;int, int&gt; memo;  // state -&gt; countint backtrack(int row, int cols, int diag1, int diag2, int n) &#123;    int state = (cols &lt;&lt; 20) | (diag1 &lt;&lt; 10) | diag2;        if (memo.count(state)) &#123;        return memo[state];    &#125;        // ... 正常回溯 ...        memo[state] = count;    return count;&#125;\n3. 启发式搜索\n优先选择约束最多的列（Most Constrained First）：\n// 选择可用列数最少的行优先搜索int countAvailable(int cols, int diag1, int diag2, int n) &#123;    int available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));    return __builtin_popcount(available);&#125;\n\n扩展问题\n变种1: 不同颜色的皇后\n有两种颜色的皇后，同色不能互相攻击：\nvoid backtrack(/* ... */, int color) &#123;    // 分别维护两套标记数组    // ...&#125;\n变种2: 矩形棋盘\nm×n 的矩形棋盘上放置皇后：\nvoid backtrack(int row, int m, int n) &#123;    if (row == min(m, n)) &#123;        // ...    &#125;&#125;\n变种3: 障碍物\n棋盘上有一些位置不能放置皇后：\nif (board[row][col] == &#x27;X&#x27;) &#123;  // 障碍物    continue;&#125;\n\n常见错误\n❌ 错误1: 忘记回溯\nboard[row][col] = &#x27;Q&#x27;;backtrack(board, row + 1, result);// 忘记撤销！\n✅ 正确：\nboard[row][col] = &#x27;Q&#x27;;backtrack(board, row + 1, result);board[row][col] = &#x27;.&#x27;;  // 撤销选择\n❌ 错误2: 对角线索引计算错误\nint d1 = row - col;  // 可能为负数！\n✅ 正确：\nint d1 = row - col + n - 1;  // 保证非负\n❌ 错误3: 位运算范围错误\nint available = ~(cols | diag1 | diag2);  // 包含高位的1\n✅ 正确：\nint available = ((1 &lt;&lt; n) - 1) &amp; (~(cols | diag1 | diag2));\n\n总结\n三种解法对比\n\n\n\n特性\n基础回溯\n标记数组\n位运算\n\n\n\n\n难度\n⭐⭐\n⭐⭐⭐\n⭐⭐⭐⭐\n\n\n速度\n慢\n中等\n最快\n\n\n空间\nO(n²)\nO(n)\nO(n)\n\n\n可读性\n高\n中\n低\n\n\n推荐场景\n学习理解\n面试推荐\n性能要求高\n\n\n\n核心思想\ngraph TD\n    A[N皇后问题] --&gt; B[逐行放置]\n    B --&gt; C[回溯框架]\n    C --&gt; D[合法性检查]\n    D --&gt; E[基础: O n 遍历]\n    D --&gt; F[优化: O 1 查表]\n    D --&gt; G[极致: 位运算]\n    \n    E --&gt; H[适合学习]\n    F --&gt; I[适合面试]\n    G --&gt; J[适合竞赛]\n    \n    style I fill:#90EE90\n关键要点\n✅ 逐行放置是关键思路\n✅ 对角线索引的计算要熟练\n✅ 回溯三步：做选择 → 递归 → 撤销\n✅ 位运算优化是进阶技巧\n\nN皇后问题是回溯算法的经典代表，从基础实现到极致优化，体现了算法设计中&quot;用空间换时间&quot;和&quot;巧用特性优化&quot;的核心思想。掌握这道题，你将对回溯算法有更深刻的理解！\n\n推荐练习：\n\nLeetCode 51 - N皇后\nLeetCode 52 - N皇后 II\nLeetCode 37 - 解数独（类似思想）\n\n","categories":["LeetCode"],"tags":["C++","LeetCode","位运算","回溯","N皇后","剪枝优化"]},{"title":"深入理解计算机系统知识点总结","url":"/posts/aac6e27d/","content":"深入理解计算机系统：从程序员视角看计算机\n\n基于经典教材 CSAPP 的系统知识全面总结\n\n引言\n《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective, CSAPP) 是一本从程序员视角审视计算机系统的经典教材。本书不仅仅教授理论知识，更强调理解计算机系统如何影响程序的正确性、性能和实用性。\n核心理念：\n\n程序员必须理解系统才能写出高效、可靠的代码\n硬件和软件的边界越来越模糊\n系统知识是成为优秀程序员的必备技能\n\n\n第一部分：程序结构和执行\n信息的表示和处理\n1. 信息存储\n计算机中的所有信息都以位 (bit) 的形式存储和处理。\n关键概念：\n字节 (Byte) = 8 位字 (Word) = 机器字长（32位或64位系统）地址空间：- 32位系统：2^32 = 4GB- 64位系统：2^64 = 16EB (理论上)\n字节序 (Endianness)：\n大端序 (Big Endian):    高位字节存储在低地址小端序 (Little Endian): 低位字节存储在低地址示例：整数 0x01234567地址:     0x100  0x101  0x102  0x103大端:      01     23     45     67小端:      67     45     23     01\ngraph LR\n    A[数据 0x01234567] --&gt; B&#123;字节序&#125;\n    B --&gt;|大端| C[01 23 45 67]\n    B --&gt;|小端| D[67 45 23 01]\n2. 整数表示\n无符号编码：\n范围: [0, 2^w - 1]示例 (8位): 0 ~ 255\n补码编码 (最常用的有符号数表示)：\n范围: [-2^(w-1), 2^(w-1) - 1]示例 (8位): -128 ~ 127补码规则：- 正数：与无符号数相同- 负数：按位取反加1-1 的补码 (8位): 11111111-128 的补码 (8位): 10000000\n关键陷阱：\n// 有符号数与无符号数混合运算int a = -1;unsigned int b = 1;if (a &lt; b) &#123;  // ❌ 永远为 false!    // a 会被转换为无符号数，变成很大的正数&#125;// 整数溢出int max = INT_MAX;int overflow = max + 1;  // 溢出，变成负数\n3. 浮点数表示\nIEEE 754 标准：\n单精度 (32位):[符号位 1位][指数 8位][尾数 23位]双精度 (64位):[符号位 1位][指数 11位][尾数 52位]值 = (-1)^s × M × 2^E\n特殊值：\n\n\n\n值\n指数\n尾数\n\n\n\n\n0\n全0\n全0\n\n\n∞\n全1\n全0\n\n\nNaN\n全1\n非0\n\n\n\n浮点数陷阱：\nfloat a = 0.1 + 0.2;if (a == 0.3) &#123;  // ❌ 可能为 false    // 浮点数精度问题&#125;// 正确做法if (fabs(a - 0.3) &lt; 1e-6) &#123;  // ✓    // 使用误差范围比较&#125;\n\n程序的机器级表示\n1. 汇编语言基础\nx86-64 寄存器：\n通用寄存器 (64位):%rax - 返回值%rbx - 被调用者保存%rcx - 第4个参数%rdx - 第3个参数%rsi - 第2个参数%rdi - 第1个参数%rbp - 帧指针%rsp - 栈指针%r8~%r15 - 额外寄存器\nAT&amp;T 语法 vs Intel 语法：\n; AT&amp;T 语法 (GCC 默认)movq $5, %rax          # 将立即数5移到raxmovq %rax, %rbx        # 源在前，目的在后; Intel 语法 (Windows 常用)mov rax, 5             ; 目的在前，源在后mov rbx, rax\n2. 函数调用约定\n栈帧结构：\n高地址+------------------+| 参数7            || 参数6            || 返回地址         |  &lt;- 调用者的栈帧+------------------+| 保存的%rbp       |  &lt;- %rbp 指向这里| 局部变量         || ...              |+------------------+  &lt;- %rsp 指向这里低地址\ngraph TD\n    A[调用者] --&gt; B[保存参数1-6到寄存器]\n    B --&gt; C[额外参数压栈]\n    C --&gt; D[call指令]\n    D --&gt; E[被调用者]\n    E --&gt; F[保存旧rbp]\n    F --&gt; G[分配栈帧]\n    G --&gt; H[执行函数]\n    H --&gt; I[恢复栈帧]\n    I --&gt; J[ret返回]\n参数传递规则：\n前6个参数: %rdi, %rsi, %rdx, %rcx, %r8, %r9第7+参数: 通过栈传递返回值: %rax (整数), %xmm0 (浮点数)\n3. 数组和结构体\n数组访问：\nint array[10];int *ptr = &amp;array[3];// 汇编实现// array[i] 的地址 = base + i * sizeof(element)leaq (%rdi,%rsi,4), %rax  # rax = rdi + rsi*4\n结构体对齐：\nstruct S1 &#123;    char c;     // 1字节    int i;      // 4字节，需要对齐    char d;     // 1字节&#125;;// 实际大小：12字节 (因为对齐)struct S2 &#123;    char c;     // 1字节    char d;     // 1字节    int i;      // 4字节&#125;;// 实际大小：8字节 (更好的排列)\n\n处理器体系结构\n1. 指令集架构 (ISA)\nCISC vs RISC：\n\n\n\n特性\nCISC (x86)\nRISC (ARM, RISC-V)\n\n\n\n\n指令复杂度\n复杂，功能强大\n简单，固定长度\n\n\n寻址模式\n多种\n较少\n\n\n寄存器数量\n较少\n较多\n\n\n示例\nx86, x86-64\nARM, MIPS, RISC-V\n\n\n\n2. 流水线 (Pipeline)\n5级流水线：\n1. 取指 (Fetch)2. 译码 (Decode)3. 执行 (Execute)4. 访存 (Memory)5. 写回 (Write-back)\ngraph LR\n    A[指令1] --&gt; B[取指]\n    B --&gt; C[译码]\n    C --&gt; D[执行]\n    D --&gt; E[访存]\n    E --&gt; F[写回]\n流水线冒险：\n\n结构冒险：硬件资源冲突\n数据冒险：指令间存在数据依赖\n控制冒险：分支指令导致的不确定性\n\n分支预测：\n// 代码示例for (int i = 0; i &lt; n; i++) &#123;    if (data[i] &gt;= 128) &#123;  // 分支点        sum += data[i];    &#125;&#125;// 对排序后的数据，分支预测器表现更好// 因为分支模式更规律\n\n优化程序性能\n1. 性能指标\nCPU 性能公式：\n程序执行时间 = 指令数 × CPI × 时钟周期CPI (Cycles Per Instruction): 每条指令的平均时钟周期数\n关键优化原则：\n\n减少指令数\n降低 CPI\n提高时钟频率\n\n2. 编译器优化\n优化级别：\ngcc -O0  # 无优化，便于调试gcc -O1  # 基本优化gcc -O2  # 推荐优化级别gcc -O3  # 激进优化\n常见优化技术：\n// 1. 循环展开// 优化前for (int i = 0; i &lt; n; i++) &#123;    sum += a[i];&#125;// 优化后（展开4次）for (int i = 0; i &lt; n; i += 4) &#123;    sum += a[i] + a[i+1] + a[i+2] + a[i+3];&#125;// 2. 消除冗余计算// 优化前for (int i = 0; i &lt; n; i++) &#123;    result[i] = sqrt(x) * array[i];  // sqrt(x) 重复计算&#125;// 优化后double temp = sqrt(x);for (int i = 0; i &lt; n; i++) &#123;    result[i] = temp * array[i];&#125;\n3. 内存性能优化\n局部性原理：\n// ❌ 差的局部性 - 按列访问for (int j = 0; j &lt; N; j++) &#123;    for (int i = 0; i &lt; N; i++) &#123;        sum += array[i][j];  // 跳跃访问    &#125;&#125;// ✓ 好的局部性 - 按行访问for (int i = 0; i &lt; N; i++) &#123;    for (int j = 0; j &lt; N; j++) &#123;        sum += array[i][j];  // 连续访问    &#125;&#125;\n\n第二部分：在系统上运行程序\n存储器层次结构\n1. 存储器层次\ngraph TD\n    A[CPU寄存器] --&gt; B[L1缓存]\n    B --&gt; C[L2缓存]\n    C --&gt; D[L3缓存]\n    D --&gt; E[主存DRAM]\n    E --&gt; F[本地磁盘]\n    F --&gt; G[远程存储]\n典型参数：\n\n\n\n层次\n容量\n访问时间\n价格\n\n\n\n\n寄存器\n&lt;1KB\n0.25ns\n最贵\n\n\nL1缓存\n32-64KB\n1ns\n很贵\n\n\nL2缓存\n256KB-1MB\n4ns\n贵\n\n\nL3缓存\n8-32MB\n10-20ns\n较贵\n\n\n主存\n4-16GB\n100ns\n适中\n\n\nSSD\n256GB-2TB\n100μs\n便宜\n\n\nHDD\n1-10TB\n10ms\n很便宜\n\n\n\n2. 缓存原理\n缓存映射方式：\n\n直接映射：每个内存块只能映射到一个缓存行\n全相联：内存块可以映射到任意缓存行\n组相联：折中方案，最常用\n\n缓存写策略：\n写命中:- 写直达 (Write-through): 同时写缓存和内存- 写回 (Write-back): 只写缓存，延迟写回内存写缺失:- 写分配 (Write-allocate): 加载到缓存再写- 非写分配 (Not-write-allocate): 直接写内存\n3. 缓存友好的代码\n// ❌ 缓存不友好 - 矩阵转置void transpose_bad(int src[N][N], int dst[N][N]) &#123;    for (int i = 0; i &lt; N; i++) &#123;        for (int j = 0; j &lt; N; j++) &#123;            dst[j][i] = src[i][j];  // dst 跳跃访问        &#125;    &#125;&#125;// ✓ 缓存友好 - 分块优化void transpose_good(int src[N][N], int dst[N][N]) &#123;    int B = 8;  // 块大小    for (int i = 0; i &lt; N; i += B) &#123;        for (int j = 0; j &lt; N; j += B) &#123;            for (int ii = i; ii &lt; i + B; ii++) &#123;                for (int jj = j; jj &lt; j + B; jj++) &#123;                    dst[jj][ii] = src[ii][jj];                &#125;            &#125;        &#125;    &#125;&#125;\n\n链接\n1. 链接过程\ngraph LR\n    A[源文件.c] --&gt; B[预处理]\n    B --&gt; C[编译]\n    C --&gt; D[汇编]\n    D --&gt; E[目标文件.o]\n    E --&gt; F[链接器]\n    G[库文件] --&gt; F\n    F --&gt; H[可执行文件]\n目标文件格式 (ELF)：\nELF Header+------------------+| .text   | 代码段  || .data   | 数据段  || .bss    | 未初始化 || .rodata | 只读数据 || .symtab | 符号表  |+------------------+\n2. 符号解析\n符号类型：\nint global_var = 42;           // 强符号，已初始化int global_uninit;             // 弱符号，未初始化static int local_var = 10;     // 本地符号extern int external_var;       // 外部引用\n链接规则：\n\n多个强符号：错误\n一个强符号，多个弱符号：选择强符号\n多个弱符号：任选一个（危险！）\n\n3. 静态库与动态库\n静态库 (.a)：\n# 创建静态库ar rcs libmylib.a file1.o file2.o# 链接静态库gcc main.c -L. -lmylib -o app\n动态库 (.so / .dll)：\n# 创建动态库gcc -shared -fPIC -o libmylib.so file1.c file2.c# 链接动态库gcc main.c -L. -lmylib -o app\n对比：\n\n\n\n特性\n静态库\n动态库\n\n\n\n\n链接时间\n编译时\n运行时\n\n\n文件大小\n大\n小\n\n\n更新\n需重编译\n只需替换库\n\n\n启动速度\n快\n慢\n\n\n\n\n异常控制流\n1. 异常分类\ngraph TD\n    A[异常] --&gt; B[中断]\n    A --&gt; C[陷阱]\n    A --&gt; D[故障]\n    A --&gt; E[终止]\n    \n    B --&gt; F[异步IO设备]\n    C --&gt; G[同步系统调用]\n    D --&gt; H[可恢复错误]\n    E --&gt; I[不可恢复错误]\n异常示例：\n中断: 键盘输入，网络数据包陷阱: 系统调用 (read, write, fork)故障: 缺页异常，除零错误终止: 硬件错误，非法指令\n2. 进程控制\n创建进程：\npid_t pid = fork();if (pid == 0) &#123;    // 子进程    printf(&quot;子进程 PID = %d\\n&quot;, getpid());    execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);    exit(0);&#125; else if (pid &gt; 0) &#123;    // 父进程    printf(&quot;父进程，子PID = %d\\n&quot;, pid);    int status;    waitpid(pid, &amp;status, 0);&#125;\n3. 信号\n常见信号：\n\n\n\n信号\n默认行为\n触发条件\n\n\n\n\nSIGINT\n终止\nCtrl+C\n\n\nSIGKILL\n终止\nkill -9\n\n\nSIGSEGV\n终止\n段错误\n\n\nSIGCHLD\n忽略\n子进程终止\n\n\n\n信号处理：\n#include &lt;signal.h&gt;void handler(int sig) &#123;    printf(&quot;捕获信号 %d\\n&quot;, sig);&#125;int main() &#123;    signal(SIGINT, handler);    while (1) &#123;        sleep(1);    &#125;    return 0;&#125;\n\n虚拟内存\n1. 虚拟地址空间\nLinux 进程地址空间：\n高地址+------------------+| 内核空间         |+------------------+| 栈 ↓            ||                  || ↑ 堆            |+------------------+| .bss 段         || .data 段        || .text 段        |+------------------+低地址\n2. 页表\n地址转换：\n虚拟地址 = [虚拟页号 VPN | 页内偏移]           ↓ 页表转换物理地址 = [物理页号 PPN | 页内偏移]页大小: 4KB (2^12)\n多级页表：\ngraph LR\n    A[虚拟地址] --&gt; B[一级页表]\n    B --&gt; C[二级页表]\n    C --&gt; D[三级页表]\n    D --&gt; E[物理页]\n3. 内存映射\nmmap 系统调用：\n#include &lt;sys/mman.h&gt;int fd = open(&quot;data.txt&quot;, O_RDONLY);void *ptr = mmap(NULL, file_size, PROT_READ,                  MAP_PRIVATE, fd, 0);// 使用映射的内存char ch = ((char*)ptr)[100];munmap(ptr, file_size);close(fd);\n\n第三部分：程序间的交互和通信\n系统级I/O\n1. Unix I/O 模型\n文件描述符：\n// 标准文件描述符0 - stdin1 - stdout2 - stderrint fd = open(&quot;file.txt&quot;, O_RDONLY);char buf[1024];ssize_t n = read(fd, buf, sizeof(buf));write(fd, &quot;hello&quot;, 5);close(fd);\n2. I/O 多路复用\nselect 示例：\nfd_set readfds;FD_ZERO(&amp;readfds);FD_SET(sockfd, &amp;readfds);struct timeval tv = &#123;5, 0&#125;;int ready = select(sockfd + 1, &amp;readfds, NULL, NULL, &amp;tv);if (ready &gt; 0 &amp;&amp; FD_ISSET(sockfd, &amp;readfds)) &#123;    // socket 有数据&#125;\n\n网络编程\n1. 套接字编程\nTCP 服务器：\n// 1. 创建socketint listenfd = socket(AF_INET, SOCK_STREAM, 0);// 2. 绑定struct sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_addr.s_addr = INADDR_ANY;addr.sin_port = htons(8080);bind(listenfd, (struct sockaddr*)&amp;addr, sizeof(addr));// 3. 监听listen(listenfd, 5);// 4. 接受连接int connfd = accept(listenfd, NULL, NULL);// 5. 读写char buf[1024];read(connfd, buf, sizeof(buf));write(connfd, &quot;Hello&quot;, 5);close(connfd);close(listenfd);\nTCP 三次握手：\nsequenceDiagram\n    participant C as 客户端\n    participant S as 服务器\n    \n    C-&gt;&gt;S: SYN\n    S-&gt;&gt;C: SYN+ACK\n    C-&gt;&gt;S: ACK\n    Note over C,S: 连接建立\n\n并发编程\n1. 线程\n创建线程：\n#include &lt;pthread.h&gt;void *thread_func(void *arg) &#123;    printf(&quot;线程运行中\\n&quot;);    return NULL;&#125;int main() &#123;    pthread_t tid;    pthread_create(&amp;tid, NULL, thread_func, NULL);    pthread_join(tid, NULL);    return 0;&#125;\n2. 同步机制\n互斥锁：\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;mutex);// 临界区counter++;pthread_mutex_unlock(&amp;mutex);\n信号量：\nsem_t sem;sem_init(&amp;sem, 0, 1);sem_wait(&amp;sem);  // P操作// 临界区sem_post(&amp;sem);  // V操作\n3. 经典问题\n生产者-消费者：\nsem_t empty, full;pthread_mutex_t mutex;void *producer(void *arg) &#123;    while (1) &#123;        sem_wait(&amp;empty);        pthread_mutex_lock(&amp;mutex);        // 生产        pthread_mutex_unlock(&amp;mutex);        sem_post(&amp;full);    &#125;&#125;void *consumer(void *arg) &#123;    while (1) &#123;        sem_wait(&amp;full);        pthread_mutex_lock(&amp;mutex);        // 消费        pthread_mutex_unlock(&amp;mutex);        sem_post(&amp;empty);    &#125;&#125;\n\n总结\n核心思想\n\n抽象层次：理解系统的多层抽象\n性能优化：缓存、局部性、并行性\n正确性保证：理解底层避免bug\n系统思维：程序在系统中运行\n\n","categories":["知识分享"],"tags":["性能优化","计算机系统","系统编程","操作系统","CSAPP"]},{"title":"现代C++","url":"/posts/c396c10e/","content":"现代C++核心特性详解：从类型推导到完美转发\n\n深入理解现代 C++ 的核心机制，掌握高性能编程的关键技术\n\n引言\n现代 C++（C++11/14/17/20）引入了许多强大的特性，其中类型推导、移动语义和完美转发是构建高性能应用的基石。本文将深入剖析这些核心概念，帮助你写出更高效、更安全的C++代码。\n\n第一部分：类型推导机制\n模板类型推导\n模板类型推导是理解现代 C++ 的第一步。对于模板函数：\ntemplate&lt;typename T&gt;void f(ParamType param);f(expr); // 编译器根据 expr 推导 T 和 ParamType\n推导规则分为三种情况：\n情况一：ParamType 是引用或指针\ntemplate&lt;typename T&gt;void f(T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   // T 是 int,       param 是 int&amp;f(cx);  // T 是 const int, param 是 const int&amp;f(rx);  // T 是 const int, param 是 const int&amp;\n关键点：const 被保留，引用性质在推导前被忽略。\n情况二：ParamType 是万能引用（T&amp;&amp;）\ntemplate&lt;typename T&gt;void f(T&amp;&amp; param);f(x);   // x 是左值  -&gt; T 是 int&amp;,       param 是 int&amp;f(27);  // 27 是右值 -&gt; T 是 int,        param 是 int&amp;&amp;\n这是完美转发的基础，也是最重要的推导规则。\n情况三：ParamType 是按值传参\ntemplate&lt;typename T&gt;void f(T param);f(x);   // T 是 intf(cx);  // T 是 int (const 被丢弃)f(rx);  // T 是 int (引用和 const 都被丢弃)\n特殊情况：指针的 const\nconst char* const ptr = &quot;Fun&quot;;f(ptr);// T 是 const char* (指针本身的 const 被丢弃，指向内容的 const 保留)\n推导规则对比表\n\n\n\nParamType 形式\n传入左值\n传入右值\nconst 属性\n适用场景\n\n\n\n\nT&amp;\n✓\n✗\n保留\n需要修改参数，或大对象只读\n\n\nT&amp;&amp;\n推导为 T&amp;\n推导为 T\n保留\n完美转发\n\n\nT\n拷贝\n移动/拷贝\n丢弃\n标量类型，或极小对象\n\n\n\n\nauto 类型推导\nauto 类型推导与模板推导机制99%相同，唯一例外是花括号初始化：\nauto x1 = 27;    // x1 是 intauto x2(27);     // x2 是 intauto x3 = &#123;27&#125;;  // ⚠️ x3 是 std::initializer_list&lt;int&gt;auto x4&#123;27&#125;;     // C++17: int, C++14: std::initializer_list&lt;int&gt;\n函数返回值的 auto\n当 auto 用于函数返回值时，使用的是模板推导规则：\nauto create_dims() &#123;    return &#123;1, 2, 3&#125;; // ❌ 编译错误！模板推导不支持 &#123;&#125;&#125;// 正确做法auto create_dims() &#123;    return std::vector&lt;int&gt;&#123;1, 2, 3&#125;; // ✓&#125;\n\ndecltype 详解\ndecltype 是&quot;诚实的复读机&quot;，它返回表达式的确切类型，不会丢弃引用和 const：\nconst int i = 0;auto a = i;            // a 是 int (const 被丢弃)decltype(i) d = i;     // d 是 const int (原样保留)\ndecltype(auto)：完美转发返回值\n这是 C++14 的杀手级特性：\ntemplate&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];&#125;std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;authAndAccess(vec, 0) = 100;  // 返回 int&amp;，可以修改auto val = authAndAccess(std::vector&lt;int&gt;&#123;1, 2, 3&#125;, 0);  // 返回 int，移动语义\ndecltype 的陷阱：括号的魔力\nint x = 10;decltype(x)   t1;   // t1 是 intdecltype((x)) t2;   // t2 是 int&amp; ⚠️ 危险！\n关键规则：\n\ndecltype(name) → 返回声明类型\ndecltype((name)) → 返回引用（因为 (name) 是左值表达式）\n\ngraph TD\n    A[decltype 推导] --&gt; B&#123;是名字还是表达式?&#125;\n    B --&gt;|名字| C[返回声明类型]\n    B --&gt;|表达式| D&#123;是否为左值?&#125;\n    D --&gt;|是| E[返回引用类型]\n    D --&gt;|否| F[返回值类型]\n\n查看类型推导结果\n方法一：编译器报错（最推荐）\ntemplate&lt;typename T&gt;class TD;  // 只声明，不定义int x = 10;auto y = x;TD&lt;decltype(y)&gt; debug;  // 编译错误会显示：TD&lt;int&gt;\n方法二：运行时 typeid（有坑）\n#include &lt;typeinfo&gt;std::cout &lt;&lt; typeid(y).name() &lt;&lt; std::endl;\n缺陷：会忽略引用和 const！\n方法三：IDE 提示（快但不一定准）\n鼠标悬停在 auto 上查看类型，对简单类型有效。\n\n第二部分：引用与移动语义\n万能引用 vs 右值引用\n判断规则：\n// 有类型推导 → 万能引用template&lt;typename T&gt; void f(T&amp;&amp; param);  // 万能引用auto&amp;&amp; var = value;                       // 万能引用// 无类型推导 → 右值引用void f(int&amp;&amp; param);                      // 右值引用\n万能引用示例\ntemplate&lt;typename T&gt;void process(T&amp;&amp; param) &#123;    // param 可以绑定左值或右值&#125;int x = 10;process(x);   // T 推导为 int&amp;，  param 是 int&amp;process(10);  // T 推导为 int，   param 是 int&amp;&amp;graph LR    A[T&amp;&amp;] --&gt; B&#123;有类型推导?&#125;    B --&gt;|是| C[万能引用]    B --&gt;|否| D[右值引用]        C --&gt; E[可以绑定左值]    C --&gt; F[可以绑定右值]        D --&gt; G[只能绑定右值]\n\nstd::move 和 std::forward\nstd::move：无条件转为右值\nstd::string str1 = &quot;Hello&quot;;std::string str2 = std::move(str1);  // str1 被清空\n本质：std::move 不移动任何东西，只是类型转换：\ntemplate&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) &#123;    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(param);&#125;\nstd::forward：有条件地保持值类别\ntemplate&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg));  // 保持左值/右值属性&#125;\n为什么需要 forward？\n// 不使用 forwardtemplate&lt;typename Container, typename Index&gt;decltype(auto) badAccess(Container&amp;&amp; c, Index i) &#123;    return c[i];  // 总是返回左值引用！&#125;// 使用 forwardtemplate&lt;typename Container, typename Index&gt;decltype(auto) goodAccess(Container&amp;&amp; c, Index i) &#123;    return std::forward&lt;Container&gt;(c)[i];    // 左值容器 → 返回左值引用    // 右值容器 → 返回右值引用（可移动）&#125;\n对比总结\n\n\n\n特性\nstd::move\nstd::forward\n\n\n\n\n目的\n无条件转为右值\n有条件保持值类别\n\n\n使用场景\n确定要移动对象\n完美转发模板参数\n\n\n返回值\n总是右值引用\n可能是左值或右值引用\n\n\n\n\n左值与右值的本质\n核心规则\n有名字的右值引用是左值：\nvoid process(Resource&amp;&amp; rref) &#123;    // rref 是右值引用类型，但 rref 本身是左值    Resource r1 = rref;              // ❌ 调用拷贝构造    Resource r2 = std::move(rref);   // ✓ 调用移动构造&#125;\n移动构造函数中的 std::move\nclass Resource &#123;    std::vector&lt;int&gt; data;public:    Resource(Resource&amp;&amp; other) noexcept        : data(std::move(other.data)) &#123;  // 必须使用 std::move        // other.data 是左值，需要转为右值才能触发移动    &#125;&#125;;\n类型分析：\n\n\n\n表达式\n类型\n值类别\n需要 move？\n\n\n\n\nother\nResource&amp;&amp;\n左值\n是\n\n\nother.data\nstd::vector&lt;int&gt;&amp;\n左值\n是\n\n\nstd::move(other)\nResource&amp;&amp;\n右值\n-\n\n\n\ngraph TD\n    A[右值引用参数] --&gt; B[有名字的变量]\n    B --&gt; C[是左值]\n    C --&gt; D[访问成员]\n    D --&gt; E[成员也是左值]\n    E --&gt; F&#123;要移动吗?&#125;\n    F --&gt;|是| G[使用 std::move]\n    F --&gt;|否| H[直接使用 - 拷贝]\n\n第三部分：auto 的最佳实践\n优先使用 auto 的理由\n1. 避免隐形的类型转换\nstd::unordered_map&lt;std::string, int&gt; map;// ❌ 错误：每次循环都拷贝！for (const std::pair&lt;std::string, int&gt;&amp; p : map) &#123;    // map 的元素类型是 std::pair&lt;const std::string, int&gt;    // 类型不匹配，发生拷贝构造&#125;// ✓ 正确：零拷贝for (const auto&amp; p : map) &#123;    // 编译器推导为 std::pair&lt;const std::string, int&gt;&amp;&#125;\n2. 强制初始化\nint x;       // 未初始化，可能是垃圾值auto x;      // ❌ 编译错误auto x = 0;  // ✓ 必须初始化\n3. 可移植性\nstd::vector&lt;int&gt; v;unsigned sz = v.size();  // ⚠️ 32位系统可能溢出auto sz = v.size();      // ✓ 总是正确\n\nstd::function vs auto\n性能对比\n// std::function：类型擦除，有开销std::function&lt;int(int)&gt; func = [](int x) &#123; return x * x; &#125;;// auto：零开销，可内联auto lambda = [](int x) &#123; return x * x; &#125;;\n性能差异：\n\n\n\n特性\nstd::function\nauto\n\n\n\n\n大小\n固定（24-64字节）\n等于实际对象\n\n\n调用开销\n间接调用\n直接调用，可内联\n\n\n内存分配\n可能堆分配\n无额外分配\n\n\n性能\n慢 2-5 倍\n最优\n\n\n\n使用场景\n使用 std::function：\n\n需要存储不同类型的可调用对象\n运行时替换回调\n公共 API 接口\n\n使用 auto：\n\n局部变量\n性能关键代码\n模板函数参数\n\ngraph TD\n    A[需要存储可调用对象?] --&gt; B&#123;类型统一?&#125;\n    B --&gt;|否| C[std::function]\n    B --&gt;|是| D&#123;性能关键?&#125;\n    D --&gt;|是| E[auto/模板]\n    D --&gt;|否| F[两者皆可]\n    \n    C --&gt; G[容器存储]\n    C --&gt; H[回调系统]\n    \n    E --&gt; I[局部使用]\n    E --&gt; J[可内联]\n\n类型擦除与闭包\n类型擦除\n将不同类型的对象放入统一接口：\n// 不同的类型auto lambda1 = [](int x) &#123; return x * 2; &#125;;auto lambda2 = [](int x) &#123; return x + 5; &#125;;// 统一的&quot;盒子&quot;（类型擦除）std::function&lt;int(int)&gt; box;box = lambda1;  // ✓box = lambda2;  // ✓\n实现原理（简化版）：\ntemplate&lt;typename R, typename... Args&gt;class function&lt;R(Args...)&gt; &#123;    struct CallableBase &#123;        virtual R call(Args...) = 0;        virtual ~CallableBase() = default;    &#125;;    template&lt;typename F&gt;    struct CallableImpl : CallableBase &#123;        F f;        R call(Args... args) override &#123; return f(args...); &#125;    &#125;;    CallableBase* callable;  // 多态&#125;;\n闭包\n闭包 = 函数 + 环境\nauto makeCounter() &#123;    int count = 0;    return [count]() mutable &#123;        return ++count;    &#125;;&#125;auto counter1 = makeCounter();auto counter2 = makeCounter();counter1();  // 1counter1();  // 2counter2();  // 1 (独立环境)\n编译器生成的等价类：\nclass __Closure &#123;    int count;  // 捕获的变量public:    __Closure(int c) : count(c) &#123;&#125;    int operator()() &#123; return ++count; &#125;&#125;;\n捕获方式：\nint a = 1, b = 2;[a, b]()      // 值捕获[&amp;a, &amp;b]()    // 引用捕获[=]()         // 全部值捕获[&amp;]()         // 全部引用捕获[=, &amp;a]()     // a 引用，其他值捕获[value = a + b]()  // 初始化捕获（C++14）\n\n总结\n核心要点\n\n模板推导：理解三种情况（引用、万能引用、按值），万能引用是完美转发的基础\nauto vs decltype：auto 会去引用，decltype 保留原样\nstd::move vs std::forward：move 无条件转右值，forward 条件保持值类别\n优先使用 auto：避免拷贝、强制初始化、更好的可移植性\nstd::function vs auto：性能关键用 auto，需要类型擦除用 std::function\n\n记忆口诀\n// 万能引用：T&amp;&amp;template&lt;typename T&gt; void f(T&amp;&amp; param);  // 左值右值都能绑定// 使用规则void process(Widget&amp;&amp; w) &#123;    use(std::move(w));  // 右值引用 → move&#125;template&lt;typename T&gt;void relay(T&amp;&amp; param) &#123;    other(std::forward&lt;T&gt;(param));  // 万能引用 → forward&#125;\n最佳实践\n// ✓ 推荐for (const auto&amp; item : container) &#123; &#125;      // 避免拷贝auto lambda = [](int x) &#123; return x * 2; &#125;;  // 性能最优decltype(auto) f() &#123; return expr; &#125;         // 完美转发返回值// ✗ 避免for (const Type&amp; item : container) &#123; &#125;      // 可能类型不匹配std::function&lt;int(int)&gt; f = [...];          // 非必要的开销auto x = &#123;1, 2, 3&#125;;                         // 意外的 initializer_list\n\n参考资源\n\n《Effective Modern C++》- Scott Meyers\nC++ Reference\nCppCon Talks\n\n","categories":["知识分享"],"tags":["C++","现代C++","性能优化","类型推导","移动语义","完美转发"]}]