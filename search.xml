<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python实战之Web开发-续</title>
    <url>/posts/71a5f1f6.html</url>
    <content><![CDATA[用户账户
用户添加主题
在learning_log目录中创建forms.py文件，添加
from django import formsfrom .models import Topicclass TopicForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating topics.&quot;&quot;&quot;    class Meta:        model = Topic        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field
添加URL：path('new_topic/', views.new_topic, name='new_topic')
创建视图函数new_topic
def new_topic(request):    &quot;&quot;&quot;Add a new topic.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = TopicForm()    else:        # POST data submitted; process data.        form = TopicForm(data=request.POST)        if form.is_valid():            new_topic = form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=new_topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_topic.html&#x27;, context)
创建模板new_topic.html
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Add a new topic:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;
链接到页面：&lt;a href = &quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt;
代码解释：当用户在网页中点击 &lt;a href=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot;&gt;Add a new topic&lt;/a&gt; 这个链接时，浏览器会跳转到 /new_topic/。这个路径在 urls.py 中由 path('new_topic/', views.new_topic, name='new_topic') 映射到 views.new_topic 函数。
当请求被送到这个视图函数时，Django 会调用 new_topic(request) 来处理。这个视图首先判断请求的方法是不是 POST。如果用户只是点击链接，还没提交表单，那么请求方法是 GET，程序会创建一个空的表单对象 form = TopicForm()，此时这个表单中没有预填数据，只是用于初次显示在网页上。
如果用户已经在表单中输入了内容并点击了提交按钮，那么浏览器发送的是 POST 请求，此时视图就会执行 form = TopicForm(data=request.POST) 来从用户提交的数据构造一个表单实例。接着通过 form.is_valid() 检查数据是否合法（比如字段有没有漏填，格式是否正确）。如果验证通过，就执行 form.save()，这会自动创建一条新的 Topic 记录并保存到数据库中。接着用 redirect('learning_log:topic', topic_id=new_topic.id) 跳转到刚创建的主题详情页。
不论是初次打开页面，还是提交失败（例如空表单或非法输入），视图最后都会调用 render(request, 'learning_log/new_topic.html', context) 来渲染模板，把表单对象传入 context 变量中。
这个模板 new_topic.html 继承自 base.html，并在 &#123;% block content %&#125; 中放入了一段 HTML 表单。&lt;form action=&quot;&#123;% url 'learning_log:new_topic' %&#125;&quot; method=&quot;post&quot;&gt; 声明了该表单提交回自己；&#123;% csrf_token %&#125; 是 Django 要求添加的防跨站攻击标记；&#123;&#123; form.as_div &#125;&#125; 是将表单对象渲染为 HTML 元素。最后 &lt;button type=&quot;submit&quot;&gt;Add Topic&lt;/button&gt; 是提交按钮。
添加条目
代码如下
# 新建formclass EntryForm(forms.ModelForm):    &quot;&quot;&quot;A form for creating and updating entries.&quot;&quot;&quot;    class Meta:        model = Entry        fields = [&#x27;text&#x27;]        labels = &#123;&#x27;text&#x27;: &#x27;&#x27;&#125;  # No label for the text field        widgets = &#123;&#x27;text&#x27;: forms.Textarea(attrs=&#123;&#x27;cols&#x27;: 80&#125;)&#125;  # Wider text area        # 添加URLpath(&#x27;new_entry/&lt;int:topic_id&gt;/&#x27;, views.new_entry, name=&#x27;new_entry&#x27;)# 添加视图def new_entry(request, topic_id):    &quot;&quot;&quot;Add a new entry for a particular topic.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    if request.method != &#x27;POST&#x27;:        # No data submitted; create a blank form.        form = EntryForm()    else:        # POST data submitted; process data.        form = EntryForm(data=request.POST)        if form.is_valid():            new_entry = form.save(commit=False)            new_entry.topic = topic            new_entry.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic_id)    # Display a blank or invalid form.    context = &#123;&#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/new_entry.html&#x27;, context)
&#123;# 新建模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Add a new entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Add Entry&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add a new entry&lt;/a&gt;    &lt;/p&gt;
代码解释：这一套代码实现了在某个具体主题（Topic）下添加新学习内容（Entry）的功能。它包括一个基于模型的表单 EntryForm，用于生成输入框，主要针对 Entry 模型中的 text 字段，并通过 widgets 设置了一个宽一些的多行文本区域。URL 配置中使用了路径参数 &lt;int:topic_id&gt; 来标识具体主题，这样不同主题就能通过不同链接添加各自的学习记录。视图函数 new_entry 首先获取对应的 Topic 实例，然后根据请求方法判断是初次访问还是表单提交。如果是提交请求，就根据提交内容构造表单并校验，若通过验证，就先创建一个未保存的 Entry 实例，手动指定其 topic 属性，然后保存到数据库，并跳转回该主题的详情页。
模板部分继承自基础模板 base.html，显示了当前主题的名称，并提供一个表单用于输入新条目。提交按钮下方还包含一个返回原主题页面的链接。最后那段 HTML 链接代码负责在主题详情页中显示“Add a new entry”按钮，点击即可跳转到添加页面。

编辑条目
代码如下
# 添加URLpath(&#x27;edit_entry/&lt;int:entry_id&gt;/&#x27;, views.edit_entry, name=&#x27;edit_entry&#x27;)# 添加edit_entry函数def edit_entry(request, entry_id):    &quot;&quot;&quot;Edit an existing entry.&quot;&quot;&quot;    entry = Entry.objects.get(id=entry_id)    topic = entry.topic    if request.method != &#x27;POST&#x27;:        # Initial request; pre-fill form with the current entry.        form = EntryForm(instance=entry)    else:        # POST data submitted; process data.        form = EntryForm(instance=entry, data=request.POST)        if form.is_valid():            form.save()            return redirect(&#x27;learning_log:topic&#x27;, topic_id=topic.id)    # Display a blank or invalid form.    context = &#123;&#x27;entry&#x27;: entry, &#x27;topic&#x27;: topic, &#x27;form&#x27;: form&#125;    return render(request, &#x27;learning_log/edit_entry.html&#x27;, context)
&#123;# 添加html #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/p&gt;    &lt;p&gt;Edit entry:&lt;/p&gt;    &lt;form action=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot; method=&quot;post&quot;&gt;        &#123;% csrf_token %&#125;        &#123;&#123; form.as_div &#125;&#125;        &lt;button type=&quot;submit&quot;&gt;Save Changes&lt;/button&gt;    &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接 #&#125;&lt;li&gt;    &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;    &lt;p&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;Edit entry&lt;/a&gt;    &lt;/p&gt;&lt;/li&gt;
创建用户
首先创建一个新的应用程序来管理账户相关的内容
python .\manage.py startapp accounts
在INSTALLED_APPS中添加accounts，并包含accounts的URL：path('accounts/', include('accounts.urls'))
在accounts中新建urls.py，添加以下内容
from django.urls import path, includeapp_name = &#x27;accounts&#x27;urlpatterns = [    # Include the default auth URLs    path(&#x27;&#x27;, include(&#x27;django.contrib.auth.urls&#x27;)),]
在templates中新建registration文件夹，添加login.html文件
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;  &#123;% if form.errors %&#125;    &lt;p&gt;Your username and password didn&#x27;t match. Please try again.&lt;/p&gt;  &#123;% endif %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Log in&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;
随后在settings中添加成功登录后的重定向地址：LOGIN_REDIRECT_URL = 'learning_log:index'
修改base.html如下
&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt; -    &lt;a href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;Topics&lt;/a&gt; -     &#123;% if user.is_authenticated %&#125;        Hello, &#123;&#123; user.username &#125;&#125;! -        &#123;% else %&#125;        &lt;a href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;Log in&lt;/a&gt; -        &#123;% endif %&#125;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;
此时就可以通过http://localhost:8000/accounts/login/来登录了，可以使用我们的管理员账号来测试（提前在管理界面退出）

注销和注册用户
注销账户
在base.html中添加注销表单
&#123;% if user.is_authenticated %&#125;  &lt;hr /&gt;  &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &lt;button name=&#x27;submit&#x27;&gt;Log out&lt;/button&gt;  &lt;/form&gt;&#123;% endif %&#125;
如果账户登录，那么则在最下方显示一个注销按钮用于注销账户，注销后将页面链接到主页：LOGOUT_REDIRECT_URL = 'learning_log:index'
注册账户
# 添加URLpath(&#x27;register/&#x27;, views.register, name=&#x27;register&#x27;)# 创建视图函数def register(request):    &quot;&quot;&quot;Register a new user.&quot;&quot;&quot;    if request.method != &#x27;POST&#x27;:        # Display blank registration form.        form = UserCreationForm()    else:        # Process completed form.        form = UserCreationForm(data=request.POST)        if form.is_valid():            new_user = form.save()            # Log the user in and then redirect to home page.            login(request, new_user)            return redirect(&#x27;learning_log:index&#x27;)    # Display a blank or invalid form.    context = &#123;&#x27;form&#x27;: form&#125;    return render(request, &#x27;registration/register.html&#x27;, context)
&#123;# 创建模板 #&#125;&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;&#123; form.as_div &#125;&#125;    &lt;button name=&quot;submit&quot;&gt;Register&lt;/button&gt;  &lt;/form&gt;&#123;% endblock content %&#125;&#123;# 链接注册界面 #&#125;&lt;a href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register&lt;/a&gt; -
当用户登录后，base.html 会显示一个“注销”按钮，它触发的是 accounts:logout 路由（即 Django 默认的登出视图），并通过 LOGOUT_REDIRECT_URL = 'learning_log:index' 设置注销后跳转回主页。
对于注册功能，定义了一个新的 URL 路由 /accounts/register/，并在对应视图函数 register() 中使用 Django 提供的 UserCreationForm 构建注册表单。如果请求为 POST，则处理表单提交并保存用户数据，注册成功后自动登录该用户，并重定向到主页。否则显示一个空白或验证失败的注册表单。
前端模板继承自 base.html，通过 &#123;% csrf_token %&#125; 加入安全标记，表单本体使用 &#123;&#123; form.as_div &#125;&#125; 渲染输入字段，点击“Register”按钮即可提交注册。
创建用户数据
在未登录的状态下，learning_log中的内容除了主页外，其余内容应该均不可访问，对此我们通过装饰器@login_required来限制未登录用户的访问，如果用户未登录，我们将其重定向到登录界面，在settings中添加LOGIN_URL = 'accounts:login'即可
对于不同的用户，除了主页外，其他的内容应该只能访问自己的部分，我们将数据关联到用户，在Topic中添加owner = models.ForeignKey(User, on_delete=models.CASCADE)，将主题与用户关联。然后把数据库中的内容进行迁移，由于我们新增了owner字段，迁移时会提示我们选择哪一种方式，我们选择“1”让系统自动给我们添加一个默认值，然后将所有的内容迁移到管理账户中，即ID“1”

虽然把主题全部与管理账户进行了关联，但是目前任何用户登录均可访问所有主题，在topics中添加topics = Topic.objects.filter(owner=request.user).order_by('date_added')，将不属于当前用户的所有Topic过滤掉，然后在topic和edit_entry中添加以下代码
if topic.owner != request.user:    raise Http404
从而防止用户通过网址直接访问他人的数据
最后将新的topic关联到当前用户中，添加代码如下
new_topic = form.save(commit=False)new_topic.owner = request.usernew_topic.save()
此时任何用户都可创建自己的账号并拥有自己独立的数据了
样式更改
我们的web已经具备基本的功能了，如创建主题、创建与之关联的条目，并且每个用户都有自己的数据而不必担心被其他人访问，但我们的界面还过于简陋，无法吸引用户，因此接下来我们将更改它的布局，使其更加美观
首先安装django-bootstrap5，我们将使用其中的模板
pip install django-bootstrap5
然后在INSTALLED_APPS中我们的应用和默认应用之间添加django_bootstrap5，接下来修改base.html
&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Learning Log&lt;/title&gt;  &#123;% load django_bootstrap5 %&#125;  &#123;% bootstrap_css %&#125;  &#123;% bootstrap_javascript %&#125;&lt;/head&gt;&lt;body&gt;  &lt;nav class=&quot;navbar navbar-expand-md navbar-light bg-light mb-4 border&quot;&gt;    &lt;div class=&quot;container-fluid&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;          Learning Log&lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot;        data-bs-target=&quot;#navbarCollapse&quot; aria-controls=&quot;navbarCollapse&quot;        aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarCollapse&quot;&gt;        &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-md-0&quot;&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;&gt;              Topics&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt; &lt;!-- End of links on left side of navbar --&gt;        &lt;!-- Account-related links --&gt;        &lt;ul class=&quot;navbar-nav ms-auto mb-2 mb-md-0&quot;&gt;          &#123;% if user.is_authenticated %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;span class=&quot;navbar-text me-2&quot;&gt;Hello, &#123;&#123; user.username &#125;&#125;.                &lt;/span&gt;&lt;/li&gt;          &#123;% else %&#125;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;                  Register&lt;/a&gt;&lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;              &lt;a class=&quot;nav-link&quot; href=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;&gt;                  Log in&lt;/a&gt;&lt;/li&gt;          &#123;% endif %&#125;        &lt;/ul&gt; &lt;!-- End of account-related links --&gt;        &#123;% if user.is_authenticated %&#125;          &lt;form action=&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;            &#123;% csrf_token %&#125;            &lt;button name=&#x27;submit&#x27; class=&#x27;btn btn-outline-secondary btn-sm&#x27;&gt;              Log out&lt;/button&gt;          &lt;/form&gt;        &#123;% endif %&#125;      &lt;/div&gt; &lt;!-- Closes collapsible parts of navbar --&gt;    &lt;/div&gt; &lt;!-- Closes navbar&#x27;s container --&gt;  &lt;/nav&gt; &lt;!-- End of navbar --&gt;  &lt;main class=&quot;container&quot;&gt;    &lt;div class=&quot;pb-2 mb-2 border-bottom&quot;&gt;      &#123;% block page_header %&#125;&#123;% endblock page_header %&#125;    &lt;/div&gt;    &lt;div&gt;      &#123;% block content %&#125;&#123;% endblock content %&#125;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;&lt;/html&gt;
修改主页index.html的样式
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;div class=&quot;p-3 mb-4 bg-light border rounded-3&quot;&gt;    &lt;div class=&quot;container-fluid py-4&quot;&gt;      &lt;h1 class=&quot;display-3&quot;&gt;Track your learning.&lt;/h1&gt;            &lt;p class=&quot;lead&quot;&gt;Make your own Learning Log, and keep a list of the      topics you&#x27;re learning about. Whenever you learn something new      about a topic, make an entry summarizing what you&#x27;ve learned.&lt;/p&gt;      &lt;a class=&quot;btn btn-primary btn-lg mt-1&quot;          href=&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;&gt;Register &amp;raquo;&lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;&#123;% endblock page_header %&#125;
修改登录界面login.html的样式
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% load django_bootstrap5 %&#125;&#123;% block page_header %&#125;  &lt;h2&gt;Log in to your account.&lt;/h2&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;form action=&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot; method=&#x27;post&#x27;&gt;    &#123;% csrf_token %&#125;    &#123;% bootstrap_form form %&#125;    &#123;% bootstrap_button button_type=&quot;submit&quot; content=&quot;Log in&quot; %&#125;  &lt;/form&gt;&#123;% endblock content %&#125;
修改页面topics的样式
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;Topics&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;ul class=&quot;list-group border-bottom pb-2 mb-4&quot;&gt;    &#123;% for topic in topics %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;          &#123;&#123; topic.text &#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &#123;% empty %&#125;      &lt;li class=&quot;list-group-item border-0&quot;&gt;No topics have been added yet.&lt;/li&gt;    &#123;% endfor %&#125;  &lt;/ul&gt;  &lt;a href=&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;&gt;Add a new topic&lt;/a&gt;&#123;% endblock content %&#125;
修改页面topic条目的样式
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block page_header %&#125;  &lt;h1&gt;&#123;&#123; topic.text &#125;&#125;&lt;/h1&gt;&#123;% endblock page_header %&#125;&#123;% block content %&#125;  &lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;&gt;Add new entry&lt;/a&gt;  &lt;/p&gt;  &#123;% for entry in entries %&#125;    &lt;div class=&quot;card mb-3&quot;&gt;      &lt;!-- Card header with timestamp and edit link --&gt;      &lt;h4 class=&quot;card-header&quot;&gt;        &#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;        &lt;small&gt;&lt;a href=&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;&gt;          edit entry&lt;/a&gt;&lt;/small&gt;      &lt;/h4&gt;      &lt;!-- Card body with entry text --&gt;      &lt;div class=&quot;card-body&quot;&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &#123;% empty %&#125;    &lt;p&gt;There are no entries for this topic yet.&lt;/p&gt;  &#123;% endfor %&#125;&#123;% endblock content %&#125;
修改后的界面如下

项目部署
这部分内容主要就是把项目部署到远程服务器上，让其他人访问，全是配置，没啥意思，不搞了
]]></content>
      <categories>
        <category>Diango开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实战之外星人入侵《一》</title>
    <url>/posts/25297ba4.html</url>
    <content><![CDATA[武装飞船由于不经常用Python写程序，最近在用Python写一个可视化工具时，惊觉发现自己的Python水平严重下滑，因此又重新拿起了《Python编程-从入门到实践》这本书。
经过简单的复习，觉得还是有必要把书中的项目给练习一遍，同时也通过Blog记录一下我的实现过程，该篇文章以及后续系列将会讲解这本书中的“外星人入侵”项目，经过第十二、十三、十四章的阅读，我觉得在开始编程之前有必要先分析一下要实现的功能以及项目的整体架构，姑且就按照书上的顺序来吧。
这里我们需要四个类，分别是主程序类AlienInvasion、子弹类Bullet、设置类Settings、飞船类Ship，主程序类主要用于初始化游戏界面，然后通过循环来更新游戏，子弹类和飞船类主要用于自身属性的初始化、显示和更新位置，设置类主要包含游戏的界面大小、飞船和子弹的移动速度等。整体结构大致如下

游戏入口我的IDE是Pycharm，首先创建一个名为 Alien-Invasion-Project 并初始化了git仓库的项目，后续的所有开发代码都将放到我的Gitghub Alien-Invasion-Project 同名仓库中，有兴趣可以访问查看。这里我们首先安装开发需要用到的模块pygame，使用命令pip instal pygame即可，如下

提示“Successfully ……”表明安装成功，也可使用书中的命令python -m pip install --user pygame来安装
初步实现界面先创建一个alien_invasion.py文件，用来实现界面的初始化，然后创建AlienInvasion类，添加如下代码
import  pygameclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.screen = pygame.display.set_mode((800, 600))        pygame.display.set_caption(&quot;外星人来喽&quot;)    def run_game(self):        # 游戏主循环        while True:            passif __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()

这里我们通过pygame.init()来实现游戏环境的初始化，然后设置了一个800*600的游戏界面，再通过pygame.display.set_caption(&quot;外星人来喽&quot;)来设置游戏界面的Title，同时我们定义一个run_game函数用来进入游戏，这里添加了一个while的死循环，通过pass占位符来保持界面的显示，并在main里面完成游戏类的实例化和进入游戏中的循环，运行程序，如下图

大致就是一个黑框框，里面什么都没有，由于我们只初始化了游戏界面的大小和标题，因此不会有其他的内容，同时各位应该也能注意到运行之后电脑很卡，这是因为我们在程序中添加了一个死循环，下面我们来对程序进行优化
优化界面我们在其中添加事件处理程序来监听事件，首先导入系统模块sys，然后删除pass，在循环中添加如下代码
for event in pygame.event.get():    if event.type == pygame.QUIT:        pygame.quit()        sys.exit()

这段程序表明我们一直在监听事件，如果有退出的事件发生，我们将调用pygame和系统的退出函数来结束游戏的运行，这时候运行代码，就不会卡了，同时点击X号也能正常退出
下一步我们对游戏界面填充背景色，同时控制游戏的刷新的帧率
添加成员变量bg_color，并在while循环中通过screen.fill()来绘制屏幕，然后使用pygame.display.flip()来使屏幕显示出来，运行结果如下

帧率的控制主要通过限制循环中屏幕刷新的时间来实现，添加成员变量clock来定义时钟，然后在循环的末尾启动计时，我们这里设个90帧，代码如下
class AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.clock = pygame.time.Clock()        ……    def run_game(self):        # 游戏主循环        while True:            ……            # 控制游戏帧率            self.clock.tick(90)

封装Settings类为了方便，我们可以把游戏设置相关的内容统一组织起来，放入单独的类中，比如屏幕大小，背景颜色等
创建settings.py文件，并在其中添加Settings类，将屏幕大小，背景颜色甚至帧率等添加到类中，如下
class Settings:    def __init__(self):        self.screen_width = 800        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;

在主程序创建Settings的实例，并用其中的属性替换掉原来的硬编码行为，这样便于我们理解和组织代码以及后续拓展开发
创建Ship类这里我们要在游戏界面创建一个飞船，首先需要准备一张照片，创建文件夹imgs，将书中源码位置的图片复制到imgs下，并添加新文件ship.py，Ship类要加载图片显示，初始位置应当位于屏幕中心底部，并且支持左右移动，代码如下
import pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(&#x27;imgs/ship.bmp&#x27;)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += 3        if self.moving_left and self.rect.left &gt; 0:            self.x -= 3        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)

突然发现写博客还是比较费时间的，这里就不过多解释了，完成Ship类之后就需要对主程序进行更改了，我们对原来的代码进行重构，因为要添加左右移动的消息，所以将while循环中的内容简化，尽可能的封装为函数模块，大致分为事件检测、事件执行、飞船更新、屏幕更新等
事件检测：
def _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP:            self._check_keyup_events(event)

判断消息类型，如果是退出，就结束游戏，如果是键盘按键按下或者是键盘按键松开，则执行对应的函数
事件执行：
def _check_keydown_events(self, event):    &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = True    elif event.key == pygame.K_LEFT:        self.ship.moving_left = True    elif event.key == pygame.K_q:        pygame.quit()        sys.exit()

如果键盘按下，则判断按下的是哪一个键，右键激活飞船的右移动标识，左键则激活左移动标识，如果是q键，同样执行退出，这是为了方便用户结束游戏而不用每次都点击右上角X号
def _check_keyup_events(self, event):    &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        self.ship.moving_right = False    elif event.key == pygame.K_LEFT:        self.ship.moving_left = False

如果键盘松开，则根据松开的按键来结束对应的移动标识
屏幕更新：
def _update_screen(self):    &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;    self.screen.fill(self.settings.bg_color)    self.ship.draw()    pygame.display.flip()

综上，while循环目前应该包含的内容如下
while True:    # 监听事件    self._check_events()    # 更新飞船位置    self.ship.update()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)

运行

这个时候我们的飞船就可以正常移动了
创建Bullet类首先创建bullet.py文件，在其中创建Bullet类，为了便于管理子弹，我们采用群组的方式将其继承Sprite，Bullet类应当包含颜色、大小、速度等，同时绘制自身并更新位置，代码如下
import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        self.color = (60, 60, 60)        self.rect = pygame.Rect(0, 0, 3, 15)               self.speed = 4        self.rect.midtop = self.game.ship.rect.midtop()        self.y = float(self.rect.y)    def update(self):        self.y -= self.speed        self.rect.y = self.y    def draw(self):        pygame.draw.rect(self.game.screen, self.color, self.rect)

更改主程序代码，以pygame.sprite.Group()的方式创建子弹群组，在按下键盘事件中添加空格的侦听，并添加发射子弹的函数，然后在主循环中添加更新子弹的函数，用于更新子弹的位置并删除超出屏幕的子弹，最后在刷新屏幕的函数中添加显示子弹的代码，主要添加内容如下
def _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)            def _fire_bullet(self):    &quot;&quot;&quot;发射子弹&quot;&quot;&quot;    if len(self.bullets) &lt; 6:        new_bullet = Bullet(self)        self.bullets.add(new_bullet)

运行如下

这样就可以正常发射子弹了。下面我们还需要对代码进行简单的修改，将子弹的相关配置放入Settings中
代码优化跟设置相关的内容我们应该放在Settings类当中，同时尽可能的减少硬编码的行为，优化后的完整代码如下
alien_invasion.py
import  pygameimport sysfrom settings import Settingsfrom ship import Shipfrom bullet import Bulletclass AlienInvasion:    # 初始化界面    def __init__(self):        pygame.init()        self.settings = Settings()        self.clock = pygame.time.Clock()        self.screen = pygame.display.set_mode((self.settings.screen_width, self.settings.screen_height))        pygame.display.set_caption(self.settings.TITLE)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()    def run_game(self):        # 游戏主循环        while True:            # 监听事件            self._check_events()            # 更新飞船位置            self.ship.update()            # 更新子弹位置            self._update_bullets()            # 更新屏幕            self._update_screen()            # 控制游戏帧率            self.clock.tick(self.settings.FPS)    def _check_events(self):        &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)    def _check_keydown_events(self, event):        &quot;&quot;&quot;响应按键按下事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            pygame.quit()            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()    def _check_keyup_events(self, event):        &quot;&quot;&quot;响应按键松开事件&quot;&quot;&quot;        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    def _update_screen(self):        &quot;&quot;&quot;更新屏幕&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        for bullet in self.bullets.sprites():            bullet.draw()        self.ship.draw()        pygame.display.flip()    def _update_bullets(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.bullets.update()        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                self.bullets.remove(bullet)    def _fire_bullet(self):        &quot;&quot;&quot;发射子弹&quot;&quot;&quot;        if len(self.bullets) &lt; self.settings.bullet_limit:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)if __name__ == &#x27;__main__&#x27;:    # 实例化AlienInvasion类并运行游戏    alien_invasion = AlienInvasion()    alien_invasion.run_game()

bullet.py
import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 设置子弹的属性        self.color = self.game.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.game.settings.bullet_width, self.game.settings.bullet_height)        # 将子弹放在飞船的顶部        self.rect.midtop = self.game.ship.rect.midtop		        # 子弹的y轴位置        self.y = float(self.rect.y)    def update(self):        &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;        self.y -= self.game.settings.bullet_speed        self.rect.y = self.y    def draw(self):        &quot;&quot;&quot;绘制子弹&quot;&quot;&quot;        pygame.draw.rect(self.game.screen, self.color, self.rect)

settings.py
class Settings:    def __init__(self):        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;        self.screen_width = 1600        self.screen_height = 600        self.bg_color = (230, 230, 230)        self.FPS = 90        self.TITLE = &quot;外星人来喽&quot;        # 飞船设置        self.ship_image_path = &#x27;imgs/ship.bmp&#x27;        self.ship_speed = 3        # 子弹设置        self.bullet_color = (60, 60, 60)        self.bullet_speed = 4        self.bullet_width = 3        self.bullet_height = 15        self.bullet_limit = 10

ship.py
import pygameclass Ship:    def __init__(self, game):        self.game = game        # 加载图片        self.image = pygame.image.load(self.game.settings.ship_image_path)        self.rect = self.image.get_rect()        # 显示图片在底部        self.rect.midbottom = self.game.screen.get_rect().midbottom        # 图片当前所在的x轴位置        self.x = float(self.rect.x)        # 移动标识        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;更新飞船位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.game.settings.screen_width:            self.x += self.game.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:            self.x -= self.game.settings.ship_speed        # 更新rect对象的位置        self.rect.x = self.x    def draw(self):        &quot;&quot;&quot;绘制飞船&quot;&quot;&quot;        self.game.screen.blit(self.image, self.rect)

]]></content>
      <categories>
        <category>Python实战之外星人入侵</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实战之外星人入侵《二》</title>
    <url>/posts/153f977c.html</url>
    <content><![CDATA[创建Alien类
创建一个alien.py文件，并把书中源码的alien.bmp图片拷贝到我们的imgs文件夹中，代码如下
import pygamefrom pygame.sprite import Spriteclass Alien(Sprite):    def __init__(self, game):        super().__init__()        self.game = game        # 加载外星人图片        self.image = pygame.image.load(&#x27;imgs/alien.bmp&#x27;)        self.rect = self.image.get_rect()        # 设置外星人初始位置        self.rect.x = self.rect.width        self.rect.y = self.rect.height        # 外星人当前的x轴位置        self.x = float(self.rect.x)
创建Alien实例
由于外星人通常是成批次出现，因此我们也要通过Sprite管理，如self.aliens = pygame.sprite.Group()，这里我们单独创建一个函数用于外星人的生成
def _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    self.aliens.add(alinen)
然后在更新屏幕的函数中添加如下代码用于外星人在屏幕上的显示
self.aliens.draw(self.screen)
运行

此时在屏幕的左上角已经出现了一个外星人
创建Alien舰队
上述我们在_create_fleet中只生成了一个外星人，下面进行修改来生成多行外星人，代码如下
def _create_fleet(self):    &quot;&quot;&quot;创建外星人舰队&quot;&quot;&quot;    alinen = Alien(self)    alien_width = alinen.rect.width    alien_height = alinen.rect.height    current_x, current_y = alien_width, alien_height    # 计算屏幕可以容纳多少个外星人    while current_y &lt; (self.settings.screen_height - 3 * alien_height):        while current_x &lt; (self.settings.screen_width - 2 * alien_width):            self._create_alien(current_x, current_y)            current_x += 2 * alien_width        # 重置当前x位置，移动到下一行        current_y += 2 * alien_height        current_x = alien_widthdef _create_alien(self, current_x, current_y):    &quot;&quot;&quot;创建一个外星人&quot;&quot;&quot;    alien = Alien(self)    alien.x = current_x    alien.rect.x = current_x    alien.rect.y = current_y    self.aliens.add(alien)
这里我们先生成一个实例，然后获取到它的宽度和高度并赋值为当前的x轴位置和y轴位置，内层循环用来生成一行外星人，从距离屏幕一个外星人的宽度开始，每隔一个外星人宽度创建一个实例，直到屏幕宽度不满足两个外星人的宽度为止，外层循环首先更新y轴位置，将其下移两个外星人的高度，然后初始化当前的x轴位置，再次创建一行，直到屏幕高度不满足三个外星人的高度位置为止，运行如下

此时我们已经创建了一个外星人的舰队
移动舰队
在Setting中添加如下代码
# 外星人设置self.alien_speed = 1self.alien_drop_speed = 10self.alien_direction = 1  # 1表示向右移动，-1表示向左移动
分别表示外星人的水平速度、下降速度、水平方向
然后在Alien中添加更新位置的函数
def update(self):    &quot;&quot;&quot;更新外星人位置&quot;&quot;&quot;    self.x += self.game.settings.alien_speed * self.game.settings.alien_direction    self.rect.x = self.x
通过alien_direction来决定水平方向的移动，但这样只会让舰队朝着一个方向不停移动直到超出屏幕范围，在舰队即将到达屏幕边缘时，我们应该改变它的方向，让它朝着相反的方向移动，并下降一段距离。先添加边缘检测函数，如下
def check_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    screen_rect = self.game.screen.get_rect()    if self.rect.right &gt;= screen_rect.right or self.rect.left &lt;= 0:        return True    return False
先获取屏幕大小，然后根据外星人所在的位置判断是否超出了屏幕边界，超了就返回True，否则返回就False
随后我们在主程序添加检测函数，并在到达边缘时使其下降一段距离
def _check_fleet_edges(self):    &quot;&quot;&quot;检查外星人是否到达屏幕边缘&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.check_edges():            self._change_fleet_direction()            breakdef _change_fleet_direction(self):    &quot;&quot;&quot;改变外星人舰队的方向&quot;&quot;&quot;    for alien in self.aliens.sprites():        alien.rect.y += self.settings.alien_drop_speed    self.settings.alien_direction *= -1
对于每一个外星人我们都检测其是否超出了屏幕范围，然后改变所有外星人其移动方向，并下降一段距离，此时我们在更新外星人位置的函数中调用检测边界函数，运行结果如下

射击外星人
此时我们发射子弹，子弹并不能击落外星人，而是会直接穿过外星人，因为我们还没有做子弹和外星人的碰撞检测，下面我们来逐步实现这一过程
检测子弹和外星人的碰撞
要实现这个功能非常简单，我们只需要利用pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)这个函数即可，前两个参数分别表示子弹群组和外星人群组，后面两个参数表示碰撞后是否消失，True表明碰撞后子弹和外星人均消失。但这样还有个缺陷，就是我们把外星人全部击落之后，屏幕将没有外星人了，我们应该在打完所有外星人之后重新生成新的外星人舰队，代码如下
def _update_bullets(self):    &quot;&quot;&quot;更新子弹位置&quot;&quot;&quot;    self.bullets.update()    for bullet in self.bullets.copy():        if bullet.rect.bottom &lt;= 0:            self.bullets.remove(bullet)                self._check_bullet_alien_collisions()def _check_bullet_alien_collisions(self):    &quot;&quot;&quot;检查子弹与外星人碰撞&quot;&quot;&quot;    collisions = pygame.sprite.groupcollide(self.bullets, self.aliens, True, True)    if not self.aliens:        # 如果没有外星人了，重新创建外星人舰队        self._create_fleet()        self.bullets.empty()
我们在更新子弹的后面加入了调用检测碰撞的函数，并在所有外星人消失后重新生成新的外星人舰队，同时清除所有子弹，从而使我们继续游戏
检测飞船和外星人的碰撞
如果按照上述的逻辑，那么这个游戏将没有终止的时候，为此应该加入游戏结束的一些条件，比如我们的飞船和外星人发生了碰撞，在更新外星人的函数中添加代码如下
# 检测外星人和飞船的碰撞if pygame.sprite.spritecollideany(self.ship, self.aliens):    print(&quot;飞船被外星人撞了！&quot;)
spritecollideany(self.ship, self.aliens)函数接收一个精灵和一个编组，用于检测飞船是否有和外星人碰撞，如果发生碰撞，将打印&quot;飞船被外星人撞了！&quot;。通常来讲，我们不应当在飞船撞毁之后直接结束游戏，而是应该给予玩家多次机会，下面我们创建一个game_status.py文件，用于记录游戏信息，内容如下
class GameStatus:    def __init__(self, game):        &quot;&quot;&quot;初始化游戏状态&quot;&quot;&quot;        self.ships_left = None        self.game = game        self.reset_status()            def reset_status(self):        &quot;&quot;&quot;重置游戏状态&quot;&quot;&quot;        self.ships_left = self.game.settings.ship_limit
同时在Settings中添加self.ship_limit = 3，表明飞船最多只有三次，ships_left则用来记录剩余的飞船数量
下面我们对主程序进行修改，添加一个用于游戏状态表示的实例：self.status = GameStatus(self)，然后创建撞击后的响应函数，如下
def _ship_hit(self):    &quot;&quot;&quot;响应飞船被外星人撞击的事件&quot;&quot;&quot;    if self.status.ships_left &gt; 0:        # 减少剩余飞船数量        self.status.ships_left -= 1        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 重新创建外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()        # 暂停一段时间        sleep(1)    else:        print(&quot;游戏结束！&quot;)
如果被撞击并且飞船数量大于0，则减少一个飞船数量并清空子弹和外星人，从而生成新的外星人和飞船。删除碰撞函数里print()函数，替换为_ship_hit()，并在Ship中添加如下函数
def center_ship(self):    &quot;&quot;&quot;将飞船放在屏幕底部中央&quot;&quot;&quot;    self.rect.midbottom = self.game.screen.get_rect().midbottom    self.x = float(self.rect.x)
使新生成的飞船位于屏幕底部中心
到达屏幕底部边缘
如果外星人到达屏幕底部，我们同样应该跟碰撞一样响应，添加屏幕下边缘检测函数
def _check_alien_bottom(self):    &quot;&quot;&quot;检查外星人是否到达屏幕底部&quot;&quot;&quot;    for alien in self.aliens.sprites():        if alien.rect.bottom &gt;= self.settings.screen_height:            self._ship_hit()            break
检查每个外星人的底部是否超过了屏幕的高度，如果超过则调用_ship_hit()函数。在更新外星人的最后添加self._check_alien_bottom()，此时当外星人到达屏幕底部游戏也将重置
GameOver
细心一点可能会注意到，当我们死亡超过三次时，游戏仍然没有结束，事实上它永远也不会结束，因为我们在_ship_hit()函数中，当ships_left小于0时，只是调用了print(&quot;游戏结束！&quot;)，其他什么也没有做，因此ships_left只会越来越小，我们应该为其添加一个游戏标识，如果标识为False则终止某些部分的运行，从而实现游戏的结束。在主程序添加self.game_active = True，并将print(&quot;游戏结束！&quot;)替换为self.game_active = False，同时修改主循环如下
# 游戏主循环while True:    # 监听事件    self._check_events()    if self.game_active:        # 更新飞船位置        self.ship.update()        # 更新子弹位置        self._update_bullets()        # 更新外星人位置        self._update_aliens()    # 更新屏幕    self._update_screen()    # 控制游戏帧率    self.clock.tick(self.settings.FPS)
]]></content>
      <categories>
        <category>Python实战之外星人入侵</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实战之外星人入侵《三》</title>
    <url>/posts/5821342e.html</url>
    <content><![CDATA[添加Play按钮
首先在Setting中添加如下代码
# 按钮设置self.button_color = (0, 255, 0)self.button_width = 200self.button_height = 50self.button_text_color = (255, 255, 255)self.button_font = 48self.play_button_text = &quot;Play&quot;
将按钮的相关属性加入到设置相关的类中，然后创建button.py文件，添加如下代码
import pygame.fontclass Button:    def __init__(self, game, msg):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.button_font)        self.rect = pygame.Rect(0, 0, self.game.settings.button_width, self.game.settings.button_height)        self.rect.center = self.game.screen.get_rect().center        self._pre_msg(msg)    def _pre_msg(self, msg):        &quot;&quot;&quot;将msg渲染为图像&quot;&quot;&quot;        self.msg_image = self.font.render(msg, True, self.game.settings.button_text_color, self.game.settings.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw(self):        &quot;&quot;&quot;绘制按钮&quot;&quot;&quot;        self.game.screen.fill(self.game.settings.button_color, self.rect)        self.game.screen.blit(self.msg_image, self.msg_image_rect)
__init__()函数用于按钮的初始化，如按钮的大小、字体、位置等，_pre_msg()函数用于将字符串消息转换为图像并填充到矩形中，draw()函数用于绘制按钮
接下来我们在主程序中将game_active设为False，从而为了显示按钮，然后添加按钮属性self.play_button = Button(self, self.settings.play_button_text)，接着在更新屏幕的地方判断如果游戏处于非活跃状态就显示按钮
if not self.game_active:    self.play_button.draw()
现在运行游戏

开始游戏
此时点击按钮并没有做出反应，因为我们还没有添加鼠标点击响应的事件，首先在_check_events中添加如下代码
elif event.type == pygame.MOUSEBUTTONDOWN:    mouse_pos = pygame.mouse.get_pos()    self._check_play_button(mouse_pos)
上述代码用于检测是否有鼠标按下，如果有则获取鼠标点击的位置，然后将变量传递给_check_play_button，现在我们添加该函数
def _check_play_button(self, mouse_pos):    &quot;&quot;&quot;响应Play按钮的点击事件&quot;&quot;&quot;    if self.play_button.rect.collidepoint(mouse_pos):        # 重置游戏状态        self.status.reset_status()        self.game_active = True        # 清空子弹和外星人        self.bullets.empty()        self.aliens.empty()        # 创建新的外星人舰队        self._create_fleet()        # 重置飞船位置        self.ship.center_ship()
一旦有点击事件的发生，我们就判断点击位置是否位于按钮中，如果是，则重置游戏状态并清空所有子弹和外星人，创建新的外星人和飞船，从而表明我们开启了新游戏，运行如下

游戏优化
当前游戏中还存在Bug，如果我们点击按钮所在区域，即便是按钮已经消失但仍会做出响应并重置游戏，因为我们的鼠标点击事件还会判断其点击位置与按钮位置重合，因此我们需要对判断做出优化
if self.play_button.rect.collidepoint(mouse_pos) and not self.game_active:
将_check_play_button函数中的if判断语句改为上述代码，从而防止其在游戏运行时仍会执行重置代码
另外，玩游戏时我们应该将光标隐藏，在游戏结束时显示光标
在_check_play_button的末尾添加pygame.mouse.set_visible(False)，游戏开始将光标隐藏，在_ship_hit的else块的末尾添加pygame.mouse.set_visible(True) ，游戏结束时将光标显示
提升趣味性
在Settings中添加如下代码
    # 游戏速度设置    self.speed_scale = 1.1    self.init_settings()def init_settings(self):    &quot;&quot;&quot;初始化游戏的动态设置&quot;&quot;&quot;    self.ship_speed = 30    self.bullet_speed = 10    self.alien_speed = 10    self.alien_drop_speed = 10    self.alien_direction = 1def increase_speed(self):    &quot;&quot;&quot;提高游戏速度设置&quot;&quot;&quot;    self.ship_speed *= self.speed_scale    self.bullet_speed *= self.speed_scale    self.alien_speed *= self.speed_scale    self.alien_drop_speed *= self.speed_scale
speed_scale用于控制游戏增长的速度，init_settings用于初始化设置，increase_speed用于将相关参数增长从而提高游戏难度
在_check_bullet_alien_collisions中，如果外星人全部被击落，我们就调用self.settings.increase_speed()增加游戏速度。当然每次开启新游戏时，应当将所有设置还原，在_check_play_button的if语块的第一行添加self.settings.init_settings()，这将使得新游戏的属性为初始化值
记录分数
在GameStatus中添加属性self.score = 0用于重置分数，在Settings中添加分数相关设置
# 游戏分数设置self.score_text_color = (30, 30, 30)self.score_font = 48
然后创建gamescore.py文件添加如下代码
import pygame.fontclass GameScore:    def __init__(self, game):        self.game = game        self.font = pygame.font.SysFont(None, self.game.settings.score_font)        self.prep_score()    def prep_score(self):        &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;        score_str = str(self.game.status.score)        self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)        self.score_rect = self.score_image.get_rect()        self.score_rect.right = self.game.screen.get_rect().right - 20        self.score_rect.top = 20    def show_score(self):        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;        self.game.screen.blit(self.score_image, self.score_rect)
在主程序中添加成员self.score = GameScore(self)，随后在更新屏幕函数中显示分数面板self.score.show_score()，此时运行游戏就能显示分数面板了
更新得分
在Settings的init_settings中添加self.alien_points = 50，用于表示每个外星人击落的初始得分，然后在主程序的_check_bullet_alien_collisions中添加
if collisions:    for aliens in collisions.values():        self.status.score += self.settings.alien_points * len(aliens)    self.score.prep_score()
表示每次击中一个外星人则对其进行加分，同时击落多个外星人也能同时记分，当然每次开始游戏我们也要重置分数，在_check_play_button中添加self.score.prep_score()，用新的分数来初始化记分面板
对于不同速度的外星人，我们也应该增加其击落分数，在Settings中添加self.score_scale = 1.5表示外星人的分数增长速度，然后在increase_speed中添加self.alien_points = int(self.alien_points * self.score_scale)，更新新的外星人分数，最后再对分数进行取舍，在GameScore的prep_score中修改代码如下
def prep_score(self):    &quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;    rounded_score = round(self.game.status.score, -1)    score_str = f&quot;&#123;rounded_score:,&#125;&quot;  # 使用逗号分隔千位    self.score_image = self.font.render(score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.score_rect = self.score_image.get_rect()    self.score_rect.right = self.game.screen.get_rect().right - 20    self.score_rect.top = 20
表示我们通过round函数将分数取为10的整数倍，这样每个外星人的分数都是10的倍数了
获取最高分
在GameStatus添加新属性self.max_score = 0用来记录最高分，随后在GameScore中添加新函数
def prep_high_score(self):    &quot;&quot;&quot;将最高得分渲染为图像&quot;&quot;&quot;    high_score = round(self.game.status.max_score, -1)    high_score_str = f&quot;&#123;high_score:,&#125;&quot;    self.high_score_image = self.font.render(high_score_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.high_score_rect = self.high_score_image.get_rect()    self.high_score_rect.centerx = self.game.screen.get_rect().centerx    self.high_score_rect.top = self.score_rect.top    def check_high_score(self):    &quot;&quot;&quot;检查是否达到了新的最高得分&quot;&quot;&quot;    if self.game.status.score &gt; self.game.status.max_score:        self.game.status.max_score = self.game.status.score        self.prep_high_score()
这里将最高分渲染为图像并放置在屏幕正中央的上方，在__init__中调用prep_high_score，然后在show_score中将high_score_image显示出来，并在主程序中每当碰撞发生时就调用check_high_score判断当前分数是否超过了最高分，运行如下

显示等级和飞船数
在GameStatus的reset_status中添加self.level = 1，在GameScore的__init__添加函数self.prep_level()，代码如下
def prep_level(self):    &quot;&quot;&quot;将当前关卡渲染为图像&quot;&quot;&quot;    level_str = str(self.game.status.level)    self.level_image = self.font.render(level_str, True, self.game.settings.score_text_color, self.game.settings.bg_color)    self.level_rect = self.level_image.get_rect()    self.level_rect.right = self.score_rect.right    self.level_rect.top = self.score_rect.bottom + 10
将等级渲染为图片并显示在得分的正下方，然后在show_score中添加self.game.screen.blit(self.level_image, self.level_rect)来显示图像，在主程序中清除所有外星人之后提升等级，代码如下
if not self.aliens:    # 如果没有外星人了，重新创建外星人舰队    self._create_fleet()    self.bullets.empty()    self.settings.increase_speed()    # 提升关卡    self.status.level += 1    self.score.prep_level()
最后在_check_play_button中重置等级，调用self.score.prep_level()即可，运行如下

接下来我们要显示剩余飞船数，这里我们对飞船也要使用Sprite，更改Ship类如下
class Ship(Sprite):    def __init__(self, game):        super().__init__()
将Ship继承自Sprite，在GameScore中添加函数prep_ships如下
def prep_ships(self):    &quot;&quot;&quot;显示剩余飞船数量&quot;&quot;&quot;    self.ships = Group()    for ship_number in range(self.game.status.ships_left):        ship = Ship(self.game)        ship.rect.x = 10 + ship_number * ship.rect.width        ship.rect.y = 10        self.ships.add(ship)
这个函数用于根据剩余的飞船数量来创建飞船对象并调整位置，然后在初始化的函数中添加self.prep_ships()。下一步我们就要绘制飞船了，在show_score中添加self.ships.draw(self.game.screen)即可，然后在主程序的游戏开始和飞船被撞击的地方调用self.score.prep_ships()就能够正常加载和显示剩余飞船了，如下

游戏Bug更改
到上述部分我们就完成了书中的所有内容，但经过我的测试，这款游戏存在一定的Bug，看图

是不是很奇怪？游戏还没有开始怎么就出现了一条横线？其实这是因为我们通过循环来侦听不同事件的发生，如果在游戏开始之前点击空格按钮，那么就会执行发射子弹的函数。但此时游戏状态并没有被激活，因此这条横线会停在这里，而且由于我们的子弹比较大，我们的飞船图像并不能完全遮盖子弹，所以就出现了这种现象，但从逻辑上来讲，如果我们不停按空格，程序应该每次都会执行空格所对应的响应，所以这里我们对其进行修改
def _check_events(self):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            pygame.quit()            sys.exit()        elif event.type == pygame.KEYDOWN and self.game_active:            self._check_keydown_events(event)        elif event.type == pygame.KEYUP and self.game_active:            self._check_keyup_events(event)        elif event.type == pygame.MOUSEBUTTONDOWN:            mouse_pos = pygame.mouse.get_pos()            self._check_play_button(mouse_pos)
上述代码主要增加了当键盘响应时游戏是否处于激活状态，如果游戏未激活则不响应任何按键，此时我们无论按键盘上的哪里，都不会再次出现上述的情况了，至此，该项目就完全结束了。源码访问点击这里
]]></content>
      <categories>
        <category>Python实战之外星人入侵</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulink调用外部Dll可视化《二》</title>
    <url>/posts/4e6df0d5.html</url>
    <content><![CDATA[介绍
这篇文章主要实现在Simulink中可视化的工作，由于自身求解工具的可视化代码采用C++编程，同时与项目耦合过多，难以独立摘出或通过Matlab重现，因此这里采用新建桥接工程将所有需要用到的可视化代码封装并导出
封装Dll并导出C函数
首先在VS中新建空项目工程并进行配置，主要是关于项目依赖、导出Dll相关，然后将所有可能用到的代码进行简化和封装，我这里采用的类进行管理，由于跟项目相关不进行展示，新建XXXBridgeDLL.h和XXXBridgeDLL.cpp用于导出C接口供Matlab调用，内容如下
#pragma once#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    EXPORT_API void* CreateProcessor();    EXPORT_API void DeleteProcessor(void* p);    EXPORT_API int  ReadXXXDat(void* p, const char* folder, int* pNumPts);        EXPORT_API int   GetPointCount(void* p);                      /* 返回总点数         */    EXPORT_API int   CopyX_mm(void* p, double* out, int max);  /* 轴向坐标 (mm)     */    EXPORT_API int   CopyPower(void* p, double* out, int max);  /* 输出功率 (W)      */    EXPORT_API int   CopyGain(void* p, double* out, int max);  /* 增益 (dB)         */    EXPORT_API int   CopyEff(void* p, double* out, int max);  /* 效率 (%)          */#ifdef __cplusplus&#125;#endif
这段代码是一个 C/C++ 动态链接库（DLL）的头文件（.h），用于定义向外部导出的一组函数接口。

DLL 导出宏定义部分
#ifdef XXXBRIDGEDLL_EXPORTS#define EXPORT_API __declspec(dllexport)#else#define EXPORT_API __declspec(dllimport)#endif

作用：用于在不同编译阶段切换导出/导入。

如果编译的是 DLL 本身（定义了 XXXBRIDGEDLL_EXPORTS），则 EXPORT_API 展开为 __declspec(dllexport)，导出符号；
如果是使用 DLL 的客户端程序，则展开为 __declspec(dllimport)，用于导入符号。




extern &quot;C&quot; 块
#ifdef __cplusplusextern &quot;C&quot; &#123;#endif...#ifdef __cplusplus&#125;#endif

使得这些函数按照 C语言方式 进行链接（不进行 C++ 名字改编 / name mangling），以便在 C/C++/Python/MATLAB 等跨语言调用时保持接口兼容。


导出的函数接口
EXPORT_API void* CreateProcessor();

创建一个处理器对象，返回一个 void* 指针（通常是一个类的实例地址）。

EXPORT_API void DeleteProcessor(void* p);

删除处理器对象，释放资源。

EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pNumPts);

从指定文件夹读取数据，p 是处理器对象指针，folder 是数据路径，pNumPts 用于返回读取到的点数。


数据访问函数（数据从内存复制出来）
EXPORT_API int GetPointCount(void* p);

获取数据点总数。

EXPORT_API int CopyX_mm(void* p, double* out, int max);

复制轴向坐标数据（单位：mm）到 out 指针所指向的数组，max 是允许写入的最大点数。

EXPORT_API int CopyPower(void* p, double* out, int max);

复制输出功率数据（单位：瓦特）。

EXPORT_API int CopyGain(void* p, double* out, int max);

复制增益数据（单位：dB）。

EXPORT_API int CopyEff(void* p, double* out, int max);

复制电子效率数据（单位：百分比）。

这个 DLL 接口提供了一个基于文件夹读取仿真结果（XXX仿真输出），并通过一系列函数获取：

坐标（X）
功率（Power）
增益（Gain）
效率（Eff）

#define XXXBRIDGEDLL_EXPORTS#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125; extern &quot;C&quot; &#123;    EXPORT_API void* CreateProcessor() &#123; return new CXXXProcessor(); &#125;    EXPORT_API void  DeleteProcessor(void* p) &#123; delete static_cast&lt;CXXXProcessor*&gt;(p); &#125;    EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;        if (!p || !folder || !pts) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        bool ok = proc-&gt;ReadXXXDat(folder);        *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;        return ok;    &#125;    EXPORT_API int GetPointCount(void* p) &#123;        return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;    &#125;    EXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;        if (!p || !out || max &lt;= 0) return 0;        auto proc = static_cast&lt;CXXXProcessor*&gt;(p);        int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);        for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;        return n;    &#125;    EXPORT_API int CopyPower(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);    &#125;    EXPORT_API int CopyGain(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);    &#125;    EXPORT_API int CopyEff(void* p, double* o, int m) &#123;        return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,            [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);    &#125;&#125;
这段代码是 XXXBridgeDLL.dll 的 实现部分（C++源文件），与之前的头文件 XXXBridgeDLL.h 搭配使用，向外部程序提供接口来访问 XXX 仿真数据

文件头部设置
#define XXXBRIDGEDLL_EXPORTS

定义此宏意味着当前正在编译 DLL，因此头文件中的 EXPORT_API 会变成 __declspec(dllexport)，导出接口。


#include &quot;XXXBridgeDLL.h&quot;#include &quot;CXXXProcessor.h&quot;#include &lt;algorithm&gt;#include &lt;vector&gt;

引入头文件和 STL 库。CXXXProcessor 是处理器类，核心功能由它实现，接口只是封装。


匿名命名空间 copyVector
namespace &#123;    template&lt;typename SRC_GETTER&gt;    int copyVector(CXXXProcessor* proc, double* out, int max, SRC_GETTER getter)    &#123;        if (!proc || !out || max &lt;= 0) return 0;        const auto&amp; vec = getter(proc);        int n = std::min&lt;int&gt;(vec.size(), max);        std::copy(vec.begin(), vec.begin() + n, out);        return n;    &#125;&#125;

作用：通用的向 double* out 中复制数据的函数模板。
SRC_GETTER 是一个 Lambda，返回某个 vector&lt;double&gt; 的引用。
使用匿名命名空间是为了限定作用域（防止链接冲突）。


导出接口（extern &quot;C&quot;）

CreateProcessor

EXPORT_API void* CreateProcessor() &#123;    return new CXXXProcessor();&#125;

返回新建的处理器对象（指针以 void* 形式传出，保持 C 接口风格）。


DeleteProcessor

EXPORT_API void DeleteProcessor(void* p) &#123;    delete static_cast&lt;CXXXProcessor*&gt;(p);&#125;

释放 CreateProcessor() 创建的对象。


ReadXXXDat

EXPORT_API int ReadXXXDat(void* p, const char* folder, int* pts) &#123;    if (!p || !folder || !pts) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    bool ok = proc-&gt;ReadXXXDat(folder);    *pts = ok ? static_cast&lt;int&gt;(proc-&gt;m_vdpX.size()) : 0;    return ok;&#125;

调用 CXXXProcessor::ReadXXXDat(folder) 加载文件夹中的数据。
加载成功后将数据点数写入 pts。
m_vdpX 是轴向坐标数组。


GetPointCount

EXPORT_API int GetPointCount(void* p) &#123;    return p ? static_cast&lt;int&gt;(static_cast&lt;CXXXProcessor*&gt;(p)-&gt;m_vdpX.size()) : 0;&#125;

返回总的数据点数（坐标数量）。


CopyX_mm

EXPORT_API int CopyX_mm(void* p, double* out, int max) &#123;    if (!p || !out || max &lt;= 0) return 0;    auto proc = static_cast&lt;CXXXProcessor*&gt;(p);    int n = std::min&lt;int&gt;(proc-&gt;m_vdpX.size(), max);    for (int i = 0; i &lt; n; ++i) out[i] = proc-&gt;m_vdpX[i] * 1000.0;    return n;&#125;

将轴向坐标 m_vdpX（单位：米）转换为毫米（乘以 1000）并复制到 out 缓冲区。


CopyPower, CopyGain, CopyEff

EXPORT_API int CopyPower(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;PowerOut; &#125;);&#125;

通过 copyVector 模板复制 PowerOut 数据。

EXPORT_API int CopyGain(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Gain; &#125;);&#125;

复制增益（Gain）数据。

EXPORT_API int CopyEff(void* p, double* o, int m) &#123;    return copyVector(static_cast&lt;CXXXProcessor*&gt;(p), o, m,        [](CXXXProcessor* q)-&gt;const std::vector&lt;double&gt;&amp;&#123;return q-&gt;Eff; &#125;);&#125;

复制效率（Eff）数据。


模块用途概览



函数名
功能描述




CreateProcessor
创建处理器对象


DeleteProcessor
释放处理器对象


ReadXXXDat
从指定目录读取 XXX 数据文件


GetPointCount
获取总数据点数


CopyX_mm
获取轴向坐标（单位 mm）


CopyPower
获取输出功率（单位 W）


CopyGain
获取增益（单位 dB）


CopyEff
获取电子效率（单位 %）



编译成功后会在指定目录生成dll文件，把dll文件和导出函数头文件放到Matlab的工作目录下供其使用
Matlab及Simulink调用Dll
在Matlab中新建m文件，内容如下
% 0. 环境与路径dll = &#x27;H:\Matlab\bin\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\Matlab\bin\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\Users\pc\Desktop\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);endp   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;% --- 指针缓冲区 ---xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);x    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;% --- 绘图 ---figure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);% --- 清理 ---calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);
这段 MATLAB 代码演示了如何通过调用 C++ 动态链接库 XXXBridgeDLL.dll 来读取 XXX 仿真数据，并绘制输出功率、增益和效率随轴向位置变化的曲线

1. 加载 DLL 与设置路径
dll = &#x27;H:\Matlab\bin\XXXBridgeDLL.dll&#x27;;hdr = &#x27;H:\Matlab\bin\XXXBridgeDLL.h&#x27;;dir = &#x27;C:\Users\pc\Desktop\XXX&#x27;;if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)    loadlibrary(dll,hdr);end

设置 DLL 文件路径、头文件路径和数据文件夹路径。
如果 DLL 尚未加载，则调用 loadlibrary 加载 DLL 并注册其接口函数。


2. 创建处理器并读取数据
p   = calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CreateProcessor&#x27;);nPt = libpointer(&#x27;int32Ptr&#x27;,0);assert(calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;ReadXXXDat&#x27;,p,dir,nPt)==1,&#x27;读取失败&#x27;);N = nPt.Value;

创建处理器实例 p（C++ 对象的指针）。
申请一个 int32 类型的指针 nPt 用于返回数据点数量。
调用 ReadXXXDat 从 dir 文件夹读取仿真数据。
将数据点个数保存在 N 中。


3. 分配输出缓冲区并复制数据
xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N,1));effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N,1));calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyX_mm&#x27;, p, xPtr,   N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyPower&#x27;,p, powPtr, N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyGain&#x27;, p, gainPtr,N);calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;CopyEff&#x27;,  p, effPtr ,N);

为四类数据创建指针缓冲区，长度为 N。
通过调用 DLL 中的接口函数将数据从 C++ 内部复制到 MATLAB 缓冲区中。


4. 将指针值转换为 MATLAB 向量
x    = xPtr.Value;pow  = powPtr.Value;gain = gainPtr.Value;eff  = effPtr.Value;

将指针对象中的数据取出，转换为 MATLAB 可用的数组。


5. 绘制仿真结果曲线
figure;subplot(3,1,1); plot(x,pow,&#x27;-b&#x27;);  title(&#x27;输出功率曲线&#x27;);xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;W&#x27;);subplot(3,1,2); plot(x,gain,&#x27;-b&#x27;); title(&#x27;增益曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;dB&#x27;);subplot(3,1,3); plot(x,eff ,&#x27;-b&#x27;); title(&#x27;效率曲线&#x27;);    xlabel(&#x27;z / mm&#x27;);ylabel(&#x27;%&#x27;);

打开一个新图像窗口，将三种数据绘制在三个子图中：

输出功率 vs. 坐标
增益 vs. 坐标
效率 vs. 坐标




6. 清理资源
calllib(&#x27;XXXBridgeDLL&#x27;,&#x27;DeleteProcessor&#x27;,p);unloadlibrary(&#x27;XXXBridgeDLL&#x27;);

释放处理器对象 p。
卸载 DLL，释放系统资源。

这段代码实现了：

加载 DLL 并创建处理器。
调用 C++ 函数读取 XXX 仿真数据。
将结果复制到 MATLAB 并绘图。
使用完后清理资源，避免内存泄漏。

运行效果如下

与求解工具链接
现在的可视化模块只是通过硬编码的方式读取指定文件，下面需要把求解工具和可视化链接，通过求解工具输出的参数来进行泛型可视化
修改现有的调用求解工具S Function代码
function sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\Solver\XXX.exe&#x27;;    paramPath = &#x27;C:\Users\pc\Desktop\XXX&#x27;;    %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end
这段代码是一个 Level-2 MATLAB S-Function，用于在 Simulink 中检测输入信号的 上升沿（从0变为1），然后异步启动一个外部 EXE 程序（XXX.exe），并轮询进程状态，完成后自动停止仿真。



步骤
说明




①
输入信号从 0 → 1，触发启动 XXX.exe


②
启动进程，记录 PID 和运行状态


③
每 0.5 秒轮询一次，判断进程是否结束


④
若 EXE 正常退出，则输出状态为 2，仿真停止；否则输出 -1 并停止


⑤
清理进程资源，防止残留




调用工具代码解释

顶部函数入口

function sfun_callXXX(block)    setup(block);end

S-Function 的主函数入口，调用 setup() 注册接口。


setup(block)：配置端口、采样、方法等

block.NumInputPorts  = 1;  % 输入1个信号（控制启动）block.NumOutputPorts = 1;  % 输出当前状态（0, 1, 2, -1）block.SampleTimes = [0.5 0];  % 每 0.5 秒执行一次block.RegBlockMethod(...)    % 注册各阶段的回调函数set_param(..., &#x27;StopTime&#x27;, &#x27;inf&#x27;);  % 设置仿真不主动终止

PostProp：声明离散状态（DWork）

block.NumDworks = 3;names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;

prevU：上一时刻输入值（检测上升沿用）
exeState：执行状态（0=未启动，1=运行中，2=正常退出，-1=错误）
pid：外部进程 PID


InitCond：初始化 DWork 数据

block.Dwork(1).Data = 0;  % 上一时刻输入值block.Dwork(2).Data = 0;  % exeStateblock.Dwork(3).Data = 0;  % pid

Outputs(block)：主逻辑处理区

u = block.InputPort(1).Data;
上升沿触发：启动外部 EXE
if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0    [ok, procObj, pid, exeState] = launchExe(...);end
运行中：轮询状态（每次采样调用）
if exeState == 1    [exeState, pid] = pollProcessExitStatus(...);    if exeState == 2 || exeState == -1        stopSimulation(block);  % 进程完成 → 停止仿真    endend
输出当前状态并保存状态数据
block.OutputPort(1).Data = exeState;

Terminate：终止残留进程（防挂后台）

if ~isempty(procObj)    terminateProcess(procObj);end
内部 helper 函数说明
launchExe(exePath, paramPath)

启动 XXX.exe
参数格式是 '1|1|参数路径'
返回是否成功、进程对象、PID、状态

pollProcessExitStatus(procObj, pid)

检查进程是否已退出
如果异常，也尝试通过 PID 判断
根据 ExitCode 判断：

0 → 正常结束（返回状态 2）
非 0 → 异常（状态 -1）



isProcAlive(pid)

尝试通过 PID 检查进程是否还活着

terminateProcess(procObj)

如果进程还在运行，则强制结束并释放资源

stopSimulation(block)

调用 Simulink 命令强制停止整个仿真

状态码含义总结



状态码
含义




0
初始未启动


1
正在运行 EXE


2
EXE 正常退出


-1
启动或执行异常



修改M文件
将调用dll的Matlab代码改为S Function的方式，并通过1→2来进行触发，代码如下
function sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\bin\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\bin\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\Users\pc\Desktop\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)end
这段代码实现了一个 MATLAB Level-2 S-Function，主要功能是当输入信号为 2 时触发外部 DLL（XXXBridgeDLL.dll）的数据读取和处理，之后进行数据的可视化。
总体功能流程

输入信号：该 S-Function 监听一个输入信号 u。
脉冲触发：当信号 u == 2 且前一时刻 prevU != 2 时，触发读取数据。
调用 DLL：加载外部 DLL (XXXBridgeDLL.dll)，读取 XXX 仿真数据。
数据处理与绘图：读取坐标、功率、增益和效率数据，并绘制图形。
清理资源：在操作完成后，清理 DLL 资源。

代码分解

sfun_callXXXProcess(block)

function sfun_callXXXProcess(block)    setup(block);end

这是 S-Function 的入口函数，调用 setup(block) 设置仿真模块的基本配置。


setup(block): 配置端口、采样时间与方法

function setup(block)    block.NumInputPorts  = 1;  % 一个输入端口    block.NumOutputPorts = 0;  % 无输出端口    block.SampleTimes        = [0.5 0];  % 每 0.5 秒触发一次    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;  % 默认的仿真状态兼容性    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);end

配置输入端口和采样时间（每 0.5 秒触发一次）。
注册方法：PostPropagationSetup、InitializeConditions、Outputs 和 Terminate。


PostProp(block): 声明 DWork 状态变量

function PostProp(block)    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevU&#x27;;  % 存储上一时刻的输入信号    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;  % double 类型    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end

声明一个名为 prevU 的 DWork 变量，用于保存前一时刻的输入信号值。


InitCond(block): 初始化 DWork 数据

function InitCond(block)    block.Dwork(1).Data = 0;  % 初始化 `prevU` 为 0end

初始化时，prevU 设置为 0，表示初始状态。


Outputs(block): 主逻辑处理区

function Outputs(block)    u = block.InputPort(1).Data;  % 获取当前输入信号    prevU = block.Dwork(1).Data;  % 获取前一时刻的输入信号    if u == 2 &amp;&amp; prevU ~= 2        % 读取 XXX 数据        dll = &#x27;.\bin\XXXBridgeDLL.dll&#x27;;        hdr = &#x27;.\bin\XXXBridgeDLL.h&#x27;;        dir = &#x27;C:\Users\pc\Desktop\XXX&#x27;;        if ~libisloaded(&#x27;XXXBridgeDLL&#x27;)            loadlibrary(dll, hdr);  % 加载 DLL        end        p   = calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);  % 创建处理器对象        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        assert(calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt) == 1, &#x27;读取失败&#x27;);  % 读取数据        N = nPt.Value;  % 获取数据点数量        % 初始化指针缓冲区        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        % 从 DLL 中复制数据到指针        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;CopyEff&#x27;, p, effPtr, N);        % 获取数据        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % 绘图        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % 清理资源        calllib(&#x27;XXXBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;XXXBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end

当 u == 2 时，调用 XXXBridgeDLL.dll 进行数据读取，获取 x（坐标）、pow（功率）、gain（增益）和 eff（效率）数据。
使用 figure 绘制三张子图，显示输出功率、增益和效率随坐标的变化。
在操作完成后，清理 DLL 资源。


Terminate(~): 清理

function Terminate(~)end

在仿真结束时，Terminate 函数被调用，但在这个实现中没有进行额外操作。

工作流程

输入信号：当输入信号为 2 时，触发外部 EXE 进程。
调用 DLL：通过 XXXBridgeDLL.dll 读取 XXX 仿真数据。
数据处理与绘图：读取数据并绘制输出功率、增益和效率曲线。
清理：仿真结束后清理 DLL 资源。

运行示例

]]></content>
      <categories>
        <category>Simulink仿真</category>
      </categories>
      <tags>
        <tag>Simulink</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulink调用外部工具仿真《一》</title>
    <url>/posts/51a3b25e.html</url>
    <content><![CDATA[该项目旨在使用Simulink来完成某些计算和仿真，计算工具采用自己的求解器，因此Simulink在这里的作用主要为模拟输入输出接口和触发信号，后续可能会引入优化器来对参数进行优化，本篇作为开头，主要介绍如何使用Simulink调用外部工具。
创建m文件首先打开Matlab，指定工作路径，在命令行窗口输入edit sfun_callXXX从而在当前路径下创建sfun_callXXX.m文件，输入下述代码
function sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);endfunction setup(block)    % 一个输入端口：触发信号（1 表示触发执行）    block.NumInputPorts = 1;    block.SetPreCompInpPortInfoToDynamic;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    % 一个输出端口：执行状态    block.NumOutputPorts = 1;    block.SetPreCompOutPortInfoToDynamic;    block.OutputPort(1).Dimensions   = 1;    block.OutputPort(1).DatatypeID   = 0;    block.OutputPort(1).Complexity   = &#x27;Real&#x27;;    % 一个 Dwork 变量：用于保存上一个输入（用于边沿检测）    block.NumDworks = 1;    block.Dwork(1).Name            = &#x27;prevInput&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;    % 每 1 秒调用一次    block.SampleTimes = [1.0 0.0];    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.InitializeConditions = @InitConditions;    block.Outputs              = @Output;endfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值：输入未触发endfunction Output(block)    u = block.InputPort(1).Data;    prev = block.Dwork(1).Data;    % 只在输入从 0 → 1 的跳变时执行    if u == 1 &amp;&amp; prev == 0        % 配置路径        exePath = &#x27;I:\XXX.exe&#x27;;        paramPath = &#x27;C:\Users\pc\Desktop\XXX&#x27;;        % 检查 EXE 是否存在        if ~isfile(exePath)            warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);            block.OutputPort(1).Data = -2;            block.Dwork(1).Data = u;            return;        end        % 检查参数路径是否存在        if ~isfolder(paramPath)            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);            block.OutputPort(1).Data = -3;            block.Dwork(1).Data = u;            return;        end        % 构造命令        exePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];        paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];        args = [&#x27;1|1|&#x27; paramPathQuoted];        cmd = [exePathQuoted &#x27; &#x27; args];        disp([&#x27;[XXX] 正在执行: &#x27; cmd]);        % 执行命令        status = system(cmd);        if status == 0            block.OutputPort(1).Data = 1;  % 成功        else            block.OutputPort(1).Data = -1; % 执行失败        end    else        block.OutputPort(1).Data = 0;  % 无触发    end    % 更新 Dwork 状态    block.Dwork(1).Data = u;end

该函数的主要作用是在 Simulink 中通过输入触发器调用外部程序 XXX.exe，实现如下特性：

支持多次触发执行，但只在输入信号从 0 到 1 的上升沿执行
执行结果通过输出端口返回状态码：
1 → 执行成功；
-1 → 执行失败；
-2 → EXE 路径不存在；
-3 → 参数路径不存在；
0 → 没有触发。



主函数部分function sfun_callXXX(block)% Level-2 MATLAB S-Function: 可多次触发执行 XXX.exe，并做路径检查setup(block);end

这是主入口函数，Simulink 在加载该 S-Function 时会调用这个函数。block 是代表这个 S-Function 块的对象，包含输入输出、状态等所有接口
function setup(block)

block.NumInputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;  % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;

设置只有 1 个输入端口，类型为 double 实数，输入数据是一个触发信号，为 1 表示要执行 XXX.exe
block.NumOutputPorts = 1;block.SetPreCompOutPortInfoToDynamic;block.OutputPort(1).Dimensions   = 1;block.OutputPort(1).DatatypeID   = 0;block.OutputPort(1).Complexity   = &#x27;Real&#x27;;

也只有 1 个输出端口，用于输出执行状态
block.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;block.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;

Dwork 是 S-Function 中的离散状态变量，在仿真期间保留，这里用来保存上一时刻的输入值，从而判断是否出现了 0→1 的跳变（上升沿）
block.SampleTimes = [1.0 0.0];block.SimStateCompliance = &#x27;DefaultSimState&#x27;;block.InitializeConditions = @InitConditions;block.Outputs              = @Output;

SampleTimes = [1.0 0.0] → 每 1 秒调用一次 Output 函数，注册初始化函数和主输出函数
初始化函数 InitConditionsfunction InitConditions(block)    block.Dwork(1).Data = 0;  % 初始值设为0，表示“未触发”end

初始化 Dwork 状态变量，表示开始时没有任何触发信号
主执行函数 Outputfunction Output(block)

u = block.InputPort(1).Data;prev = block.Dwork(1).Data;

u 是当前输入值，prev 是上一个采样时刻的输入值，用于检测跳变
if u == 1 &amp;&amp; prev == 0


只有从 0 → 1 的跳变，才执行外部命令
如果持续为 1，不会重复执行

exePath = &#x27;...XXX.exe&#x27;;paramPath = &#x27;...指定输入&#x27;;

exePath 是要调用的外部可执行文件路径，paramPath 是输入数据或配置文件的路径
if ~isfile(exePath)    warning(&#x27;[XXX] EXE 路径不存在: %s&#x27;, exePath);    block.OutputPort(1).Data = -2;    block.Dwork(1).Data = u;    return;endif ~isfolder(paramPath)    warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);    block.OutputPort(1).Data = -3;    block.Dwork(1).Data = u;    return;end


如果 EXE 不存在 → 返回 -2
如果参数目录不存在 → 返回 -3

exePathQuoted = [&#x27;&quot;&#x27; exePath &#x27;&quot;&#x27;];paramPathQuoted = [&#x27;&quot;&#x27; paramPath &#x27;&quot;&#x27;];args = [&#x27;1|1|&#x27; paramPathQuoted];cmd = [exePathQuoted &#x27; &#x27; args];disp([&#x27;[XXX] 正在执行: &#x27; cmd]);


把路径加引号是为了防止路径中有空格报错

执行命令类似于（根据自己的可执行文件进行修改，这里的1|1|是参数需要）
&quot;I:\...\XXX.exe&quot; 1|1|&quot;C:\Users\...\指定输入&quot;

status = system(cmd);if status == 0    block.OutputPort(1).Data = 1;  % 成功else    block.OutputPort(1).Data = -1; % 失败end


system(cmd) 用于调用系统命令
如果返回值为 0，表示执行成功 → 输出 1
否则 → 输出 -1

else    block.OutputPort(1).Data = 0;  % 无触发，不执行end


输入无变化或不是上升沿时，输出 0

block.Dwork(1).Data = u;


用当前输入值覆盖 Dwork，供下一次仿真调用使用




输出值
含义



1
成功执行 XXX.exe


-1
执行失败


-2
找不到 EXE


-3
参数目录不存在


0
无触发（未上升沿）


代码流程概览


阶段
Simulink 触发
函数
功能描述



模块加载时
Simulink 加载模型
sfun_callXXX() → setup()
初始化输入输出端口、采样时间、Dwork 状态变量等


仿真开始时
点击仿真按钮 Run
InitializeConditions()
将 prevInput 初始化为 0


每个仿真步
每秒调用一次
Output()
检测输入信号是否跳变为 1，如果是就执行 XXX.exe


在Simulink中使用S Function在命令行窗口输入simulink或直接点击菜单面板“Simulink”来打开Simulink仿真工具，新建空白模型

将该模型保存到当前目录下（与上述.m文件相同），在库浏览器中依次将Constant、Level-2 MATLAB S-Function（不能直接选S-Function，因为我们的代码是针对Level 2的）、Display模块拖入，并连接如下

双击S-Function模块，将 S-function name 设为 sfun_callXXX，确认之后提示出错。
这里的主要原因为MATLAB Level-2 S-Function 的 Dwork 区只能在 PostPropagationSetup() 阶段设置，而目前把 NumDworks 和 Dwork 配置写在了 setup() 里，这是不允许的，修改如下
function sfun_callXXX(block)% Level-2 MATLAB S-Function：检测 0→1 边沿并调用 XXX.exe    setup(block);end%-----------------------------------------------------------%function setup(block)%% 1. 端口block.NumInputPorts  = 1;block.NumOutputPorts = 1;block.SetPreCompInpPortInfoToDynamic;block.SetPreCompOutPortInfoToDynamic;block.InputPort(1).Dimensions        = 1;block.InputPort(1).DatatypeID        = 0;   % doubleblock.InputPort(1).Complexity        = &#x27;Real&#x27;;block.InputPort(1).DirectFeedthrough = true;block.OutputPort(1).Dimensions = 1;block.OutputPort(1).DatatypeID = 0;block.OutputPort(1).Complexity = &#x27;Real&#x27;;%% 2. 采样时间（每 1 s 执行一次）block.SampleTimes = [1 0];%% 3. S-Function 状态机合规block.SimStateCompliance = &#x27;DefaultSimState&#x27;;%% 4. 注册回调 —— 用 RegBlockMethod（关键）block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostPropSetup);block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitConditions);block.RegBlockMethod(&#x27;Outputs&#x27;,              @Output);end%-----------------------------------------------------------%function PostPropSetup(block)%% Dwork 在此阶段声明block.NumDworks = 1;block.Dwork(1).Name            = &#x27;prevInput&#x27;;block.Dwork(1).Dimensions      = 1;block.Dwork(1).DatatypeID      = 0;  % doubleblock.Dwork(1).Complexity      = &#x27;Real&#x27;;block.Dwork(1).UsedAsDiscState = true;end%-----------------------------------------------------------%function InitConditions(block)%% 仿真开始时：prevInput 置零block.Dwork(1).Data = 0;end%-----------------------------------------------------------%function Output(block)%% 边沿检测 + 执行外部 EXEu    = block.InputPort(1).Data;prev = block.Dwork(1).Data;if u == 1 &amp;&amp; prev == 0    % 路径设定    exePath   = &#x27;I:\XXX.exe&#x27;;    paramPath = &#x27;C:\Users\pc\Desktop\XXX&#x27;;    % -------- 路径检查（兼容旧版 MATLAB：用 exist） --------    if exist(exePath,&#x27;file&#x27;) ~= 2        warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath);        block.OutputPort(1).Data = -2;    elseif exist(paramPath,&#x27;dir&#x27;) ~= 7        warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath);        block.OutputPort(1).Data = -3;    else        % 构造命令        cmd = [&#x27;&quot;&#x27; exePath &#x27;&quot; 1|1|&quot;&#x27; paramPath &#x27;&quot;&#x27;];        disp([&#x27;[XXX] 执行: &#x27; cmd]);        status = system(cmd);        block.OutputPort(1).Data = double(status == 0) * 2 - 1;  % 1 成功 /-1 失败    endelse    block.OutputPort(1).Data = 0;                                % 未触发end% 更新上周期输入block.Dwork(1).Data = u;end

运行仿真，观察到Display显示为1表明正确调用执行，为了方便截图，我把Display换为Scope，观察如下

第一秒，输入从0→1 调用exe成功并输出1，第二秒没有跳变发生，输出为0
Simulink 对该 S-Function 模块的调用时序如下



时间
执行
来自 S-Function 的函数调用
说明



0s
初始化
setup() → InitializeConditions()
初始化端口、状态变量（prevInput&#x3D;0）


每秒
仿真步
Output() 被调用一次
判断输入信号是否从 0→1 变化，若是就调用 EXE


假设输入信号如下



步数
输入 u
prevInput
是否执行 EXE？
输出值



1
0
0
否
0


2
1
0
是（跳变）
1 &#x2F; -1


3
1
1
否
0


4
0
1
否
0


5
1
0
是（跳变）
1 &#x2F; -1


]]></content>
      <categories>
        <category>Simulink仿真</category>
      </categories>
      <tags>
        <tag>Simulink</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode插件开发-文件统计功能</title>
    <url>/posts/57a69459.html</url>
    <content><![CDATA[修改package.json
在开发 VS Code 插件时，package.json 是整个插件的“说明书”。这里以一个简单的功能为例进行测试
&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;],&quot;main&quot;: &quot;./out/extension.js&quot;,&quot;contributes&quot;: &#123;  &quot;commands&quot;: [    &#123;      &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,      &quot;title&quot;: &quot;File State&quot;,      &quot;category&quot;: &quot;Code Auto Test&quot;    &#125;  ],  &quot;menus&quot;: &#123;    &quot;editor/context&quot;: [      &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ],    &quot;explorer/context&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,        &quot;group&quot;: &quot;navigation&quot;      &#125;    ]  &#125;&#125;
&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.getFileState&quot;]

意义：插件不会在 VS Code 启动时就加载，而是在用户执行命令 code-auto-test.getFileState 时激活。
优势：提升启动性能，遵循 VS Code 插件的延迟加载机制。

指定插件的主入口
&quot;main&quot;: &quot;./out/extension.js&quot;

指向插件的主模块，通常是 TypeScript 编译后的文件。
extension.js 中通常包含 activate(context) 和 deactivate() 函数，用于插件的生命周期管理。

注册自定义命令
&quot;commands&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;title&quot;: &quot;File State&quot;,    &quot;category&quot;: &quot;Code Auto Test&quot;  &#125;]

command：命令的唯一标识符，供代码调用。
title：在命令面板（Ctrl+Shift+P）中的显示名称。
category：命令分类，显示为 &quot;Code Auto Test: File State&quot;。

执行位置包括：

命令面板
上下文菜单（通过 menus 配置）

集成到右键菜单中
编辑器右键菜单
&quot;editor/context&quot;: [  &#123;    &quot;when&quot;: &quot;editorFocus&quot;,    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]

插入位置：当编辑器中有焦点时，在右键菜单的“导航”区域显示。
when: 上下文条件，这里为 editorFocus 表示编辑器有焦点时才显示。

资源管理器右键菜单
&quot;explorer/context&quot;: [  &#123;    &quot;command&quot;: &quot;code-auto-test.getFileState&quot;,    &quot;group&quot;: &quot;navigation&quot;  &#125;]

插入位置：资源管理器（文件树）右键菜单中。
可用于对选中的文件/文件夹执行操作。

通过这段简单的配置，我们实现了一个功能完整的 VS Code 插件功能点：



功能
实现方式




延迟激活
activationEvents 指定命令触发激活


注册命令
contributes.commands


集成编辑器右键菜单
menus.editor/context


集成资源管理器右键菜单
menus.explorer/context



这套模式是编写 VS Code 插件的基础，适用于各种需要通过右键或命令面板触发逻辑的场景，比如自动测试、代码分析、格式化工具等。
修改extension.ts
查看文件状态的命令实现（extension.ts）
我们前面在 package.json 中注册了命令 code-auto-test.getFileState，接下来在插件主入口文件中进行具体实现。
文件路径：src/extension.ts
// 引入 VS Code 扩展 APIimport * as vscode from &#x27;vscode&#x27;;import * as fs from &#x27;fs&#x27;;// 插件激活时触发export function activate(context: vscode.ExtensionContext) &#123;	console.log(&#x27;插件已激活：code-auto-test&#x27;);	// 注册 getFileState 命令	const disposable = vscode.commands.registerCommand(&#x27;code-auto-test.getFileState&#x27;, (uri: vscode.Uri) =&gt; &#123;		// 获取文件路径		const filePath = uri.fsPath;		// 异步获取文件信息		fs.stat(filePath, (err, stats) =&gt; &#123;			if (err) &#123;				vscode.window.showErrorMessage(`获取文件信息失败: $&#123;err.message&#125;`);				return;			&#125;			// 判断是否为文件夹			if (stats.isDirectory()) &#123;				vscode.window.showWarningMessage(&#x27;检测的是文件夹，不是文件，请重新选择！&#x27;);				return;			&#125;			// 若是普通文件，显示基本信息			if (stats.isFile()) &#123;				const size = stats.size;				const createTime = stats.birthtime.toLocaleString();				const modifyTime = stats.mtime.toLocaleString();				vscode.window.showInformationMessage(					` 文件大小: $&#123;size&#125; 字节\n 创建时间: $&#123;createTime&#125;\n 修改时间: $&#123;modifyTime&#125;`,					&#123; modal: true &#125;				);			&#125;		&#125;);		// 调试用：同步读取 stat 信息输出日志		try &#123;			const statsSync = fs.statSync(filePath);			console.log(&#x27;statSync:&#x27;, statsSync);			console.log(&#x27;isFile:&#x27;, statsSync.isFile());		&#125; catch (err) &#123;			console.error(&#x27;statSync 读取失败:&#x27;, err);		&#125;	&#125;);	// 将命令加入插件上下文中	context.subscriptions.push(disposable);&#125;// 插件被卸载时触发export function deactivate() &#123;&#125;



功能点
说明




vscode.Uri
命令参数自动传入，支持从资源管理器中点击文件触发命令。


fs.stat()
异步获取文件状态，包含文件大小、创建时间、修改时间等。


fs.statSync()
同步版本，用于调试或日志输出。


vscode.window.showInformationMessage(..., &#123; modal: true &#125;)
使用模态窗口展示信息，确保用户注意查看。



在编辑器中右键文件：

显示：File State
点击后弹出文件大小、创建时间、修改时间

在资源管理器中右键文件：

同样支持显示该命令
若选中文件夹则给出提示


通过 package.json + extension.ts，我们构建了一个结构完整、功能清晰的 VS Code 插件，具备以下特征：

延迟激活（按需加载）
支持右键菜单调用
使用原生 Node.js 文件系统 API 获取信息
弹出信息提示（用户交互友好）

]]></content>
      <categories>
        <category>VSCode插件</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实战之Web开发</title>
    <url>/posts/1a56256.html</url>
    <content><![CDATA[创建Django项目我使用Pycharm来创建Django项目，也可以自己手动创建虚拟环境等，配置如下，所有代码可点击这里查看

运行，在浏览器输入http://localhost:8000/，显示如下表明项目创建正确

创建应用程序终端输入python manage.py migrate创建数据库，用于将项目相关的信息存储，然后输入python manage.py startapp learning_log来创建应用程序，项目结构如下

.venv/
Python 虚拟环境目录。
包含你项目安装的所有依赖（如 Django）。
通常会在 .gitignore 中忽略它。

manage.py
管理工具脚本，用于执行各种 Django 命令，如：
python manage.py runserver      # 启动开发服务器python manage.py makemigrations # 创建迁移python manage.py migrate        # 应用迁移到数据库python manage.py createsuperuser # 创建管理员账户

__init__.py
让该目录成为 Python 包可为空

settings.py
Django 项目的配置文件
包含数据库设置、应用注册、模板路径、静态文件配置、安全设置等

urls.py
项目级URL 路由入口

将不同的 URL 请求分发给对应的 app 处理

通常写法：
from django.urls import path, includeurlpatterns = [    path(&#x27;admin/&#x27;, admin.site.urls),    path(&#x27;&#x27;, include(&#x27;learning_log.urls&#x27;)),  # 指向 app 的 url]

wsgi.py
用于部署到 WSGI 服务器
生产环境使用

asgi.py
用于部署到 ASGI 服务器
用于支持 WebSocket、异步视图

__init__.py
表示这是一个 Python 包

admin.py
用于注册模型到 Django 管理后台（admin site）

示例：
from django.contrib import adminfrom .models import Entryadmin.site.register(Entry)

apps.py
定义 app 的元信息，通常不需修改
当你在 INSTALLED_APPS 中注册 app 时，这里也会用到

models.py
定义数据模型（Model）类
每个模型对应数据库中的一张表

views.py
视图函数，用来处理用户请求并返回响应
例如返回 HTML 页面、JSON 数据等

tests.py
单元测试文件，可编写自动化测试
Django 内建测试框架基于 Python 的 unittest

migrations/
自动生成的数据库迁移文件

每当你修改模型（models.py）并运行：
python manage.py makemigrations

就会在此生成一个迁移脚本，用于记录数据库变更


templates/
存放 HTML 模板文件的目录
用于 Django 的模板引擎渲染页面

例如： 你可以在 templates/ 中创建 index.html，然后在视图中渲染：
from django.shortcuts import renderdef index(request):    return render(request, &#x27;index.html&#x27;)

db.sqlite3
默认使用的 SQLite 数据库文件
存储了你项目所有模型的数据内容




文件&#x2F;文件夹
作用说明



.venv/
虚拟环境，包含依赖


manage.py
管理命令脚本


DjangoProject/settings.py
项目配置


DjangoProject/urls.py
URL 路由入口


DjangoProject/wsgi.py
部署用 WSGI 接口


learning_log/
自定义 app


models.py
定义数据库模型


views.py
编写视图函数


admin.py
注册后台模型


migrations/
数据库变更记录


templates/
HTML 模板目录


db.sqlite3
SQLite 数据库文件


应用设置修改models.py文件如下
from django.db import models# Create your models here.class Topic(models.Model):    &quot;&quot;&quot;A topic the user is learning about.&quot;&quot;&quot;    text = models.CharField(max_length=200)    date_added = models.DateTimeField(auto_now_add=True)    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        return self.text

在settings.py的INSTALLED_APPS中添加learning_log，然后执行数据库迁移，如下
python manage.py makemigrationspython manage.py migrate 


创建超级用户输入python manage.py createsuperuser来创建管理者，账户名、密码、邮箱自行设置，其中密码会被隐藏

随后在admin.py文件中修改代码如下
from django.contrib import adminfrom learning_log.models import Topic# Register your models here.admin.site.register(Topic)

这段代码用于向管理网站注册Topic
由于我在创建项目时没有勾选“启用Django admin”，因此这里需要对项目进行简单的更改

将urls.py中注释的部分取消
# from django.contrib import adminfrom django.urls import pathurlpatterns = [    #    path(&#x27;admin/&#x27;, admin.site.urls),]

在settings.py的INSTALLED_APPS中添加django.contrib.admin


访问http://localhost:8000/admin/，显示如下

输入账户和密码，登录进去界面显示如下

User和Group是Django自动在管理网站添加的模型，而Topic是我们刚刚自己添加的。此时可以点击Topic，添加任意的主题
定义Entry在models.py中添加如下代码
class Entry(models.Model):    &quot;&quot;&quot;Something specific learned about a topic.&quot;&quot;&quot;    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)    text = models.TextField()    date_added = models.DateTimeField(auto_now_add=True)    class Meta:        verbose_name_plural = &#x27;entries&#x27;    def __str__(self):        &quot;&quot;&quot;Return a string representation of the model.&quot;&quot;&quot;        if len(self.text) &gt; 50:            return f&quot;&#123;self.text[:50]&#125;...&quot;        else:            return self.text

这里主要说一下两个地方

topic = models.ForeignKey(Topic, on_delete=models.CASCADE)是将每一条 Entry 都关联一个 Topic，形成多对一的关系

元信息配置（Meta）：默认 Django 会把模型名称小写加 “s” 做复数，这句是为了告诉 Django这个模型的复数名称设置为 entries，而不是默认的 Entrys


由于修改了模型文件，因此我们需要再次迁移数据库，执行
python manage.py makemigrations learning_logpython manage.py migrate 

然后在管理网站注册Entry：admin.site.register(Entry)（有关模型导入的问题这里不做叙述）
进入管理网站后会发现多出了一个Entries条目，进入该条目，点击下拉框就可以选择对应的主题，如下图

这时候我们就可以创建条目并将其与对应的主题相关联。不过，目前除了后台管理界面，我们还没任何可供用户访问的界面，下一步我们将尝试创建一个网页来让其他人访问
创建网页使用Django创建网页主要分为三个步骤，定义URL、编写视图、编写模板，完成这三个部分的顺序通常无关紧要，每个人都可以按照个人喜好来实现
映射URL当前http://localhost:8000返回默认的Django网站，下面进行修改，打开urls.py文件，在`urlpatterns`中添加`path(‘’, include(‘learning_log.urls’)),&#96;表示我们导入应用learning_log中的url。然后在应用learning_log中添加urls.py文件，内容如下
from django.urls import pathfrom . import viewsapp_name = &#x27;learning_log&#x27;urlpatterns = [    # Home page    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),]

这段代码主要为当前 app 即（learning_log）配置 URL 路由，其中app_name = &#39;learning_log&#39;，给这个 app 的 URL 配置一个命名空间，防止与其他 app 中的 URL 名称冲突，在模板中使用 &#123;% url 'learning_log:index' %&#125; 就能明确地调用这个 URL。urlpatterns 是 Django 查找 URL 的核心列表，每一个 path() 定义了一个 URL 与视图的映射。path(&#39;&#39;, views.index, name=&#39;index&#39;),第一个参数是一个字符串用于正确的路由请求，这里表示匹配根路径，第二个参数表示当匹配到 / 时，调用 views.py 中的 index() 函数，第三个参数给这个 URL 取了一个名字叫 &#39;index&#39;，在模板中可以用 &#123;% url 'learning_log:index' %&#125; 来反向生成地址
编写视图视图函数接受请求中的信息，准备好生成网页所需的数据，然后将其发送给浏览器。在前面我们调用了 views.py 中的 index() 函数，但该函数还未编写，打开views.py文件，添加代码如下
from django.shortcuts import render# Create your views here.def index(request):    return render(request, &#x27;learning_log/index.html&#x27;)

它接受一个 request 对象作为参数，这是 Django 在用户访问网页时自动传入的请求信息对象。函数的返回值是 render(request, &#39;learning_log/index.html&#39;)，表示让 Django 去找一个路径为 learning_log/index.html 的模板文件，并渲染它，默认的模板查找路径为app/templates/app_name/文件名.html 
编写模板模板定义网页的外观，每当访问网页时，Django都将填入相关的数据用于显示，我们的template文件夹位于根目录，所以无需在app目录中重新创建，但需要在settings.py的TEMPLATES中检查是否存在&#39;DIRS&#39;: [BASE_DIR / &#39;templates&#39;]，以便正确检索html文件
在template文件夹中创建learning_log文件夹并在其中创建index.html，添加代码如下
&lt;p&gt;Learning Log&lt;/p&gt;&lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.&lt;/p&gt;

这里添加了两个段落，运行访问界面如下

创建其他网页创建父模板在index.html所在的目录中，创建一个base.html文件，这个模板将包含所有页面的通用元素，并将所有子模板都继承它，添加内容如下
&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;&#123;% block content %&#125;&#123;% endblock content %&#125;

&lt;p&gt;    &lt;a href=&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;&gt;Learning Log&lt;/a&gt;&lt;/p&gt;

这段表示页面顶部的一个链接，点击后会跳转到名为 &#39;learning_log:index&#39; 的 URL 对应的页面。

&#123;% url 'learning_log:index' %&#125; 是 Django 模板语言提供的 URL 反向解析标签。
&#39;learning_log&#39; 是在 learning_log/urls.py 中定义的 app_name。
&#39;index&#39; 是在 urlpatterns 中为首页设置的 name。

所以最终这个标签会被渲染为：
&lt;a href=&quot;/&quot;&gt;Learning Log&lt;/a&gt;

如果将 index 页面映射到 /，那么这个链接就是返回首页的作用。
&#123;% block content %&#125;&#123;% endblock content %&#125;

这是 Django 模板语言中非常关键的部分，称为 模板块（template block），它用于定义“可扩展区域”。
解释如下：

&#123;% block content %&#125;` 是定义一个名为 `content` 的内容区块。
- `&#123;% endblock content %&#125; 表示这个区块的结束。

换句话说，子模板可以继承这个模板，并用自己的内容替换掉这个 block 区域，例如：
&#123;% extends &quot;learning_log/base.html&quot; %&#125;&#123;% block content %&#125;  &lt;h2&gt;This is the home page!&lt;/h2&gt;&#123;% endblock content %&#125;

创建子模板重写index.html文件，使其继承base.html，如下
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Learning Log is a tool for tracking your learning progress.     It allows you to create entries for each topic you are studying,     including notes, resources, and reflections.     You can also categorize your entries by subject or skill level.    &lt;/p&gt;&#123;% endblock content %&#125;

这里将index从base继承下来，使用&#123;% block content %&#125;`定义一个`content`并插入内容，使用`&#123;% endblock content %&#125;结束content块，里面内容将显示在界面上，此时通过修改父模板将修改所有继承它的界面，方便统一管理
显示所有主题的页面首先定义URL，添加path(&#39;topics/&#39;,  views.topics, name=&#39;topics&#39;)，在视图中定义topics函数如下
def topics(request):    &quot;&quot;&quot;Show all topics.&quot;&quot;&quot;    topics = Topic.objects.order_by(&#x27;date_added&#x27;)    context = &#123;&#x27;topics&#x27;: topics&#125;    return render(request, &#x27;learning_log/topics.html&#x27;, context)

将所有主题按照时间顺序排序并返回，然后创建topics.html，内容如下
&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topics&lt;/p&gt;    &lt;ul&gt;        &#123;% for topic in topics %&#125;            &lt;li&gt;&#123;&#123; topic.text &#125;&#125;&lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No topics have been created yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;&#123;% endblock content %&#125;

这里主要将topics中的内容通过无序列表的方式呈现出来。随后在base.html中添加连字符以及代码&lt;a href=&quot;&#123;% url 'learning_log:topics' %&#125;&quot;&gt;Topics&lt;/a&gt;，这将产生一个与Topics匹配的URL链接，访问http://localhost:8000/topics/，如下![image-20250712114413813](https://cdn.jsdelivr.net/gh/psmarter/blog-imgs/Python%E5%AE%9E%E6%88%98%E4%B9%8BWeb%E5%BC%80%E5%8F%91%2F2025-07-12-23-47-46-91b35a.png)
显示特定主题我们已经创建了两次页面，对其基本流程应该有所了解了，后续关于URL、视图、模板相关的内容将进行简略，我们再次创建一个页面用于显示特定的主题及其所有的条目
# URLpath(&#x27;topics/&lt;int:topic_id&gt;/&#x27;, views.topic, name=&#x27;topic&#x27;)# topic函数def topic(request, topic_id):    &quot;&quot;&quot;Show a single topic and all its entries.&quot;&quot;&quot;    topic = Topic.objects.get(id=topic_id)    entries = topic.entry_set.order_by(&#x27;-date_added&#x27;)    context = &#123;&#x27;topic&#x27;: topic, &#x27;entries&#x27;: entries&#125;    return render(request, &#x27;learning_log/topic.html&#x27;, context)

&#123;# 模板 #&#125;&#123;% extends &#x27;learning_log/base.html&#x27; %&#125;&#123;% block content %&#125;    &lt;p&gt;Topic:&#123;&#123; topic.text &#125;&#125;&lt;/p&gt;        &lt;p&gt;Entries:&lt;/p&gt;    &lt;ul&gt;            &#123;% for entry in entries %&#125;            &lt;li&gt;                &lt;p&gt;&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;&lt;/p&gt;                &lt;p&gt;&#123;&#123; entry.text|linebreaks &#125;&#125;&lt;/p&gt;            &lt;/li&gt;        &#123;% empty %&#125;            &lt;li&gt;No entries have been created for this topic yet.&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% endblock content %&#125;

在topic函数中先通过id获取到特定的主题，然后将主题中的条目降序排列，最后将Topic和Entries返回。模板主要把entries按照特定的格式显示，“|”表示过滤符，也就是将时间按照：January 1, 2025 23:00格式。linebreaks是将文本中的换行符转变为浏览器理解的内容。
然后修改topics.html，将每个主题都映射为对应的链接
&#123;% for topic in topics %&#125;    &lt;li&gt;        &lt;a href=&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;&gt;&#123;&#123; topic.text &#125;&#125;&lt;/a&gt;    &lt;/li&gt;

运行之后在Topic页面点击主题，显示如下

]]></content>
      <categories>
        <category>Diango开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>创建VS Code插件</title>
    <url>/posts/7d850c90.html</url>
    <content><![CDATA[本人打算创建一个VS Code插件用于调试代码，拟结合AI用于生成测试用例，分析代码等
环境准备安装Node.isVS Code 插件开发使用 JavaScript &#x2F; TypeScript 编写，需要 Node.js 来运行开发脚本和构建流程
官网：https://nodejs.org
安装后验证是否成功
node -v


安装脚手架这里会用到yo和generator-code
yo 是 Yeoman 的命令行工具，是一个用于快速生成项目脚手架的工具，类似于项目生成器
generator-code 是一个 Yeoman 生成器插件，专门用于生成 VS Code 插件项目 的脚手架。
全局安装yo和generator-code
npm i -g yo generator-code

我这里已经安装过了，输出如下

创建VS Code插件项目新建工程在你需要创建插件的目录下输入
yo code

执行如下


[!NOTE]
这里将会依次问你如下几个问题

选择你的插件类型
插件的名字
插件的唯一标识
插件的描述
是否需要git仓库
打包工具选择
选择包管理工具


我的配置如图

选择完成之后出现如下内容

然后可以选择打开新建的工程或者直接跳过，这里选择第一个，打开之后项目结构如图所示，其中最重要的文件是package.json和extension.js，到这里一个VS Code的框架算是基本完成了。

目录介绍
[!NOTE]
.vscode: 里面的文件是用来测试插件或者测试代码的一些文件。node_modules: 第三方依赖。src/test：测试文件。src/extension.ts：插件的主文件

package.json文件该文件是vscode扩展的清单文件，具体可以看文档：发布内容配置
&#123;  &quot;name&quot;: &quot;code-auto-test&quot;,	// 插件名  &quot;displayName&quot;: &quot;code-auto-test&quot;,	// 应用市场显示的名字  &quot;description&quot;: &quot;自动执行代码测试&quot;,	// 插件描述  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;engines&quot;: &#123;    &quot;vscode&quot;: &quot;^1.101.0&quot;  &#125;,  &quot;categories&quot;: [    &quot;Other&quot;	// 扩展类别  ],   // 激活事件组，在那些事件情况下被激活  &quot;activationEvents&quot;: [],   // 插件的主入口文件  &quot;main&quot;: &quot;./out/extension.js&quot;,  &quot;contributes&quot;: &#123;     // 命令    &quot;commands&quot;: [      &#123;        &quot;command&quot;: &quot;code-auto-test.helloWorld&quot;,        &quot;title&quot;: &quot;Hello World&quot;      &#125;    ]  &#125;,  &quot;scripts&quot;: &#123;    &quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,    &quot;compile&quot;: &quot;tsc -p ./&quot;,    &quot;watch&quot;: &quot;tsc -watch -p ./&quot;,    &quot;pretest&quot;: &quot;npm run compile &amp;&amp; npm run lint&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;test&quot;: &quot;vscode-test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@types/vscode&quot;: &quot;^1.101.0&quot;,    &quot;@types/mocha&quot;: &quot;^10.0.10&quot;,    &quot;@types/node&quot;: &quot;20.x&quot;,    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.31.1&quot;,    &quot;@typescript-eslint/parser&quot;: &quot;^8.31.1&quot;,    &quot;eslint&quot;: &quot;^9.25.1&quot;,    &quot;typescript&quot;: &quot;^5.8.3&quot;,    &quot;@vscode/test-cli&quot;: &quot;^0.0.10&quot;,    &quot;@vscode/test-electron&quot;: &quot;^2.5.2&quot;  &#125;&#125;

extension.js文件入口文件，即package.json中main字段对应的文件，文件中有导出两个方法：activate和deactivate
测试在package.json文件中添加激活事件
&quot;activationEvents&quot;: [&quot;onCommand:code-auto-test.helloWorld&quot;],

终端进入项目
cd code-auto-testnpm installnpm run compile

这会将 src/extension.ts 编译到 out/extension.js，为插件运行做好准备
F5运行插件，会启动扩展宿主环境，打开任意文件夹，按下ctrl+shift+p 并输入helloworld

确认选择Hello World，右下角出现如图内容表明运行成功

先到这吧，累了😮‍💨
]]></content>
      <categories>
        <category>VSCode插件</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.09.30)</title>
    <url>/posts/5c81f568.html</url>
    <content><![CDATA[一：环形链表

1. 哈希表
遍历节点并将节点存入哈希表，判断表中是否存在之前的节点即可
class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return true;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return false;    &#125;&#125;;
public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return true;			// 或if (!hashTable.add(head)) return true;            hashTable.add(head);            head = head.next;        &#125;        return false;    &#125;&#125;
class Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        hashTable = set()        while head:            if head in hashTable:                return True            hashTable.add(head)            head = head.next        return False

2. 快慢指针
通过两个不同的指针来表示行进速度，差值为1，从初始到最后相遇相当于快指针多走了一个环
class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return false;        ListNode* fastNode = head-&gt;next;        // 相差一个起始位置，从而进入循环        ListNode* slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return false;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;        &#125;        return true;    &#125;&#125;;
public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        ListNode fastNode = head.next;        // 相差一个起始位置，从而进入循环        ListNode slowNode = head;        while (slowNode != fastNode)        &#123;            if (fastNode == null || fastNode.next == null) return false;            slowNode = slowNode.next;            fastNode = fastNode.next.next;        &#125;        return true;    &#125;&#125;
class Solution:    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:        if head is None or head.next is None:            return False        fastNode = head.next;        # 相差一个起始位置，从而进入循环        slowNode = head        while slowNode != fastNode:            if fastNode is None or fastNode.next is None:                return false            slowNode = slowNode.next            fastNode = fastNode.next.next        return True

二：合并两个有序链表

1. 迭代
依次比较两个链表中的值，较小值放在较大值的前面
class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);			// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;
class Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)			# 没有new        cur = preNode        if not list1:			# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next

2. 递归
根据最小值按照相反方向逐一返回
class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (!list1) return list2;        if (!list2) return list1;        if (list1-&gt;val &lt; list2-&gt;val)        &#123;            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);            return list1;        &#125; else        &#123;            list2-&gt;next = mergeTwoLists(list2-&gt;next, list1);            return list2;        &#125;    &#125;&#125;;
class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        if (list1 == null) return list2;        if (list2 == null) return list1;        if (list1.val &lt; list2.val)        &#123;            list1.next = mergeTwoLists(list1.next, list2);            return list1;        &#125; else        &#123;            list2.next = mergeTwoLists(list2.next, list1);            return list2;        &#125;    &#125;&#125;
class Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if list1 == None:            return list2        if list2 == None:            return list1        if list1.val &lt; list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list2.next, list1)            return list2

三：二叉树的中序遍历

1. 递归
先逐层访问左节点，然后保存当前值，再访问右节点
class Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        recursion(root);        return nodes;    &#125;    void recursion(TreeNode* root)    &#123;        if (!root) return;        recursion(root-&gt;left);        nodes.emplace_back(root-&gt;val);        recursion(root-&gt;right);    &#125;&#125;;
class Solution &#123;    private List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();		// 需要new    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        recursion(root);        return nodes;    &#125;    public void recursion(TreeNode root)    &#123;        if (root == null) return;        recursion(root.left);        nodes.add(root.val);        recursion(root.right);    &#125;&#125;
class Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        self.nodes = []        self._recursion(root)        return self.nodes    def _recursion(self, root: Optional[TreeNode]):        if not root:            return        self._recursion(root.left)        self.nodes.append(root.val)				# 这里使用append        self._recursion(root.right)

2. 迭代
这里需要一个栈来维护树的层次
class Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            nodes.emplace_back(root-&gt;val);            treeStack.pop();                    // 拿到数据出栈            root = root-&gt;right;       &#125;        return nodes;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            nodes.add(root.val);            root = root.right;        &#125;        return nodes;    &#125;&#125;
class Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            nodes.append(root.val)            root = root.right        return nodes

3. Morris 中序遍历
查找第一个左节点，然后遍历该结点的右节点，将最后一个右节点指向根节点，依次循环，访问时向右遍历即可
class Solution &#123;private:    vector&lt;int&gt; nodes;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        TreeNode* cur = nullptr;        while (root)        &#123;            if (root-&gt;left)            &#123;                cur = root-&gt;left;                while (cur-&gt;right != nullptr &amp;&amp; cur-&gt;right != root )                &#123;                    cur = cur-&gt;right;                &#125;                if (cur-&gt;right == nullptr)                &#123;                    cur-&gt;right = root;                    root = root-&gt;left;                &#125; else                &#123;                    nodes.emplace_back(root-&gt;val);                    cur-&gt;right = nullptr;           // 要赋空，否则死循环                    root = root-&gt;right;                &#125;            &#125; else             &#123;                nodes.emplace_back(root-&gt;val);                root = root-&gt;right;            &#125;        &#125;        return nodes;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();        TreeNode cur = null;        while (root != null)        &#123;            if (root.left != null)            &#123;                cur = root.left;                while (cur.right != null &amp;&amp; cur.right != root)     // cur.right != root必须有                &#123;                    cur = cur.right;                &#125;                if (cur.right == null)                &#123;                    cur.right = root;                    root = root.left;                &#125; else                &#123;                    nodes.add(root.val);                    cur.right = null;           // 要赋空，否则死循环                    root = root.right;                &#125;            &#125; else             &#123;                nodes.add(root.val);                root = root.right;            &#125;        &#125;        return nodes;    &#125;&#125;
class Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        nodes = []        cur = None        while root is not None:            if root.left is not None:                cur = root.left                while cur.right is not None and cur.right is not root:     # cur.right is not root必须有                    cur = cur.right                if cur.right == None:                    cur.right = root                    root = root.left                else:                    nodes.append(root.val)                    cur.right = None           # 要赋空，否则死循环                    root = root.right            else:                nodes.append(root.val)                root = root.right          return nodes

四：二叉树的最大深度

1. 深度优先搜索
利用递归依次遍历左右节点，取其中的较大值
class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;
class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; // 使用Math.max    &#125;&#125;
class Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1		# 加self

2. 广度优先搜索
用队列维护
class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == nullptr) return 0;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(root);        int depth = 0;        while (!treeQueue.empty())        &#123;            int size = treeQueue.size();            while (size &gt; 00)            &#123;                TreeNode* root = treeQueue.front();                treeQueue.pop();                if (root-&gt;left) treeQueue.push(root-&gt;left);                if (root-&gt;right) treeQueue.push(root-&gt;right);                --size;            &#125;            ++depth;        &#125;        return depth    &#125;&#125;;
class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;();        treeQueue.offer(root);      // 使用offer        int depth = 0;        while (treeQueue.isEmpty() == false)        &#123;            int size = treeQueue.size();            while (size &gt; 0)            &#123;                TreeNode newroot = treeQueue.poll();       // 使用poll                if (newroot.left != null) treeQueue.offer(newroot.left);                if (newroot.right != null) treeQueue.offer(newroot.right);                --size;            &#125;            ++depth;        &#125;        return depth;    &#125;&#125;
class Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root == None:            return 0        treeQueue = deque([root])         # 使用deque            depth = 0        while treeQueue:            size = len(treeQueue)            while size &gt; 0:                newroot = treeQueue.popleft()       # 使用popleft                if newroot.left:                    treeQueue.append(newroot.left)      # 使用append                if newroot.right:                    treeQueue.append(newroot.right)                size -= 1            depth += 1        return depth

五：翻转二叉树

1. 递归
左右节点依次递归，找到叶子节点，然后交换左右位置
class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        TreeNode* temp = root-&gt;left;        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = invertTree(temp);        return root;    &#125;&#125;;
class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        TreeNode temp = root.left;        root.left = invertTree(root.right);        root.right = invertTree(temp);        return root;    &#125;&#125;
class Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        temp = root.left		# 或平行赋值        root.left = self.invertTree(root.right)        root.right = self.invertTree(temp)        return root

2. 迭代
用队列维护
class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root == nullptr) return nullptr;        stack&lt;TreeNode*&gt; treeStack;        TreeNode* cur = nullptr;        TreeNode* temp = nullptr;        treeStack.push(root);        while (!treeStack.empty())        &#123;            cur = treeStack.top();            treeStack.pop();            if (cur-&gt;left != nullptr) treeStack.push(cur-&gt;left);            if (cur-&gt;right != nullptr) treeStack.push(cur-&gt;right);            temp = cur-&gt;left;            cur-&gt;left = cur-&gt;right;            cur-&gt;right = temp;        &#125;        return root;    &#125;&#125;;
class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) return null;        Stack&lt;TreeNode&gt; treeStack = new Stack&lt;&gt;();        treeStack.add(root);        TreeNode cur = null;        TreeNode temp = null;        while (!treeStack.isEmpty())        &#123;            cur = treeStack.pop();            if (cur.left != null) treeStack.add(cur.left);            if (cur.right != null) treeStack.add(cur.right);            temp = cur.left;            cur.left = cur.right;            cur.right = temp;        &#125;        return root;    &#125;&#125;
class Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root == None:            return None        treeStack = []        treeStack.append(root)        while treeStack:            cur = treeStack.pop()            if cur.left != None: treeStack.append(cur.left)            if cur.right != None: treeStack.append(cur.right)            cur.left, cur.right = cur.right, cur.left        return root

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.09.29)</title>
    <url>/posts/8c812416.html</url>
    <content><![CDATA[一：两数之和

1. 暴力
不写
2. 哈希表
哈希表通过用空间换时间，使用哈希函数将任意长度的键转换为一个固定范围的数组下标，时间复杂度为O(1)O(1)O(1)
class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; hashMap;        for(int i = 0; i &lt; nums.size(); ++i)        &#123;            auto it = hashMap.find(target - nums[i]);       // 返回迭代器            if(it != hashMap.end())             // 和尾后迭代器比对            &#123;                return &#123;it-&gt;second, i&#125;;         // 找到就返回下标            &#125;            hashMap[nums[i]] = i;               // 没找到就把数据添加进hash表        &#125;        return &#123;&#125;;    &#125;&#125;;
class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashMap = dict()        for i, num in enumerate(nums):          # 遍历            if target - nums[i] in hashMap:     # 是否存在，可把nums[i]改为num                return [hashMap[target - num], i]            hashMap[nums[i]] = i        return []        
class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;();         // 初始化一个哈希表        for( int i = 0; i &lt; nums.length; ++i)        &#123;            if(hashMap.containsKey(target - nums[i]))           // 这里的K大写            &#123;                return new int[]&#123;hashMap.get(target - nums[i]), i&#125;;            &#125;            hashMap.put(nums[i], i);        &#125;        return new int[0];              // 返回为空    &#125;&#125;

二：移动零

1. 双指针
题目要求不能复制，同时保证原有序列的顺序不变，因此只能交换非零值和零值的位置。

思路一：处理零值，将零和右边非零值进行交换
思路二：处理非零值，将非零值和左边零值进行交换

方式一需要不断寻找非零值，性能稍差，因此采用方式二
class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int Left = 0, Right = 0;                // Left的左边均为非零值，其指向第一个零值。Right的右边为未处理的序列，当前指向用于判断零值和非零值        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            if (nums[i])            &#123;                swap(nums[Left], nums[Right]);              // 交换位置                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;;
class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        Left = Right = 0        for num in nums:            if num:                nums[Left], nums[Right] = nums[Right], nums[Left]                Left += 1            Right += 1
class Solution &#123;    public void moveZeroes(int[] nums) &#123;        int Left = 0;        int Right = 0;        int temp;        for (int i = 0; i &lt; nums.length; ++i)        &#123;            if (nums[i] != 0)            &#123;                temp = nums[Left];                nums[Left] = nums[Right];                nums[Right] = temp;                ++Left;            &#125;            ++Right;        &#125;    &#125;&#125;

三：相交链表
1. Hash表
将其中一个链表的数据放入哈希表，第二个链表依次判断是否包含即可
class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode *&gt; hashTalble;        while (headA)        &#123;            hashTalble.insert(headA);            headA = headA-&gt;next;        &#125;        while (headB)        &#123;            if (hashTalble.count(headB))            &#123;                return headB;            &#125;            headB = headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;
class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        hashTable = set()        while headA:            hashTable.add(headA)            headA = headA.next              # 使用.运算符不是-&gt;，非指针                while headB:            if headB in hashTable:                return headB            headB = headB.next        return None             # 空为None        
public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (headA != null)               // 不能直接判断headA        &#123;            hashTable.add(headA);            headA = headA.next;             // 使用.        &#125;        while (headB != null)        &#123;            if (hashTable.contains(headB))            &#123;                return headB;            &#125;            headB = headB.next;        &#125;        return null;            // 使用null    &#125;&#125;

2. 双指针
使用两个指针指向两个链表的头结点，判断两个指针是否相等，走到末尾如果两者不相同则将指针赋值为另一个链表的头结点继续遍历，如果有相交结点，在不超过第二次遍历一定会在相交结点使两个指针相等
class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *pA = headA;        ListNode *pB = headB;        if (!pA || !pB)        &#123;            return nullptr;        &#125;        while (pA != pB)        &#123;            if (pA == nullptr) pA = headB;          // 可用三元运算符替代            else pA = pA-&gt;next;            if (pB == nullptr) pB = headA;            else pB = pB-&gt;next;        &#125;        return pA;    &#125;&#125;;
class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        pA = headA        pB = headB        while pA != pB:             # 也可以用is not            if not pA:              # 或if pA is None:                pA = headB            else:                pA = pA.next            if not pB:                pB = headA            else:                pB = pB.next        return pA
public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if (headA == null || headB == null)            return null;        ListNode pA = headA, pB = headB;        while (pA != pB)        &#123;            pA = (pA == null) ? headB : pA.next;            pB = pB == null ? headA : pB.next;        &#125;        return pA;    &#125;&#125;

四：反转链表


1. 迭代反转
根据头结点可获取到下一个结点，头结点的先前结点为空，可依次遍历将当前结点的指向进行反转，题目要求输出的结果也是反转的，因此需要返回最后一个结点
class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;				// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;
class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;
class Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre

2. 递归反转
依次传入下一个结点，并返回最后一个结点，与上一个解法的区别在于由后向前反转，此时不需要前继结点
class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (!head || !head-&gt;next)            // 链表为空或只有单结点        &#123;            return head;        &#125;        ListNode *Last = reverseList(head-&gt;next);           // 最后一个结点在这里        head-&gt;next-&gt;next = head;        // 这里不能用Last，因为Last不动，而head一直向前        head-&gt;next = nullptr;			// 必须设为空，否则第一个结点和第二个结点将互指        return Last;            // 一直返回最后一个结点    &#125;&#125;;
class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null)        &#123;            return head;        &#125;        ListNode Last = reverseList(head.next);        head.next.next = head;        head.next = null;        return Last;    &#125;&#125;
class Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head or not head.next:            return head        Last = self.reverseList(head.next)			// 这里要用self        head.next.next = head        head.next = None        return Last

五：回文链表

1. 数组
将链表中的数据复制到数组中，然后将数组反转或遍历第一个和最后一个数据进行比较
class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        while (head)        &#123;            vals.emplace_back(head-&gt;val);            head = head-&gt;next;        &#125;        for (int i = 0, j = static_cast&lt;int&gt;(vals.size() - 1); i &lt; j; ++i, --j)        &#123;            if (vals[i] != vals[j]) return false;        &#125;        return true;    &#125;&#125;;
class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();        while (head != null)        &#123;            vals.add(head.val);            head = head.next;        &#125;        for (int i = 0, j = vals.size() - 1; i &lt; j; ++i, --j)        &#123;            if (vals.get(i) != vals.get(j)) return false;        &#125;        return true;    &#125;&#125;
class Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        vals = []        while head:            vals.append(head.val)            head = head.next        return vals == vals[::-1]			# 可直接利用反转列表来比对

2. 递归
递归可以从后往前遍历，但是也需要从前往后的一个结点来进行对比
class Solution &#123;private:    ListNode *frontIteration = nullptr;			// 从前往后public:    bool isPalindrome(ListNode* head) &#123;        frontIteration = head;        return recursion(frontIteration);    &#125;    bool recursion(ListNode* head)    &#123;        if (head)        &#123;            if (!recursion(head-&gt;next))		// false继续返回false                &#123;                    return false;                &#125;            if (head-&gt;val != frontIteration-&gt;val) return false;		// true则进行比对            frontIteration = frontIteration-&gt;next;			// 每一层向后遍历        &#125;        return true;		// 末尾返回true    &#125;&#125;;
class Solution &#123;    private ListNode frontIteration = null;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        frontIteration = head;        return recursion(head);    &#125;    public boolean recursion(ListNode head)    &#123;        if (head != null)        &#123;            if (!recursion(head.next))            &#123;                return false;            &#125;            if (head.val != frontIteration.val) return false;            frontIteration = frontIteration.next;        &#125;        return true;    &#125;&#125;
class Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        self.frontIteration = head              # 成员变量的初始化，如果不在这里需要在__init__中        return self._recursion(head)    def _recursion(self, head: Optional[ListNode]) -&gt; bool:         # _表明内部使用，Optional表示可能的类型，-&gt; bool返回类型        if head:            if not self._recursion(head.next):                return False            if head.val != self.frontIteration.val:                return False            self.frontIteration = self.frontIteration.next        return True

3.快慢指针
该方法主要是寻找到链表的中间结点，然后将前半部分或者后半部分反转，对两部分进行比较，由于中间需要修改链表，并发处理下需要锁定其他线程或进程对链表的访问。快慢的意思则是通过两个指针，一个步长为2，另一个为1，当快指针到达尾节点时，慢指针到达中间结点，从而减少重复遍历的时间。反转可以使用之前的代码
class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if (!head) return true;        ListNode *lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != nullptr)        &#123;            if (head-&gt;val != lastNode-&gt;val) return false;            head = head-&gt;next;            lastNode = lastNode-&gt;next;        &#125;        return true;    &#125;    // 寻找中间节点，    ListNode* interMediateNode(ListNode* head)    &#123;        ListNode *fastNode = head;        ListNode *slowNode = head;        while (fastNode != nullptr &amp;&amp; fastNode-&gt;next-&gt;next != nullptr)        &#123;            fastNode = fastNode-&gt;next-&gt;next;            slowNode = slowNode-&gt;next;        &#125;        return slowNode;    &#125;    ListNode* reverseList(ListNode* head) &#123;        ListNode *pre = nullptr;        ListNode *next = nullptr;        ListNode *cur = head;        while (cur)        &#123;            next = cur-&gt;next;				// 先拿到后继结点            cur-&gt;next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;;
class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        // boolean非bool        if (head == null) return true;        ListNode lastNode = reverseList(interMediateNode(head));        while (head != lastNode &amp;&amp; head != null)        &#123;            if (head.val != lastNode.val) return false;            head = head.next;            lastNode = lastNode.next;        &#125;        return true;    &#125;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode next = null;        ListNode cur = head;        while (cur != null)        &#123;            next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;    public ListNode interMediateNode(ListNode head)    &#123;        ListNode fastNode = head;        ListNode slowNode = head;        while (fastNode != null &amp;&amp; fastNode.next.next != null)        &#123;            fastNode = fastNode.next.next;            slowNode = slowNode.next;        &#125;        return slowNode;    &#125;&#125;
class Solution:    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        if (not head):            return True        lastNode = self.reverseList(self.interMediateNode(head))        while (head != lastNode and head):            if head.val != lastNode.val:                return False            head = head.next            lastNode = lastNode.next        return True    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre        def interMediateNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fastNode = head        slowNode = head        while fastNode and fastNode.next.next:            fastNode = fastNode.next.next            slowNode = slowNode.next        return slowNode

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.1)</title>
    <url>/posts/2bc0b0cc.html</url>
    <content><![CDATA[一：对称二叉树
1. 递归
每次访问左右两个节点，不相同则为false
class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return recursion(root-&gt;left, root-&gt;right);    &#125;    bool recursion(TreeNode* left, TreeNode* right)    &#123;        if (left == nullptr &amp;&amp; right == nullptr) return true;       // 都为空        if (left == nullptr || right == nullptr) return false;      // 其中一个为空        return left-&gt;val == right-&gt;val &amp;&amp; recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left);   // 左节点的左节点与右节点的右节点，左节点的右节点与右节点的左节点    &#125;&#125;;
class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return recursion(root.left, root.right);    &#125;    public boolean recursion(TreeNode left, TreeNode right)    &#123;        if (left == null &amp;&amp; right == null) return true;              if (left == null || right == null) return false;             return left.val == right.val &amp;&amp; recursion(left.left, right.right) &amp;&amp; recursion(left.right, right.left);       &#125;&#125;
class Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._recursion(root.left, root.right)    def _recursion(self, left: Optional[TreeNode], right: Optional[TreeNode]) -&gt; bool:        if left == None and right == None: return True              if (left == None or right == None): return False             return left.val == right.val and self._recursion(left.left, right.right) and self._recursion(left.right, right.left)  

2. 迭代
使用队列管理左右节点
class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return iteration(root, root);    &#125;    bool iteration(TreeNode* left, TreeNode* right)    &#123;        queue&lt;TreeNode*&gt; treeQueue;        treeQueue.push(left);        treeQueue.push(right);        while (!treeQueue.empty())        &#123;            left = treeQueue.front();       // 先进先出            treeQueue.pop();            right = treeQueue.front();            treeQueue.pop();            if (left == nullptr &amp;&amp; right == nullptr) continue;            if (left == nullptr || right == nullptr || left-&gt;val != right-&gt;val) return false;            treeQueue.push(left-&gt;left);            treeQueue.push(right-&gt;right);            treeQueue.push(left-&gt;right);            treeQueue.push(right-&gt;left);        &#125;        return true;    &#125;&#125;;
class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return iteration(root, root);    &#125;    public boolean iteration(TreeNode left, TreeNode right)    &#123;        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        treeQueue.offer(left);        treeQueue.offer(right);        while (!treeQueue.isEmpty())        &#123;            left = treeQueue.poll();       // 先进先出            right = treeQueue.poll();            if (left == null &amp;&amp; right == null) continue;            if (left == null || right == null || left.val != right.val) return false;            treeQueue.offer(left.left);            treeQueue.offer(right.right);            treeQueue.offer(left.right);            treeQueue.offer(right.left);        &#125;        return true;    &#125;&#125;
class Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        return self._iteration(root, root)    def _iteration(self, left, right) -&gt; bool:        treeQueue = []        treeQueue.append(left)        treeQueue.append(right)        while (treeQueue):            left = treeQueue.pop()                  right = treeQueue.pop()            if (left == None and right == None): continue            if (left == None or right == None or left.val != right.val): return False            treeQueue.append(left.left)            treeQueue.append(right.right)            treeQueue.append(left.right)            treeQueue.append(right.left)        return True    

二：二叉树的直径

1. 深度优先
长度为节点数减1，通过递归可获得左右子树的深度，左右子树的深度+1则为经过的节点数
class Solution &#123;public:    int diameterOfBinaryTree(TreeNode* root) &#123;        int nodeNum = 1;    // 初始节点为1，也可设为0表示长度        recursion(nodeNum, root);        return  nodeNum - 1;    // 返回长度    &#125;    int recursion(int&amp; nodeNum, TreeNode* node)    &#123;        if (node == nullptr) return 0;        int leftNum = recursion(nodeNum, node-&gt;left);        int rightNum = recursion(nodeNum, node-&gt;right);        nodeNum = max(nodeNum, leftNum + rightNum + 1);     // 拿到最大节点        return max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;;
class Solution &#123;    public int nodeNum = 0; // 初始长度为0    public int diameterOfBinaryTree(TreeNode root) &#123;        recursion(root);        return  nodeNum;    // 返回长度    &#125;    public int recursion(TreeNode node)    &#123;        if (node == null) return 0;        int leftNum = recursion(node.left);        int rightNum = recursion(node.right);        nodeNum = Math.max(nodeNum, leftNum + rightNum);     // 拿到最大长度        return Math.max(leftNum, rightNum) + 1;      // 拿到深度    &#125;&#125;
class Solution:    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:        self.nodeNum = 0        self._recursion(root)        return  self.nodeNum        def _recursion(self, node) -&gt; int:        if (node == None): return 0        leftNum = self._recursion(node.left)        rightNum = self._recursion(node.right)        self.nodeNum = max(self.nodeNum, leftNum + rightNum)             return max(leftNum, rightNum) + 1      

三：将有序数组转换为二叉搜索树

1. 左边中序遍历
给定升序数组，对于二叉搜索树则是中序遍历，可将数组的中间数据或偏左作为根节点，左右两段分别为左右子树
class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;
class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);		// 使用length    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right) / 2;       // 中间偏左或正中        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;
class Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root

2. 中间中序遍历
这里是用中间位置或偏右作为中间结点
class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + 1) / 2;       // 这里加1        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;
class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        int mid = (left + right + 1) / 2;              TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;
class Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + 1) // 2       # 这里用//而非/        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root

3. 右边中序遍历
class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    TreeNode* recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left &gt; right) return nullptr;        int mid = (left + right + rand() % 2) / 2;       // 随机，rand返回一个伪随机的整数        TreeNode* root = new TreeNode(nums[mid]);        root-&gt;left = recursion(nums, left, mid - 1);        root-&gt;right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;;
class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    TreeNode recursion(int[] nums, int left, int right)    &#123;        if (left &gt; right) return null;        Random rand = new Random();         // 随机对象        int mid = (left + right + rand.nextInt(2)) / 2;       // 返回这个范围(2)内的随机整数        TreeNode root = new TreeNode(nums[mid]);        root.left = recursion(nums, left, mid - 1);        root.right = recursion(nums, mid + 1, right);        return root;    &#125;&#125;
class Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        return self._recursion(nums, 0, len(nums) - 1)    def _recursion(self, nums, left, right) -&gt; Optional[TreeNode]:        if (left &gt; right): return None        mid = (left + right + randint(0, 1)) // 2       # 随机整数的范围，包括起点和终点        root = TreeNode(nums[mid])        root.left = self._recursion(nums, left, mid - 1)        root.right = self._recursion(nums, mid + 1, right)        return root

四：搜索插入位置

1. 二分
根据二分查找的思想，依次比较中间点
class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2; // 避免溢出的写法，也可使用java的方法            if (nums[mid] == target) &#123;                return mid;             &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;             &#125; else &#123;                right = mid - 1;             &#125;        &#125;        // 循环结束后，left 指针就是目标应该插入的位置        return left;    &#125;&#125;;
class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target &lt;= nums[mid])            &#123;                cur = mid;                right = mid - 1;            &#125; else            &#123;                left = mid + 1;            &#125;        &#125;        return cur;    &#125;&#125;
class Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1         cur = right + 1        while (left &lt;= right):            mid = ((right - left) // 2) + left                  if (target &lt;= nums[mid]):                cur = mid                right = mid - 1            else:                left = mid + 1        return cur

五：有效的括号

1. 栈
先把左括号放入栈中，遇到右括号则弹出栈顶，判断是否相同
class Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 != 0) return false;        unordered_map&lt;char, char&gt; unMap = &#123;            &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,            &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;,             &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;&#125;;        // 遇到右括号寻找左括号        stack&lt;char&gt; chStk;        for (auto ch : s)        &#123;            if (unMap.count(ch))            &#123;                if (chStk.empty()) return false;                char top = chStk.top();                chStk.pop();                if (unMap[ch] != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.empty();    &#125;&#125;;
class Solution &#123;    public boolean isValid(String s) &#123;        if (s.length() % 2 != 0) return false;        Map&lt;Character, Character&gt; unMap = new HashMap&lt;&gt;();          // 使用Character而非char        unMap.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);        unMap.put(&#x27;]&#x27;, &#x27;[&#x27;);        unMap.put(&#x27;)&#x27;, &#x27;(&#x27;);        Deque&lt;Character&gt; chStk = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; s.length(); ++i)        &#123;            char ch = s.charAt(i);            if (unMap.containsKey(ch))            &#123;                if (chStk.isEmpty()) return false;                char top = chStk.peek();                chStk.pop();                if (unMap.get(ch) != top) return false;            &#125; else            &#123;                chStk.push(ch);            &#125;        &#125;        return chStk.isEmpty();    &#125;&#125;
class Solution:    def isValid(self, s: str) -&gt; bool:        if (len(s) % 2 != 0): return False        unMap = &#123;            &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,            &#x27;]&#x27;: &#x27;[&#x27;,            &#x27;)&#x27;: &#x27;(&#x27;,        &#125;              chStk =[]        for ch in s:            if (ch in unMap):                if (not chStk): return False                top = chStk[-1]     # 最后一个值                chStk.pop()         # 弹出                if (unMap[ch] != top): return False            else:                chStk.append(ch)        return not chStk

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.2)</title>
    <url>/posts/ede30f.html</url>
    <content><![CDATA[一：买卖股票的最佳时机

1. 暴力
不写
2. 一次遍历
记录最低值和利润最高值
class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int maxP = 0;           // 后面的最大利润        int minP = 1e9;         // 之前的最低值        for (auto price : prices)        &#123;            maxP = max(maxP, price - minP);            minP = min(minP, price);        &#125;        return maxP;    &#125;&#125;;
class Solution &#123;    public int maxProfit(int[] prices) &#123;        int maxP = 0;                   int minP = Integer.MAX_VALUE;                 for (int i =  0; i &lt; prices.length; ++i)        &#123;            int price = prices[i];            maxP = Math.max(maxP, price - minP);            minP = Math.min(minP, price);        &#125;        return maxP;    &#125;&#125;
class Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        maxP = 0                   minP = 1e9                 for price in prices:            maxP = max(maxP, price - minP)            minP = min(minP, price)        return maxP

二：爬楼梯

1. 动态规划
f(x)=f(x−1)+f(x−2)f(x)=f(x−1)+f(x−2)
f(x)=f(x−1)+f(x−2)
爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和，f(0)=1f(0)=1f(0)=1，f(1)=1f(1)=1f(1)=1，对空间的优化使用滚动数组

class Solution &#123;public:    int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;		// 赋值顺序不能反            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;;
class Solution &#123;    public int climbStairs(int n) &#123;        int sPre = 0, pre = 0, cur = 1;        for (int i = 1; i &lt;= n; ++i)        &#123;            sPre = pre;            pre = cur;            cur = sPre + pre;        &#125;        return cur;    &#125;&#125;
class Solution:    def climbStairs(self, n: int) -&gt; int:        sPre, pre, cur = 0, 0, 1        # 赋值        for _ in range(n):      # 遍历，_不使用            sPre = pre            pre = cur            cur = sPre + pre        return cur

2. 矩阵快速幂
[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} f(n) \\ f(n-1) \end{bmatrix} = \begin{bmatrix} f(n)+f(n-1) \\ f(n) \end{bmatrix} = \begin{bmatrix} f(n+1) \\ f(n) \end{bmatrix}
[11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]
[f(n+1)f(n)]=[1110]n[f(1)f(0)]\begin{bmatrix} f(n+1) \\ f(n) \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^{n} \begin{bmatrix} f(1) \\ f(0) \end{bmatrix}
[f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]
M=[1110]M = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
M=[11​10​]
常规计算M的n次方时间复杂度同上，这里使用快速幂
**快速幂是一种用于在 O(log⁡n)O(\log n)O(logn) 时间内计算 ana^nan 的高效算法。它利用了指数的二进制表示来减少乘法运算的次数，通常用于解决指数非常大时可能导致超时的问题。
基本思想
传统方法计算 ana^nan 需要进行 n−1n-1n−1 次乘法（即 a×a×⋯×aa \times a \times \dots \times aa×a×⋯×a）。快速幂则利用以下数学性质：

如果 nnn 是偶数，an=an/2×an/2a^n = a^{n/2} \times a^{n/2}an=an/2×an/2。
如果 nnn 是奇数，an=a(n−1)/2×a(n−1)/2×aa^n = a^{(n-1)/2} \times a^{(n-1)/2} \times aan=a(n−1)/2×a(n−1)/2×a。

这个思想的核心是将指数 nnn 不断折半。通过将 nnn 转换为二进制形式，我们可以将 ana^nan 的计算分解为一系列乘法和平方操作。例如，要计算 a13a^{13}a13，因为 131313 的二进制是 110111011101，即 13=8+4+113 = 8 + 4 + 113=8+4+1，所以：
a13=a8+4+1=a8×a4×a1a^{13} = a^{8+4+1} = a^8 \times a^4 \times a^1a13=a8+4+1=a8×a4×a1
我们只需要计算 a1,a2,a4,a8a^1, a^2, a^4, a^8a1,a2,a4,a8（通过不断平方得到），然后将这些项相乘即可。这比直接进行 12 次乘法要快得多。
算法步骤

初始化结果 res = 1。
将底数 base 设为 aaa。
当指数 n&gt;0n &gt; 0n&gt;0 时循环：

如果 nnn 的二进制最后一位是 1（即 nnn 为奇数），将 res 乘以 base。
将 base 自身相乘（base = base * base）。
将 nnn 右移一位（n = n &gt;&gt; 1），相当于 n=n/2n = n / 2n=n/2。


返回 res。


class Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;vector&lt;long long&gt;&gt; init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        vector&lt;vector&lt;long long&gt;&gt; result = matrixPow(init, n);        return result[0][0];    &#125;    vector&lt;vector&lt;long long&gt;&gt; multiplication(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b)      // 二阶矩阵乘法    &#123;         vector&lt;vector&lt;long long&gt;&gt; c(2, vector&lt;long long&gt;(2));        for (int i = 0; i &lt; a.size(); ++i)        &#123;            for (int j = 0; j &lt; b[0].size(); ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    vector&lt;vector&lt;long long&gt;&gt; matrixPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int n)    &#123;        vector&lt;vector&lt;long long&gt;&gt; unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;;
class Solution &#123;    public int climbStairs(int n) &#123;        int[][] init = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        // 使用int[][]或long        int[][] result = matrixPow(init, n);        return result[0][0];    &#125;    public int[][] multiplication(int[][] a, int[][] b)      // 二阶矩阵乘法    &#123;         int[][] c = new int[2][2];         // 基本数据类型        for (int i = 0; i &lt; a.length; ++i)        &#123;            for (int j = 0; j &lt; b[0].length; ++j)            &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];            &#125;        &#125;        return c;    &#125;    public int[][] matrixPow(int[][] a, int n)    &#123;        int[][] unit = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;        &#125;;        while (n &gt; 0)        &#123;            if ((n &amp; 1) == 1) unit = multiplication(unit, a);            a = multiplication(a, a);            n &gt;&gt;= 1;        &#125;        return unit;    &#125;&#125;
class Solution:    def climbStairs(self, n: int) -&gt; int:        init = [[1, 1], [1, 0]]                result = self._matrixPow(init, n)        return result[0][0]    def multiplication(self, a, b):            c = [[1, 1], [1, 0]]              for i in range(2):            for j in range(2):                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]        return c    def _matrixPow(self, a, n):        unit = [[1, 0], [0, 1]]          while n &gt; 0:            if ((n &amp; 1) == 1): unit = self.multiplication(unit, a)            a = self.multiplication(a, a)            n &gt;&gt;= 1        return unit

3. 通项公式

class Solution &#123;public:    int climbStairs(int n) &#123;        double sqrt5 = sqrt(5);        return static_cast&lt;int&gt;(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;;
class Solution &#123;    public int climbStairs(int n) &#123;        double sqrt5 = Math.sqrt(5);        return (int)(Math.round((Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1)) / sqrt5));    &#125;&#125;
class Solution:    def climbStairs(self, n: int) -&gt; int:        sqrt5 = sqrt(5)        return (int)(round((pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5))

三：杨辉三角

1. 数学分析

class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; result(numRows);        for (int i= 0; i &lt; numRows; ++i)        &#123;            result[i].resize(i + 1);            result[i][0] = result[i][i] = 1;            for (int j = 1; j &lt; i; ++j)            &#123;                result[i][j] = result[i - 1][j] + result[i - 1][j - 1];            &#125;        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        for (int i= 0; i &lt; numRows; ++i)        &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            for (int j = 0; j &lt;= i; ++j)            &#123;                if (j == 0 || j == i) row.add(1);                else row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));            &#125;            result.add(row);        &#125;        return result;    &#125;&#125;
class Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        result = []        for i in range(numRows):            row = []            for j in range(0, i + 1):       # 0-i                if j == 0 or j == i: row.append(1)                else: row.append(result[i - 1][j] + result[i - 1][j - 1])            result.append(row)        return result

四：只出现一次的数字

1. 位运算
题目要求使用空间复杂度为常量，因此常规解法不可用。这里采用异或，性质如下

class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result = 0;        for (auto num : nums)            result ^=num;        return result;    &#125;&#125;;
class Solution &#123;    public int singleNumber(int[] nums) &#123;        int result = 0;        for (int num : nums)        // 没有auto            result ^=num;        return result;    &#125;&#125;
class Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        result = 0        for num in nums:                   result ^=num        return result		# return reduce(lambda x, y: x ^ y, nums) 使用lambda，reduce从可迭代对象中取出第一个和第二个元素，用指定的函数进行计算，将计算结果与第三个元素再次进行计算，直到所有元素处理完毕

五：多数元素

1. 哈希表
数组的值作为键，出现的次数作为值
class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; hashMap;        int count = 0, numberous = 0;        for (auto num : nums)        &#123;            ++hashMap[num];            if (hashMap[num] &gt; count)		// 通过该方式无需再次遍历哈希表            &#123;                count = hashMap[num];                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;;
class Solution &#123;    public int majorityElement(int[] nums) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        int count = 0, numberous = 0;        for (int num : nums)        &#123;            if (hashMap.containsKey(num)) hashMap.put(num, hashMap.get(num) + 1);            else hashMap.put(num, 1);                        if (hashMap.get(num) &gt; count)            &#123;                count = hashMap.get(num) ;                numberous = num;            &#125;        &#125;         return numberous;    &#125;&#125;
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)		# 统计每个元素的个数，保存为字典        return max(counts.keys(), key = counts.get)			# 根据键取出对应的值的最大值

2. 排序
由于多数总是超过元素总和的二分之一，那么排序后中间的元素一定是多数（奇偶均可）
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        counts = collections.Counter(nums)        return max(counts.keys(), key = counts.get)
class Solution &#123;    public int majorityElement(int[] nums) &#123;        Arrays.sort(nums);      // 使用Arrays        return nums[nums.length / 2];    &#125;&#125;
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // 2]

3. 随机化
随机挑选一个元素作为多数，然后统计
class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        while (true)        &#123;            int count = 0;            int right = nums[rand() % nums.size()];		// 也可以假设第一个为多数，依次尝试，比随机时间稍低，因为不会重复            for (auto num : nums)                if (num == right) ++count;            if (count &gt; nums.size() / 2) return right;        &#125;    &#125;&#125;;
class Solution &#123;    public int majorityElement(int[] nums) &#123;        Random rand = new Random();        while (true)        &#123;            int right = nums[rand.nextInt(nums.length)];            int count = 0;            for (int num : nums)                if (num == right) ++count;            if (count &gt; nums.length / 2) return right;        &#125;    &#125;&#125;
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        while True:            right = random.choice(nums)            count = 0            for num in nums:		# 或if sum(1 for elem in nums if elem == candidate) &gt; majority_count:                if num == right: count += 1            if count &gt; len(nums) // 2: return right

4. 分治
将数据分为两组，多数一定会存在其中一组
class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1);    &#125;    int recursion(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);		// 两者相等可以直接返回了leftNum == rightNum        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(vector&lt;int&gt;&amp; nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;;
class Solution &#123;    public int majorityElement(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1);    &#125;    public int recursion(int[] nums, int left, int right)    &#123;        if (left == right) return nums[left];        int mid = ((right - left) &gt;&gt; 1) + left;        int leftNum = recursion(nums, left, mid);        int rightNum = recursion(nums, mid + 1, right);        if (countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2) return leftNum;        if (countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2) return rightNum;        return -1;    &#125;    int countNum(int[] nums, int target, int lo, int hi)    &#123;        int count = 0;        for (int i = lo; i &lt;= hi; ++i)            if (nums[i] == target)                ++count;        return count;    &#125;&#125;
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1)    def recursion(self, nums, left, right):        if (left == right): return nums[left]        mid = ((right - left) // 2) + left        leftNum = self.recursion(nums, left, mid)        rightNum = self.recursion(nums, mid + 1, right)        if (self.countNum(nums, leftNum, left, right) &gt; (right - left + 1) / 2): return leftNum        if (self.countNum(nums, rightNum, left, right) &gt; (right - left + 1) / 2): return rightNum        return -1    def countNum(self, nums, target, lo, hi):        count = 0        for num in nums:            if (num == target):                count +=1        return count    # 官方写法class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        def majority_elem在·ent_rec(lo, hi) -&gt; int:            if lo == hi:                return nums[lo]                        mid = (hi - lo) // 2 + lo            left = majority_element_rec(lo, mid)            right = majority_element_rec(mid + 1, hi)            if left == right:                return left            left_count = sum(1 for i in range(lo, hi + 1) if nums[i] == left)            right_count = sum(1 for i in range(lo, hi + 1) if nums[i] == right)            return left if left_count &gt; right_count else right        return majority_element_rec(0, len(nums) - 1)

5. Boyer-Moore 投票算法

利用多数大于二分之一的性质，所有元素加减之后一定大于零，最后一个零出现的位置意味着之后的第一个元素一定是多数，因为如果不是多数，后面还会出现零
class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int right = -1;    int count = 0;    for (auto num : nums)    &#123;        if (count == 0) right = num;        if (num == right) ++count;        else --count;    &#125;    return right;    &#125;&#125;;
class Solution &#123;    public int majorityElement(int[] nums) &#123;        int right = -1;        int count = 0;        for (int num : nums)        &#123;            if (count == 0) right = num;            if (num == right) ++count;            else --count;        &#125;        return right;    &#125;&#125;
class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        right = -1        count = 0        for num in nums:            if (count == 0): right = num            if (num == right): count += 1            else: count -= 1        return right

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.3)</title>
    <url>/posts/19f6d24e.html</url>
    <content><![CDATA[一：字母异位词分组

1. 排序
字母异位词排序之后相同，可使用哈希表
class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str : strs)        &#123;            string key = str;            sort(key.begin(), key.end());            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)        &#123;            result.emplace_back(row.second);        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            char[] arrayStr = str.toCharArray();            Arrays.sort(arrayStr);            String key = new String(arrayStr);            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            // getOrDefault 它的作用是：如果 map 中存在 key，则返回 key 对应的值；            // 如果不存在，则返回 new ArrayList&lt;String&gt;() 并添加到 map 中            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;
class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            # sorted(st) 返回一个按字母排序的列表 [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;t&#x27;]            # &quot;&quot;.join(...) 将列表中的字符连接成字符串 &quot;aet&quot;            key = &quot;&quot;.join(sorted(str))            hashMap[key].append(str)        return list(hashMap.values())

2. 计数
跟排序道理相同，只不过增加了字符的次数
class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; hashMap;        for (string&amp; str: strs) &#123;            array&lt;int, 26&gt; counts&#123;&#125;;            for (char ch : str)                 counts[ch - &#x27;a&#x27;] ++;            string key;            for (auto count : counts)                 key += to_string(count) + &quot;#&quot;;            hashMap[key].emplace_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (auto&amp; row : hashMap)            result.emplace_back(row.second);        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();        for (String str : strs)        &#123;            int[] counts = new int[26];            for (int i = 0; i &lt; str.length(); i++)                counts[str.charAt(i) - &#x27;a&#x27;]++;            StringBuffer sb = new StringBuffer();            for (int i = 0; i &lt; 26; i++)                if (counts[i] != 0)			// 这里也可以使用python的方式，但是必须在字符之间添加分界符，原因是出现次数超过10的字母会导致键不唯一                &#123;                    sb.append((char)(&#x27;a&#x27; + i));                    sb.append(counts[i]);                &#125;            String key = sb.toString();            List&lt;String&gt; value = hashMap.getOrDefault(key, new ArrayList&lt;String&gt;());            value.add(str);            hashMap.put(key, value);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(hashMap.values());    &#125;&#125;
class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        hashMap = collections.defaultdict(list)        for str in strs:            counts = [0] * 26            for ch in str:                counts[ord(ch) - ord(&quot;a&quot;)] += 1            hashMap[tuple(counts)].append(str)		# 直接使用计数数组，注意这里保留了顺序，因为生成的是元组        return list(hashMap.values())

二：最长连续序列

1. 哈希表
将数据放入哈希表，然后不断寻找它的下一位，时间大概为线性，但有些数据没必要再次寻找，如已经找过的数据
class Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; hashSet;        int maxCount = 0;        for (auto num : nums) hashSet.insert(num);        for (auto num : hashSet)        &#123;            if (!hashSet.count(num - 1))            &#123;                int count = 1;                  while (hashSet.count(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = max(maxCount, count);            &#125;        &#125;         return maxCount;                                       &#125;&#125;;
class Solution &#123;    public int longestConsecutive(int[] nums) &#123;        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        int maxCount = 0;        for (int num : nums) hashSet.add(num);        for (int num : hashSet)        &#123;            if (!hashSet.contains(num - 1))            &#123;                int count = 1;                  while (hashSet.contains(num + 1))                &#123;                    ++count;                    ++num;                &#125;                maxCount = Math.max(maxCount, count);            &#125;        &#125;         return maxCount;        &#125;&#125;
class Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        hashSet = set(nums)        maxCount = 0        for num in hashSet:            if num - 1 not in hashSet:                count = 1                  while (num + 1) in hashSet:                    count += 1                    num += 1                maxCount = max(maxCount, count)        return maxCount   

三：盛水最多的容器

1. 双指针
从两端开始，移动小的向中间靠近
class Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int left = 0, right = height.size() - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;;
class Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0, right = height.length - 1;        int maxA = 0;        while (left &lt; right)        &#123;            int curArea = Math.min(height[left], height[right]) * (right - left);            if (height[left] &lt; height[right]) ++left;            else --right;            maxA = Math.max(maxA, curArea);        &#125;        return maxA;    &#125;&#125;
class Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, maxA = 0, 0        right = len(height) - 1        while left &lt; right:            curArea = min(height[left], height[right]) * (right - left)            if (height[left] &lt; height[right]): left += 1            else: right -= 1            maxA = max(maxA, curArea)        return maxA

四：三数之和

1. 排序 + 双指针
首先对数组进行排序，外层循环从左往右，内层从右往左，题目要求三元组不重复意味着相同的值无需处理跳过即可
当我们想要枚举数组中的两个元素时，如果发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N2)O(N^2)O(N2) 减少至 O(N)O(N)O(N)。为什么是 O(N)O(N)O(N) 呢？这是因为在枚举的过程中，每一步中，“左指针”会向右移动一个位置，而“右指针”会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)O(N)。均摊下来，每次也只向右移动一个位置，因此时间复杂度为 O(N)O(N)O(N)。
class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0) result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);            &#125;        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        int length = nums.length;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        for (int i = 0; i &lt; length; ++i)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            int k = length - 1;            for (int j = i + 1; j &lt; length; ++j)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                while (nums[i] + nums[j] + nums[k] &gt; 0 &amp;&amp; j &lt; k) --k;                if (j == k) break;                if (nums[i] + nums[j] + nums[k] == 0)                &#123;                    List&lt;Integer&gt; row = new ArrayList&lt;&gt;();                    row.add(nums[i]);                    row.add(nums[j]);                    row.add(nums[k]);                    result.add(row);                &#125;            &#125;        &#125;        return result;    &#125;&#125;
class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        length = len(nums)        result = list()        nums.sort()        for i in range(length):            if i &gt; 0 and nums[i] == nums[i - 1]: continue            k = length - 1            for j in range(i + 1, length):                if j &gt; i + 1 and nums[j] == nums[j - 1]: continue                while nums[i] + nums[j] + nums[k] &gt; 0 and j &lt; k: k -= 1                if j == k: break                if nums[i] + nums[j] + nums[k] == 0:                    result.append([nums[i], nums[j], nums[k]])        return result

五：无重复字符的最长子串

1. 滑动窗口
通过哈希表维护窗口，两个指针指向字符串，若右指针元素不在哈希表则添加并右移，若包含则左指针右移并剔除当前指向元素
class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        unordered_set&lt;char&gt; hashSet;        int right = 0;        int length = s.size();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.count(s[right]))            &#123;                hashSet.insert(s[right]);                ++right;            &#125;            hashSet.erase(s[i]);            result = max(result, right - i);        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();        int right = 0;        int length = s.length();        int result = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            while (right &lt; length &amp;&amp; !hashSet.contains(s.charAt(right)))            &#123;                hashSet.add(s.charAt(right));                ++right;            &#125;            hashSet.remove(s.charAt(i));            result = Math.max(result, right - i);        &#125;        return result;    &#125;&#125;
class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        hashSet = set()        right = 0        length = len(s)        result = 0        for i in range(length):            while (right &lt; length and s[right] not in hashSet):                hashSet.add(s[right])                right += 1            hashSet.remove(s[i])            result = max(result, right - i)        return result

六：找到字符串中所有字母异位词

1. 滑动窗口
p的长度固定，在s中寻找p可使用p的长度的作为窗口宽度，利用当前宽度两个字符串出现的次数即可作为判定
class Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; pCharCount(26);        vector&lt;int&gt; sCharCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p[i] - &#x27;a&#x27;];            ++sCharCount[s[i] - &#x27;a&#x27;];        &#125;        if (sCharCount == pCharCount) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s[i] - &#x27;a&#x27;];            ++sCharCount[s[i + pL] - &#x27;a&#x27;];            if (sCharCount == pCharCount) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] pCharCount = new int[26];        int[] sCharCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            ++pCharCount[p.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        if (Arrays.equals(pCharCount, sCharCount)) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            --sCharCount[s.charAt(i) - &#x27;a&#x27;];            ++sCharCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (Arrays.equals(pCharCount, sCharCount)) result.add(i + 1);        &#125;        return result;    &#125;&#125;
class Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        pCharCount = [0] * 26        sCharCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            pCharCount[ord(p[i]) - 97] += 1            sCharCount[ord(s[i]) - 97] += 1        if (sCharCount == pCharCount): result.append(0)        for i in range(sL - pL):               sCharCount[ord(s[i]) - 97] -= 1            sCharCount[ord(s[i + pL]) - 97] += 1            if (sCharCount == pCharCount): result.append(i + 1)        return result

2. 优化
不比较两个字符串在窗口的位置，直接比较差值
class Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        vector&lt;int&gt; result;        int sL = s.size(), pL = p.size();        vector&lt;int&gt; charCount(26);        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p[i] - &#x27;a&#x27;];            ++charCount[s[i] - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.emplace_back(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s[i] - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s[i] - &#x27;a&#x27;] == 0) ++dif;            --charCount[s[i] - &#x27;a&#x27;];            if (charCount[s[i + pL] - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s[i + pL] - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s[i + pL] - &#x27;a&#x27;];            if (dif == 0) result.emplace_back(i + 1);        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int sL = s.length(), pL = p.length();        int[] charCount = new int[26];        if (sL &lt; pL) return result;        for (int i = 0; i &lt; pL; ++i)        &#123;            --charCount[p.charAt(i) - &#x27;a&#x27;];            ++charCount[s.charAt(i) - &#x27;a&#x27;];        &#125;        int dif = 0;        for (int i = 0; i &lt; 26; ++i)            if (charCount[i] != 0) ++dif;        if (dif == 0) result.add(0);        for (int i = 0; i &lt; sL - pL; ++i)      // 开始滑动，剔除左边，增加右边         &#123;            if (charCount[s.charAt(i) - &#x27;a&#x27;] == 1) --dif;      // 左边为1，则dif减小，为0则dif增加，为-1则不变，右边同理            else if (charCount[s.charAt(i) - &#x27;a&#x27;] == 0) ++dif;            --charCount[s.charAt(i) - &#x27;a&#x27;];            if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == -1) --dif;                  else if (charCount[s.charAt(i + pL) - &#x27;a&#x27;] == 0) ++dif;            ++charCount[s.charAt(i + pL) - &#x27;a&#x27;];            if (dif == 0) result.add(i + 1);        &#125;        return result;    &#125;&#125;
class Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        result = list()        sL, pL = len(s), len(p)        charCount = [0] * 26        if (sL &lt; pL): return result        for i in range(pL):            charCount[ord(p[i]) - 97] -= 1            charCount[ord(s[i]) - 97] += 1        differ = [c != 0 for c in charCount].count(True)        if (differ == 0): result.append(0)        for i in range(sL - pL):               if charCount[ord(s[i]) - 97] == 1: differ -= 1            elif charCount[ord(s[i]) - 97] == 0: differ += 1            charCount[ord(s[i]) - 97] -= 1            if charCount[ord(s[i + pL]) - 97] == -1: differ -= 1            elif charCount[ord(s[i + pL]) - 97] == 0: differ += 1            charCount[ord(s[i + pL]) - 97] += 1            if (differ == 0): result.append(i + 1)        return result

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.4)</title>
    <url>/posts/56b74489.html</url>
    <content><![CDATA[一：和为K的子数组

1. 枚举
其实就是暴力，两层循环，python可能会超时
class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;;
class Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        int length = nums.length;        int count = 0;        for (int i = 0; i &lt; length; ++i)        &#123;            int sum = 0;            for (int j = i; j &lt; length; ++j)            &#123;                sum += nums[j];                if (sum == k) ++count;            &#125;        &#125;        return count;    &#125;&#125;
class Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        length = len(nums)        count = 0        for i in range(length):            sum = 0            for j in range(i, length):                sum += nums[j]                if (sum == k): count += 1        return count

2. 哈希表
遍历时记录所有和并放入哈希表，寻找子串时只寻找当前值与目标值的差，相同值通过哈希表的值来记录
class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; hashMap;        hashMap[0] = 1;         // 相同值需要        int sum = 0;        int count = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            if (hashMap.count(sum - k)) count += hashMap[sum - k];            ++hashMap[sum];        &#125;        return count;    &#125;&#125;;
class Solution &#123;    public int subarraySum(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(0, 1);        int sum = 0;        int count = 0;        for (int num : nums)        &#123;            sum += num;            if (hashMap.containsKey(sum - k)) count += hashMap.get(sum - k);            hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);        &#125;        return count;    &#125;&#125;
class Solution:    def subarraySum(self, nums: List[int], k: int) -&gt; int:        hashMap = &#123;0 : 1&#125;        sum = 0        count = 0        for num in nums:            sum += num            if (sum - k in hashMap): count += hashMap[sum - k]            hashMap[sum] = hashMap.get(sum, 0) + 1        return count

二：最大子数组和

1. 动态规划
class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int next = 0;        int result = nums[0];        for (auto&amp; num : nums)        &#123;            next = max(next + num, num);            // 局部最优            result = max(result, next);        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int next = 0;        int result = nums[0];        for (int num : nums)        &#123;            next = Math.max(next + num, num);            // 局部最优            result = Math.max(result, next);        &#125;        return result;    &#125;&#125;
class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        next = 0        result = nums[0]        for num in nums:            next = max(next + num, num)                      result = max(result, next)        return result

2. 分治
class Solution &#123;public:    struct Status &#123;        int left, right, media, sum;    &#125;;    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        return recursion(nums, 0, nums.size() - 1).media;    &#125;    Status recursion(vector&lt;int&gt; &amp;a, int l, int r) &#123;        if (l == r) &#123;            return (Status) &#123;a[l], a[l], a[l], a[l]&#125;;        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;        Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = max(l.left, l.sum + r.left);        int rSum = max(r.right, r.sum + l.right);        int mSum = max(max(l.media, r.media), l.right + r.left);        return (Status) &#123;lSum, rSum, mSum, iSum&#125;;    &#125;;&#125;;
class Solution &#123;    public class Status &#123;        public int left, right, media, sum;        public Status(int lSum, int rSum, int mSum, int iSum) &#123;            this.left = lSum;            this.right = rSum;            this.media = mSum;            this.sum = iSum;        &#125;    &#125;    public int maxSubArray(int[] nums) &#123;        return recursion(nums, 0, nums.length - 1).media;    &#125;    public Status recursion(int[] a, int l, int r) &#123;        if (l == r) &#123;            return new Status (a[l], a[l], a[l], a[l]);        &#125;        int m = ((r - l) &gt;&gt; 1) + l;        Status lSub = recursion(a, l, m);        Status rSub = recursion(a, m + 1, r);        return pushUp(lSub, rSub);    &#125;    public Status pushUp(Status l, Status r) &#123;             // 关于区间合并的解决        int iSum = l.sum + r.sum;        int lSum = Math.max(l.left, l.sum + r.left);        int rSum = Math.max(r.right, r.sum + l.right);        int mSum = Math.max(Math.max(l.media, r.media), l.right + r.left);        return new Status (lSum, rSum, mSum, iSum);    &#125;;&#125;
class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        return self.recursion(nums, 0, len(nums) - 1).media    def recursion(self, a, l, r):        if l == r:            val = a[l]            return (val, val, val, val)                m = (r + l) // 2        l_sub = self.recursion(a, l, m)        r_sub = self.recursion(a, m + 1, r)          return self.pushUp(l_sub, r_sub)    def pushUp(self, l, r):        l_left, l_right, l_media, l_sum = l        r_left, r_right, r_media, r_sum = r                i_sum = l_sum + r_sum        l_sum_new = max(l_left, l_sum + r_left)        r_sum_new = max(r_right, r_sum + l_right)        m_sum_new = max(max(l_media, r_media), l_right + r_left)                return (l_sum_new, r_sum_new, m_sum_new, i_sum)

3. 前缀法
参考第一题的第二中解法，时间和空间同动态规划方法
class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int minV = 0, maxV = -1e9;        int sum = 0;        for (auto&amp; num : nums)        &#123;            sum += num;            maxV = max(maxV, sum - minV);            minV = min(minV , sum);        &#125;        return maxV;    &#125;&#125;;
三：合并区间

1. 排序
对首元素排序，然后判断每个区间的首尾大小即可
class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(), intervals.end());        vector&lt;vector&lt;int&gt;&gt; reruslt;        for (int i = 0; i &lt; intervals.size(); ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.back()[1] &lt; left) reruslt.emplace_back(intervals[i]);            else reruslt.back()[1] = max(reruslt.back()[1], right);        &#125;         return reruslt;    &#125;&#125;;
class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] interval1, int[] interval2) &#123;                return interval1[0] - interval2[0];            &#125;        &#125;);        List&lt;int[]&gt; reruslt = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; intervals.length; ++i)        &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if (reruslt.size() == 0 || reruslt.get(reruslt.size() - 1)[1] &lt; left) reruslt.add(new int[]&#123;left, right&#125;);            else reruslt.get(reruslt.size() - 1)[1] = Math.max(reruslt.get(reruslt.size() - 1)[1], right);        &#125;         return reruslt.toArray(new int[reruslt.size()][]);    &#125;&#125;
class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        result = []        for interval in intervals:            if not result or result[-1][1] &lt; interval[0]: result.append(interval)            else: result[-1][1] = max(result[-1][1], interval[1])        return result

四：轮转数组

1. 额外数组
使用一个额外数组来存储移动后的元素
class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; newNums(nums.size());        for (int i = 0; i &lt; nums.size(); ++i)        &#123;            newNums[(i + k) % nums.size()] = nums[i];        &#125;        return nums.assign(newNums.begin(), newNums.end());    &#125;&#125;;
class Solution &#123;    public void rotate(int[] nums, int k) &#123;        int[] newNums = new int[nums.length];        for (int i = 0; i &lt; nums.length; ++i)        &#123;            newNums[(i + k) % nums.length] = nums[i];        &#125;        System.arraycopy(newNums, 0, nums, 0, nums.length);    &#125;&#125;
class Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        newNums = [0] * len(nums)        for i in range(len(nums)):            newNums[(i + k) % len(nums)] = nums[i]        nums[:] = newNums

2. 环状替换
以环为单位在数组元素中跳动反转，跳转几次后会回到原点，使用临时值来作为其中一个交换对象，如果遍历交换，则需要多个值来存储交换对象，效率变低
class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int length = nums.size();        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                swap(nums[cur], curV);            &#125; while(i != cur);        &#125;    &#125;&#125;;
class Solution &#123;    public int gcd(int x, int y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;    public void rotate(int[] nums, int k) &#123;        int length = nums.length;        k = k % length;        int step = gcd(k, length);       // 最大公约数，得出需要的环        for (int i = 0; i &lt; step; ++i)        &#123;            int cur = i;            int curV = nums[i];            do            &#123;                cur = (cur + k) % length;                int temp = nums[cur];                nums[cur] = curV;                curV = temp;            &#125; while(i != cur);        &#125;    &#125;&#125;
class Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        length = len(nums)        k = k % length        step = math.gcd(k, length)               for i in range(step):            cur = i            curV = nums[i]            while True:                cur = (cur + k) % length                nums[cur], curV = curV, nums[cur]                if i == cur: break

3. 数组反转
先将数组反转，然后反转前k个值，最后反转剩余值就得到换位后的数组
class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        k = k % nums.size();        reverse(nums, 0, nums.size() - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.size() - 1);    &#125;    void reverse(vector&lt;int&gt;&amp; nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j) swap(nums[i], nums[j]);    &#125;&#125;;
class Solution &#123;   public void rotate(int[] nums, int k) &#123;        k = k % nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    &#125;    public void reverse(int[] nums, int left, int right)    &#123;        for (int i = left, j = right; i &lt; j; ++i, --j)        &#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;        &#125;    &#125;&#125;
class Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        k = k % len(nums)        self.reverse(nums, 0, len(nums) - 1)        self.reverse(nums, 0, k - 1)        self.reverse(nums, k, len(nums) - 1)    def reverse(self, nums, left, right):        while left &lt; right:            nums[left], nums[right] = nums[right], nums[left]            left += 1            right -= 1

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.5)</title>
    <url>/posts/4fac75c8.html</url>
    <content><![CDATA[一：除自身以外数组的乘积

1. 左右乘积列表
用两个数组分别记录左右两端的乘积
class Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; left(length);        vector&lt;int&gt; right(length);        vector&lt;int&gt; result(length);        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;;
class Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] left = new int[length] ;        int[] right = new int[length] ;        int[] result = new int[length] ;        left[0] = 1;        right[length -  1] = 1;        for (int i = 1, j = length - 2; i &lt;length &amp;&amp; j &gt;= 0; ++i, --j)        &#123;            left[i] = nums[i - 1] * left[i - 1];            right[j] = nums[j + 1] * right[j + 1];        &#125;        for (int i = 0; i &lt; length; ++i)            result[i] = left[i] * right[i];        return result;    &#125;&#125;
class Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        left = [0] * length        right = [0] * length        result = [0] * length        left[0] = 1        right[length -  1] = 1        for i in range(1, length):            left[i] = nums[i - 1] * left[i - 1]        for j in reversed(range(length - 1)):            right[j] = nums[j + 1] * right[j + 1]        for i in range(length):            result[i] = left[i] * right[i]        return result

2. 空间复杂度O(1)O(1)O(1)的方法
用结果数组先作为左乘积列表，然后使用临时变量记录每个右乘积并更新数组
class Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        vector&lt;int&gt; result(length);        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] result = new int[length] ;        result[0] = 1;        for (int i = 1; i &lt;length; ++i)            result[i] = nums[i - 1] * result[i - 1];        int rightMul = 1;        for (int j = length - 1; j &gt;= 0; --j)        &#123;            result[j] = result[j] * rightMul;            rightMul *= nums[j];        &#125;        return result;    &#125;&#125;
class Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        length = len(nums)        result = [0] * length        result[0] = 1        for i in range(1, length):            result[i] = nums[i - 1] * result[i - 1]        rightMul = 1        for j in reversed(range(length)):            result[j] = result[j] * rightMul            rightMul *= nums[j]        return result

二：矩阵置零

1. 使用标记数组
通过两个数组来记录二维数组中某行或这某列是否包含零
class Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        vector&lt;int&gt; vRow(nRow);        vector&lt;int&gt; vCol(nCol);        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;;
class Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        int[] vRow = new int[nRow];        int[] vCol = new int[nCol];        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (matrix[i][j] == 0) vRow[i] = vCol[j] = 1;        for (int i = 0; i &lt; nRow; ++i)            for (int j = 0; j &lt; nCol; ++j)                if (vRow[i] == 1 || vCol[j] == 1) matrix[i][j] = 0;    &#125;&#125;
class Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        vRow = [0] * nRow        vCol = [0] * nCol        for i in range(nRow):            for j in range(nCol):                if (matrix[i][j] == 0): vRow[i] = vCol[j] = 1        for i in range(nRow):            for j in range(nCol):                if (vRow[i] == 1 or vCol[j] == 1): matrix[i][j] = 0

2. 使用两个标记变量
使用第一行和第一列来记录其余位置的零，再使用两个标记变量来记录第一行和第一列的情况
class Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstRow = false;        bool firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;;
class Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstRow = false;        boolean firstCol = false;        for (int i = 0; i &lt; nRow; ++i)            if (matrix[i][0] == 0) firstCol = true;        for (int i = 0; i &lt; nCol; ++i)            if (matrix[0][i] == 0) firstRow = true;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        for (int i = 1; i &lt; nRow; ++i)            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;        if (firstCol == true)            for (int i = 0; i &lt; nRow; ++i)                matrix[i][0] = 0;        if (firstRow == true)            for (int i = 0; i &lt; nCol; ++i)                matrix[0][i] = 0;    &#125;&#125;
class Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        firstRow = False        firstCol = False        for i in range(nRow):            if (matrix[i][0] == 0): firstCol = True        for i in range(nCol):            if (matrix[0][i] == 0): firstRow = True        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in range(1, nRow):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0        if (firstCol == True):            for i in range(nRow):                matrix[i][0] = 0        if (firstRow == True):            for i in range(nCol):                matrix[0][i] = 0

3. 使用一个标记变量
用左上角的元素作为标记变量
class Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int nRow = matrix.size();        int nCol = matrix[0].size();        bool firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;;
class Solution &#123;    public void setZeroes(int[][] matrix) &#123;        int nRow = matrix.length;        int nCol = matrix[0].length;        boolean firstFlag = false;        for (int i = 0; i &lt; nRow; ++i)        &#123;            if (matrix[i][0] == 0) firstFlag = true;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0;        &#125;        for (int i = nRow - 1; i &gt;= 0; --i)        &#123;            for (int j = 1; j &lt; nCol; ++j)                if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;            if (firstFlag == true)                matrix[i][0] = 0;        &#125;    &#125;&#125;
class Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        nRow = len(matrix)        nCol = len(matrix[0])        flag = False        for i in range(nRow):            if (matrix[i][0] == 0): flag = True            for j in range(1, nCol):                if (matrix[i][j] == 0): matrix[i][0] = matrix[0][j] = 0        for i in reversed(range(nRow)):            for j in range(1, nCol):                if (matrix[i][0] == 0 or matrix[0][j] == 0): matrix[i][j] = 0            if flag == True:                matrix[i][0] = 0

三：螺旋矩阵

1. 模拟
定义一个旋转方向，当遇到边界和访问过的节点进行旋转（属于暴力）
class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowCnt = matrix.size();        int colCnt = matrix[0].size();        enum Rule &#123;leftToright, upTodow, rightToleft, downToup&#125;;        Rule myRule = Rule::leftToright;        vector&lt;int&gt; results;        vector&lt;vector&lt;int&gt;&gt; visited(rowCnt, vector&lt;int&gt;(colCnt));        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            int nextRow = row, nextCol = col;            results.emplace_back(matrix[row][col]);            visited[row][col] = 1;            if (myRule == 0) nextCol = col + 1;            if (myRule == 1) nextRow = row + 1;            if (myRule == 2) nextCol = col - 1;            if (myRule == 3) nextRow = row - 1;            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                myRule = static_cast&lt;Rule&gt;((myRule + 1) % 4);            if (myRule == 0) ++col;            if (myRule == 1) ++row;            if (myRule == 2) --col;            if (myRule == 3) --row;        &#125;        return results;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int rowCnt = matrix.length;        int colCnt = matrix[0].length;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int[][] visited = new int[rowCnt][colCnt];        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;        int directionIndex = 0;        int row = 0, col = 0;        for (int i = 0; i &lt; rowCnt * colCnt; ++i)        &#123;            results.add(matrix[row][col]);            visited[row][col] = 1;            int nextRow = row + directions[directionIndex][0];            int nextCol = col + directions[directionIndex][1];            if (nextRow &gt;= rowCnt || nextRow &lt; 0 || nextCol &gt;= colCnt || nextCol &lt; 0 || visited[nextRow][nextCol] == 1)                directionIndex = (directionIndex + 1) % 4;            row += directions[directionIndex][0];            col += directions[directionIndex][1];        &#125;        return results;    &#125;&#125;
class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        rowCnt, colCnt = len(matrix), len(matrix[0])        results = []        visited = [[0] * colCnt for _ in range(rowCnt)]        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]        direction_index = 0          row, col = 0, 0        for _ in range(rowCnt * colCnt):            results.append(matrix[row][col])            visited[row][col] = True            next_row = row + directions[direction_index][0]            next_col = col + directions[direction_index][1]            if not (0 &lt;= next_row &lt; rowCnt and 0 &lt;= next_col &lt; colCnt and not visited[next_row][next_col]):                direction_index = (direction_index + 1) % 4            row += directions[direction_index][0]            col += directions[direction_index][1]        return results

2. 按层模拟
每一圈相当于将最外围的数据输出，需要四个循环将四个边界输出，然后通过大的循环来遍历每一圈，注意圈的截止条件
class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;;        int bottom = matrix.size() - 1;        int right = matrix[0].size() - 1;        vector&lt;int&gt; results;        int left = 0, top = 0;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.emplace_back(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.emplace_back(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom) 			// 到这里可能剩余不足围成圈，如1*n或n*1，此时前两个循环已经足够处理，如果不加以限制，那么在n大于1的情况下，下述的循环将会有一个进入导致最后结尾出现多余的数据            &#123;                for (int i = right - 1; i &gt; left; --i) results.emplace_back(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.emplace_back(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;;
class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int bottom = matrix.length - 1;        int right = matrix[0].length - 1;        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();        int left = 0, top = 0;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return results;        while (left &lt;= right &amp;&amp; top &lt;= bottom)        &#123;            for (int i = left; i &lt;= right; ++i) results.add(matrix[top][i]);            for (int i = top + 1; i &lt;= bottom; ++i) results.add(matrix[i][right]);            if (left &lt; right &amp;&amp; top &lt; bottom)             &#123;                for (int i = right - 1; i &gt; left; --i) results.add(matrix[bottom][i]);                for (int i = bottom; i &gt; top; --i) results.add(matrix[i][left]);            &#125;            ++left;            ++top;            --bottom;            --right;        &#125;        return results;    &#125;&#125;
class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        bottom, right = len(matrix) - 1, len(matrix[0]) - 1        results = list()         left, top = 0, 0        while left &lt;= right and top &lt;= bottom:            for i in range(left, right + 1): results.append(matrix[top][i])            for i in range(top + 1, bottom + 1): results.append(matrix[i][right])            if left &lt; right and top &lt; bottom:                for i in range(right - 1, left, -1): results.append(matrix[bottom][i])                for i in range(bottom, top, -1): results.append(matrix[i][left])            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1        return results

四：旋转图像

1. 辅助数组
将旋转后的元素放入新的数组
class Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        auto result = matrix;        int m = matrix.size();        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        matrix.assign(result.begin(), result.end());    &#125;&#125;;
class Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        int[][] result = new int[m][m];        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; m; ++j)                result[j][m - 1 - i] = matrix[i][j];        for (int i = 0; i &lt; m; i++) &#123;            System.arraycopy(result[i], 0, matrix[i], 0, m);        &#125;    &#125;&#125;
class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        n = len(matrix)        result = [[0] * n for _ in range(n)]        for i in range(n):            for j in range(n):                result[j][n - 1 - i] = matrix[i][j]        matrix[:] = result

2. 原地旋转
参考移动数组的解决方案，这里旋转四次会回到原地，一圈会移动四个数据，那么也就是只需要旋转约四分之一的元素，n的奇的情况下，中间不需要管
class Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;;
class Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; (m + 1) / 2; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - 1 - j][i];                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1];                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1];                matrix[j][m - 1 - i] = temp;            &#125;    &#125;&#125;
class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range((m + 1) // 2):                temp = matrix[i][j]                matrix[i][j] = matrix[m - 1 - j][i]                matrix[m - j - 1][i] = matrix[m - i - 1][m - j - 1]                matrix[m - i - 1][m - j - 1] = matrix[j][m - i - 1]                matrix[j][m - 1 - i] = temp

3. 翻转
先水平后主对角线，也可以先竖直
class Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int m = matrix.size();        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)                swap(matrix[i][j], matrix[m - i - 1][j]);        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)                swap(matrix[i][j], matrix[j][i]);    &#125;&#125;;
class Solution &#123;    public void rotate(int[][] matrix) &#123;        int m = matrix.length;        for (int i = 0; i &lt; m / 2; ++i)            for (int j = 0; j &lt; m; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[m - i - 1][j];                matrix[m - i - 1][j] = temp;            &#125;        for (int i = 0; i &lt; m; ++i)            for (int j = 0; j &lt; i; ++j)            &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;    &#125;&#125;
class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        m = len(matrix)        for i in range(m // 2):            for j in range(m):                matrix[i][j], matrix[m - i - 1][j] = matrix[m - i - 1][j], matrix[i][j]        for i in range(m):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

五：搜索二维矩阵

1. 暴力
不写

2. 二分
由于数组左右有序，对每一行使用二分从中间查找
class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        for (auto&amp; row : matrix)        &#123;            auto it = lower_bound(row.begin(), row.end(), target);			// 返回不小于目标值的第一个元素的迭代器            if (it != row.end() &amp;&amp; *it == target) return true;        &#125;        return false;    &#125;&#125;;
class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        for (int[] row : matrix)        &#123;            int index = searchInsert(row, target);            if (index != -1) return true;        &#125;        return false;    &#125;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, cur = right + 1;        while (left &lt;= right)        &#123;            int mid = ((right - left) &gt;&gt; 1) + left;       // 防止int越界            if (target == nums[mid]) return mid;            else if (target &lt; nums[mid])                     right = mid - 1;            else                left = mid + 1;        &#125;        return -1;    &#125;&#125;
class Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        for row in matrix:            it = bisect.bisect_left(row, target)			            if it &lt; len(row) and row[it] == target: return True        return False

3. Z 字形查找
充分运用题目要求，第二种方法只有了一个条件，但数据从上往下也是递增，从右上角开始，横竖作为边界，也就是说如果某个位置的值小于目标值，行数可以加一，如果大于目标值，则列数应该减一
class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m = matrix.size();        int n = matrix[0].size();        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;;
class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length;        int n = matrix[0].length;        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0)        &#123;            if (matrix[i][j] == target) return true;            else if (matrix[i][j] &gt; target) --j;            else if(matrix[i][j] &lt; target) ++i;        &#125;        return false;    &#125;&#125;
class Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        m = len(matrix)        n = len(matrix[0])        i = 0        j = n - 1        while i &lt; m and j &gt;= 0:            if (matrix[i][j] == target): return True            elif (matrix[i][j] &gt; target): j -= 1            elif(matrix[i][j] &lt; target): i += 1        return False

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.6)</title>
    <url>/posts/6481260b.html</url>
    <content><![CDATA[一：环形链表2️⃣

1. 哈希表
这道题的思路和环形链表的方法一相同
class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; hashTable;        while (head != nullptr)        &#123;            if (hashTable.count(head)) return head;            hashTable.insert(head);            head = head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;
public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        Set&lt;ListNode&gt; hashTable = new HashSet&lt;ListNode&gt;();        while (head != null)        &#123;            if (hashTable.contains(head)) return head;			            hashTable.add(head);            head = head.next;        &#125;        return null;    &#125;&#125;
class Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        hashTable = set()        while head:            if head in hashTable:                return head            hashTable.add(head)            head = head.next        return None

2. 快慢指针
这道题的思路和环形链表的方法二相同，如果有环相遇点一定在环中，且快指针比慢指针多n圈，进入环之后快指针比慢指针多一圈

class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return nullptr;        ListNode* fastNode = head;               ListNode* slowNode = head;        while (fastNode != nullptr)        &#123;            if (fastNode == nullptr || fastNode-&gt;next == nullptr) return nullptr;            slowNode = slowNode-&gt;next;            fastNode = fastNode-&gt;next-&gt;next;            if (fastNode == slowNode)            &#123;                ListNode* cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur-&gt;next;                    slowNode = slowNode-&gt;next;                &#125;                return cur;            &#125;        &#125;        return nullptr;    &#125;&#125;;
public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        if (head == null || head.next == null) return null;        ListNode fastNode = head;               ListNode slowNode = head;        while (fastNode != null)        &#123;            if (fastNode == null || fastNode.next == null) return null;            slowNode = slowNode.next;            fastNode = fastNode.next.next;            if (fastNode == slowNode)            &#123;                ListNode cur = head;                while ( cur != slowNode)                 &#123;                    cur = cur.next;                    slowNode = slowNode.next;                &#125;                return cur;            &#125;        &#125;        return null;    &#125;&#125;
class Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return None        fastNode = head               slowNode = head        while (fastNode != None):            if (fastNode == None or fastNode.next == None): return None            slowNode = slowNode.next            fastNode = fastNode.next.next            if (fastNode == slowNode):                cur = head                while ( cur != slowNode):                     cur = cur.next                    slowNode = slowNode.next                return cur        return None

二：两数相加

1. 模拟
直接对对应节点的数字进行相加，难点在于处理进位和非对齐的场景
class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        int carry = 0;        ListNode* head = nullptr;        ListNode* cur = nullptr;        while (l1 != nullptr || l2 != nullptr)        &#123;            int num1= l1 ? l1-&gt;val : 0;            int num2= l2 ? l2-&gt;val : 0;            int sum= num1 + num2 + carry;            if (head == nullptr)                cur = head = new ListNode(sum % 10);            else                cur = cur-&gt;next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != nullptr) l1 = l1-&gt;next;            if (l2 != nullptr) l2 = l2-&gt;next;        &#125;        if (carry != 0) cur-&gt;next = new ListNode(carry);        return head;    &#125;&#125;;
class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int carry = 0;        ListNode head = null;        ListNode cur = null;        while (l1 != null || l2 != null)        &#123;            int num1= l1 != null ? l1.val : 0;            int num2= l2 != null ? l2.val : 0;            int sum= num1 + num2 + carry;            if (head == null)                cur = head = new ListNode(sum % 10);            else                cur = cur.next = new ListNode(sum % 10);            carry = sum / 10;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        if (carry != 0) cur.next = new ListNode(carry);        return head;    &#125;&#125;
class Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        carry = 0        head = None        cur = None        while (l1 != None or l2 != None):            num1 = l1.val if l1 else 0            num2 = l2.val if l2 else 0            sum= num1 + num2 + carry            if (head == None):                head = ListNode(sum % 10)                cur = head            else:                cur.next = ListNode(sum % 10)                cur = cur.next            carry = sum // 10            if (l1 != None): l1 = l1.next            if (l2 != None): l2 = l2.next        if (carry != 0): cur.next = ListNode(carry)        return head

三：删除链表的倒数第 N 个结点

1. 计算链表长度
需要一个虚拟头结点，这样可以删除任意的节点，否则如果只有一个节点并删除自己，则需要单独处理
class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        int length = GetLength(head);        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur-&gt;next;        &#125;        cur-&gt;next = cur-&gt;next-&gt;next;        ListNode* ans = dummy-&gt;next;        return ans;    &#125;    int GetLength(ListNode* head)    &#123;        int length = 0;        while (head)        &#123;            head = head-&gt;next;            ++length;        &#125;         return length;    &#125;&#125;;
class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        int length = GetLength(head);        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        for (int i = 1; i &lt; length - n + 1; ++i) &#123;            cur = cur.next;        &#125;        cur.next = cur.next.next;        ListNode ans = dummy.next;        return ans;    &#125;    public int GetLength(ListNode head)    &#123;        int length = 0;        while (head != null)        &#123;            head = head.next;            ++length;        &#125;         return length;    &#125;&#125;
class Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        def GetLength(head : Optional[ListNode]) -&gt; Optional[int]:            length = 0            while (head != None):                head = head.next                length += 1            return length        length = GetLength(head)        cur = ListNode(0, head)        dummy = cur        for i in range(1, length + 1 -n):            cur = cur.next        cur.next = cur.next.next        ans = dummy.next        return ans

2. 栈
用一个栈去存储节点，之后弹出的第n个节点就是需要删除的地方
class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* cur = new ListNode(0, head);        ListNode* dummy = cur;        stack&lt;ListNode*&gt; stk;        while (cur != nullptr)         &#123;            stk.push(cur);            cur = cur-&gt;next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.top();        head-&gt;next = head-&gt;next-&gt;next;        return dummy-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode cur = new ListNode(0, head);        ListNode dummy = cur;        Deque&lt;ListNode&gt; stk = new LinkedList&lt;&gt;();        while (cur != null)         &#123;            stk.push(cur);            cur = cur.next;        &#125;        for (int i = 0; i &lt; n; ++i) stk.pop();        head = stk.peek();        head.next = head.next.next;        return dummy.next;    &#125;&#125;
class Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        cur = ListNode(0, head)        dummy = cur        stk = list()        while (cur != None):             stk.append(cur)            cur = cur.next        for i in range(n): stk.pop()        head = stk[-1]        head.next = head.next.next        return dummy.next

3. 双指针
使用两个指针，快指针比慢指针多n个节点，快指针到达末尾则慢指针位置就是需要处理的地方
class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* slow = pre;           // 不从head开始的原因在于，可以刚好到达倒数第n节点的前继结点        ListNode* fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast-&gt;next;        while (fast != nullptr)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        slow-&gt;next = slow-&gt;next-&gt;next;        return pre-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode pre = new ListNode(0, head);        ListNode slow = pre;                 ListNode fast = head;        for (int i = 0; i &lt; n; ++i) fast = fast.next;        while (fast != null)        &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return pre.next;    &#125;&#125;
class Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        slow = pre                 fast = head        for i in range(n): fast = fast.next        while (fast != None):            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return pre.next

四：两两交换链表中的节点

1. 递归
终止条件为末尾只有单个节点或没有节点，一个递归需要处理两个节点
class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) return head;        ListNode* n1 = head-&gt;next;        head-&gt;next = swapPairs(n1-&gt;next);        n1-&gt;next = head;        return n1;    &#125;&#125;;
class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) return head;        ListNode n1 = head.next;        head.next = swapPairs(n1.next);        n1.next = head;        return n1;    &#125;&#125;
class Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None or head.next == None): return head        n1 = head.next        head.next = self.swapPairs(n1.next)        n1.next = head        return n1

2. 迭代
我们定义一个前继结点，依次交换后面的两个节点，然后前继结点向前移动两个位置
class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* pre = new ListNode(0, head);        ListNode* cur = pre;        while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)        &#123;            ListNode* n1 = cur-&gt;next;            ListNode* n2 = cur-&gt;next-&gt;next;            cur-&gt;next = n2;            n1-&gt;next = n2-&gt;next;            n2-&gt;next = n1;            cur = n1;        &#125;        return pre-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0, head);        ListNode cur = pre;        while (cur.next != null &amp;&amp; cur.next.next != null)        &#123;            ListNode n1 = cur.next;            ListNode n2 = cur.next.next;            cur.next = n2;            n1.next = n2.next;            n2.next = n1;            cur = n1;        &#125;        return pre.next;    &#125;&#125;
class Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = ListNode(0, head)        cur = pre        while (cur.next != None and cur.next.next != None):            n1 = cur.next            n2 = cur.next.next            cur.next = n2            n1.next = n2.next            n2.next = n1            cur = n1        return pre.next

五：随机链表的复制

1. 回溯+哈希表
该题的难度在于随机指针的处理，因为拷贝节点时，随机指针指向的节点可能还未创建，一种方法是先不拷贝随机指针，在第二次循环中再拷贝，或者利用递归的思想反向处理
class Solution &#123;public:    unordered_map&lt;Node*, Node*&gt; hashMap;    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return head;        if (!hashMap.count(head))        &#123;            Node* newNode = new Node(head-&gt;val);            hashMap[head] = newNode;            newNode-&gt;next = copyRandomList(head-&gt;next);     // 到这里完成了除随机指针的拷贝            newNode-&gt;random = copyRandomList(head-&gt;random);		// 等效于第二次遍历，此时节点已完成创建        &#125;        return hashMap[head];    &#125;&#125;;
class Solution &#123;    public Map&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();    public Node copyRandomList(Node head) &#123;        if (head == null) return head;        if (hashMap.containsKey(head) == false)        &#123;            Node newNode = new Node(head.val);            hashMap.put(head, newNode);            newNode.next = copyRandomList(head.next);                 newNode.random = copyRandomList(head.random);             &#125;        return hashMap.get(head);    &#125;&#125;
class Solution:    def __init__(self):        self.hashMap = &#123;&#125;		# 这里初始化    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return head        if (head not in self.hashMap):            newNode= Node(head.val)            self.hashMap[head] = newNode            newNode.next = self.copyRandomList(head.next)                 newNode.random = self.copyRandomList(head.random)             return self.hashMap[head]

2. 迭代+拆分
将每一个拷贝后的节点作为原节点的后继结点，随机指针则为原指针的随机指针节点的后继位置，空除外
class Solution &#123;public:    Node* copyRandomList(Node* head) &#123;        if (head == nullptr) return nullptr;        Node* newHead = nullptr;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)		// 建立复制链表        &#123;            Node* newNode = new Node(start-&gt;val);            newNode-&gt;next = start-&gt;next;            start-&gt;next = newNode;        &#125;        for (Node* start = head; start != nullptr; start = start-&gt;next-&gt;next)		// 对随机指针赋值        &#123;            if (start-&gt;random != nullptr) start-&gt;next-&gt;random = start-&gt;random-&gt;next;            else start-&gt;next-&gt;random =nullptr;        &#125;        newHead = head-&gt;next;        for (Node* start = head; start != nullptr; start = start-&gt;next)			// 恢复原链表，连接新链表        &#123;            Node* newNode = start-&gt;next;            start-&gt;next = start-&gt;next-&gt;next;            newNode-&gt;next = (newNode-&gt;next != nullptr) ? newNode-&gt;next-&gt;next : nullptr;        &#125;        return newHead;    &#125;&#125;;
class Solution &#123;    public Node copyRandomList(Node head) &#123;        if (head == null) return null;        Node newHead = null;        for (Node start = head; start != null; start = start.next.next)		        &#123;            Node newNode = new Node(start.val);            newNode.next = start.next;            start.next = newNode;        &#125;        for (Node start = head; start != null; start = start.next.next)		        &#123;            if (start.random != null) start.next.random = start.random.next;            else start.next.random =null;        &#125;        newHead = head.next;        for (Node start = head; start != null; start = start.next)			        &#123;            Node newNode = start.next;            start.next = start.next.next;            newNode.next = (newNode.next != null) ? newNode.next.next : null;        &#125;        return newHead;    &#125;&#125;
class Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if (head == None): return None        start = head        while start:	            newNode = Node(start.val)            newNode.next = start.next            start.next = newNode            start = newNode.next        start = head        while start:	            if (start.random != None): start.next.random = start.random.next            else: start.next.random = None            start = start.next.next        newHead = head.next        start = head        while start:		            newNode = start.next            start.next = start.next.next            if newNode.next:                newNode.next = newNode.next.next            start = start.next        return newHead

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode热题100(25.10.7)</title>
    <url>/posts/7d9a174a.html</url>
    <content><![CDATA[一：排序链表

1. 自顶向下归并排序
对链表不断切分，然后使用合并两个有序链表的方式合并
class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        return recursion(head, nullptr);    &#125;    ListNode* recursion(ListNode* left, ListNode* right)    &#123;        if (left == nullptr || left-&gt;next == nullptr) return left;        if (left-&gt;next == right)        &#123;            left-&gt;next = nullptr;            return left;        &#125;        ListNode* slow = left, *fast = left;        while (fast != right)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;            if (fast != right) fast = fast-&gt;next;        &#125;        ListNode* mid = slow;        ListNode* leftNew = recursion(left, mid);        ListNode* rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);			// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode sortList(ListNode head) &#123;        return recursion(head, null);    &#125;    public ListNode recursion(ListNode left, ListNode right)    &#123;        if (left == null || left.next == null) return left;        if (left.next == right)        &#123;            left.next = null;            return left;        &#125;        ListNode slow = left, fast = left;        while (fast != right)        &#123;            slow = slow.next;            fast = fast.next;            if (fast != right) fast = fast.next;        &#125;        ListNode mid = slow;        ListNode leftNew = recursion(left, mid);        ListNode rightNew = recursion(mid, right);        return MergeTwoLists(leftNew, rightNew);    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;
class Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.recursion(head, None)    def recursion(self, left, right):        if (left == None or left.next == None): return left        if (left.next == right):            left.next = None            return left        slow, fast = left, left        while (fast != right):            slow = slow.next            fast = fast.next            if (fast != right): fast = fast.next        mid = slow        leftNew = self.recursion(left, mid)        rightNew = self.recursion(mid, right)        return self.MergeTwoLists(leftNew, rightNew)     def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)			# 没有new        cur = preNode        if not list1:			# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next

2. 自底向上归并排序
第一层处理两个节点，将它们断开并排序，第二层结束处理四个节点，其中的两两已经处理好，是有序链表，因此可直接排序，依次迭代
class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (head == nullptr) return head;        int length = 0;        ListNode* temp = head;        ListNode* pre = new ListNode(0, head);        while (temp != nullptr)        &#123;            ++length;            temp = temp-&gt;next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode* preCur = pre;            ListNode* cur = pre-&gt;next;            while (cur != nullptr)            &#123;                ListNode* node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur-&gt;next != nullptr; ++i) cur = cur-&gt;next;                ListNode* node2 = cur-&gt;next;                cur-&gt;next = nullptr;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != nullptr &amp;&amp; cur-&gt;next !=nullptr; ++i) cur = cur-&gt;next;                ListNode* next = nullptr;                if (cur != nullptr)                &#123;                    next = cur-&gt;next;                    cur-&gt;next = nullptr;                    cur = next;                &#125;                preCur-&gt;next = MergeTwoLists(node1, node2);                while (preCur-&gt;next != nullptr) preCur = preCur-&gt;next;            &#125;        &#125;        return pre-&gt;next;    &#125;    ListNode* MergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* preNode = new ListNode(0);			// 哨兵节点         ListNode* cur = preNode;        if (!list1) return list2;        if (!list2) return list1;        while (list1 != nullptr &amp;&amp; list2 != nullptr)        &#123;            if (list1-&gt;val &lt; list2-&gt;val)            &#123;                cur-&gt;next = list1;                list1 = list1-&gt;next;            &#125;             else            &#123;                cur-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            cur = cur-&gt;next;        &#125;        cur-&gt;next = list1 == nullptr ? list2 : list1;        return preNode-&gt;next;    &#125;&#125;;
class Solution &#123;    public ListNode sortList(ListNode head) &#123;        if (head == null) return head;        int length = 0;        ListNode temp = head;        ListNode pre = new ListNode(0, head);        while (temp != null)        &#123;            ++length;            temp = temp.next;        &#125;        for (int sub = 1; sub &lt; length; sub *= 2)        &#123;            ListNode preCur = pre;            ListNode cur = pre.next;            while (cur != null)            &#123;                ListNode node1 = cur;                for (int i = 1; i &lt; sub &amp;&amp; cur.next != null; ++i) cur = cur.next;                ListNode node2 = cur.next;                cur.next = null;                cur = node2;                for (int i = 1; i &lt; sub &amp;&amp; cur != null &amp;&amp; cur.next !=null; ++i) cur = cur.next;                ListNode next = null;                if (cur != null)                &#123;                    next = cur.next;                    cur.next = null;                    cur = next;                &#125;                preCur.next = MergeTwoLists(node1, node2);                while (preCur.next != null) preCur = preCur.next;            &#125;        &#125;        return pre.next;    &#125;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode preNode = new ListNode(0);        ListNode cur = preNode;        if (list1 == null) return list2;        if (list2 == null) return list1;        while (list1 != null &amp;&amp; list2 != null)        &#123;            if (list1.val &lt; list2.val)            &#123;                cur.next = list1;                list1 = list1.next;            &#125;             else            &#123;                cur.next = list2;                list2 = list2.next;            &#125;            cur = cur.next;        &#125;        cur.next = list1 == null ? list2 : list1;        return preNode.next;    &#125;&#125;
class Solution:    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if (head == None): return head        length = 0        temp = head        pre = ListNode(0, head)        while (temp != None):            length += 1            temp = temp.next        sub = 1        while (sub &lt; length):            preCur = pre            cur = pre.next            while (cur != None):                node1 = cur                for i in range(1, sub):                    if cur.next:                        cur = cur.next                    else:                        break                node2 = cur.next                cur.next = None                cur = node2                for i in range(1, sub):                    if cur and cur.next:                        cur = cur.next                    else:                        break                next = None                if (cur != None):                    next = cur.next                    cur.next = None                    cur = next                preCur.next = self.MergeTwoLists(node1, node2)                while (preCur.next != None): preCur = preCur.next            sub *= 2        return pre.next    def MergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        preNode = ListNode(0)			# 没有new        cur = preNode        if not list1:			# 这个判断好像不需要，后面的代码实现同样的功能            return list2        if not list2:            return list1        while list1 and list2:               if list1.val &lt; list2.val:                cur.next = list1                list1 = list1.next            else:                cur.next = list2                list2 = list2.next            cur = cur.next        if list1:            cur.next = list1        else:            cur.next = list2        return preNode.next

二：LRU缓存

1. 哈希表+双向链表
使用哈希表保存键和双向链表的节点，节点保存键值和前后指针，这样每个操作都为常数
class LRUCache &#123;private:struct DoubleList&#123;    int key;    int value;    DoubleList* pre;    DoubleList* next;    DoubleList() : key(0), value(0), pre(nullptr), next(nullptr) &#123;&#125;    DoubleList(int _key, int _value) : key(_key), value(_value), pre(nullptr), next(nullptr) &#123;&#125;&#125;;public:    unordered_map&lt;int, DoubleList*&gt; hashMap;    DoubleList* head;    DoubleList* tail;    int capacity = 0;    int size = 0;    LRUCache(int capacity) &#123;        this-&gt;capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head-&gt;next = tail;        tail-&gt;pre = head;    &#125;        int get(int key) &#123;        if (hashMap.count(key) == false) return -1;        else        &#123;            DoubleList* cur = hashMap[key];            AddToHead(DeleteNode(cur));            return cur-&gt;value;        &#125;    &#125;        void put(int key, int value) &#123;        if (hashMap.count(key) == false)        &#123;            DoubleList* newNode = new DoubleList(key, value);            hashMap[key] = newNode;            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList* deleteNode = DeleteNode(tail-&gt;pre);                hashMap.erase(deleteNode-&gt;key);                delete deleteNode;                --size;            &#125;        &#125; else        &#123;            DoubleList* cur = hashMap[key];            cur-&gt;value = value;            AddToHead(DeleteNode(cur));        &#125;    &#125;    DoubleList* DeleteNode(DoubleList* node)    &#123;        node-&gt;next-&gt;pre = node-&gt;pre;        node-&gt;pre-&gt;next = node-&gt;next;        return node;    &#125;    void AddToHead(DoubleList* node)    &#123;        node-&gt;pre = head;        node-&gt;next = head-&gt;next;        head-&gt;next = node;        node-&gt;next-&gt;pre = node;    &#125;&#125;;
class LRUCache &#123;    class DoubleList    &#123;        int key;        int value;        DoubleList pre;        DoubleList next;        public DoubleList() &#123;&#125;        public DoubleList(int _key, int _value) &#123;key = _key; value = _value;&#125;    &#125;    Map&lt;Integer, DoubleList&gt; hashMap = new HashMap&lt;&gt;();    DoubleList head;    DoubleList tail;    int capacity = 0;    int size = 0;    public LRUCache(int capacity) &#123;        this.capacity = capacity;        head = new DoubleList();        tail = new DoubleList();        head.next = tail;        tail.pre = head;    &#125;        public int get(int key) &#123;        if (hashMap.containsKey(key) == false) return -1;        else        &#123;            DoubleList cur = hashMap.get(key);            AddToHead(DeleteNode(cur));            return cur.value;        &#125;    &#125;        public void put(int key, int value) &#123;        if (hashMap.containsKey(key) == false)        &#123;            DoubleList newNode = new DoubleList(key, value);            hashMap.put(key, newNode);            AddToHead(newNode);            ++size;            if (size &gt; capacity)            &#123;                DoubleList deleteNode = DeleteNode(tail.pre);                hashMap.remove(deleteNode.key);                --size;            &#125;        &#125; else        &#123;            DoubleList cur = hashMap.get(key);            cur.value = value;            AddToHead(DeleteNode(cur));        &#125;     &#125;    public DoubleList DeleteNode(DoubleList node)    &#123;        node.next.pre = node.pre;        node.pre.next = node.next;        return node;    &#125;    public void AddToHead(DoubleList node)    &#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;&#125;
class LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.size = 0        self.hashMap = dict()        self.head = DoubleList()        self.tail = DoubleList()        self.head.next = self.tail        self.tail.prev = self.head    def get(self, key: int) -&gt; int:        if (key not in self.hashMap): return -1        else:            cur = self.hashMap[key]            self.AddToHead(self.DeleteNode(cur))            return cur.value    def put(self, key: int, value: int) -&gt; None:        if (key not in self.hashMap):            newNode = DoubleList(key, value)            self.hashMap[key] = newNode            self.AddToHead(newNode)            self.size += 1            if (self.size &gt; self.capacity):                   deleteNode = self.DeleteNode(self.tail.pre)                self.hashMap.pop(deleteNode.key)                self.size -= 1        else:            cur = self.hashMap[key]            cur.value = value            self.AddToHead(self.DeleteNode(cur))    def DeleteNode(self, node):        node.next.pre = node.pre        node.pre.next = node.next        return node    def AddToHead(self, node):        node.pre = self.head        node.next = self.head.next        self.head.next = node        node.next.pre = nodeclass DoubleList:    def __init__(self, key = 0, value = 0):        self.key = key        self.value = value        self.prev = None        self.next = None

三：二叉树的层序遍历

1. 广度优先搜索
用队列表示每一层，逐层遍历
class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if (root == nullptr) return result;        queue&lt;TreeNode*&gt; queueTree;        queueTree.push(root);        while (queueTree.empty() == false)        &#123;            int size = queueTree.size();            result.emplace_back(vector&lt;int&gt;());            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode* newNode = queueTree.front();                queueTree.pop();                result.back().emplace_back(newNode-&gt;val);                if (newNode-&gt;left) queueTree.push(newNode-&gt;left);                if (newNode-&gt;right) queueTree.push(newNode-&gt;right);              &#125;        &#125;        return result;    &#125;&#125;;
class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if (root == null) return result;        Queue&lt;TreeNode&gt; queueTree = new LinkedList&lt;&gt;();        queueTree.offer(root);        while (queueTree.isEmpty() == false)        &#123;            int size = queueTree.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; size; ++i)            &#123;                TreeNode newNode = queueTree.poll();                level.add(newNode.val);                if (newNode.left != null) queueTree.offer(newNode.left);                if (newNode.right != null) queueTree.offer(newNode.right);              &#125;            result.add(level);        &#125;        return result;    &#125;&#125;
class Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        result = []        if (root == None): return result        queueTree = deque([root])        while (queueTree):            size = len(queueTree)            level = []            for _ in range(size):                newNode = queueTree.popleft()                level.append(newNode.val)                if (newNode.left != None): queueTree.append(newNode.left)                if (newNode.right != None): queueTree.append(newNode.right)              result.append(level)        return result

四：验证二叉搜索树

1. 递归
参考二叉树的中序遍历的递归写法，这里多了对数据大小的判断
class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        return recursion(root, LONG_MIN, LONG_MAX);    &#125;    bool recursion(TreeNode* node, long long min, long long max)    &#123;        if (node == nullptr) return true;        if (node-&gt;val &lt;= min || node-&gt;val &gt;= max) return false;        bool flagLeft = recursion(node-&gt;left, min, node-&gt;val);        bool flagRight = recursion(node-&gt;right, node-&gt;val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;;
class Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public boolean recursion(TreeNode node, long min, long max)    &#123;        if (node == null) return true;        if (node.val &lt;= min || node.val &gt;= max) return false;        boolean flagLeft = recursion(node.left, min, node.val);        boolean flagRight = recursion(node.right, node.val, max);        return flagLeft &amp;&amp; flagRight;    &#125;&#125;
class Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def recursion(node, min, max):            if (node == None): return True            if (node.val &lt;= min or node.val &gt;= max): return False            flagLeft = recursion(node.left, min, node.val)            flagRight = recursion(node.right, node.val, max)            return flagLeft and flagRight        return recursion(root, float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;))

2. 中序遍历
参考二叉树的中序遍历的迭代写法，这里多了对数据大小的判断
class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeStack;        long long min = (long long)INT_MIN - 1;        while (root != nullptr || !treeStack.empty())       // 需要保证栈中的内容处理完毕        &#123;            while (root != nullptr)            &#123;                treeStack.push(root);           // 入栈                root = root-&gt;left;            &#125;            root = treeStack.top();             // 栈顶            treeStack.pop();                    // 拿到数据出栈            if (root -&gt; val &lt;= min) return false;            min = root -&gt; val;            root = root-&gt;right;       &#125;        return true;    &#125;&#125;;
class Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            if (root.val &lt;= min) return false;            min = root.val;            root = root.right;        &#125;        return true;    &#125;&#125;
class Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        treeStack = []        min = float(&#x27;-inf&#x27;)        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            if (root.val &lt;= min): return False            min = root.val            root = root.right        return True

五：二叉搜索树中第 K 小的元素

1. 中序遍历
利用中序遍历得到有序数组，找到数组中的第K个元素即可。迭代用栈管理，栈弹出的顺序就是有序列表，因此第K个就是需要的值
class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        stack&lt;TreeNode*&gt; treeStack;        while (root != nullptr || !treeStack.empty())              &#123;            while (root != nullptr)            &#123;                treeStack.push(root);                       root = root-&gt;left;            &#125;            root = treeStack.top();                   treeStack.pop();                    // 第一个出栈的为最小元素，出栈k次即可得到结果            --k;            if (k == 0) break;             root = root-&gt;right;       &#125;        return root-&gt;val;    &#125;&#125;;
class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        Deque&lt;TreeNode&gt; treeDeque = new ArrayDeque&lt;TreeNode&gt;();        double min = -Double.MAX_VALUE - 1;        while (root != null || !treeDeque.isEmpty())        // 使用isEmpty        &#123;            while (root != null)            &#123;                treeDeque.push(root);                root = root.left;            &#125;            root = treeDeque.pop();            --k;            if (k == 0) break;            root = root.right;        &#125;        return root.val;    &#125;&#125;
class Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        treeStack = []        while root is not None or treeStack:            while root is not None:                treeStack.append(root)                root = root.left            root = treeStack.pop()            k -= 1            if (k == 0): break            root = root.right        return root.val

2. 记录子树的节点
把每个节点的左右子树的节点数量记录，此时只需要判断k与子树节点数量的大小，因为左子树一定小于当前节点，右子树大于当前节点。适用于频繁寻找k值
class Solution &#123;public:    unordered_map&lt;TreeNode*, int&gt; hashMap;    TreeNode* root;    int kthSmallest(TreeNode* root, int k) &#123;        this-&gt;root = root;        CountNum(root);        return SearchTarget(k);    &#125;    int CountNum(TreeNode* node)    &#123;        if (node == nullptr) return 0;        hashMap[node] = 1 + CountNum(node-&gt;left) + CountNum(node-&gt;right);        return hashMap[node];    &#125;    int GetNum(TreeNode* node)    &#123;        if (node != nullptr &amp;&amp; hashMap.count(node)) return hashMap[node];        else return 0;    &#125;    int SearchTarget(int k)    &#123;        TreeNode* node = root;        while (node != nullptr)        &#123;            int leftNum = GetNum(node-&gt;left);            if (leftNum &lt; k - 1)            &#123;                node = node-&gt;right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node-&gt;left;            else break;        &#125;        return node-&gt;val;    &#125;&#125;;
class Solution &#123;    public Map&lt;TreeNode, Integer&gt; hashMap = new HashMap&lt;&gt;();    public TreeNode root;    public int kthSmallest(TreeNode root, int k) &#123;        this.root = root;        CountNum(root);        return SearchTarget(k);    &#125;    public int CountNum(TreeNode node)    &#123;        if (node == null) return 0;        hashMap.put(node, 1 + CountNum(node.left) + CountNum(node.right));        return hashMap.get(node);    &#125;    public int GetNum(TreeNode node)    &#123;        if (node != null &amp;&amp; hashMap.containsKey(node)) return hashMap.get(node);        else return 0;    &#125;    public int SearchTarget(int k)    &#123;        TreeNode node = root;        while (node != null)        &#123;            int leftNum = GetNum(node.left);            if (leftNum &lt; k - 1)            &#123;                node = node.right;                k -= leftNum + 1;            &#125; else if (leftNum &gt; k - 1) node = node.left;            else break;        &#125;        return node.val;    &#125;&#125;
class Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        self.hashMap = &#123;&#125;        self.root = root        self.CountNum(self.root)        return self.SearchTarget(k)    def CountNum(self, node):        if (node == None): return 0        self.hashMap[node] = 1 + self.CountNum(node.left) + self.CountNum(node.right)        return self.hashMap[node]    def GetNum(self, node):        if (node != None and node in self.hashMap): return self.hashMap[node]        else: return 0    def SearchTarget(self, k):        node = self.root        while (node != None):            leftNum = self.GetNum(node.left)            if (leftNum &lt; k - 1):                node = node.right                k -= leftNum + 1            elif (leftNum &gt; k - 1): node = node.left            else: break        return node.val

3. 平衡二叉搜索树
官方给的题解太长了，使用了经典的AVL树数据结构，并添加了一些常用的操作，没必要，简化一下吧
struct Node &#123;    int val;    Node * parent;    Node * left;    Node * right;    int size;    int height;    Node(int val, Node * parent) &#123;        this-&gt;val = val;        this-&gt;parent = parent;        this-&gt;left = nullptr;        this-&gt;right = nullptr;        this-&gt;height = 0;         this-&gt;size = 1;     &#125;&#125;;class AVL &#123;public:    Node * root;    AVL(vector&lt;int&gt; &amp; vals) &#123;        if (!vals.empty()) &#123;            root = build(vals, 0, vals.size() - 1, nullptr);        &#125;    &#125;    Node * build(vector&lt;int&gt; &amp; vals, int l, int r, Node * parent) &#123;        int m = (l + r) &gt;&gt; 1;        Node * node = new Node(vals[m], parent);        if (l &lt;= m - 1) &#123;            node-&gt;left = build(vals, l, m - 1, node);        &#125;        if (m + 1 &lt;= r) &#123;            node-&gt;right = build(vals, m + 1, r, node);        &#125;        recompute(node);        return node;    &#125;    void recompute(Node * node) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));        node-&gt;size = 1 + getSize(node-&gt;left) + getSize(node-&gt;right);    &#125;    static int getHeight(Node * node) &#123;        return node != nullptr ? node-&gt;height : 0;    &#125;    static int getSize(Node * node) &#123;        return node != nullptr ? node-&gt;size : 0;    &#125;    int kthSmallest(int k) &#123;        Node * node = root;        while (node != nullptr) &#123;            int left = getSize(node-&gt;left);            if (left &lt; k - 1) &#123;                node = node-&gt;right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node-&gt;left;            &#125;        &#125;        return node-&gt;val;    &#125;&#125;;class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        vector&lt;int&gt; inorderList;        inorder(root, inorderList);        AVL avl(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode * node, vector&lt;int&gt; &amp; inorderList) &#123;        if (node-&gt;left != nullptr) &#123;            inorder(node-&gt;left, inorderList);        &#125;        inorderList.push_back(node-&gt;val);        if (node-&gt;right != nullptr) &#123;            inorder(node-&gt;right, inorderList);        &#125;    &#125;&#125;;
class Node &#123;    int val;    Node parent;    Node left;    Node right;    int size;    int height;    Node(int val, Node parent) &#123;        this.val = val;        this.parent = parent;        this.left = null;        this.right = null;        this.height = 0;         this.size = 1;     &#125;&#125;class AVL &#123;    Node root;    AVL(List&lt;Integer&gt; vals) &#123;        if (!vals.isEmpty()) &#123;            root = build(vals, 0, vals.size() - 1, null);        &#125;    &#125;    Node build(List&lt;Integer&gt; vals, int l, int r, Node parent) &#123;        if (l &gt; r) &#123;            return null;        &#125;        int m = l + (r - l) / 2;        Node node = new Node(vals.get(m), parent);        node.left = build(vals, l, m - 1, node);        node.right = build(vals, m + 1, r, node);                recompute(node);        return node;    &#125;    void recompute(Node node) &#123;        if (node == null) return;        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));        node.size = 1 + getSize(node.left) + getSize(node.right);    &#125;    static int getHeight(Node node) &#123;        return node != null ? node.height : 0;    &#125;    static int getSize(Node node) &#123;        return node != null ? node.size : 0;    &#125;    int kthSmallest(int k) &#123;        Node node = root;        while (node != null) &#123;            int left = getSize(node.left);            if (left &lt; k - 1) &#123;                node = node.right;                k -= left + 1;            &#125; else if (left == k - 1) &#123;                break;            &#125; else &#123;                node = node.left;            &#125;        &#125;        return node.val;    &#125;&#125;class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;        List&lt;Integer&gt; inorderList = new ArrayList&lt;&gt;();        inorder(root, inorderList);                if (inorderList.isEmpty() || k &lt;= 0 || k &gt; inorderList.size()) &#123;            return -1;        &#125;        AVL avl = new AVL(inorderList);        return avl.kthSmallest(k);    &#125;    void inorder(TreeNode node, List&lt;Integer&gt; inorderList) &#123;        if (node == null) &#123;            return;        &#125;        inorder(node.left, inorderList);        inorderList.add(node.val);        inorder(node.right, inorderList);    &#125;&#125;
class Node:    def __init__(self, val: int, parent: Optional[&#x27;Node&#x27;] = None):        self.val = val        self.parent = parent        self.left = None        self.right = None        self.height = 0        self.size = 1class AVL:    def __init__(self, vals: List[int]):        self.root: Optional[Node] = None        if vals:            self.root = self.build(vals, 0, len(vals) - 1, None)    def build(self, vals: List[int], l: int, r: int, parent: Optional[Node]) -&gt; Optional[Node]:        if l &gt; r:            return None                m = (l + r) // 2        node = Node(vals[m], parent)                node.left = self.build(vals, l, m - 1, node)        node.right = self.build(vals, m + 1, r, node)                self.recompute(node)        return node    def recompute(self, node: Node):        if node is None:            return                    left_height = AVL.get_height(node.left)        right_height = AVL.get_height(node.right)                node.height = 1 + max(left_height, right_height)        node.size = 1 + AVL.get_size(node.left) + AVL.get_size(node.right)    @staticmethod    def get_height(node: Optional[Node]) -&gt; int:        return node.height if node else 0    @staticmethod    def get_size(node: Optional[Node]) -&gt; int:        return node.size if node else 0    def kthSmallest(self, k: int) -&gt; int:        node = self.root        while node:            left_size = AVL.get_size(node.left)                        if left_size &lt; k - 1:                k -= left_size + 1                node = node.right            elif left_size == k - 1:                return node.val            else:                node = node.left                return -1class Solution:    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:        inorder_list: List[int] = []        self._inorder(root, inorder_list)                if not inorder_list or k &lt;= 0 or k &gt; len(inorder_list):            return -1                    avl = AVL(inorder_list)        return avl.kthSmallest(k)    def _inorder(self, node: Optional[TreeNode], inorder_list: List[int]):        if node is None:            return                    self._inorder(node.left, inorder_list)        inorder_list.append(node.val)        self._inorder(node.right, inorder_list)

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulink调用外部Dll交互《三》</title>
    <url>/posts/ee275623.html</url>
    <content><![CDATA[介绍
本文主要实现了Simulink下模块化GUI与外部Dll数据交互的功能。首先将需要用到的交互接口封装，导出为C风格的函数，然后在模块中创建可视化界面并导入外部Dll，用于显示和操作数据，并在修改数据后通过接口保存到文件，如果成功，则与后续接口通信，调用求解器并显示结果
导出交互接口
// 参数交互EXPORT_API void LoadParametersFromIni(void* p, const char* filename);EXPORT_API int GetGlobalParameterCount(void* p);EXPORT_API const char* GetParameterName(void* p, int index);EXPORT_API double GetParameterValue(void* p, int index);EXPORT_API double GetParameterMin(void* p, int index);EXPORT_API double GetParameterMax(void* p, int index);EXPORT_API const char* GetParameterDescription(void* p, int index);EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath);
//-------------参数交互用-------------------   EXPORT_API void LoadParametersFromIni(void* p, const char* filename) &#123;       if (!p || !filename) return;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       proc-&gt;LoadIniParametersToGlobalParameter(filename);  // 调用现有方法   &#125;   EXPORT_API int GetGlobalParameterCount(void* p) &#123;       if (!p) return 0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       return static_cast&lt;int&gt;(proc-&gt;m_vglobalParams.size());   &#125;   EXPORT_API const char* GetParameterName(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetName().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API double GetParameterValue(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetValue();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMin(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMin();       &#125;       return 0.0;   &#125;   EXPORT_API double GetParameterMax(void* p, int index) &#123;       if (!p || index &lt; 0) return 0.0;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetMax();       &#125;       return 0.0;   &#125;   EXPORT_API const char* GetParameterDescription(void* p, int index) &#123;       if (!p || index &lt; 0) return nullptr;       auto proc = static_cast&lt;CXXXProcessor*&gt;(p);       if (index &lt; proc-&gt;m_vglobalParams.size()) &#123;           return proc-&gt;m_vglobalParams[index]-&gt;GetDescription().c_str();       &#125;       return nullptr;   &#125;   EXPORT_API bool RewriteBWIIni_Param(void* p, const char* paramName, double newValue, const char* projectPath) &#123;       if (!p || !paramName || !projectPath) &#123;           return false;       &#125;       try &#123;           auto proc = static_cast&lt;CXXXProcessor*&gt;(p);           // 调用 C++ 类成员函数进行参数修改           return proc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);                   &#125;       catch (const std::exception&amp; e) &#123;           std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;           return false;       &#125;   &#125;
这段代码主要是通过 C++ 的 EXPORT_API 宏将 CXXXProcessor 类的相关函数暴露为 API 接口，允许外部调用进行参数的读取、修改以及加载配置。
1. EXPORT_API 宏
每个函数前面都使用了 EXPORT_API 宏，这通常是为了将这些函数导出为 DLL 接口，让外部应用可以调用这些函数。这种做法常见于需要将 C++ 类和方法暴露给其他编程语言（如 Python 或 C#）的情况。EXPORT_API 一般在头文件中定义，并用来标记需要导出的函数。
2. 参数校验
在所有函数内部，第一步都是检查指针或参数是否为空或无效。例如：
if (!p || !filename) return;
这种做法可以确保在程序运行时避免因为传入无效参数而导致的崩溃，增强了代码的鲁棒性。
3. static_cast 类型转换
很多地方使用了 static_cast 来进行类型转换。比如：
auto proc = static_cast&lt;CXXXProcessor*&gt;(p);
这里 p 是一个 void* 类型的指针，指向 CXXXProcessor 类型的对象。static_cast 将 void* 转换成 CXXXProcessor* 类型，以便调用该类的成员函数。通过这种方式，可以在不暴露类内部实现的情况下，提供面向外部的 API 接口。
4. 函数功能设计
加载参数 (LoadParametersFromIni)
proc-&gt;LoadIniParametersToGlobalParameter(filename);
该函数的设计目的是加载指定的 .ini 配置文件，并将参数值导入到类内部的全局参数列表中。它的设计思想是将文件读取与内存中数据的存储解耦，便于后续的参数操作。
参数获取函数
包括：

GetGlobalParameterCount：返回全局参数的数量。
GetParameterName、GetParameterValue、GetParameterMin、GetParameterMax：返回指定参数的不同属性（名称、值、最小值、最大值）。
GetParameterDescription：返回参数的描述信息。

这些函数的设计方式非常直观，主要是通过访问类内部 m_vglobalParams 成员（一个存储参数的容器，如 std::vector）来返回相应的信息。每个函数都首先检查传入的索引是否有效，确保在访问数组或容器时不会越界。
修改参数 (RewriteBWIIni_Param)
proc-&gt;RewriteBWIIni_Param(paramName, newValue, projectPath);
此函数负责修改指定参数的值并将其更新回 .ini 配置文件中。它利用 CXXXProcessor 类中的现有方法 RewriteBWIIni_Param 来执行实际的修改操作。在设计上，这个函数有一个异常处理机制（try-catch 语句），用于捕获运行时可能出现的异常，防止程序崩溃。错误信息会通过 std::cerr 输出，便于调试。
5. 数据封装与分离
函数内部使用了 CXXXProcessor 类封装了所有参数相关的操作，外部调用者仅通过接口来操作这些数据。这样的封装设计符合面向对象编程（OOP）的原则，数据与操作方法分离，外部只关心接口而无需了解内部实现细节。

m_vglobalParams 是存储所有全局参数的容器，封装了参数的读取、修改等操作。
CXXXProcessor 类中提供了对参数的处理函数，如 LoadIniParametersToGlobalParameter 和 RewriteBWIIni_Param，而 API 函数仅暴露必要的接口给外部调用。

6. 错误处理与返回值
大多数函数都进行了参数校验和错误处理。比如 GetParameterName 和其他类似的获取参数信息的函数都返回 nullptr 或默认值（如 0.0），当输入无效时避免出现错误：
if (!p || index &lt; 0) return nullptr;
RewriteBWIIni_Param 函数则使用 try-catch 机制来捕获异常，确保在发生异常时能返回 false，并输出错误信息。
7. 代码设计的一致性与可扩展性

所有获取参数的函数（如 GetParameterName、GetParameterValue 等）具有一致的接口设计，参数索引作为输入，返回相关数据。这使得 API 易于扩展和维护，后期可以轻松增加更多的参数获取功能。
RewriteBWIIni_Param 与加载参数的功能解耦，遵循了单一职责原则，使得每个函数都专注于自己的一部分工作，易于理解和测试。

Matlab GUI实现
将上个步骤的代码编译为Dll，并把其头文件、dll文件以及所有用到的其他dll拷贝到Matlab的运行环境下
function sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0        start_import_gui(block.BlockHandle);  % 传递块句柄给 GUI        block.Dwork(1).Data = 1;  % 设置 GUI 已启动标志    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        % 自动开始仿真，无需手动输入        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;  % 设置已启动标志    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            % 检查仿真是否正在运行，若正在运行则停止            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                % 如果仿真正在运行，取消仿真                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            % 如果没有仿真，或其他错误，则跳过            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(blockHandle)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.blockHandle = blockHandle;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end
这段代码是一个用于在 Simulink 模型中调用自定义 S-Function 的实现，目的是在仿真过程中与图形用户界面 (GUI) 交互，导入和修改参数。
S-Function 主体
首先，sfun_callInterface 函数是 S-Function 的入口，调用了 setup 函数来进行初始化配置。setup 函数为 S-Function 设置了输入输出端口、采样时间、以及仿真相关的回调方法。
setup 函数
在 setup 函数中，设置了 S-Function 的输入和输出端口配置。它没有输入端口，只有一个输出端口，并且输出的维度和数据类型进行了设定。该端口的采样模式为 Sample，表示输出数据为常规的样本数据。
此外，SampleTimes 被设置为 [0 0]，这意味着该 S-Function 会立即执行并且不会进行周期性的采样。通过注册 PostPropagationSetup, InitializeConditions, Outputs, 和 Terminate 四个方法，定义了仿真生命周期内不同阶段的行为。
最后，set_param 设置了 OpenFcn 触发，指向了 start_import_gui 函数，用于启动 GUI 界面。
PostPropagationSetup 函数
该函数用于声明 S-Function 中的 DWork（数据工作区）。DWork 是用来存储状态信息的地方。这里定义了三个 DWork 变量：

guiLaunched 用于标识 GUI 是否已启动。
confirmationFlag 用于存储从 GUI 获取的确认状态。
simStarted 用于标记仿真是否已经启动。

这些 DWork 变量的作用是确保 GUI 在需要时只启动一次，并且管理仿真状态，防止重复操作。
InitCond 函数
InitCond 函数在每次仿真开始时被调用，用来初始化 DWork 变量。在这里，所有的标志变量（guiLaunched, confirmationFlag, simStarted）都被初始化为 0，表示 GUI 尚未启动，确认标志为未设置，仿真尚未开始。
Outputs 函数
Outputs 函数是在仿真过程中持续被调用的，用来控制和更新仿真输出。首先，它获取了 GUI 启动状态、确认标志和仿真启动状态。如果 GUI 尚未启动，则调用 start_import_gui 函数启动 GUI 界面，并将 guiLaunched 标志设为 1。
如果 GUI 已经启动，尝试从基础工作空间获取 confirmationFlag 变量的值。如果获取到有效值，则更新 DWork 中的 confirmationFlag。
然后，函数检查确认标志的值：

如果 confirmationFlag 为 1 且仿真尚未启动，则自动启动仿真，并将 simStarted 设为 1。
如果 confirmationFlag 为 -1，表示取消，尝试停止正在运行的仿真。

Terminate 函数
Terminate 函数在仿真结束时调用，主要作用是清理基础工作空间中的标志变量 confirmationFlag，以防止在下次仿真中出现残留的状态信息。
start_import_gui 函数
start_import_gui 函数用于创建并显示 GUI 窗口。首先，它计算并设置窗口居中显示的坐标。然后，创建了一个图形界面，并在其中添加了以下元素：

一个按钮用来触发数据导入。
一个表格用来显示导入的数据。
一个文本框用来显示当前选择的文件夹路径。
“确认”和“取消”按钮，用来控制数据导入和取消操作。

此外，在 GUI 初始化时加载了一个动态链接库（DLL），用于后续的参数导入和修改操作。
调用Dll
% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end
import_data 函数
import_data 函数是在用户点击导入按钮时调用的。它弹出一个文件夹选择对话框，允许用户选择包含数据文件的文件夹。如果用户选择了文件夹并且其中包含 bwiparamtemp.ini 文件，程序会调用 DLL 函数读取该文件中的参数并将其显示在表格中。
confirm_action 函数
confirm_action 函数在用户点击“确认”按钮时被调用。它从表格中读取每个参数的名称和值，并将更新的参数通过 DLL 保存到指定路径的 .ini 文件中。如果参数值有变化，则执行更新操作。
更新成功后，将 confirmationFlag 设置为 1，表示操作已完成，仿真可以开始。
cancel_action 函数
cancel_action 函数在用户点击“取消”按钮时调用。它将 confirmationFlag 设置为 -1，表示取消操作，然后关闭 GUI 窗口。
close_gui 函数
close_gui 函数用于关闭 GUI 窗口时调用。它会卸载已经加载的 DLL，并释放其他资源。
总结
这段代码实现了一个与 Simulink 模型交互的 GUI 系统，允许用户在仿真过程中导入和修改参数，启动或停止仿真。代码通过 S-Function 接口与 Simulink 仿真框架进行集成，并使用 MATLAB 图形界面元素提供用户交互界面。设计上使用了 DWork 数据工作区来存储和管理仿真状态，并通过回调函数实现不同阶段的功能。
关于文件在不同运行环境下编码不同的问题

其主要原因在于，Matlab的运行环境和Visual Studio不同，而封装的读写代码中用到了windows的API，该API会根据运行编译环境来选择不同的写入方式，而Matlab默认使用UTF-8，从而导致写入数据时中文出现乱码的情况，如下图

如果不需要在多个环境下运行（如Unicode），我们可以固定写入方式，如读写均采用ANSI方式
char *CIniFile::ReadString(string &amp;m_Sec, string &amp;m_Ident, char *m_Def)&#123;	GetPrivateProfileStringA(m_Sec.c_str(), m_Ident.c_str(), m_Def, Buffer, sizeof(Buffer), m_Name);	return Buffer;&#125;bool CIniFile::WriteString(const char *m_Sec, const char *m_Ident, const char *m_Val)&#123;	return (bool)WritePrivateProfileStringA(m_Sec, m_Ident, m_Val, m_Name);&#125;
也可以使用开源替代库来替代原有的ini操作类，如SimpleIni，或者自己手动检测编码，手动写入，如下
void CIniFile::detectEncoding() &#123;	m_isUtf8 = false;	m_hasUtf8BOM = false;	unsigned char bom[3] = &#123; 0,0,0 &#125;;	if (FILE* f = std::fopen(m_Name, &quot;rb&quot;)) &#123;		std::fread(bom, 1, 3, f);		std::fclose(f);		if (bom[0] == 0xEF &amp;&amp; bom[1] == 0xBB &amp;&amp; bom[2] == 0xBF) &#123;			m_isUtf8 = true;			m_hasUtf8BOM = true;		&#125;	&#125;	// 如果无 BOM：保守视为 MBCS/ANSI（如 GBK）；这样不会把老文件强转 UTF-8。&#125;bool CIniFile::saveInternal() &#123;	if (!m_loaded) return false;	// UTF-8 文件：是否写 BOM：保持与原文件一致	const bool addSig = (m_isUtf8 &amp;&amp; m_hasUtf8BOM);	// 如果是 GB2312/GBK 编码，保存时不写 BOM	if (!m_isUtf8) &#123;		SI_Error rc = m_ini.SaveFile(m_Name, false); // No BOM for MBCS/ANSI		if (rc &lt; 0) return false;	&#125;	else &#123;		// 保存为 UTF-8 编码，并且根据原文件是否有 BOM 来决定是否加 BOM		SI_Error rc = m_ini.SaveFile(m_Name, addSig);		if (rc &lt; 0) return false;	&#125;	m_dirty = false;	return true;&#125;

注意：如果非同一个项目，需要把所有用到的项目进行编译，并把运行需要的dll文件拷贝到Matlab环境下

运行示例

]]></content>
      <categories>
        <category>Simulink仿真</category>
      </categories>
      <tags>
        <tag>Simulink</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Simulink中参数传递的解决方案</title>
    <url>/posts/fcf42186.html</url>
    <content><![CDATA[介绍
本文主要对之前的Simulink工作进行优化，前面通过S Function一共实现了三个模块，分别为参数交互模块、调用求解模块和数据展示模块。但后续两个模块的代码中都采用了硬编码的方式来指定文件夹的路径，事实上后续两个模块的文件夹路径与第一个模块选中的文件夹是同一个路径，因此为了减少因为硬编码而导致的路径错误，我们将修改代码，把第一个模块选中的文件夹传递给后续的模块，这里将会使用Simulink的封装功能
如何传递模块参数
核心问题：传递文件夹路径
目前，sfun_callXXX.m 和 sfun_callXXXProcess.m 中的文件路径是硬编码的，这降低了灵活性。
% sfun_callXXX.mparamPath = &#x27;C:\Users\pc\Desktop\XXX_互作用-helix-非线性特征仿真实例\注波互作用1\指定输入&#x27;;% sfun_callXXXProcess.mdir = &#x27;C:\Users\pc\Desktop\XXX_互作用-helix-非线性特征仿真实例\注波互作用1\指定输入&#x27;;
最佳的解决方案是利用 Simulink 的 Mask Parameters (模块参数) 来接收路径，然后由第一个 S-Function (sfun_callInterface) 在用户确认路径后，通过编程方式设置这些参数。

在 Simulink 模型中，右键点击 sfun_callXXX 模块，选择 Mask &gt; Create Mask。
在 Mask Editor 窗口中，进入 Parameters &amp; Dialog 选项卡。
在左侧面板添加一个 Edit 参数。
在右侧的 Parameter Properties 中，设置:

Prompt: 求解器参数路径
Name: paramPath
Evaluate：取消勾选


点击 OK 或 Apply 保存 Mask。
对 sfun_callXXXProcess 模块重复以上步骤，但将参数 Name 设置为 dataDir。
再次右键点击该模块，选择 Block Parameters (S-function)。
在打开的对话框中，找到一个名为 S-function parameters 的输入框。
在这个输入框里，填入你的 变量名 (paramPath 或 dataDir)。
点击 OK 或 Apply。
为另一个 S-Function 模块重复上述步骤。


这个操作的目的是建立 Mask 和 S-Function 代码之间的连接。当你在 Mask 界面输入路径时，该路径字符串会存入名为 paramPath 的变量中。然后，通过将 paramPath填入 “S-function parameters” 字段，这个变量的值就被传递给了 S-Function 内部，代码 block.DialogPrm(1).Data 才能成功地接收到这个路径。
现在，修改这两个 S-Function，让它们从刚刚创建的 Mask Parameter 中读取路径，而不是使用硬编码的字符串。
修改 sfun_callXXX.m:


在 setup 函数中，声明该模块有一个 Mask Parameter。
function setup(block)    % ... (I/O 配置)    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    % ... (SampleTime 等其他配置)end


在 Outputs 函数中，用 block.DialogPrm(1).Data 替换硬编码的路径。
function Outputs(block)    % ...    %— 配置区：路径 —————————    exePath   = &#x27;.\Solver\XXX.exe&#x27;;    % paramPath = &#x27;C:\Users\pc\Desktop\...&#x27;; % &lt;--- 删除或注释掉这一行    paramPath = block.DialogPrm(1).Data;    % &lt;--- 添加这一行    % ...end


修改 sfun_callXXXProcess.m:


同样，在 setup 函数中声明 Mask Parameter。
function setup(block)    % ...    block.NumDialogPrms  = 1; % &lt;--- 添加这一行    block.SampleTimes        = [0.5 0];    % ...end


在 Outputs 函数中，替换硬编码的路径。
function Outputs(block)    % ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\bin\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\bin\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\Users\pc\Desktop\...&#x27;; % &lt;--- 删除或注释掉这一行        dir = block.DialogPrm(1).Data;    % &lt;--- 添加这一行        % ...    end    % ...end


最后，修改第一个 S-Function 的 GUI 确认回调函数 (confirm_action)，让它在用户点击“确认”时，自动将选定的文件夹路径写入另外两个模块的 Mask Parameter。
为此，需要在 Simulink 模型中为 sfun_callXXX 和 sfun_callXXXProcess 模块指定一个清晰的、可编程访问的名称。例如，将它们分别命名为 XXX_Launcher 和 XXX_Processor。如图所示

修改 sfun_callInterface.m 中的 confirm_action 函数:
% sfun_callInterface.mfunction confirm_action(fig)    % ... (前面的代码保持不变)    % --- 新增代码：获取模型名称和设置其他模块的参数 ---    try        blockHandle = fig.UserData.blockHandle;        modelName = bdroot(blockHandle); % 获取顶层模型的名称                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);    catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % 释放处理器并返回，防止在出错时继续执行        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        return;    end    % --- 新增代码结束 ---    % ... (释放处理器、设置 confirmationFlag 和关闭 GUI 的代码保持不变)        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end
小结: 通过以上三步，完成了下述工作：

sfun_callInterface 的 GUI 捕获用户选择的路径。
当用户点击“确认”时，该模块通过 set_param 函数，将路径动态地写入 XXX_Launcher 和 XXX_Processor 模块的 Mask 中。
这两个模块在运行时，从自己的 Mask Parameter 中读取路径，从而实现了动态配置，完全避免了硬编码。


注意：上述代码仍会出现问题，具体来说是modelName无法被识别，后续我将附上全部修改代码，这里不做展示


加载/卸载Dll的优化
此时多个模块正在加载和卸载同一个DLL (BWIBridgeDLL.dll)。这种做法效率低下，并且可以被简化。最佳实践是在整个仿真生命周期内将DLL作为共享资源进行管理：在仿真开始时加载一次，在仿真终止时卸载一次。
1. 修改 sfun_callInterface.m
该模块应负责加载DLL，并确保它在仿真期间保持加载状态。
在 close_gui 函数中，删除卸载DLL的那一行代码。GUI不再需要管理DLL的卸载，这个任务将交给仿真的终止阶段来处理。
原始代码 (sfun_callInterface.m):
function close_gui(fig)    % 卸载 DLL 如果已加载    if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 清理其他资源如果需要    delete(fig);end
建议修改:
function close_gui(fig)    % DLL 不再在这里卸载。它将由仿真流程中最后一个S-Function模块的    % Terminate 函数来处理。    delete(fig);end
2. 修改 sfun_callXXXProcess.m
该模块应负责在仿真结束时卸载DLL。其 Outputs 函数也应简化，直接使用已加载的库。
a. 在 Outputs 函数中:
移除 loadlibrary 和 unloadlibrary 调用。现在代码应该假设DLL已经被第一个模块加载了。为保险起见，可以添加一个 libisloaded 检查。
原始代码 (sfun_callXXXProcess.m):
function Outputs(block)    % ... (前面的代码) ...    if u == 2 &amp;&amp; prevU ~= 2        % --- 读取数据并绘图 ---        dll = &#x27;.\bin\BWIBridgeDLL.dll&#x27;;        hdr = &#x27;.\bin\BWIBridgeDLL.h&#x27;;        dir = block.DialogPrm(1).Data;        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            loadlibrary(dll, hdr);        end        % ... (调用库的逻辑) ...                % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % ... (剩余的代码) ...end
建议修改:
function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\n&#x27;);            return;        end        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        % ... (其余逻辑保持不变) ...        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary 调用已从此函数中移除。    end    block.Dwork(1).Data = u;end
b. 在 Terminate 函数中:
此函数在仿真停止时会执行一次。这是卸载DLL的理想位置。
原始代码 (sfun_callXXXProcess.m):
function Terminate(~)end
建议修改:
function Terminate(~)    fprintf(&#x27;[XXX] Simulation terminated. Unloading BWIBridgeDLL.\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend
经过修改之后，我们的代码理论上只会在仿真开始时加载Dll，在仿真结束后卸载Dll，避免中间过程对Dll的反复调用
隐含问题
在sfun_callXXX.m的代码中，还存在着一个潜在的重要问题，我们使用了如下代码
%— 持久变量：进程句柄 —————————————persistent procObj
这是一个持久变量，用来检测进程的状态，当我们使用了不止于一个sfun_callXXX模块时，所有模块将共享这个变量，如果我们在第一个模块中启动一个.exe进程，并将其句柄存入 procObj。紧接着，第二个模块启动另一个.exe进程，并将其句柄覆盖到同一个 procObj 变量中。此时，第一个进程的句柄就丢失了。系统将无法再轮询或终止第一个进程，从而导致逻辑错误和进程失控。简单来说，当前的设计只适用于模型中只有一个XXX_Launcher模块的情况。一旦需要多个，就会立即出错。
目前这个问题还没有解决，后续如果遇到了，会在该系列文章中提供解决方案
最后附上全部代码
function sfun_callInterface(block)    % 初始化 S-Function    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    % I/O 配置（没有输入端口）    block.NumInputPorts  = 0;    block.NumOutputPorts = 1;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位    % 明确设置输出端口的采样模式（设置为样本数据）    block.OutputPort(1).SamplingMode = &#x27;Sample&#x27;;  % FRAME_NO: 样本数据    % SampleTime 配置    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    % 注册方法    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;, @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;, @Terminate);    % 设置 OpenFcn 触发 GUI    set_param(block.BlockHandle, &#x27;OpenFcn&#x27;, &#x27;start_import_gui&#x27;);         % 这里的双击回调函数并不能正常使用，如要使用，可能要把start_import_gui及相关代码作为独立的文件和函数end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;        % Dwork 1: 用于存储 GUI 是否已启动的标志    block.Dwork(1).Name            = &#x27;guiLaunched&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;        % Dwork 2: 用于存储确认标志    block.Dwork(2).Name            = &#x27;confirmationFlag&#x27;;    block.Dwork(2).Dimensions      = 1;    block.Dwork(2).DatatypeID      = 0;    block.Dwork(2).Complexity      = &#x27;Real&#x27;;    block.Dwork(2).UsedAsDiscState = true;    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）    block.Dwork(3).Name            = &#x27;simStarted&#x27;;    block.Dwork(3).Dimensions      = 1;    block.Dwork(3).DatatypeID      = 0;    block.Dwork(3).Complexity      = &#x27;Real&#x27;;    block.Dwork(3).UsedAsDiscState = true;end% ─── InitializeConditions：初始化 DWork ───function InitCond(block)    % 每次仿真开始时重置标志    block.Dwork(1).Data = 0;  % GUI 未启动    block.Dwork(2).Data = 0;  % 确认标志为 0    block.Dwork(3).Data = 0;  % 未启动仿真end% ─── Outputs ───function Outputs(block)    % 获取当前状态    guiLaunched = block.Dwork(1).Data;    confirmationFlag = block.Dwork(2).Data;    simStarted = block.Dwork(3).Data;        % 如果 GUI 尚未启动，则启动 GUI    if guiLaunched == 0                % --- 确保 modelName 永远是字符串 ---        rootSystem = bdroot(block.BlockHandle); % 获取顶层模型，结果可能是句柄或名称                modelName = &#x27;&#x27;; % 初始化        if isnumeric(rootSystem) &amp;&amp; ishandle(rootSystem)            % 如果返回的是数字句柄，则通过句柄获取名称            modelName = get_param(rootSystem, &#x27;Name&#x27;);        elseif ischar(rootSystem)            % 如果返回的是字符串名称，则直接使用            modelName = rootSystem;        end        % 添加一个安全检查，如果获取名称失败则报错并停止        if isempty(modelName)            errordlg(&#x27;无法获取 Simulink 模型名称，GUI 无法启动。&#x27;, &#x27;严重错误&#x27;);            % 在这种严重错误下，停止仿真可能更安全            set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);            return; % 提前退出函数        end        % --- 修复结束 ---                start_import_gui(modelName);        block.Dwork(1).Data = 1;    end        % 尝试从基础工作空间获取确认状态    try        confirmationFlag = evalin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;);        block.Dwork(2).Data = confirmationFlag;    catch        % 如果变量不存在，保持当前值    end        % 输出确认标志    block.OutputPort(1).Data = confirmationFlag;        % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真    if confirmationFlag == 1 &amp;&amp; simStarted == 0        set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;start&#x27;);        block.Dwork(3).Data = 1;    end    % 如果确认标志是 -1，表示取消，停止仿真    if confirmationFlag == -1        try            simStatus = get_param(bdroot(block.BlockHandle), &#x27;SimulationStatus&#x27;);            if strcmp(simStatus, &#x27;running&#x27;)                set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);                disp(&#x27;仿真已取消&#x27;);            end        catch            disp(&#x27;未能检查到正在运行的仿真，或仿真未启动&#x27;);        end    endend% ─── Terminate：处理进程退出 ───function Terminate(~)    % 清理基础工作空间中的标志变量    evalin(&#x27;base&#x27;, &#x27;clear confirmationFlag&#x27;);endfunction start_import_gui(modelName)    % 获取屏幕大小    screenSize = get(0, &#x27;ScreenSize&#x27;);    screenWidth = screenSize(3);    screenHeight = screenSize(4);        % 设置图形界面大小    figWidth = 800;    figHeight = 400;    % 计算居中显示的坐标    figPosX = (screenWidth - figWidth) / 2;    figPosY = (screenHeight - figHeight) / 2;    % 创建图形界面（窗口），居中显示    fig = uifigure(&#x27;Name&#x27;, &#x27;数据导入与显示&#x27;, &#x27;Position&#x27;, [figPosX, figPosY, figWidth, figHeight], ...                   &#x27;CloseRequestFcn&#x27;, @(src, event) close_gui(fig));    % 存储块句柄在图形对象的 UserData 中    fig.UserData.modelName  = modelName;    % 加载 DLL（在 GUI 启动时加载一次）    dll = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.dll&#x27;);    hdr = fullfile(pwd, &#x27;bin&#x27;, &#x27;BWIBridgeDLL.h&#x27;);    if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)        loadlibrary(dll, hdr);    end    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载    % 创建按钮来导入数据    btnImport = uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;导入数据&#x27;, &#x27;Position&#x27;, [680, 360, 100, 30], ...                         &#x27;ButtonPushedFcn&#x27;, @(src, event) import_data(fig));    % 创建一个uitable用于显示数据    uit = uitable(fig, &#x27;Position&#x27;, [20, 60, 760, 280], ...                  &#x27;ColumnName&#x27;, &#123;&#x27;变量名&#x27;, &#x27;数值&#x27;, &#x27;最小值&#x27;, &#x27;最大值&#x27;, &#x27;说明&#x27;&#125;, ...                  &#x27;Data&#x27;, &#123;&#125;, &#x27;ColumnEditable&#x27;, [false true false false false]);    uit.Tag = &#x27;dataTable&#x27;;  % 设置标签，方便后续操作    % 用于保存数据的临时变量（移到 fig.UserData）    fig.UserData.data = [];    fig.UserData.originalData = [];  % 用于存储原始数据    % 创建一个TextArea来显示文件夹路径    filePathLabel = uilabel(fig, &#x27;Text&#x27;, &#x27;选择的文件夹路径：&#x27;, &#x27;Position&#x27;, [20, 360, 100, 30]);    filePathTextArea = uitextarea(fig, &#x27;Position&#x27;, [130, 360, 530, 30], &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    filePathTextArea.Editable = &#x27;off&#x27;;  % 设置为只读    % 创建&quot;确认&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;确认&#x27;, &#x27;Position&#x27;, [520, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) confirm_action(fig));    % 创建&quot;取消&quot;按钮    uibutton(fig, &#x27;push&#x27;, &#x27;Text&#x27;, &#x27;取消&#x27;, &#x27;Position&#x27;, [640, 20, 100, 30], ...             &#x27;ButtonPushedFcn&#x27;, @(src, event) cancel_action(fig));end% 导入数据的回调函数function import_data(fig)    % 弹出文件夹选择对话框    folderPath = uigetdir(&#x27;&#x27;, &#x27;选择数据文件夹&#x27;);        if folderPath == 0  % 用户取消选择文件夹        return;    end    % 拼接完整路径    iniFilePath = fullfile(folderPath, &#x27;bwiparamtemp.ini&#x27;);        if ~isfile(iniFilePath)        uialert(fig, &#x27;bwiparamtemp.ini 文件不存在&#x27;, &#x27;导入错误&#x27;);        return;    end        % 调用 DLL 读取数据    try        % 创建处理器        proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);                % 调用函数加载 INI 参数        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;LoadParametersFromIni&#x27;, proc, iniFilePath);                % 获取参数数量        paramCount = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetGlobalParameterCount&#x27;, proc);                % 获取参数的名称、数值、最小值、最大值、描述等        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述        for i = 0:paramCount-1            name = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterName&#x27;, proc, i);            value = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterValue&#x27;, proc, i);            minVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMin&#x27;, proc, i);            maxVal = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterMax&#x27;, proc, i);            desc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;GetParameterDescription&#x27;, proc, i);                        % 假设 value, minVal, maxVal 是 double，确保一致            data&#123;i+1, 1&#125; = char(name);      % 变量名 (确保字符串)            data&#123;i+1, 2&#125; = value;           % 数值 (double)            data&#123;i+1, 3&#125; = minVal;          % 最小值 (double)            data&#123;i+1, 4&#125; = maxVal;          % 最大值 (double)            data&#123;i+1, 5&#125; = char(desc);      % 说明 (确保字符串)        end                % 更新表格数据        uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);        uit.Data = data;  % 显示数据                % 保存数据到 fig.UserData（原始数据和当前数据）        fig.UserData.data = data;        fig.UserData.originalData = data;  % 存储原始数据副本        % 更新文件夹路径显示框        filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);        if ~isempty(filePathTextArea)            filePathTextArea.Value = &#123;folderPath&#125;;  % 显示路径 (uitextarea Value 是 cell)        else            uialert(fig, &#x27;未找到文件夹路径文本框，无法更新路径&#x27;, &#x27;更新错误&#x27;);        end                % 释放处理器        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);                disp(&#x27;数据导入成功&#x27;);    catch ME        % 读取文件失败时的处理        uialert(fig, [&#x27;文件导入失败: &#x27;, ME.message], &#x27;导入错误&#x27;);    endend% 确认按钮的回调function confirm_action(fig)    % 获取表格数据    uit = findobj(fig, &#x27;Tag&#x27;, &#x27;dataTable&#x27;);    data = uit.Data;  % 表格中的所有数据    % 获取文件夹路径作为项目路径    filePathTextArea = findobj(fig, &#x27;Tag&#x27;, &#x27;filePathTextArea&#x27;);    folderPath = filePathTextArea.Value&#123;1&#125;;  % 获取显示的文件夹路径 (从 cell 取)        if isempty(folderPath)        uialert(fig, &#x27;文件夹路径无效&#x27;, &#x27;导入错误&#x27;);        return;    end    % 确保将 folderPath 转换为字符向量    folderPath = char(folderPath);    % 创建处理器    proc = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);    % 获取原始数据从 fig.UserData    originalData = fig.UserData.originalData;        % 如果没有原始数据，则使用当前数据作为原始数据    if isempty(originalData)        originalData = data;        fig.UserData.originalData = data;    end        % 遍历表格中的每一行，获取参数名和新值    updated = false;  % 标记是否有更新    for i = 1:size(data, 1)        paramName = data&#123;i, 1&#125;;   % 参数名        newValue = data&#123;i, 2&#125;;    % 修改后的新值                % 确保 paramName 转换为字符向量        paramName = char(paramName);                % 确保 newValue 是数值类型 (表格编辑可能返回 char)        if ischar(newValue) || iscell(newValue)            newValue = str2double(newValue);        end        if isnan(newValue)            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 的值无效（非数值）&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end                % 获取原始值        originalValue = originalData&#123;i, 2&#125;;                % 检查值是否发生变化        if isequal(newValue, originalValue)            disp([&#x27;参数 &#x27;, paramName, &#x27; 未发生变化，跳过更新&#x27;]);            continue; % 跳过这个参数        end                % 更新参数        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;RewriteBWIIni_Param&#x27;, proc, paramName, newValue, folderPath);                % 检查更新是否成功        if result            disp([&#x27;参数 &#x27;, paramName, &#x27; 修改成功&#x27;]);            % 更新原始数据            originalData&#123;i, 2&#125; = newValue;            updated = true;        else            uialert(fig, [&#x27;参数 &#x27;, paramName, &#x27; 修改失败&#x27;], &#x27;导入错误&#x27;);            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);            return;        end    end        % 更新原始数据    fig.UserData.originalData = originalData;    try        % 从 UserData 获取模型名称字符串        modelName = fig.UserData.modelName; % &lt;--- 修改点                % 检查 modelName 是否有效 (例如，不是空的)        if isempty(modelName) || ~ischar(modelName)            error(&#x27;未能获取有效的模型名称。&#x27;); % 抛出一个错误        end                % 设置 sfun_callXXX 模块的路径参数        set_param([modelName, &#x27;/XXX_Launcher&#x27;], &#x27;paramPath&#x27;, folderPath);                % 设置 sfun_callXXXProcess 模块的路径参数        set_param([modelName, &#x27;/XXX_Processor&#x27;], &#x27;dataDir&#x27;, folderPath);                disp(&#x27;已成功将路径参数传递到后续模块。&#x27;);            catch ME        uialert(fig, [&#x27;无法设置后续模块的路径参数: &#x27;, ME.message], &#x27;参数传递错误&#x27;);        % ... (释放处理器并返回)        return;    end        % 释放处理器    calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, proc);        % 在基础工作空间中设置确认标志为 1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, 1);        % 关闭 GUI 窗口    delete(fig);end% 取消按钮的回调function cancel_action(fig)    % 在基础工作空间中设置确认标志为 -1    assignin(&#x27;base&#x27;, &#x27;confirmationFlag&#x27;, -1);        % 关闭 GUI 窗口    delete(fig);end% GUI 关闭回调函数function close_gui(fig)    % 卸载 DLL 如果已加载    % if isfield(fig.UserData, &#x27;dllLoaded&#x27;) &amp;&amp; fig.UserData.dllLoaded &amp;&amp; libisloaded(&#x27;BWIBridgeDLL&#x27;)    %     unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    % end    % 清理其他资源如果需要    delete(fig);end
function sfun_callXXX(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    %— I/O 配置 —————————————————————————————————————————————    block.NumInputPorts  = 1;    block.NumOutputPorts = 1;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).DirectFeedthrough = true;    block.OutputPort(1).Dimensions       = 1;    block.OutputPort(1).DatatypeID       = 0;    block.NumDialogPrms  = 1;     %— SampleTime 配置 ———————————————————————    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    %— 注册方法 —————————————————————————    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);    %— 设置仿真时间为无限，直到进程完成 —————    set_param(bdroot(block.BlockHandle), &#x27;StopTime&#x27;, &#x27;inf&#x27;);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 3;    names = &#123;&#x27;prevU&#x27;, &#x27;exeState&#x27;, &#x27;pid&#x27;&#125;;    for k = 1:3        block.Dwork(k).Name            = names&#123;k&#125;;        block.Dwork(k).Dimensions      = 1;        block.Dwork(k).DatatypeID      = 0;        block.Dwork(k).Complexity      = &#x27;Real&#x27;;        block.Dwork(k).UsedAsDiscState = true;    endend% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;    block.Dwork(2).Data = 0;    block.Dwork(3).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u        = block.InputPort(1).Data;    prevU    = block.Dwork(1).Data;    exeState = block.Dwork(2).Data;    pid      = block.Dwork(3).Data;    %— 持久变量：进程句柄 —————————————    persistent procObj    if isempty(procObj), procObj = []; end    %— 配置区：路径 —————————    exePath   = &#x27;.\Solver\XXX.exe&#x27;;    % paramPath = &#x27;C:\Users\pc\Desktop\XXX_互作用-helix-非线性特征仿真实例\注波互作用1\指定输入&#x27;;    paramPath = block.DialogPrm(1).Data;     %— ① Rising-edge → 启动 EXE —————————    if u == 1 &amp;&amp; prevU == 0 &amp;&amp; exeState == 0        [ok, procObj, pid, exeState] = launchExe(exePath, paramPath);        if ok            fprintf(&#x27;[XXX] PID=%d 已启动\n&#x27;, pid);        else            exeState = -1;  % 启动失败        end    end    %— ② 运行中 → 轮询进程是否退出 —————    if exeState == 1        [exeState, pid] = pollProcessExitStatus(procObj, pid);        if exeState == 2 || exeState == -1            fprintf(&#x27;[XXX] PID=%d 已退出\n&#x27;, block.Dwork(3).Data)            stopSimulation(block);        end    end    %— ③ 输出 &amp; 保存 —————————    block.OutputPort(1).Data = exeState;    block.Dwork(1).Data      = u;    block.Dwork(2).Data      = exeState;    block.Dwork(3).Data      = pid;end% ─── Terminate：处理进程退出 —──function Terminate(~)    persistent procObj    if ~isempty(procObj)        try            terminateProcess(procObj);        catch            % Ignore if the process has already been terminated        end    endend% ─── helper：启动进程 ───function [ok, proc, pid, exeState] = launchExe(exePath, paramPath)    ok = false; proc = []; pid = 0; exeState = 0;    try        if exist(exePath, &#x27;file&#x27;) ~= 2            warning(&#x27;[XXX] EXE 不存在: %s&#x27;, exePath); return; end        if exist(paramPath, &#x27;dir&#x27;) ~= 7            warning(&#x27;[XXX] 参数路径不存在: %s&#x27;, paramPath); return; end        argStr = [&#x27;1|1|&#x27; paramPath];  % 启动参数        proc = System.Diagnostics.Process();        info = proc.StartInfo;        info.FileName        = exePath;        info.Arguments       = argStr;        info.UseShellExecute = false;        info.CreateNoWindow  = true;        ok = proc.Start();        if ok            pid = double(proc.Id);            exeState = 1;   % 运行中        end    catch ME        warning(&#x27;[XXX] 启动 EXE 异常: %s&#x27;, E.message);    endend% ─── helper：轮询进程退出状态 ───function [exeState, pid] = pollProcessExitStatus(procObj, pid)    finished = false;    try        procObj.Refresh();        finished = procObj.HasExited;        if ~finished            finished = procObj.WaitForExit(50);  % 等待 50 ms        end    catch        finished = ~isProcAlive(pid);    end        if finished        exitC = getExitCodeSafe(procObj);        exeState = (exitC == 0) * 2 + (exitC ~= 0) * (-1);        pid = 0;    else        exeState = 1; % Running    endend% ─── helper：检查 PID 是否仍存活 ───function alive = isProcAlive(pid)    alive = false;    if pid &lt;= 0, return; end    try        pchk = System.Diagnostics.Process.GetProcessById(pid);        alive = ~pchk.HasExited;    catch        % Process not found    endend% ─── helper：读取 ExitCode ───function code = getExitCodeSafe(procObj)    code = -1;    try code = procObj.ExitCode; catch, endend% ─── helper：终止进程 ───function terminateProcess(procObj)    if ~procObj.HasExited        procObj.Kill();    end    procObj.Dispose();end% ─── helper：停止仿真 ───function stopSimulation(block)    set_param(bdroot(block.BlockHandle), &#x27;SimulationCommand&#x27;, &#x27;stop&#x27;);end
function sfun_callXXXProcess(block)    setup(block);end% ─────────────────── SETUP ────────────────────function setup(block)    block.NumInputPorts  = 1;    block.NumOutputPorts = 0;    block.InputPort(1).Dimensions        = 1;    block.InputPort(1).DatatypeID        = 0;   % double    block.InputPort(1).Complexity        = &#x27;Real&#x27;;    block.InputPort(1).DirectFeedthrough = true;    block.NumDialogPrms  = 1;    block.SampleTimes        = [0.5 0];         % 0.5 s 轮询    block.SimStateCompliance = &#x27;DefaultSimState&#x27;;    block.RegBlockMethod(&#x27;PostPropagationSetup&#x27;, @PostProp);    block.RegBlockMethod(&#x27;InitializeConditions&#x27;, @InitCond);    block.RegBlockMethod(&#x27;Outputs&#x27;,              @Outputs);    block.RegBlockMethod(&#x27;Terminate&#x27;,            @Terminate);end% ─── PostPropagationSetup：声明 DWork ───function PostProp(block)    block.NumDworks = 1;                       % prevU    block.Dwork(1).Name            = &#x27;prevU&#x27;;    block.Dwork(1).Dimensions      = 1;    block.Dwork(1).DatatypeID      = 0;    block.Dwork(1).Complexity      = &#x27;Real&#x27;;    block.Dwork(1).UsedAsDiscState = true;end% ─── 初始化 ───function InitCond(block)    block.Dwork(1).Data = 0;end% ─────────────────── Outputs ───────────────────function Outputs(block)    u = block.InputPort(1).Data;    prevU = block.Dwork(1).Data;    % 如果脉冲信号为2，则开始执行数据读取    if u == 2 &amp;&amp; prevU ~= 2        % 为保险起见，检查库是否已加载        if ~libisloaded(&#x27;BWIBridgeDLL&#x27;)            fprintf(&#x27;错误: BWIBridgeDLL 未被加载。仿真可能未从 sfun_callInterface 正常启动。\n&#x27;);            return;        end        % --- 读取数据并绘图 ---        % dll = &#x27;.\bin\BWIBridgeDLL.dll&#x27;;        % hdr = &#x27;.\bin\BWIBridgeDLL.h&#x27;;        % dir = &#x27;C:\Users\pc\Desktop\XXX_互作用-helix-非线性特征仿真实例\注波互作用1\指定输入&#x27;;        dir = block.DialogPrm(1).Data;        p   = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CreateProcessor&#x27;);        nPt = libpointer(&#x27;int32Ptr&#x27;, 0);        result = calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;ReadXXXDat&#x27;, p, dir, nPt);        if ~result            fprintf(&#x27;读取失败&#x27;)            calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);            unloadlibrary(&#x27;BWIBridgeDLL&#x27;)        end;        N = nPt.Value;        % --- 指针缓冲区 ---        xPtr   = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        powPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        gainPtr= libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        effPtr = libpointer(&#x27;doublePtr&#x27;, zeros(N, 1));        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyX_mm&#x27;, p, xPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyPower&#x27;, p, powPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyGain&#x27;, p, gainPtr, N);        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;CopyEff&#x27;,  p, effPtr, N);        x    = xPtr.Value;        pow  = powPtr.Value;        gain = gainPtr.Value;        eff  = effPtr.Value;        % --- 绘图 ---        figure;        subplot(3, 1, 1);        plot(x, pow, &#x27;-b&#x27;);        title(&#x27;输出功率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;W&#x27;);        subplot(3, 1, 2);        plot(x, gain, &#x27;-b&#x27;);        title(&#x27;增益曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;dB&#x27;);        subplot(3, 1, 3);        plot(x, eff, &#x27;-b&#x27;);        title(&#x27;效率曲线&#x27;);        xlabel(&#x27;z / mm&#x27;);        ylabel(&#x27;%&#x27;);        % --- 清理 ---        calllib(&#x27;BWIBridgeDLL&#x27;, &#x27;DeleteProcessor&#x27;, p);        % unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    end    % 保存当前脉冲值    block.Dwork(1).Data = u;end% ─── Terminate：处理退出 —──function Terminate(~)    fprintf(&#x27;[XXX] Simulation 终止. 卸载 BWIBridgeDLL.\n&#x27;);    if libisloaded(&#x27;BWIBridgeDLL&#x27;)        unloadlibrary(&#x27;BWIBridgeDLL&#x27;);    endend
]]></content>
      <categories>
        <category>Simulink仿真</category>
      </categories>
      <tags>
        <tag>Simulink</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Ascend C算子开发能力认证（中级）</title>
    <url>/posts/9e1eacb0.html</url>
    <content><![CDATA[认证要求
实现Ascend C算子Sigmoid,算子命名为SigmoidCustom,编写其kernel侧代码、host侧代码,并完成aclnn算子调用测试。
相关算法:
sigmoid(x)=1/(1+exp(−x))sigmoid(x) = 1/(1 + exp(-x))
sigmoid(x)=1/(1+exp(−x))

实现流程
环境初始配置
由于华为的ModelAtrs平台每次重启会把环境中除work目录之外的内容全部清除，因此每次需要重新设置环境，执行
bash init_env.shsource ~/.bashrcsource /home/ma-user/Ascend/ascend-toolkit/set_env.shchmod +x -R *
上述命令依次用于下载包、配置环境变量以及脚本权限等
代码编写
从认证平台下载压缩包，解压之后包含SigmoidCustom和AclNNInvocation两个文件夹，SigmoidCustom中的内容主要完成代码编写、编译运行等，AclNNInvocation用于实现调用、测试等
文件主要内容如下

Host测实现
首先在sigmoid_custom_tiling.h完成tiling结构体设计，在代码的注释后添加如下内容
TILING_DATA_FIELD_DEF(uint32_t, totalLength);TILING_DATA_FIELD_DEF(uint32_t, tileNum);
然后在sigmoid_custom.cpp中的注释后添加
uint32_t totalLength = context-&gt;GetInputShape(0)-&gt;GetOriginShape().GetShapeSize();context-&gt;SetBlockDim(BLOCK_DIM);tiling.set_totalLength(totalLength);tiling.set_tileNum(TILE_NUM);tiling.SaveToBuffer(context-&gt;GetRawTilingData()-&gt;GetData(), context-&gt;GetRawTilingData()-&gt;GetCapacity());context-&gt;GetRawTilingData()-&gt;SetDataSize(tiling.GetDataSize());size_t *currentWorkspace = context-&gt;GetWorkspaceSizes(1);currentWorkspace[0] = 0;return ge::GRAPH_SUCCESS;
Device测实现
这里的代码稍微复杂，需要用户自行实现核函数的初始化、内存迁移、算法实现等，完整代码如下
#include &quot;kernel_operator.h&quot;using namespace AscendC;constexpr int32_t BUFFER_NUM = 2;class KernelSigmoid &#123;public:    __aicore__ inline KernelSigmoid() &#123;&#125;    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, uint32_t totalLength, uint32_t tileNum)    &#123;        //考生补充初始化代码        this-&gt;blockLength = totalLength / AscendC::GetBlockNum();        this-&gt;tileNum = tileNum;        this-&gt;tileLength = this-&gt;blockLength / tileNum / BUFFER_NUM;        xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        yGm.SetGlobalBuffer((__gm__ DTYPE_Y *)y + this-&gt;blockLength * AscendC::GetBlockIdx(), this-&gt;blockLength);        pipe.InitBuffer(inQueueX, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(outQueueY, BUFFER_NUM, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer1, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer2, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer3, this-&gt;tileLength * sizeof(half));        pipe.InitBuffer(tmpBuffer4, this-&gt;tileLength * sizeof(half));    &#125;    __aicore__ inline void Process()    &#123;        //考生补充对“loopCount”的定义，注意对Tiling的处理        int32_t loopCount = this-&gt;tileNum * BUFFER_NUM;        for (int32_t i = 0; i &lt; loopCount; i++) &#123;            CopyIn(i);            Compute(i);            CopyOut(i);        &#125;    &#125;private:    __aicore__ inline void HighPrecisionReciprocal(LocalTensor&lt;half&gt;&amp; dst,                                               const LocalTensor&lt;half&gt;&amp; src,                                               int32_t length,                                               int iterations = 2)    &#123;        LocalTensor&lt;half&gt; tmp = tmpBuffer4.Get&lt;half&gt;();        half two = 2.0h,negone=-1.0h;        // 初始近似值 (可以使用硬件Reciprocal的初始值)        AscendC::Reciprocal(dst, src, length);        // 牛顿迭代: x_&#123;n+1&#125; = x_n * (2 - a * x_n)        for (int i = 0; i &lt; iterations; ++i) &#123;            AscendC::Mul(tmp, src, dst, length);    // tmp = a * x_n            AscendC::Muls(tmp, tmp, negone, length);   // tmp = 2 - a * x_n            AscendC::Adds(tmp, tmp, two, length);            AscendC::Mul(dst, dst, tmp, length);     // x_&#123;n+1&#125; = x_n * tmp        &#125;    &#125;    __aicore__ inline void CopyIn(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();        AscendC::DataCopy(xLocal, xGm[progress * this-&gt;tileLength], this-&gt;tileLength);        inQueueX.EnQue(xLocal);    &#125;    __aicore__ inline void Compute(int32_t progress)    &#123;        //考生补充算子计算代码        LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;();        LocalTensor&lt;half&gt; yLocal = outQueueY.AllocTensor&lt;half&gt;();                LocalTensor&lt;half&gt; tmp1 = tmpBuffer1.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp2 = tmpBuffer2.Get&lt;half&gt;();        LocalTensor&lt;half&gt; tmp3 = tmpBuffer3.Get&lt;half&gt;();                half one=1.0,negone=-1.0;        AscendC::Muls(tmp1, xLocal, negone, this-&gt;tileLength);        AscendC::Exp(tmp2, tmp1, this-&gt;tileLength);        AscendC::Adds(tmp3, tmp2, one, this-&gt;tileLength);                HighPrecisionReciprocal(yLocal,tmp3,this-&gt;tileLength,2);        outQueueY.EnQue&lt;half&gt;(yLocal);        inQueueX.FreeTensor(xLocal);    &#125;    __aicore__ inline void CopyOut(int32_t progress)    &#123;        //考生补充算子代码        AscendC::LocalTensor&lt;half&gt; yLocal = outQueueY.DeQue&lt;half&gt;();        AscendC::DataCopy(yGm[progress * this-&gt;tileLength], yLocal, this-&gt;tileLength);        outQueueY.FreeTensor(yLocal);    &#125;private:    TPipe pipe;    //create queue for input, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;    //create queue for output, in this case depth is equal to buffer num    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueY;    GlobalTensor&lt;half&gt; xGm;    GlobalTensor&lt;half&gt; yGm;    //考生补充自定义成员变量    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;    uint32_t blockLength;    uint32_t tileNum;    uint32_t tileLength;&#125;;extern &quot;C&quot; __global__ __aicore__ void sigmoid_custom(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling) &#123;    GET_TILING_DATA(tiling_data, tiling);    KernelSigmoid op;    //补充init和process函数调用内容    op.Init(x, y, tiling_data.totalLength, tiling_data.tileNum);    op.Process();&#125;
代码解释
一个自定义算子的生命周期
在深入代码之前，我们先理解一下从编写到执行，这个 SigmoidCustom 算子经历了什么：


开发阶段: 您编写了算子定义、Tiling 逻辑和 Kernel 实现这几个文件。


编译阶段: 使用 CANN 提供的工具链进行编译。编译器会分别处理 Host 端代码（编译成标准的 CPU 可执行指令）和 Device 端代码（编译成 AI Core 能理解的 CUBE 指令）。同时，OP_ADD(SigmoidCustom) 宏会将算子的元信息（如输入输出、Tiling 函数地址等）注册到昇腾的算子库中。


图构建与下发阶段: 当用户在一个神经网络模型（例如用 MindSpore 或 PyTorch）中调用 SigmoidCustom 时，前端框架会将模型转换为昇腾的计算图（Graph）。图编译器（Graph Engine, GE）会解析这个图，当遇到 SigmoidCustom 节点时，它会：
a.  调用 InferShape 和 InferDataType 函数，在不运行实际计算的情况下，静态推断出这个节点输出的形状和数据类型，以便为整个网络预先分配好内存。
b.  调用 TilingFunc 函数，根据当前节点的输入张量大小，生成具体的任务切分方案（即 TilingData）。
c.  将编译好的 Kernel CUBE 指令和 TilingData 打包成一个任务，下发给 NPU 的任务调度器（Task Scheduler）。


执行阶段: NPU 的任务调度器根据 TilingData 中的 blockDim 信息，唤醒指定数量的 AI Core。每个被唤醒的 AI Core 都会接收到 Kernel CUBE 指令和 TilingData 的一份拷贝，然后从 sigmoid_custom 这个 __global__ 入口函数开始，独立地执行计算任务。


Host 端代码深度解析 (CPU 侧)
Host 端代码的核心目标是**“定义规则”和“制定计划”**，它不参与实际的数值计算。
1.1 算子接口定义
这部分代码是 SigmoidCustom 算子与 CANN 框架交互的“接口”或“驱动”。框架本身不知道你这个算子具体怎么算，但通过这个定义，它知道了如何使用你。

this-&gt;Input(&quot;x&quot;)... 和 this-&gt;Output(&quot;y&quot;)...: 这不仅仅是定义了输入输出的名称，更重要的是定义了数据依赖关系。图编译器根据这个关系来构建计算图的拓扑结构，决定算子执行的先后顺序。
.DataType(&#123;ge::DT_FLOAT16&#125;).Format(&#123;ge::FORMAT_ND&#125;): 这是算子的能力声明。它告诉框架：“我能处理 FP16 类型的数据，并且不关心输入的具体维度（ND 格式）。” 如果上游算子的输出格式不匹配，图编译器会自动插入一个转置（Transpose）或类型转换（Cast）算子来适配。
this-&gt;SetInferShape(ge::InferShape): 这是一个至关重要的静态分析钩子。在模型编译时，真实的输入数据还不存在，但其形状（Shape）是已知的。框架会调用 InferShape 函数，让算子根据输入的 Shape &quot;预言&quot;自己输出的 Shape。对于 Sigmoid 这种 Element-wise（逐元素）操作，输出形状与输入形状完全相同，所以实现很简单：*y_shape = *x1_shape;。这使得框架可以在运行前就规划好整个模型的内存布局。
this-&gt;AICore().SetTiling(optiling::TilingFunc): 这是将**“计划制定者”**（Tiling 函数）与算子本身绑定的关键。框架知道，每当需要执行这个算子时，都应该去调用 TilingFunc 来获取详细的执行计划。

1.2 Tiling 函数
Tiling 函数是 Host 端的智慧所在，它在 CPU 上运行，为即将开始的 Device 端计算制定精密的作战计划。

gert::TilingContext\* context: context 对象是框架传递给 Tiling 函数的**“情报手册”**。它包含了关于当前任务的所有上下文信息，最主要的就是 context-&gt;GetInputShape(0)，它让 Tiling 函数知道了待处理的数据有多大。
核心决策:

总览全局: uint32_t totalLength = ...GetShapeSize() 获取了总工作量。
分配兵力: context-&gt;SetBlockDim(BLOCK_DIM) 决定了要动用多少个 AI Core（这里硬编码为8）。这是一个关键的并行策略决策。如果 totalLength 很小，可能只用一个 AI Core 更高效（避免多核通信开销）；如果 totalLength 巨大，则可以用满所有可用的 Core。
制定指令:

tiling.set_totalLength(totalLength): 把全局信息写入“指令书” (TilingData)。
tiling.set_tileNum(TILE_NUM): 决定每个 AI Core 内部的流水线深度或切分粒度。这个值会影响性能，需要根据计算量和数据搬运量的比例（计算访存比）来权衡。TILE_NUM 越大，tileLength 就越小，数据搬运更频繁，但每个计算任务的延迟也更低，有利于流水线隐藏延迟。




信息传递: tiling.SaveToBuffer(...) 将填满信息的 TilingData 结构体序列化为一段连续的内存块。这段内存块将和编译好的 Kernel 代码一起被发送到 Device 端，成为每个 AI Core 执行任务的依据。

Device 端代码深度解析 (AI Core 侧)
Device 端代码是**“一线士兵”**，它们根据 Host 发来的计划，在自己的阵地（AI Core）上高效地执行计算。
2.1 内存模型与数据并行 (SPMD)

GM_ADDR x, GM_ADDR y: GM_ADDR 是 Global Memory Address 的缩写，代表全局内存中的一个地址。x 和 y 是输入和输出张量在全局内存中的起始地址。
SPMD (Single Program, Multiple Data): 这是 AI Core 的核心工作模式。所有被唤醒的 AI Core 都执行同一份程序代码（Single Program），但处理的数据各不相同（Multiple Data）。
AscendC::GetBlockIdx(): 这是实现 SPMD 的关键。该函数返回当前 AI Core 的唯一ID（从0到 blockDim-1）。
xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * AscendC::GetBlockIdx(), ...): 这行代码是数据划分的精髓。

(__gm__ DTYPE_X *)x: 将全局内存地址 x 转换为一个指向 FP16 类型的指针。
... + this-&gt;blockLength * AscendC::GetBlockIdx(): 计算偏移量。

对于 ID=0 的 Core，偏移量是 blockLength * 0 = 0，它处理从 x 开始的数据。
对于 ID=1 的 Core，偏移量是 blockLength * 1，它处理紧接着第一块的数据。
…


通过这种方式，totalLength 的数据被完美地分割成了 blockDim 份，每个 AI Core 都只关心自己负责的那一段，实现了无冲突的数据并行。



2.2 本地内存与流水线 (TPipe, TQue)
AI Core 的性能源泉在于其内部极速的本地内存（LM）和向量计算单元。流水线的目标就是让计算单元永远不要因为等待数据而停工。

TPipe, TQue: 这不是硬件，而是 Ascend C 提供的软件抽象，用于简化对硬件 DMA（数据搬运单元）和本地内存的管理。
InitBuffer: 在 Init 方法中，pipe.InitBuffer(inQueueX, BUFFER_NUM, ...) 相当于在本地内存中划分出 BUFFER_NUM (即2) 块独立的区域，并由 inQueueX 这个队列对象来管理。
双缓冲 (Double Buffering) 详解: BUFFER_NUM=2 构成了双缓冲。想象有两块缓冲区 A 和 B：

CopyIn: 调用 inQueueX.AllocTensor&lt;half&gt;() 会从空闲的缓冲区队列中取出一个（比如A），然后 DataCopy 指令启动 DMA 将 GM 数据拷贝到 A。完成后 inQueueX.EnQue(A) 将 A 标记为“已填充，可供计算”。
Compute: 调用 inQueueX.DeQue&lt;half&gt;() 会从“已填充”队列中取出一个（比如A），然后计算单元对 A 中的数据进行计算。
重叠执行: 当计算单元正在处理 A 的数据时，CopyIn 阶段可以同时向另一个空闲的缓冲区 B 中拷贝下一批数据。当 A 计算完成，B 也正好拷贝完成，计算单元可以马不停蹄地开始处理 B，而 DMA 则开始将 A 的计算结果写回 GM。


for 循环的流水线建立过程:

迭代 i=0: CopyIn(0) 开始（数据块0从GM-&gt;LM），Compute(0) 和 CopyOut(0) 等待。
迭代 i=1: CopyIn(1) 开始（数据块1从GM-&gt;LM），同时 Compute(0) 开始（处理数据块0）。CopyOut(1) 等待。
迭代 i=2: CopyIn(2) 开始，Compute(1) 开始，CopyOut(0) 开始（将数据块0的结果从LM-&gt;GM）。至此，三级流水线完全建立，DMA的读、计算单元、DMA的写三个硬件部件都在满负荷工作。



2.3 向量计算与硬件指令

AscendC::Muls, AscendC::Exp, AscendC::Adds: 这些函数被称为内置函数（Intrinsics）。它们在编译时会被直接映射为 AI Core 的一条或多条向量指令。
例如，AscendC::Exp(tmp2, tmp1, this-&gt;tileLength) 不是一个循环，而是一条指令。它告诉向量计算单元：“对 tmp1 指向的 tileLength 个半精度浮点数，逐个执行指数运算，并将结果存放到 tmp2 中”。这种 SIMD（单指令多数据） 的处理方式是 AI Core 性能的根本来源。

2.4 数值计算优化

问题: 硬件通常提供速度快但精度有限的近似计算指令，比如求倒数。对于某些需要高精度的算法，这可能导致误差累积。
解决方案: 牛顿-拉弗森迭代法是一种经典的数值分析方法，可以用来求方程的根。对于求 1/a，相当于求方程 f(x) = 1/x - a 的根。
代码映射:

AscendC::Reciprocal(dst, src, length);: 使用硬件指令得到一个初始近似值 x_0 (即 dst)。src 是 a。
AscendC::Mul(tmp, src, dst, length);: 计算 a * x_n，结果存入 tmp。
AscendC::Muls(tmp, tmp, negone, length);: 变为 - (a * x_n)。
AscendC::Adds(tmp, tmp, two, length);: 变为 2 - a * x_n。
AscendC::Mul(dst, dst, tmp, length);: 计算 x_n * (2 - a * x_n)，得到 x_&#123;n+1&#125;，并覆盖回 dst。


这个 for 循环每迭代一次，结果的精度就会翻倍。迭代2次就能获得非常高的精度，这体现了算法与硬件结合的优化思想。

运行测试
在运行之前，首先检查CMakePresets.json文件中的ASCEND_COMPUTE_UNIT和ASCEND_CANN_PACKAGE_PATH是否正确，如下
&quot;ASCEND_COMPUTE_UNIT&quot;: &#123;    &quot;type&quot;: &quot;STRING&quot;,    &quot;value&quot;: &quot;ascend310b;ascend910b&quot;&#125;,&quot;ASCEND_CANN_PACKAGE_PATH&quot;: &#123;    &quot;type&quot;: &quot;PATH&quot;,    &quot;value&quot;: &quot;/home/ma-user/Ascend/ascend-toolkit/latest&quot;&#125;,
然后检查SigmoidCustom中的AICore是否设置正确，如下
this-&gt;AICore().AddConfig(&quot;ascend910b&quot;)              .AddConfig(&quot;ascend310b&quot;);
如果上述设置没有问题，就可以进行编译测试了
运行编译
bash build.sh
编译之后会得到build_out目录，运行其中的安装包
cd build_out./custom_opp_ubuntu_aarch64.run
最后到AclNNInvocation中运行测试
bash run.sh
检验脚本会调用py脚本，分别用numpy和我们写的算子计算答案，然后对比误差，如果代码没有问题会给出测试成功的提示。由于华为云提供的这个环境属实有点贵，因此我就不再开机测试并截图了，大家自行操作
随后按照认证要求将SigmoidCustom打包提交即可，测试通过后会获得认证证书，如下

]]></content>
      <categories>
        <category>华为算子挑战赛</category>
      </categories>
      <tags>
        <tag>Ascend C</tag>
        <tag>算子开发</tag>
      </tags>
  </entry>
</search>
